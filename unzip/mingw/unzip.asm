In archive .\libunzip.a:

api.o:     file format pe-i386


Disassembly of section .text:

00000000 <_UzpVersion@0>:
UzpVer * UZ_EXP UzpVersion()   /* should be pointer to const struct */
{
    static UzpVer version;     /* doesn't change between calls */


    version.structlen = UZPVER_LEN;
   0:	c7 05 00 00 00 00 24 	movl   $0x24,0x0
   7:	00 00 00 

#ifdef BETA
    version.flag = 1;
#else
    version.flag = 0;
   a:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
  11:	00 00 00 
#endif
    version.betalevel = UZ_BETALEVEL;
  14:	c7 05 08 00 00 00 00 	movl   $0x0,0x8
  1b:	00 00 00 
    version.date = UZ_VERSION_DATE;
  1e:	c7 05 0c 00 00 00 01 	movl   $0x1,0xc
  25:	00 00 00 

#ifdef ZLIB_VERSION
    version.zlib_version = ZLIB_VERSION;
    version.flag |= 2;
#else
    version.zlib_version = NULL;
  28:	c7 05 10 00 00 00 00 	movl   $0x0,0x10
  2f:	00 00 00 
#endif

    /* someday each of these may have a separate patchlevel: */
    version.unzip.major = UZ_MAJORVER;
  32:	c6 05 14 00 00 00 05 	movb   $0x5,0x14
    version.unzip.minor = UZ_MINORVER;
  39:	c6 05 15 00 00 00 05 	movb   $0x5,0x15
    version.unzip.patchlevel = UZ_PATCHLEVEL;
  40:	c6 05 16 00 00 00 02 	movb   $0x2,0x16

    version.zipinfo.major = ZI_MAJORVER;
  47:	c6 05 18 00 00 00 02 	movb   $0x2,0x18
    version.zipinfo.minor = ZI_MINORVER;
  4e:	c6 05 19 00 00 00 04 	movb   $0x4,0x19
    version.zipinfo.patchlevel = UZ_PATCHLEVEL;
  55:	c6 05 1a 00 00 00 02 	movb   $0x2,0x1a

    /* these are retained for backward compatibility only: */
    version.os2dll.major = UZ_MAJORVER;
  5c:	c6 05 1c 00 00 00 05 	movb   $0x5,0x1c
    version.os2dll.minor = UZ_MINORVER;
  63:	c6 05 1d 00 00 00 05 	movb   $0x5,0x1d
    version.os2dll.patchlevel = UZ_PATCHLEVEL;
  6a:	c6 05 1e 00 00 00 02 	movb   $0x2,0x1e

    version.windll.major = UZ_MAJORVER;
  71:	c6 05 20 00 00 00 05 	movb   $0x5,0x20
    version.windll.minor = UZ_MINORVER;
  78:	c6 05 21 00 00 00 05 	movb   $0x5,0x21
    version.windll.patchlevel = UZ_PATCHLEVEL;
  7f:	c6 05 22 00 00 00 02 	movb   $0x2,0x22

    return &version;
}
  86:	b8 00 00 00 00       	mov    $0x0,%eax
  8b:	c3                   	ret    
  8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000090 <_UzpVersion2@4>:

void UZ_EXP UzpVersion2(UzpVer2 *version)
{
  90:	8b 44 24 04          	mov    0x4(%esp),%eax

    version->structlen = UZPVER_LEN;
  94:	c7 00 24 00 00 00    	movl   $0x24,(%eax)

#ifdef BETA
    version->flag = 1;
#else
    version->flag = 0;
  9a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#endif
    strcpy(version->betalevel, UZ_BETALEVEL);
  a1:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    strcpy(version->date, UZ_VERSION_DATE);
  a5:	c7 40 12 32 38 20 46 	movl   $0x46203832,0x12(%eax)
  ac:	c7 40 16 65 62 72 75 	movl   $0x75726265,0x16(%eax)
  b3:	c7 40 1a 61 72 79 20 	movl   $0x20797261,0x1a(%eax)
  ba:	c7 40 1e 32 30 30 35 	movl   $0x35303032,0x1e(%eax)
  c1:	c6 40 22 00          	movb   $0x0,0x22(%eax)
    strncpy(version->zlib_version, ZLIB_VERSION,
            sizeof(version->zlib_version) - 1);
    version->zlib_version[sizeof(version->zlib_version) - 1] = '\0';
    version->flag |= 2;
#else
    version->zlib_version[0] = '\0';
  c5:	c6 40 26 00          	movb   $0x0,0x26(%eax)
#endif

    /* someday each of these may have a separate patchlevel: */
    version->unzip.major = UZ_MAJORVER;
  c9:	c6 40 30 05          	movb   $0x5,0x30(%eax)
    version->unzip.minor = UZ_MINORVER;
  cd:	c6 40 31 05          	movb   $0x5,0x31(%eax)
    version->unzip.patchlevel = UZ_PATCHLEVEL;
  d1:	c6 40 32 02          	movb   $0x2,0x32(%eax)

    version->zipinfo.major = ZI_MAJORVER;
  d5:	c6 40 34 02          	movb   $0x2,0x34(%eax)
    version->zipinfo.minor = ZI_MINORVER;
  d9:	c6 40 35 04          	movb   $0x4,0x35(%eax)
    version->zipinfo.patchlevel = UZ_PATCHLEVEL;
  dd:	c6 40 36 02          	movb   $0x2,0x36(%eax)

    /* these are retained for backward compatibility only: */
    version->os2dll.major = UZ_MAJORVER;
  e1:	c6 40 38 05          	movb   $0x5,0x38(%eax)
    version->os2dll.minor = UZ_MINORVER;
  e5:	c6 40 39 05          	movb   $0x5,0x39(%eax)
    version->os2dll.patchlevel = UZ_PATCHLEVEL;
  e9:	c6 40 3a 02          	movb   $0x2,0x3a(%eax)

    version->windll.major = UZ_MAJORVER;
  ed:	c6 40 3c 05          	movb   $0x5,0x3c(%eax)
    version->windll.minor = UZ_MINORVER;
  f1:	c6 40 3d 05          	movb   $0x5,0x3d(%eax)
    version->windll.patchlevel = UZ_PATCHLEVEL;
  f5:	c6 40 3e 02          	movb   $0x2,0x3e(%eax)
  f9:	c2 04 00             	ret    $0x4
  fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000100 <_UzpFreeMemBuffer@4>:


#ifndef __16BIT__

void UZ_EXP UzpFreeMemBuffer(UzpBuffer *retstr)
{
 100:	53                   	push   %ebx
 101:	83 ec 18             	sub    $0x18,%esp
 104:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    if (retstr != NULL && retstr->strptr != NULL) {
 108:	85 db                	test   %ebx,%ebx
 10a:	74 1c                	je     128 <_UzpFreeMemBuffer@4+0x28>
 10c:	8b 43 04             	mov    0x4(%ebx),%eax
 10f:	85 c0                	test   %eax,%eax
 111:	74 15                	je     128 <_UzpFreeMemBuffer@4+0x28>
        free(retstr->strptr);
 113:	89 04 24             	mov    %eax,(%esp)
 116:	e8 00 00 00 00       	call   11b <_UzpFreeMemBuffer@4+0x1b>
        retstr->strptr = NULL;
 11b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        retstr->strlength = 0;
 122:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
}
 128:	83 c4 18             	add    $0x18,%esp
 12b:	5b                   	pop    %ebx
 12c:	c2 04 00             	ret    $0x4
 12f:	90                   	nop

00000130 <_setFileNotFound>:
  ---------------------------------------------------------------------------*/


void setFileNotFound(__G)
    __GDEF
{
 130:	8b 44 24 04          	mov    0x4(%esp),%eax
    G.filenotfound++;
 134:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
 13a:	42                   	inc    %edx
 13b:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
 141:	c3                   	ret    
 142:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000150 <_unzipToMemory>:


#ifndef SFX

int unzipToMemory(__GPRO__ char *zip, char *file, UzpBuffer *retstr)
{
 150:	56                   	push   %esi
 151:	53                   	push   %ebx
 152:	83 ec 24             	sub    $0x24,%esp
 155:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    char *incname[2];

    G.process_all_files = FALSE;
    G.extract_flag = TRUE;
    uO.qflag = 2;
    G.wildzipfn = zip;
 159:	8b 44 24 34          	mov    0x34(%esp),%eax


#ifndef SFX

int unzipToMemory(__GPRO__ char *zip, char *file, UzpBuffer *retstr)
{
 15d:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    uO.qflag = 2;
    G.wildzipfn = zip;

    G.pfnames = incname;
    incname[0] = file;
    incname[1] = NULL;
 161:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 168:	00 
    char *incname[2];

    G.process_all_files = FALSE;
    G.extract_flag = TRUE;
    uO.qflag = 2;
    G.wildzipfn = zip;
 169:	89 83 00 09 01 00    	mov    %eax,0x10900(%ebx)

    G.pfnames = incname;
 16f:	8d 44 24 18          	lea    0x18(%esp),%eax
 173:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
int unzipToMemory(__GPRO__ char *zip, char *file, UzpBuffer *retstr)
{
    int r;
    char *incname[2];

    G.process_all_files = FALSE;
 179:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
    G.extract_flag = TRUE;
 180:	c7 83 80 00 00 00 01 	movl   $0x1,0x80(%ebx)
 187:	00 00 00 
    uO.qflag = 2;
 18a:	c7 43 38 02 00 00 00 	movl   $0x2,0x38(%ebx)
    G.wildzipfn = zip;

    G.pfnames = incname;
    incname[0] = file;
 191:	8b 44 24 38          	mov    0x38(%esp),%eax
    incname[1] = NULL;
    G.filespecs = 1;
 195:	c7 43 6c 01 00 00 00 	movl   $0x1,0x6c(%ebx)

    r = process_zipfiles(__G);
 19c:	89 1c 24             	mov    %ebx,(%esp)
    G.extract_flag = TRUE;
    uO.qflag = 2;
    G.wildzipfn = zip;

    G.pfnames = incname;
    incname[0] = file;
 19f:	89 44 24 18          	mov    %eax,0x18(%esp)
    incname[1] = NULL;
    G.filespecs = 1;

    r = process_zipfiles(__G);
 1a3:	e8 00 00 00 00       	call   1a8 <_unzipToMemory+0x58>
    if (retstr) {
 1a8:	85 f6                	test   %esi,%esi
 1aa:	74 11                	je     1bd <_unzipToMemory+0x6d>
        retstr->strptr = (char *)G.redirect_buffer;
 1ac:	8b 93 b4 00 00 00    	mov    0xb4(%ebx),%edx
 1b2:	89 56 04             	mov    %edx,0x4(%esi)
        retstr->strlength = G.redirect_size;
 1b5:	8b 93 b0 00 00 00    	mov    0xb0(%ebx),%edx
 1bb:	89 16                	mov    %edx,(%esi)
    }
    return r;                   /* returns `PK_???' error values */
}
 1bd:	83 c4 24             	add    $0x24,%esp
 1c0:	5b                   	pop    %ebx
 1c1:	5e                   	pop    %esi
 1c2:	c3                   	ret    
 1c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 1c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000001d0 <_redirect_outfile>:
#endif /* !SFX */


int redirect_outfile(__G)
     __GDEF
{
 1d0:	56                   	push   %esi
 1d1:	53                   	push   %ebx
 1d2:	83 ec 14             	sub    $0x14,%esp
 1d5:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    if (G.redirect_size != 0 || G.redirect_buffer != NULL)
 1d9:	8b 83 b0 00 00 00    	mov    0xb0(%ebx),%eax
 1df:	85 c0                	test   %eax,%eax
 1e1:	75 0a                	jne    1ed <_redirect_outfile+0x1d>
 1e3:	8b 93 b4 00 00 00    	mov    0xb4(%ebx),%edx
 1e9:	85 d2                	test   %edx,%edx
 1eb:	74 08                	je     1f5 <_redirect_outfile+0x25>
#endif
    if (!G.redirect_buffer)
        return FALSE;
    G.redirect_pointer[G.redirect_size] = '\0';
    return TRUE;
}
 1ed:	83 c4 14             	add    $0x14,%esp

int redirect_outfile(__G)
     __GDEF
{
    if (G.redirect_size != 0 || G.redirect_buffer != NULL)
        return FALSE;
 1f0:	31 c0                	xor    %eax,%eax
#endif
    if (!G.redirect_buffer)
        return FALSE;
    G.redirect_pointer[G.redirect_size] = '\0';
    return TRUE;
}
 1f2:	5b                   	pop    %ebx
 1f3:	5e                   	pop    %esi
 1f4:	c3                   	ret    
{
    if (G.redirect_size != 0 || G.redirect_buffer != NULL)
        return FALSE;

#ifndef NO_SLIDE_REDIR
    G.redirect_slide = !G.pInfo->textmode;
 1f5:	8b 8b d8 08 00 00    	mov    0x8d8(%ebx),%ecx
 1fb:	8a 51 18             	mov    0x18(%ecx),%dl
 1fe:	c0 ea 03             	shr    $0x3,%dl
 201:	83 f2 01             	xor    $0x1,%edx
 204:	83 e2 01             	and    $0x1,%edx
 207:	89 93 a8 00 00 00    	mov    %edx,0xa8(%ebx)
#endif
#if (lenEOL != 1)
    if (G.pInfo->textmode) {
 20d:	f6 41 18 08          	testb  $0x8,0x18(%ecx)
 211:	74 3d                	je     250 <_redirect_outfile+0x80>
        G.redirect_size = G.lrec.ucsize * lenEOL;
 213:	8b 93 24 09 01 00    	mov    0x10924(%ebx),%edx
 219:	8d 34 12             	lea    (%edx,%edx,1),%esi
        if (G.redirect_size < G.lrec.ucsize)
 21c:	39 f2                	cmp    %esi,%edx
 21e:	77 38                	ja     258 <_redirect_outfile+0x88>
            G.redirect_size = ((G.lrec.ucsize > (ulg)-2L) ?
                               G.lrec.ucsize : (ulg)-2L);
    } else
#endif
    {
        G.redirect_size = G.lrec.ucsize;
 220:	89 b3 b0 00 00 00    	mov    %esi,0xb0(%ebx)
 226:	8d 46 01             	lea    0x1(%esi),%eax
    DosAllocMem((void **)&G.redirect_buffer, G.redirect_size+1,
      PAG_READ|PAG_WRITE|PAG_COMMIT);
    G.redirect_pointer = G.redirect_buffer;
#else
    G.redirect_pointer =
      G.redirect_buffer = malloc((extent)(G.redirect_size+1));
 229:	89 04 24             	mov    %eax,(%esp)
 22c:	e8 00 00 00 00       	call   231 <_redirect_outfile+0x61>
 231:	89 83 b4 00 00 00    	mov    %eax,0xb4(%ebx)
#ifdef OS2
    DosAllocMem((void **)&G.redirect_buffer, G.redirect_size+1,
      PAG_READ|PAG_WRITE|PAG_COMMIT);
    G.redirect_pointer = G.redirect_buffer;
#else
    G.redirect_pointer =
 237:	89 83 b8 00 00 00    	mov    %eax,0xb8(%ebx)
      G.redirect_buffer = malloc((extent)(G.redirect_size+1));
#endif
    if (!G.redirect_buffer)
 23d:	85 c0                	test   %eax,%eax
 23f:	74 ac                	je     1ed <_redirect_outfile+0x1d>
        return FALSE;
    G.redirect_pointer[G.redirect_size] = '\0';
 241:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
    return TRUE;
}
 245:	83 c4 14             	add    $0x14,%esp
      G.redirect_buffer = malloc((extent)(G.redirect_size+1));
#endif
    if (!G.redirect_buffer)
        return FALSE;
    G.redirect_pointer[G.redirect_size] = '\0';
    return TRUE;
 248:	b8 01 00 00 00       	mov    $0x1,%eax
}
 24d:	5b                   	pop    %ebx
 24e:	5e                   	pop    %esi
 24f:	c3                   	ret    
            G.redirect_size = ((G.lrec.ucsize > (ulg)-2L) ?
                               G.lrec.ucsize : (ulg)-2L);
    } else
#endif
    {
        G.redirect_size = G.lrec.ucsize;
 250:	8b b3 24 09 01 00    	mov    0x10924(%ebx),%esi
 256:	eb c8                	jmp    220 <_redirect_outfile+0x50>
#if (lenEOL != 1)
    if (G.pInfo->textmode) {
        G.redirect_size = G.lrec.ucsize * lenEOL;
        if (G.redirect_size < G.lrec.ucsize)
            G.redirect_size = ((G.lrec.ucsize > (ulg)-2L) ?
                               G.lrec.ucsize : (ulg)-2L);
 258:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 25d:	42                   	inc    %edx
 25e:	0f 45 c1             	cmovne %ecx,%eax
 261:	0f 94 c1             	sete   %cl
 264:	81 e1 ff 00 00 00    	and    $0xff,%ecx
 26a:	89 ce                	mov    %ecx,%esi
 26c:	83 ee 02             	sub    $0x2,%esi
#endif
#if (lenEOL != 1)
    if (G.pInfo->textmode) {
        G.redirect_size = G.lrec.ucsize * lenEOL;
        if (G.redirect_size < G.lrec.ucsize)
            G.redirect_size = ((G.lrec.ucsize > (ulg)-2L) ?
 26f:	89 b3 b0 00 00 00    	mov    %esi,0xb0(%ebx)
 275:	eb b2                	jmp    229 <_redirect_outfile+0x59>
 277:	89 f6                	mov    %esi,%esi
 279:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000280 <_writeToMemory>:
}



int writeToMemory(__GPRO__ ZCONST uch *rawbuf, extent size)
{
 280:	57                   	push   %edi
 281:	56                   	push   %esi
 282:	53                   	push   %ebx
 283:	83 ec 10             	sub    $0x10,%esp
 286:	8b 74 24 20          	mov    0x20(%esp),%esi
 28a:	8b 44 24 24          	mov    0x24(%esp),%eax
 28e:	8b 5c 24 28          	mov    0x28(%esp),%ebx
    int errflg = FALSE;

    if ((uch *)rawbuf != G.redirect_pointer) {
 292:	8b 8e b8 00 00 00    	mov    0xb8(%esi),%ecx
 298:	39 c1                	cmp    %eax,%ecx
 29a:	74 4c                	je     2e8 <_writeToMemory+0x68>
        extent redir_avail = (G.redirect_buffer + G.redirect_size) -
 29c:	8b be b4 00 00 00    	mov    0xb4(%esi),%edi
 2a2:	8b 96 b0 00 00 00    	mov    0xb0(%esi),%edx
 2a8:	01 fa                	add    %edi,%edx



int writeToMemory(__GPRO__ ZCONST uch *rawbuf, extent size)
{
    int errflg = FALSE;
 2aa:	31 ff                	xor    %edi,%edi

    if ((uch *)rawbuf != G.redirect_pointer) {
        extent redir_avail = (G.redirect_buffer + G.redirect_size) -
 2ac:	29 ca                	sub    %ecx,%edx
                             G.redirect_pointer;

        /* Check for output buffer overflow */
        if (size > redir_avail) {
 2ae:	39 d3                	cmp    %edx,%ebx
 2b0:	77 2e                	ja     2e0 <_writeToMemory+0x60>
           /* limit transfer data to available space, set error return flag */
           size = redir_avail;
           errflg = TRUE;
        }
        memcpy(G.redirect_pointer, rawbuf, size);
 2b2:	89 0c 24             	mov    %ecx,(%esp)
 2b5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 2b9:	89 44 24 04          	mov    %eax,0x4(%esp)
 2bd:	e8 00 00 00 00       	call   2c2 <_writeToMemory+0x42>
 2c2:	8b 8e b8 00 00 00    	mov    0xb8(%esi),%ecx
    }
    G.redirect_pointer += size;
 2c8:	01 cb                	add    %ecx,%ebx
    return errflg;
}
 2ca:	89 f8                	mov    %edi,%eax
           size = redir_avail;
           errflg = TRUE;
        }
        memcpy(G.redirect_pointer, rawbuf, size);
    }
    G.redirect_pointer += size;
 2cc:	89 9e b8 00 00 00    	mov    %ebx,0xb8(%esi)
    return errflg;
}
 2d2:	83 c4 10             	add    $0x10,%esp
 2d5:	5b                   	pop    %ebx
 2d6:	5e                   	pop    %esi
 2d7:	5f                   	pop    %edi
 2d8:	c3                   	ret    
 2d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    if ((uch *)rawbuf != G.redirect_pointer) {
        extent redir_avail = (G.redirect_buffer + G.redirect_size) -
                             G.redirect_pointer;

        /* Check for output buffer overflow */
        if (size > redir_avail) {
 2e0:	89 d3                	mov    %edx,%ebx
           /* limit transfer data to available space, set error return flag */
           size = redir_avail;
           errflg = TRUE;
 2e2:	66 bf 01 00          	mov    $0x1,%di
 2e6:	eb ca                	jmp    2b2 <_writeToMemory+0x32>



int writeToMemory(__GPRO__ ZCONST uch *rawbuf, extent size)
{
    int errflg = FALSE;
 2e8:	31 ff                	xor    %edi,%edi
 2ea:	eb dc                	jmp    2c8 <_writeToMemory+0x48>
 2ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000002f0 <_close_redirect>:



int close_redirect(__G)
     __GDEF
{
 2f0:	53                   	push   %ebx
 2f1:	83 ec 18             	sub    $0x18,%esp
 2f4:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    if (G.pInfo->textmode) {
 2f8:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
 2fe:	f6 40 18 08          	testb  $0x8,0x18(%eax)
 302:	75 0c                	jne    310 <_close_redirect+0x20>
             realloc(G.redirect_buffer, G.redirect_size + 1)) == NULL) {
            G.redirect_size = 0;
            return EOF;
        }
    }
    return 0;
 304:	31 c0                	xor    %eax,%eax
}
 306:	83 c4 18             	add    $0x18,%esp
 309:	5b                   	pop    %ebx
 30a:	c3                   	ret    
 30b:	90                   	nop
 30c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

int close_redirect(__G)
     __GDEF
{
    if (G.pInfo->textmode) {
        *G.redirect_pointer = '\0';
 310:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
 316:	c6 00 00             	movb   $0x0,(%eax)
        G.redirect_size = (ulg)(G.redirect_pointer - G.redirect_buffer);
 319:	8b 93 b4 00 00 00    	mov    0xb4(%ebx),%edx
 31f:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
 325:	29 d0                	sub    %edx,%eax
 327:	89 83 b0 00 00 00    	mov    %eax,0xb0(%ebx)
        if ((G.redirect_buffer =
             realloc(G.redirect_buffer, G.redirect_size + 1)) == NULL) {
 32d:	40                   	inc    %eax
 32e:	89 44 24 04          	mov    %eax,0x4(%esp)
 332:	89 14 24             	mov    %edx,(%esp)
 335:	e8 00 00 00 00       	call   33a <_close_redirect+0x4a>
     __GDEF
{
    if (G.pInfo->textmode) {
        *G.redirect_pointer = '\0';
        G.redirect_size = (ulg)(G.redirect_pointer - G.redirect_buffer);
        if ((G.redirect_buffer =
 33a:	89 83 b4 00 00 00    	mov    %eax,0xb4(%ebx)
 340:	85 c0                	test   %eax,%eax
 342:	75 c0                	jne    304 <_close_redirect+0x14>
             realloc(G.redirect_buffer, G.redirect_size + 1)) == NULL) {
            G.redirect_size = 0;
 344:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
 34b:	00 00 00 
            return EOF;
 34e:	83 c8 ff             	or     $0xffffffff,%eax
 351:	eb b3                	jmp    306 <_close_redirect+0x16>
 353:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000360 <_UzpValidate@8>:
#endif /* !__16BIT__ */



int UZ_EXP UzpValidate(char *archive, int AllCodes)
{
 360:	55                   	push   %ebp
 361:	89 e5                	mov    %esp,%ebp
 363:	56                   	push   %esi
 364:	53                   	push   %ebx
 365:	83 ec 20             	sub    $0x20,%esp
 368:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int retcode;
    CONSTRUCTGLOBALS();
 36b:	e8 00 00 00 00       	call   370 <_UzpValidate@8+0x10>
 370:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uO.jflag = 1;
 373:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
    uO.tflag = 1;
 37a:	c7 40 44 01 00 00 00 	movl   $0x1,0x44(%eax)
    uO.overwrite_none = 0;
 381:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    G.extract_flag = (!uO.zipinfo_mode &&
 388:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
 38f:	00 00 00 
#ifdef TIMESTAMP
                      && !uO.T_flag
#endif
                     );

    uO.qflag = 2;                        /* turn off all messages */
 392:	c7 40 38 02 00 00 00 	movl   $0x2,0x38(%eax)
    G.fValidate = TRUE;
 399:	c7 80 98 00 00 00 01 	movl   $0x1,0x98(%eax)
 3a0:	00 00 00 
    G.pfnames = (char **)&fnames[0];    /* assign default filename vector */
 3a3:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
 3aa:	00 00 00 
#ifdef WINDLL
    Wiz_NoPrinting(TRUE);
 3ad:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 3b4:	e8 00 00 00 00       	call   3b9 <_UzpValidate@8+0x59>
#endif

    if (archive == NULL) {      /* something is screwed up:  no filename */
 3b9:	85 db                	test   %ebx,%ebx

    uO.qflag = 2;                        /* turn off all messages */
    G.fValidate = TRUE;
    G.pfnames = (char **)&fnames[0];    /* assign default filename vector */
#ifdef WINDLL
    Wiz_NoPrinting(TRUE);
 3bb:	56                   	push   %esi
#endif

    if (archive == NULL) {      /* something is screwed up:  no filename */
 3bc:	0f 84 de 00 00 00    	je     4a0 <_UzpValidate@8+0x140>
        DESTROYGLOBALS();
        return PK_NOZIP;
    }

    G.wildzipfn = (char *)malloc(FILNAMSIZ + 1);
 3c2:	c7 04 24 05 01 00 00 	movl   $0x105,(%esp)
 3c9:	e8 00 00 00 00       	call   3ce <_UzpValidate@8+0x6e>
 3ce:	8b 75 f4             	mov    -0xc(%ebp),%esi
 3d1:	89 86 00 09 01 00    	mov    %eax,0x10900(%esi)
    strcpy(G.wildzipfn, archive);
 3d7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 3db:	89 04 24             	mov    %eax,(%esp)
 3de:	e8 00 00 00 00       	call   3e3 <_UzpValidate@8+0x83>
#if (defined(WINDLL) && !defined(CRTL_CP_IS_ISO))
    _ISO_INTERN(G.wildzipfn);
#endif

    G.process_all_files = TRUE;         /* for speed */
 3e3:	c7 46 74 01 00 00 00 	movl   $0x1,0x74(%esi)

    retcode = setjmp(dll_error_return);
 3ea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 3f1:	e8 00 00 00 00       	call   3f6 <_UzpValidate@8+0x96>

    if (retcode) {
 3f6:	85 c0                	test   %eax,%eax
 3f8:	75 67                	jne    461 <_UzpValidate@8+0x101>
        free(G.wildzipfn);
        DESTROYGLOBALS();
        return PK_BADERR;
    }

    retcode = process_zipfiles(__G);
 3fa:	8b 75 f4             	mov    -0xc(%ebp),%esi
 3fd:	89 34 24             	mov    %esi,(%esp)
 400:	e8 00 00 00 00       	call   405 <_UzpValidate@8+0xa5>

    free(G.wildzipfn);
 405:	8b 96 00 09 01 00    	mov    0x10900(%esi),%edx
 40b:	89 14 24             	mov    %edx,(%esp)
        free(G.wildzipfn);
        DESTROYGLOBALS();
        return PK_BADERR;
    }

    retcode = process_zipfiles(__G);
 40e:	89 c3                	mov    %eax,%ebx

    free(G.wildzipfn);
 410:	e8 00 00 00 00       	call   415 <_UzpValidate@8+0xb5>
#ifdef WINDLL
    Wiz_NoPrinting(FALSE);
 415:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 41c:	e8 00 00 00 00       	call   421 <_UzpValidate@8+0xc1>
 421:	50                   	push   %eax
#endif
    DESTROYGLOBALS();
 422:	89 34 24             	mov    %esi,(%esp)
 425:	e8 00 00 00 00       	call   42a <_UzpValidate@8+0xca>
 42a:	89 34 24             	mov    %esi,(%esp)
 42d:	e8 00 00 00 00       	call   432 <_UzpValidate@8+0xd2>
       We also still want to be able to get at files even if there is
       something odd about the zip archive, hence allow PK_WARN,
       PK_FIND, IZ_UNSUP as well as PK_ERR
     */

    if (AllCodes)
 432:	8b 55 0c             	mov    0xc(%ebp),%edx
        free(G.wildzipfn);
        DESTROYGLOBALS();
        return PK_BADERR;
    }

    retcode = process_zipfiles(__G);
 435:	89 d8                	mov    %ebx,%eax
       We also still want to be able to get at files even if there is
       something odd about the zip archive, hence allow PK_WARN,
       PK_FIND, IZ_UNSUP as well as PK_ERR
     */

    if (AllCodes)
 437:	85 d2                	test   %edx,%edx
 439:	75 1d                	jne    458 <_UzpValidate@8+0xf8>
        return retcode;

    if ((retcode == PK_OK) || (retcode == PK_WARN) || (retcode == PK_ERR) ||
        (retcode == IZ_UNSUP) || (retcode == PK_FIND))
 43b:	83 fb 0b             	cmp    $0xb,%ebx
 43e:	0f 94 c1             	sete   %cl
 441:	83 fb 51             	cmp    $0x51,%ebx
 444:	0f 94 c2             	sete   %dl
 447:	09 d1                	or     %edx,%ecx
     */

    if (AllCodes)
        return retcode;

    if ((retcode == PK_OK) || (retcode == PK_WARN) || (retcode == PK_ERR) ||
 449:	83 fb 02             	cmp    $0x2,%ebx
 44c:	88 c8                	mov    %cl,%al
 44e:	0f 96 c2             	setbe  %dl
 451:	09 d0                	or     %edx,%eax
    Wiz_NoPrinting(TRUE);
#endif

    if (archive == NULL) {      /* something is screwed up:  no filename */
        DESTROYGLOBALS();
        return PK_NOZIP;
 453:	25 ff 00 00 00       	and    $0xff,%eax
    if ((retcode == PK_OK) || (retcode == PK_WARN) || (retcode == PK_ERR) ||
        (retcode == IZ_UNSUP) || (retcode == PK_FIND))
        return TRUE;
    else
        return FALSE;
}
 458:	8d 65 f8             	lea    -0x8(%ebp),%esp
 45b:	5b                   	pop    %ebx
 45c:	5e                   	pop    %esi
 45d:	5d                   	pop    %ebp
 45e:	c2 08 00             	ret    $0x8

    retcode = setjmp(dll_error_return);

    if (retcode) {
#ifdef WINDLL
        Wiz_NoPrinting(FALSE);
 461:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 468:	e8 00 00 00 00       	call   46d <_UzpValidate@8+0x10d>
#endif
        free(G.wildzipfn);
 46d:	8b 5d f4             	mov    -0xc(%ebp),%ebx

    retcode = setjmp(dll_error_return);

    if (retcode) {
#ifdef WINDLL
        Wiz_NoPrinting(FALSE);
 470:	51                   	push   %ecx
#endif
        free(G.wildzipfn);
 471:	8b 83 00 09 01 00    	mov    0x10900(%ebx),%eax
 477:	89 04 24             	mov    %eax,(%esp)
 47a:	e8 00 00 00 00       	call   47f <_UzpValidate@8+0x11f>
        DESTROYGLOBALS();
 47f:	89 1c 24             	mov    %ebx,(%esp)
 482:	e8 00 00 00 00       	call   487 <_UzpValidate@8+0x127>
 487:	89 1c 24             	mov    %ebx,(%esp)
 48a:	e8 00 00 00 00       	call   48f <_UzpValidate@8+0x12f>
    if ((retcode == PK_OK) || (retcode == PK_WARN) || (retcode == PK_ERR) ||
        (retcode == IZ_UNSUP) || (retcode == PK_FIND))
        return TRUE;
    else
        return FALSE;
}
 48f:	8d 65 f8             	lea    -0x8(%ebp),%esp
#ifdef WINDLL
        Wiz_NoPrinting(FALSE);
#endif
        free(G.wildzipfn);
        DESTROYGLOBALS();
        return PK_BADERR;
 492:	b8 03 00 00 00       	mov    $0x3,%eax
    if ((retcode == PK_OK) || (retcode == PK_WARN) || (retcode == PK_ERR) ||
        (retcode == IZ_UNSUP) || (retcode == PK_FIND))
        return TRUE;
    else
        return FALSE;
}
 497:	5b                   	pop    %ebx
 498:	5e                   	pop    %esi
 499:	5d                   	pop    %ebp
 49a:	c2 08 00             	ret    $0x8
 49d:	8d 76 00             	lea    0x0(%esi),%esi
#ifdef WINDLL
    Wiz_NoPrinting(TRUE);
#endif

    if (archive == NULL) {      /* something is screwed up:  no filename */
        DESTROYGLOBALS();
 4a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
 4a3:	89 1c 24             	mov    %ebx,(%esp)
 4a6:	e8 00 00 00 00       	call   4ab <_UzpValidate@8+0x14b>
 4ab:	89 1c 24             	mov    %ebx,(%esp)
 4ae:	e8 00 00 00 00       	call   4b3 <_UzpValidate@8+0x153>
    if ((retcode == PK_OK) || (retcode == PK_WARN) || (retcode == PK_ERR) ||
        (retcode == IZ_UNSUP) || (retcode == PK_FIND))
        return TRUE;
    else
        return FALSE;
}
 4b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    Wiz_NoPrinting(TRUE);
#endif

    if (archive == NULL) {      /* something is screwed up:  no filename */
        DESTROYGLOBALS();
        return PK_NOZIP;
 4b6:	b8 09 00 00 00       	mov    $0x9,%eax
    if ((retcode == PK_OK) || (retcode == PK_WARN) || (retcode == PK_ERR) ||
        (retcode == IZ_UNSUP) || (retcode == PK_FIND))
        return TRUE;
    else
        return FALSE;
}
 4bb:	5b                   	pop    %ebx
 4bc:	5e                   	pop    %esi
 4bd:	5d                   	pop    %ebp
 4be:	c2 08 00             	ret    $0x8
 4c1:	90                   	nop
 4c2:	90                   	nop
 4c3:	90                   	nop
 4c4:	90                   	nop
 4c5:	90                   	nop
 4c6:	90                   	nop
 4c7:	90                   	nop
 4c8:	90                   	nop
 4c9:	90                   	nop
 4ca:	90                   	nop
 4cb:	90                   	nop
 4cc:	90                   	nop
 4cd:	90                   	nop
 4ce:	90                   	nop
 4cf:	90                   	nop

crc32.o:     file format pe-i386


Disassembly of section .text:

00000000 <_crc32>:
    register ZCONST uch *buf;   /* pointer to bytes to pump through */
    extent len;                 /* number of bytes in buf[] */
/* Run a set of bytes through the crc shift register.  If buf is a NULL
   pointer, then initialize the crc shift register contents instead.
   Return the current crc in either case. */
{
   0:	57                   	push   %edi
   1:	56                   	push   %esi
   2:	53                   	push   %ebx
   3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   7:	8b 74 24 18          	mov    0x18(%esp),%esi
  register ZCONST ulg near *crc_table;

  if (buf == NULL) return 0L;
   b:	85 db                	test   %ebx,%ebx
   d:	0f 84 dd 00 00 00    	je     f0 <_crc32+0xf0>

  crc_table = get_crc_table();
  13:	e8 00 00 00 00       	call   18 <_crc32+0x18>

  crc = crc ^ 0xffffffffL;
  18:	8b 54 24 10          	mov    0x10(%esp),%edx
  1c:	83 f2 ff             	xor    $0xffffffff,%edx
{
  register ZCONST ulg near *crc_table;

  if (buf == NULL) return 0L;

  crc_table = get_crc_table();
  1f:	89 c1                	mov    %eax,%ecx

  crc = crc ^ 0xffffffffL;
#ifndef NO_UNROLLED_LOOPS
  while (len >= 8) {
  21:	83 fe 07             	cmp    $0x7,%esi
  24:	0f 86 cc 00 00 00    	jbe    f6 <_crc32+0xf6>
  2a:	8d 46 f8             	lea    -0x8(%esi),%eax
  2d:	c1 e8 03             	shr    $0x3,%eax
  30:	8d 7c c3 08          	lea    0x8(%ebx,%eax,8),%edi
    DO8(buf);
  34:	88 d0                	mov    %dl,%al
  36:	83 c3 08             	add    $0x8,%ebx
  39:	c1 ea 08             	shr    $0x8,%edx
  3c:	32 43 f8             	xor    -0x8(%ebx),%al
  3f:	25 ff 00 00 00       	and    $0xff,%eax
  44:	33 14 81             	xor    (%ecx,%eax,4),%edx
  47:	88 d0                	mov    %dl,%al
  49:	c1 ea 08             	shr    $0x8,%edx
  4c:	32 43 f9             	xor    -0x7(%ebx),%al
  4f:	25 ff 00 00 00       	and    $0xff,%eax
  54:	33 14 81             	xor    (%ecx,%eax,4),%edx
  57:	88 d0                	mov    %dl,%al
  59:	c1 ea 08             	shr    $0x8,%edx
  5c:	32 43 fa             	xor    -0x6(%ebx),%al
  5f:	25 ff 00 00 00       	and    $0xff,%eax
  64:	33 14 81             	xor    (%ecx,%eax,4),%edx
  67:	88 d0                	mov    %dl,%al
  69:	c1 ea 08             	shr    $0x8,%edx
  6c:	32 43 fb             	xor    -0x5(%ebx),%al
  6f:	25 ff 00 00 00       	and    $0xff,%eax
  74:	33 14 81             	xor    (%ecx,%eax,4),%edx
  77:	88 d0                	mov    %dl,%al
  79:	c1 ea 08             	shr    $0x8,%edx
  7c:	32 43 fc             	xor    -0x4(%ebx),%al
  7f:	25 ff 00 00 00       	and    $0xff,%eax
  84:	33 14 81             	xor    (%ecx,%eax,4),%edx
  87:	88 d0                	mov    %dl,%al
  89:	c1 ea 08             	shr    $0x8,%edx
  8c:	32 43 fd             	xor    -0x3(%ebx),%al
  8f:	25 ff 00 00 00       	and    $0xff,%eax
  94:	33 14 81             	xor    (%ecx,%eax,4),%edx
  97:	88 d0                	mov    %dl,%al
  99:	c1 ea 08             	shr    $0x8,%edx
  9c:	32 43 fe             	xor    -0x2(%ebx),%al
  9f:	25 ff 00 00 00       	and    $0xff,%eax
  a4:	33 14 81             	xor    (%ecx,%eax,4),%edx
  a7:	88 d0                	mov    %dl,%al
  a9:	c1 ea 08             	shr    $0x8,%edx
  ac:	32 43 ff             	xor    -0x1(%ebx),%al
  af:	25 ff 00 00 00       	and    $0xff,%eax
  b4:	33 14 81             	xor    (%ecx,%eax,4),%edx

  crc_table = get_crc_table();

  crc = crc ^ 0xffffffffL;
#ifndef NO_UNROLLED_LOOPS
  while (len >= 8) {
  b7:	39 fb                	cmp    %edi,%ebx
  b9:	0f 85 75 ff ff ff    	jne    34 <_crc32+0x34>
  bf:	83 e6 07             	and    $0x7,%esi
    DO8(buf);
    len -= 8;
  }
#endif
  if (len) do {
  c2:	85 f6                	test   %esi,%esi
  c4:	74 1a                	je     e0 <_crc32+0xe0>
  c6:	01 fe                	add    %edi,%esi
    DO1(buf);
  c8:	47                   	inc    %edi
  c9:	88 d3                	mov    %dl,%bl
  cb:	c1 ea 08             	shr    $0x8,%edx
  ce:	32 5f ff             	xor    -0x1(%edi),%bl
  d1:	81 e3 ff 00 00 00    	and    $0xff,%ebx
  d7:	8b 04 99             	mov    (%ecx,%ebx,4),%eax
  da:	31 c2                	xor    %eax,%edx
  } while (--len);
  dc:	39 f7                	cmp    %esi,%edi
  de:	75 e8                	jne    c8 <_crc32+0xc8>
  return crc ^ 0xffffffffL;     /* (instead of ~c for 64-bit machines) */
  e0:	89 d0                	mov    %edx,%eax
}
  e2:	5b                   	pop    %ebx
  }
#endif
  if (len) do {
    DO1(buf);
  } while (--len);
  return crc ^ 0xffffffffL;     /* (instead of ~c for 64-bit machines) */
  e3:	83 f0 ff             	xor    $0xffffffff,%eax
}
  e6:	5e                   	pop    %esi
  e7:	5f                   	pop    %edi
  e8:	c3                   	ret    
  e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  f0:	5b                   	pop    %ebx
   pointer, then initialize the crc shift register contents instead.
   Return the current crc in either case. */
{
  register ZCONST ulg near *crc_table;

  if (buf == NULL) return 0L;
  f1:	31 c0                	xor    %eax,%eax
#endif
  if (len) do {
    DO1(buf);
  } while (--len);
  return crc ^ 0xffffffffL;     /* (instead of ~c for 64-bit machines) */
}
  f3:	5e                   	pop    %esi
  f4:	5f                   	pop    %edi
  f5:	c3                   	ret    

  crc_table = get_crc_table();

  crc = crc ^ 0xffffffffL;
#ifndef NO_UNROLLED_LOOPS
  while (len >= 8) {
  f6:	89 df                	mov    %ebx,%edi
  f8:	eb c8                	jmp    c2 <_crc32+0xc2>
  fa:	90                   	nop
  fb:	90                   	nop
  fc:	90                   	nop
  fd:	90                   	nop
  fe:	90                   	nop
  ff:	90                   	nop

crc_i386.o:     file format pe-i386


crctab.o:     file format pe-i386


Disassembly of section .text:

00000000 <_get_crc_table>:
#else
ZCONST ulg near *get_crc_table OF((void))
#endif
{
#ifdef DYNAMIC_CRC_TABLE
  if (CRC_TABLE_IS_EMPTY)
   0:	a1 00 00 00 00       	mov    0x0,%eax
   5:	85 c0                	test   %eax,%eax
   7:	75 06                	jne    f <_get_crc_table+0xf>
#ifdef USE_ZLIB
  return (ZCONST uLongf *)crc_table;
#else
  return (ZCONST ulg near *)crc_table;
#endif
}
   9:	b8 00 00 00 00       	mov    $0x0,%eax
   e:	c3                   	ret    
   f:	31 c9                	xor    %ecx,%ecx
    ziperr(ZE_MEM, "crc_table allocation");
  }
#endif /* DYNALLOC_CRCTAB */

  for (n = 0; n < 256; n++) {
    c = (ulg)n;
  11:	89 c8                	mov    %ecx,%eax
  13:	ba 08 00 00 00       	mov    $0x8,%edx
  18:	eb 10                	jmp    2a <_get_crc_table+0x2a>
  1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    for (k = 8; k; k--)
      c = c & 1 ? xor ^ (c >> 1) : c >> 1;
  20:	d1 e8                	shr    %eax
  22:	35 20 83 b8 ed       	xor    $0xedb88320,%eax
  }
#endif /* DYNALLOC_CRCTAB */

  for (n = 0; n < 256; n++) {
    c = (ulg)n;
    for (k = 8; k; k--)
  27:	4a                   	dec    %edx
  28:	74 09                	je     33 <_get_crc_table+0x33>
      c = c & 1 ? xor ^ (c >> 1) : c >> 1;
  2a:	a8 01                	test   $0x1,%al
  2c:	75 f2                	jne    20 <_get_crc_table+0x20>
  2e:	d1 e8                	shr    %eax
  }
#endif /* DYNALLOC_CRCTAB */

  for (n = 0; n < 256; n++) {
    c = (ulg)n;
    for (k = 8; k; k--)
  30:	4a                   	dec    %edx
  31:	75 f7                	jne    2a <_get_crc_table+0x2a>
      c = c & 1 ? xor ^ (c >> 1) : c >> 1;
    crctab_p[n] = c;
  33:	89 04 8d 00 00 00 00 	mov    %eax,0x0(,%ecx,4)
  if (crctab_p == NULL) {
    ziperr(ZE_MEM, "crc_table allocation");
  }
#endif /* DYNALLOC_CRCTAB */

  for (n = 0; n < 256; n++) {
  3a:	41                   	inc    %ecx
  3b:	81 f9 00 01 00 00    	cmp    $0x100,%ecx
  41:	75 ce                	jne    11 <_get_crc_table+0x11>
    c = (ulg)n;
    for (k = 8; k; k--)
      c = c & 1 ? xor ^ (c >> 1) : c >> 1;
    crctab_p[n] = c;
  }
  MARK_CRCTAB_FILLED;
  43:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
  4a:	00 00 00 
#ifdef USE_ZLIB
  return (ZCONST uLongf *)crc_table;
#else
  return (ZCONST ulg near *)crc_table;
#endif
}
  4d:	b8 00 00 00 00       	mov    $0x0,%eax
  52:	c3                   	ret    
  53:	90                   	nop
  54:	90                   	nop
  55:	90                   	nop
  56:	90                   	nop
  57:	90                   	nop
  58:	90                   	nop
  59:	90                   	nop
  5a:	90                   	nop
  5b:	90                   	nop
  5c:	90                   	nop
  5d:	90                   	nop
  5e:	90                   	nop
  5f:	90                   	nop

crypt.o:     file format pe-i386


Disassembly of section .text:

00000000 <_decrypt_byte>:
{
    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
                     * unpredictable manner on 16-bit systems; not a problem
                     * with any known compiler so far, though */

    temp = ((unsigned)GLOBAL(keys[2]) & 0xffff) | 2;
   0:	8b 44 24 04          	mov    0x4(%esp),%eax
   4:	8b 88 f4 0a 01 00    	mov    0x10af4(%eax),%ecx
   a:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  10:	89 c8                	mov    %ecx,%eax
  12:	83 c8 02             	or     $0x2,%eax
    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
  15:	89 c2                	mov    %eax,%edx
  17:	83 f2 01             	xor    $0x1,%edx
  1a:	0f af c2             	imul   %edx,%eax
  1d:	0f b6 c4             	movzbl %ah,%eax
}
  20:	c3                   	ret    
  21:	eb 0d                	jmp    30 <_update_keys>
  23:	90                   	nop
  24:	90                   	nop
  25:	90                   	nop
  26:	90                   	nop
  27:	90                   	nop
  28:	90                   	nop
  29:	90                   	nop
  2a:	90                   	nop
  2b:	90                   	nop
  2c:	90                   	nop
  2d:	90                   	nop
  2e:	90                   	nop
  2f:	90                   	nop

00000030 <_update_keys>:
 * Update the encryption keys with the next byte of plain text
 */
int update_keys(__G__ c)
    __GDEF
    int c;                      /* byte of plain text */
{
  30:	57                   	push   %edi
  31:	56                   	push   %esi
  32:	53                   	push   %ebx
  33:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  37:	8b 44 24 14          	mov    0x14(%esp),%eax
    GLOBAL(keys[0]) = CRC32(GLOBAL(keys[0]), c);
  3b:	89 c1                	mov    %eax,%ecx
  3d:	8b 93 ec 0a 01 00    	mov    0x10aec(%ebx),%edx
  43:	8b b3 dc 08 01 00    	mov    0x108dc(%ebx),%esi
  49:	31 d1                	xor    %edx,%ecx
  4b:	c1 ea 08             	shr    $0x8,%edx
  4e:	81 e1 ff 00 00 00    	and    $0xff,%ecx
  54:	8b 3c 8e             	mov    (%esi,%ecx,4),%edi
    GLOBAL(keys[1]) += GLOBAL(keys[0]) & 0xff;
  57:	8b 8b f0 0a 01 00    	mov    0x10af0(%ebx),%ecx
 */
int update_keys(__G__ c)
    __GDEF
    int c;                      /* byte of plain text */
{
    GLOBAL(keys[0]) = CRC32(GLOBAL(keys[0]), c);
  5d:	31 fa                	xor    %edi,%edx
  5f:	89 93 ec 0a 01 00    	mov    %edx,0x10aec(%ebx)
    GLOBAL(keys[1]) += GLOBAL(keys[0]) & 0xff;
  65:	81 e2 ff 00 00 00    	and    $0xff,%edx
  6b:	01 ca                	add    %ecx,%edx
    GLOBAL(keys[1]) = GLOBAL(keys[1]) * 134775813L + 1;
  6d:	89 d7                	mov    %edx,%edi
  6f:	89 d1                	mov    %edx,%ecx
  71:	c1 e7 04             	shl    $0x4,%edi
  74:	c1 e1 0c             	shl    $0xc,%ecx
  77:	01 f9                	add    %edi,%ecx
  79:	01 d1                	add    %edx,%ecx
  7b:	c1 e1 05             	shl    $0x5,%ecx
  7e:	01 d1                	add    %edx,%ecx
  80:	c1 e1 08             	shl    $0x8,%ecx
  83:	01 d1                	add    %edx,%ecx
  85:	8d 54 8a 01          	lea    0x1(%edx,%ecx,4),%edx
    {
      register int keyshift = (int)(GLOBAL(keys[1]) >> 24);
      GLOBAL(keys[2]) = CRC32(GLOBAL(keys[2]), keyshift);
  89:	8b 8b f4 0a 01 00    	mov    0x10af4(%ebx),%ecx
    __GDEF
    int c;                      /* byte of plain text */
{
    GLOBAL(keys[0]) = CRC32(GLOBAL(keys[0]), c);
    GLOBAL(keys[1]) += GLOBAL(keys[0]) & 0xff;
    GLOBAL(keys[1]) = GLOBAL(keys[1]) * 134775813L + 1;
  8f:	89 93 f0 0a 01 00    	mov    %edx,0x10af0(%ebx)
    {
      register int keyshift = (int)(GLOBAL(keys[1]) >> 24);
  95:	c1 ea 18             	shr    $0x18,%edx
      GLOBAL(keys[2]) = CRC32(GLOBAL(keys[2]), keyshift);
  98:	31 ca                	xor    %ecx,%edx
  9a:	c1 e9 08             	shr    $0x8,%ecx
  9d:	81 e2 ff 00 00 00    	and    $0xff,%edx
  a3:	8b 3c 96             	mov    (%esi,%edx,4),%edi
  a6:	31 f9                	xor    %edi,%ecx
  a8:	89 8b f4 0a 01 00    	mov    %ecx,0x10af4(%ebx)
    }
    return c;
}
  ae:	5b                   	pop    %ebx
  af:	5e                   	pop    %esi
  b0:	5f                   	pop    %edi
  b1:	c3                   	ret    
  b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000000c0 <_init_keys>:
 * the given password.
 */
void init_keys(__G__ passwd)
    __GDEF
    ZCONST char *passwd;        /* password string with which to modify keys */
{
  c0:	56                   	push   %esi
  c1:	53                   	push   %ebx
  c2:	83 ec 08             	sub    $0x8,%esp
  c5:	8b 74 24 14          	mov    0x14(%esp),%esi
  c9:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    GLOBAL(keys[0]) = 305419896L;
  cd:	c7 86 ec 0a 01 00 78 	movl   $0x12345678,0x10aec(%esi)
  d4:	56 34 12 
    GLOBAL(keys[1]) = 591751049L;
  d7:	c7 86 f0 0a 01 00 89 	movl   $0x23456789,0x10af0(%esi)
  de:	67 45 23 
    GLOBAL(keys[2]) = 878082192L;
  e1:	c7 86 f4 0a 01 00 90 	movl   $0x34567890,0x10af4(%esi)
  e8:	78 56 34 
    while (*passwd != '\0') {
  eb:	0f be 03             	movsbl (%ebx),%eax
  ee:	84 c0                	test   %al,%al
  f0:	74 14                	je     106 <_init_keys+0x46>
        update_keys(__G__ (int)*passwd);
        passwd++;
  f2:	43                   	inc    %ebx
{
    GLOBAL(keys[0]) = 305419896L;
    GLOBAL(keys[1]) = 591751049L;
    GLOBAL(keys[2]) = 878082192L;
    while (*passwd != '\0') {
        update_keys(__G__ (int)*passwd);
  f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  f7:	89 34 24             	mov    %esi,(%esp)
  fa:	e8 31 ff ff ff       	call   30 <_update_keys>
    ZCONST char *passwd;        /* password string with which to modify keys */
{
    GLOBAL(keys[0]) = 305419896L;
    GLOBAL(keys[1]) = 591751049L;
    GLOBAL(keys[2]) = 878082192L;
    while (*passwd != '\0') {
  ff:	0f be 03             	movsbl (%ebx),%eax
 102:	84 c0                	test   %al,%al
 104:	75 ec                	jne    f2 <_init_keys+0x32>
        update_keys(__G__ (int)*passwd);
        passwd++;
    }
}
 106:	83 c4 08             	add    $0x8,%esp
 109:	5b                   	pop    %ebx
 10a:	5e                   	pop    %esi
 10b:	c3                   	ret    
 10c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000110 <_testkey>:

local int testkey(__G__ h, key)
    __GDEF
    ZCONST uch *h;      /* decrypted header */
    ZCONST char *key;   /* decryption password to test */
{
 110:	57                   	push   %edi
 111:	56                   	push   %esi
 112:	53                   	push   %ebx
 113:	89 d6                	mov    %edx,%esi
 115:	83 ec 18             	sub    $0x18,%esp
 118:	89 c3                	mov    %eax,%ebx
    int n;
    uch *p;
    uch hh[RAND_HEAD_LEN]; /* decrypted header */

    /* set keys and save the encrypted header */
    init_keys(__G__ key);
 11a:	89 04 24             	mov    %eax,(%esp)
 11d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 121:	e8 9a ff ff ff       	call   c0 <_init_keys>
    memcpy(hh, h, RAND_HEAD_LEN);
 126:	8b 06                	mov    (%esi),%eax
 128:	89 44 24 0c          	mov    %eax,0xc(%esp)
 12c:	8b 46 04             	mov    0x4(%esi),%eax
 12f:	89 44 24 10          	mov    %eax,0x10(%esp)
 133:	8b 46 08             	mov    0x8(%esi),%eax
 136:	89 44 24 14          	mov    %eax,0x14(%esp)
 13a:	8d 7c 24 0c          	lea    0xc(%esp),%edi
 13e:	8d 74 24 18          	lea    0x18(%esp),%esi
{
    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
                     * unpredictable manner on 16-bit systems; not a problem
                     * with any known compiler so far, though */

    temp = ((unsigned)GLOBAL(keys[2]) & 0xffff) | 2;
 142:	31 d2                	xor    %edx,%edx
 144:	47                   	inc    %edi
 145:	66 8b 93 f4 0a 01 00 	mov    0x10af4(%ebx),%dx
 14c:	83 ca 02             	or     $0x2,%edx
    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
 14f:	89 d0                	mov    %edx,%eax
 151:	83 f0 01             	xor    $0x1,%eax
 154:	0f af d0             	imul   %eax,%edx
 157:	c1 ea 08             	shr    $0x8,%edx
    init_keys(__G__ key);
    memcpy(hh, h, RAND_HEAD_LEN);

    /* check password */
    for (n = 0; n < RAND_HEAD_LEN; n++) {
        zdecode(hh[n]);
 15a:	32 57 ff             	xor    -0x1(%edi),%dl
 15d:	88 57 ff             	mov    %dl,-0x1(%edi)
 160:	81 e2 ff 00 00 00    	and    $0xff,%edx
 166:	89 54 24 04          	mov    %edx,0x4(%esp)
 16a:	89 1c 24             	mov    %ebx,(%esp)
 16d:	e8 be fe ff ff       	call   30 <_update_keys>
    /* set keys and save the encrypted header */
    init_keys(__G__ key);
    memcpy(hh, h, RAND_HEAD_LEN);

    /* check password */
    for (n = 0; n < RAND_HEAD_LEN; n++) {
 172:	39 f7                	cmp    %esi,%edi
 174:	75 cc                	jne    142 <_testkey+0x32>
#else
    b = hh[RAND_HEAD_LEN-1];
    Trace((stdout, "  b = %02x  (crc >> 24) = %02x  (lrec.time >> 8) = %02x\n",
      b, (ush)(GLOBAL(lrec.crc32) >> 24),
      ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff));
    if (b != (GLOBAL(pInfo->ExtLocHdr) ?
 176:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
 17c:	31 d2                	xor    %edx,%edx
 17e:	8a 54 24 17          	mov    0x17(%esp),%dl
        ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff :
 182:	f6 40 18 02          	testb  $0x2,0x18(%eax)
 186:	74 68                	je     1f0 <_testkey+0xe0>
 188:	31 c0                	xor    %eax,%eax
 18a:	8a 83 29 09 01 00    	mov    0x10929(%ebx),%al
#else
    b = hh[RAND_HEAD_LEN-1];
    Trace((stdout, "  b = %02x  (crc >> 24) = %02x  (lrec.time >> 8) = %02x\n",
      b, (ush)(GLOBAL(lrec.crc32) >> 24),
      ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff));
    if (b != (GLOBAL(pInfo->ExtLocHdr) ?
 190:	39 c2                	cmp    %eax,%edx
 192:	75 66                	jne    1fa <_testkey+0xea>
        ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff :
        (ush)(GLOBAL(lrec.crc32) >> 24)))
        return -1;  /* bad */
#endif
    /* password OK:  decrypt current buffer contents before leaving */
    for (n = (long)GLOBAL(incnt) > GLOBAL(csize) ?
 194:	8b b3 ec 08 01 00    	mov    0x108ec(%ebx),%esi
             (int)GLOBAL(csize) : GLOBAL(incnt),
         p = GLOBAL(inptr); n--; p++)
 19a:	8b bb e8 08 01 00    	mov    0x108e8(%ebx),%edi
        ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff :
        (ush)(GLOBAL(lrec.crc32) >> 24)))
        return -1;  /* bad */
#endif
    /* password OK:  decrypt current buffer contents before leaving */
    for (n = (long)GLOBAL(incnt) > GLOBAL(csize) ?
 1a0:	39 b3 90 00 00 00    	cmp    %esi,0x90(%ebx)
 1a6:	0f 4e b3 90 00 00 00 	cmovle 0x90(%ebx),%esi
 1ad:	85 f6                	test   %esi,%esi
 1af:	74 32                	je     1e3 <_testkey+0xd3>
{
    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
                     * unpredictable manner on 16-bit systems; not a problem
                     * with any known compiler so far, though */

    temp = ((unsigned)GLOBAL(keys[2]) & 0xffff) | 2;
 1b1:	31 c0                	xor    %eax,%eax
        return -1;  /* bad */
#endif
    /* password OK:  decrypt current buffer contents before leaving */
    for (n = (long)GLOBAL(incnt) > GLOBAL(csize) ?
             (int)GLOBAL(csize) : GLOBAL(incnt),
         p = GLOBAL(inptr); n--; p++)
 1b3:	47                   	inc    %edi
{
    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
                     * unpredictable manner on 16-bit systems; not a problem
                     * with any known compiler so far, though */

    temp = ((unsigned)GLOBAL(keys[2]) & 0xffff) | 2;
 1b4:	66 8b 83 f4 0a 01 00 	mov    0x10af4(%ebx),%ax
 1bb:	83 c8 02             	or     $0x2,%eax
    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
 1be:	89 c2                	mov    %eax,%edx
 1c0:	83 f2 01             	xor    $0x1,%edx
 1c3:	0f af c2             	imul   %edx,%eax
 1c6:	c1 e8 08             	shr    $0x8,%eax
#endif
    /* password OK:  decrypt current buffer contents before leaving */
    for (n = (long)GLOBAL(incnt) > GLOBAL(csize) ?
             (int)GLOBAL(csize) : GLOBAL(incnt),
         p = GLOBAL(inptr); n--; p++)
        zdecode(*p);
 1c9:	32 47 ff             	xor    -0x1(%edi),%al
 1cc:	88 47 ff             	mov    %al,-0x1(%edi)
 1cf:	25 ff 00 00 00       	and    $0xff,%eax
 1d4:	89 44 24 04          	mov    %eax,0x4(%esp)
 1d8:	89 1c 24             	mov    %ebx,(%esp)
 1db:	e8 50 fe ff ff       	call   30 <_update_keys>
        ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff :
        (ush)(GLOBAL(lrec.crc32) >> 24)))
        return -1;  /* bad */
#endif
    /* password OK:  decrypt current buffer contents before leaving */
    for (n = (long)GLOBAL(incnt) > GLOBAL(csize) ?
 1e0:	4e                   	dec    %esi
 1e1:	75 ce                	jne    1b1 <_testkey+0xa1>
             (int)GLOBAL(csize) : GLOBAL(incnt),
         p = GLOBAL(inptr); n--; p++)
        zdecode(*p);
    return 0;       /* OK */
 1e3:	31 c0                	xor    %eax,%eax

} /* end function testkey() */
 1e5:	83 c4 18             	add    $0x18,%esp
 1e8:	5b                   	pop    %ebx
 1e9:	5e                   	pop    %esi
 1ea:	5f                   	pop    %edi
 1eb:	c3                   	ret    
 1ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    Trace((stdout, "  b = %02x  (crc >> 24) = %02x  (lrec.time >> 8) = %02x\n",
      b, (ush)(GLOBAL(lrec.crc32) >> 24),
      ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff));
    if (b != (GLOBAL(pInfo->ExtLocHdr) ?
        ((ush)GLOBAL(lrec.last_mod_dos_datetime) >> 8) & 0xff :
        (ush)(GLOBAL(lrec.crc32) >> 24)))
 1f0:	31 c0                	xor    %eax,%eax
 1f2:	8a 83 2f 09 01 00    	mov    0x1092f(%ebx),%al
 1f8:	eb 96                	jmp    190 <_testkey+0x80>
        return -1;  /* bad */
 1fa:	83 c8 ff             	or     $0xffffffff,%eax
 1fd:	eb e6                	jmp    1e5 <_testkey+0xd5>
 1ff:	90                   	nop

00000200 <_testp>:
 * Test the password.  Return -1 if bad, 0 if OK.
 */
local int testp(__G__ h)
    __GDEF
    ZCONST uch *h;
{
 200:	55                   	push   %ebp
 201:	57                   	push   %edi
 202:	56                   	push   %esi
 203:	53                   	push   %ebx
 204:	83 ec 1c             	sub    $0x1c,%esp
 207:	89 c3                	mov    %eax,%ebx
        return -1;
    /* first try, test password translated "standard" charset */
    r = testkey(__G__ h, STR_TO_CP1(key_translated, GLOBAL(key)));
#else /* !STR_TO_CP1 */
    /* first try, test password as supplied on the extractor's host */
    r = testkey(__G__ h, GLOBAL(key));
 209:	8b 88 e4 0a 01 00    	mov    0x10ae4(%eax),%ecx
 * Test the password.  Return -1 if bad, 0 if OK.
 */
local int testp(__G__ h)
    __GDEF
    ZCONST uch *h;
{
 20f:	89 d6                	mov    %edx,%esi
        return -1;
    /* first try, test password translated "standard" charset */
    r = testkey(__G__ h, STR_TO_CP1(key_translated, GLOBAL(key)));
#else /* !STR_TO_CP1 */
    /* first try, test password as supplied on the extractor's host */
    r = testkey(__G__ h, GLOBAL(key));
 211:	e8 fa fe ff ff       	call   110 <_testkey>
#endif /* ?STR_TO_CP1 */

#ifdef STR_TO_CP2
    if (r != 0) {
 216:	85 c0                	test   %eax,%eax
 218:	75 0a                	jne    224 <_testp+0x24>
 21a:	31 c0                	xor    %eax,%eax
    }
#endif /* STR_TO_CP1 */

    return r;

} /* end function testp() */
 21c:	83 c4 1c             	add    $0x1c,%esp
 21f:	5b                   	pop    %ebx
 220:	5e                   	pop    %esi
 221:	5f                   	pop    %edi
 222:	5d                   	pop    %ebp
 223:	c3                   	ret    

#ifdef STR_TO_CP2
    if (r != 0) {
#ifndef STR_TO_CP1
        /* now prepare for second (and maybe third) test with translated pwd */
        if ((key_translated = malloc(strlen(GLOBAL(key)) + 1)) == (char *)NULL)
 224:	8b ab e4 0a 01 00    	mov    0x10ae4(%ebx),%ebp
 22a:	89 2c 24             	mov    %ebp,(%esp)
 22d:	e8 00 00 00 00       	call   232 <_testp+0x32>
 232:	40                   	inc    %eax
 233:	89 04 24             	mov    %eax,(%esp)
 236:	e8 00 00 00 00       	call   23b <_testp+0x3b>
 23b:	89 c7                	mov    %eax,%edi
 23d:	85 c0                	test   %eax,%eax
 23f:	74 2d                	je     26e <_testp+0x6e>
            return -1;
#endif
        /* second try, password translated to alternate ("standard") charset */
        r = testkey(__G__ h, STR_TO_CP2(key_translated, GLOBAL(key)));
 241:	89 2c 24             	mov    %ebp,(%esp)
 244:	89 44 24 04          	mov    %eax,0x4(%esp)
 248:	e8 00 00 00 00       	call   24d <_testp+0x4d>
 24d:	89 f9                	mov    %edi,%ecx
 24f:	89 f2                	mov    %esi,%edx
 251:	50                   	push   %eax
 252:	50                   	push   %eax
 253:	89 d8                	mov    %ebx,%eax
 255:	e8 b6 fe ff ff       	call   110 <_testkey>
        if (r != 0)
            /* third try, password translated to another "standard" charset */
            r = testkey(__G__ h, STR_TO_CP3(key_translated, GLOBAL(key)));
#endif
#ifndef STR_TO_CP1
        free(key_translated);
 25a:	89 3c 24             	mov    %edi,(%esp)
        /* now prepare for second (and maybe third) test with translated pwd */
        if ((key_translated = malloc(strlen(GLOBAL(key)) + 1)) == (char *)NULL)
            return -1;
#endif
        /* second try, password translated to alternate ("standard") charset */
        r = testkey(__G__ h, STR_TO_CP2(key_translated, GLOBAL(key)));
 25d:	89 c3                	mov    %eax,%ebx
        if (r != 0)
            /* third try, password translated to another "standard" charset */
            r = testkey(__G__ h, STR_TO_CP3(key_translated, GLOBAL(key)));
#endif
#ifndef STR_TO_CP1
        free(key_translated);
 25f:	e8 00 00 00 00       	call   264 <_testp+0x64>
    }
#endif /* STR_TO_CP1 */

    return r;

} /* end function testp() */
 264:	83 c4 1c             	add    $0x1c,%esp
        /* now prepare for second (and maybe third) test with translated pwd */
        if ((key_translated = malloc(strlen(GLOBAL(key)) + 1)) == (char *)NULL)
            return -1;
#endif
        /* second try, password translated to alternate ("standard") charset */
        r = testkey(__G__ h, STR_TO_CP2(key_translated, GLOBAL(key)));
 267:	89 d8                	mov    %ebx,%eax
    }
#endif /* STR_TO_CP1 */

    return r;

} /* end function testp() */
 269:	5b                   	pop    %ebx
 26a:	5e                   	pop    %esi
 26b:	5f                   	pop    %edi
 26c:	5d                   	pop    %ebp
 26d:	c3                   	ret    
#ifdef STR_TO_CP2
    if (r != 0) {
#ifndef STR_TO_CP1
        /* now prepare for second (and maybe third) test with translated pwd */
        if ((key_translated = malloc(strlen(GLOBAL(key)) + 1)) == (char *)NULL)
            return -1;
 26e:	83 c8 ff             	or     $0xffffffff,%eax
 271:	eb a9                	jmp    21c <_testp+0x1c>
 273:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 279:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000280 <_decrypt>:
 * Return PK_ class error.
 */
int decrypt(__G__ passwrd)
    __GDEF
    ZCONST char *passwrd;
{
 280:	55                   	push   %ebp
 281:	57                   	push   %edi
 282:	56                   	push   %esi
 283:	53                   	push   %ebx
 284:	83 ec 3c             	sub    $0x3c,%esp
 287:	8b 5c 24 50          	mov    0x50(%esp),%ebx

    Trace((stdout, "\n[incnt = %d]: ", GLOBAL(incnt)));

    /* get header once (turn off "encrypted" flag temporarily so we don't
     * try to decrypt the same data twice) */
    GLOBAL(pInfo->encrypted) = FALSE;
 28b:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
 291:	80 60 18 fe          	andb   $0xfe,0x18(%eax)
    defer_leftover_input(__G);
 295:	89 1c 24             	mov    %ebx,(%esp)
 298:	e8 00 00 00 00       	call   29d <_decrypt+0x1d>
    for (n = 0; n < RAND_HEAD_LEN; n++) {
 29d:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 2a4:	00 
 2a5:	eb 25                	jmp    2cc <_decrypt+0x4c>
        b = NEXTBYTE;
 2a7:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
 2ad:	8d 50 01             	lea    0x1(%eax),%edx
 2b0:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
 2b6:	31 d2                	xor    %edx,%edx
 2b8:	8a 10                	mov    (%eax),%dl
        h[n] = (uch)b;
 2ba:	8b 44 24 20          	mov    0x20(%esp),%eax
 2be:	88 54 04 24          	mov    %dl,0x24(%esp,%eax,1)

    /* get header once (turn off "encrypted" flag temporarily so we don't
     * try to decrypt the same data twice) */
    GLOBAL(pInfo->encrypted) = FALSE;
    defer_leftover_input(__G);
    for (n = 0; n < RAND_HEAD_LEN; n++) {
 2c2:	40                   	inc    %eax
 2c3:	89 44 24 20          	mov    %eax,0x20(%esp)
 2c7:	83 f8 0b             	cmp    $0xb,%eax
 2ca:	7f 24                	jg     2f0 <_decrypt+0x70>
        b = NEXTBYTE;
 2cc:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
 2d2:	85 c0                	test   %eax,%eax
 2d4:	8d 50 ff             	lea    -0x1(%eax),%edx
 2d7:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
 2dd:	7f c8                	jg     2a7 <_decrypt+0x27>
 2df:	89 1c 24             	mov    %ebx,(%esp)
 2e2:	e8 00 00 00 00       	call   2e7 <_decrypt+0x67>
 2e7:	89 c2                	mov    %eax,%edx
 2e9:	eb cf                	jmp    2ba <_decrypt+0x3a>
 2eb:	90                   	nop
 2ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        h[n] = (uch)b;
        Trace((stdout, " (%02x)", h[n]));
    }
    undefer_input(__G);
 2f0:	89 1c 24             	mov    %ebx,(%esp)
 2f3:	e8 00 00 00 00       	call   2f8 <_decrypt+0x78>
    GLOBAL(pInfo->encrypted) = TRUE;
 2f8:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
 2fe:	80 48 18 01          	orb    $0x1,0x18(%eax)

    if (GLOBAL(newzip)) { /* this is first encrypted member in this zipfile */
 302:	8b ab 84 00 00 00    	mov    0x84(%ebx),%ebp
 308:	85 ed                	test   %ebp,%ebp
 30a:	0f 84 f0 00 00 00    	je     400 <_decrypt+0x180>
        GLOBAL(newzip) = FALSE;
        if (passwrd != (char *)NULL) { /* user gave password on command line */
 310:	8b 7c 24 54          	mov    0x54(%esp),%edi
    }
    undefer_input(__G);
    GLOBAL(pInfo->encrypted) = TRUE;

    if (GLOBAL(newzip)) { /* this is first encrypted member in this zipfile */
        GLOBAL(newzip) = FALSE;
 314:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
 31b:	00 00 00 
        if (passwrd != (char *)NULL) { /* user gave password on command line */
 31e:	85 ff                	test   %edi,%edi
 320:	0f 84 09 01 00 00    	je     42f <_decrypt+0x1af>
            if (!GLOBAL(key)) {
 326:	8b b3 e4 0a 01 00    	mov    0x10ae4(%ebx),%esi
 32c:	85 f6                	test   %esi,%esi
 32e:	0f 84 53 01 00 00    	je     487 <_decrypt+0x207>
        }
    }

    /* if have key already, test it; else allocate memory for it */
    if (GLOBAL(key)) {
        if (!testp(__G__ h))
 334:	8d 54 24 24          	lea    0x24(%esp),%edx
 338:	89 d8                	mov    %ebx,%eax
 33a:	e8 c1 fe ff ff       	call   200 <_testp>
 33f:	85 c0                	test   %eax,%eax
 341:	0f 84 a9 00 00 00    	je     3f0 <_decrypt+0x170>
            return PK_COOL;   /* existing password OK (else prompt for new) */
        else if (GLOBAL(nopwd))
 347:	8b 93 e8 0a 01 00    	mov    0x10ae8(%ebx),%edx
 34d:	85 d2                	test   %edx,%edx
 34f:	0f 85 bb 00 00 00    	jne    410 <_decrypt+0x190>
 355:	8b 83 e4 0a 01 00    	mov    0x10ae4(%ebx),%eax
            return PK_WARN;   /* user indicated no more prompting */
    } else if ((GLOBAL(key) = (char *)malloc(IZ_PWLEN+1)) == (char *)NULL)
        return PK_MEM2;

    /* try a few keys */
    n = 0;
 35b:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 362:	00 
 363:	8d ab e0 09 01 00    	lea    0x109e0(%ebx),%ebp
 369:	8d 7c 24 20          	lea    0x20(%esp),%edi
 36d:	eb 38                	jmp    3a7 <_decrypt+0x127>
 36f:	90                   	nop
            free (GLOBAL(key));
            GLOBAL(key) = NULL;
            return PK_MEM2;
        }
        if (r != IZ_PW_ENTERED) {       /* user replied "skip" or "skip all" */
            *GLOBAL(key) = '\0';        /*   We try the NIL password, ... */
 370:	8b 83 e4 0a 01 00    	mov    0x10ae4(%ebx),%eax
            n = 0;                      /*   and cancel fetch for this item. */
        }
        if (!testp(__G__ h))
 376:	8d 54 24 24          	lea    0x24(%esp),%edx
            free (GLOBAL(key));
            GLOBAL(key) = NULL;
            return PK_MEM2;
        }
        if (r != IZ_PW_ENTERED) {       /* user replied "skip" or "skip all" */
            *GLOBAL(key) = '\0';        /*   We try the NIL password, ... */
 37a:	c6 00 00             	movb   $0x0,(%eax)
            n = 0;                      /*   and cancel fetch for this item. */
        }
        if (!testp(__G__ h))
 37d:	89 d8                	mov    %ebx,%eax
            GLOBAL(key) = NULL;
            return PK_MEM2;
        }
        if (r != IZ_PW_ENTERED) {       /* user replied "skip" or "skip all" */
            *GLOBAL(key) = '\0';        /*   We try the NIL password, ... */
            n = 0;                      /*   and cancel fetch for this item. */
 37f:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 386:	00 
        }
        if (!testp(__G__ h))
 387:	e8 74 fe ff ff       	call   200 <_testp>
 38c:	85 c0                	test   %eax,%eax
 38e:	74 60                	je     3f0 <_decrypt+0x170>
            return PK_COOL;
        if (r == IZ_PW_CANCELALL)       /* User replied "Skip all" */
 390:	83 fe fe             	cmp    $0xfffffffe,%esi
 393:	0f 84 87 00 00 00    	je     420 <_decrypt+0x1a0>
            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
    } while (n > 0);
 399:	8b 44 24 20          	mov    0x20(%esp),%eax
 39d:	85 c0                	test   %eax,%eax
 39f:	7e 6f                	jle    410 <_decrypt+0x190>
 3a1:	8b 83 e4 0a 01 00    	mov    0x10ae4(%ebx),%eax
        return PK_MEM2;

    /* try a few keys */
    n = 0;
    do {
        r = (*G.decr_passwd)((zvoid *)&G, &n, GLOBAL(key), IZ_PWLEN+1,
 3a7:	89 6c 24 14          	mov    %ebp,0x14(%esp)
 3ab:	8b 93 04 09 01 00    	mov    0x10904(%ebx),%edx
 3b1:	c7 44 24 0c 51 00 00 	movl   $0x51,0xc(%esp)
 3b8:	00 
 3b9:	89 54 24 10          	mov    %edx,0x10(%esp)
 3bd:	89 44 24 08          	mov    %eax,0x8(%esp)
 3c1:	89 7c 24 04          	mov    %edi,0x4(%esp)
 3c5:	89 1c 24             	mov    %ebx,(%esp)
 3c8:	ff 93 50 0b 01 00    	call   *0x10b50(%ebx)
 3ce:	83 ec 18             	sub    $0x18,%esp
 3d1:	89 c6                	mov    %eax,%esi
                             GLOBAL(zipfn), GLOBAL(filename));
        if (r == IZ_PW_ERROR) {         /* internal error in fetch of PW */
 3d3:	83 f8 05             	cmp    $0x5,%eax
 3d6:	0f 84 8c 00 00 00    	je     468 <_decrypt+0x1e8>
            free (GLOBAL(key));
            GLOBAL(key) = NULL;
            return PK_MEM2;
        }
        if (r != IZ_PW_ENTERED) {       /* user replied "skip" or "skip all" */
 3dc:	85 c0                	test   %eax,%eax
 3de:	75 90                	jne    370 <_decrypt+0xf0>
            *GLOBAL(key) = '\0';        /*   We try the NIL password, ... */
            n = 0;                      /*   and cancel fetch for this item. */
        }
        if (!testp(__G__ h))
 3e0:	8d 54 24 24          	lea    0x24(%esp),%edx
 3e4:	89 d8                	mov    %ebx,%eax
 3e6:	e8 15 fe ff ff       	call   200 <_testp>
 3eb:	85 c0                	test   %eax,%eax
 3ed:	75 aa                	jne    399 <_decrypt+0x119>
 3ef:	90                   	nop
            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
    } while (n > 0);

    return PK_WARN;

} /* end function decrypt() */
 3f0:	83 c4 3c             	add    $0x3c,%esp
    }

    /* if have key already, test it; else allocate memory for it */
    if (GLOBAL(key)) {
        if (!testp(__G__ h))
            return PK_COOL;   /* existing password OK (else prompt for new) */
 3f3:	31 c0                	xor    %eax,%eax
            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
    } while (n > 0);

    return PK_WARN;

} /* end function decrypt() */
 3f5:	5b                   	pop    %ebx
 3f6:	5e                   	pop    %esi
 3f7:	5f                   	pop    %edi
 3f8:	5d                   	pop    %ebp
 3f9:	c3                   	ret    
 3fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            GLOBAL(key) = (char *)NULL;
        }
    }

    /* if have key already, test it; else allocate memory for it */
    if (GLOBAL(key)) {
 400:	8b 8b e4 0a 01 00    	mov    0x10ae4(%ebx),%ecx
 406:	85 c9                	test   %ecx,%ecx
 408:	0f 85 26 ff ff ff    	jne    334 <_decrypt+0xb4>
 40e:	eb 31                	jmp    441 <_decrypt+0x1c1>
            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
    } while (n > 0);

    return PK_WARN;

} /* end function decrypt() */
 410:	83 c4 3c             	add    $0x3c,%esp
    /* if have key already, test it; else allocate memory for it */
    if (GLOBAL(key)) {
        if (!testp(__G__ h))
            return PK_COOL;   /* existing password OK (else prompt for new) */
        else if (GLOBAL(nopwd))
            return PK_WARN;   /* user indicated no more prompting */
 413:	b8 01 00 00 00       	mov    $0x1,%eax
            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
    } while (n > 0);

    return PK_WARN;

} /* end function decrypt() */
 418:	5b                   	pop    %ebx
 419:	5e                   	pop    %esi
 41a:	5f                   	pop    %edi
 41b:	5d                   	pop    %ebp
 41c:	c3                   	ret    
 41d:	8d 76 00             	lea    0x0(%esi),%esi
            n = 0;                      /*   and cancel fetch for this item. */
        }
        if (!testp(__G__ h))
            return PK_COOL;
        if (r == IZ_PW_CANCELALL)       /* User replied "Skip all" */
            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
 420:	c7 83 e8 0a 01 00 01 	movl   $0x1,0x10ae8(%ebx)
 427:	00 00 00 
 42a:	e9 6a ff ff ff       	jmp    399 <_decrypt+0x119>
                    (char *)NULL)
                    return PK_MEM2;
                strcpy(GLOBAL(key), passwrd);
                GLOBAL(nopwd) = TRUE;  /* inhibit password prompting! */
            }
        } else if (GLOBAL(key)) { /* get rid of previous zipfile's key */
 42f:	8b 83 e4 0a 01 00    	mov    0x10ae4(%ebx),%eax
 435:	85 c0                	test   %eax,%eax
 437:	74 08                	je     441 <_decrypt+0x1c1>
            free(GLOBAL(key));
 439:	89 04 24             	mov    %eax,(%esp)
 43c:	e8 00 00 00 00       	call   441 <_decrypt+0x1c1>
    if (GLOBAL(key)) {
        if (!testp(__G__ h))
            return PK_COOL;   /* existing password OK (else prompt for new) */
        else if (GLOBAL(nopwd))
            return PK_WARN;   /* user indicated no more prompting */
    } else if ((GLOBAL(key) = (char *)malloc(IZ_PWLEN+1)) == (char *)NULL)
 441:	c7 04 24 51 00 00 00 	movl   $0x51,(%esp)
 448:	e8 00 00 00 00       	call   44d <_decrypt+0x1cd>
 44d:	89 83 e4 0a 01 00    	mov    %eax,0x10ae4(%ebx)
 453:	85 c0                	test   %eax,%eax
 455:	0f 85 00 ff ff ff    	jne    35b <_decrypt+0xdb>
        r = (*G.decr_passwd)((zvoid *)&G, &n, GLOBAL(key), IZ_PWLEN+1,
                             GLOBAL(zipfn), GLOBAL(filename));
        if (r == IZ_PW_ERROR) {         /* internal error in fetch of PW */
            free (GLOBAL(key));
            GLOBAL(key) = NULL;
            return PK_MEM2;
 45b:	b8 05 00 00 00       	mov    $0x5,%eax
            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
    } while (n > 0);

    return PK_WARN;

} /* end function decrypt() */
 460:	83 c4 3c             	add    $0x3c,%esp
 463:	5b                   	pop    %ebx
 464:	5e                   	pop    %esi
 465:	5f                   	pop    %edi
 466:	5d                   	pop    %ebp
 467:	c3                   	ret    
    n = 0;
    do {
        r = (*G.decr_passwd)((zvoid *)&G, &n, GLOBAL(key), IZ_PWLEN+1,
                             GLOBAL(zipfn), GLOBAL(filename));
        if (r == IZ_PW_ERROR) {         /* internal error in fetch of PW */
            free (GLOBAL(key));
 468:	8b 83 e4 0a 01 00    	mov    0x10ae4(%ebx),%eax
 46e:	89 04 24             	mov    %eax,(%esp)
 471:	e8 00 00 00 00       	call   476 <_decrypt+0x1f6>
            GLOBAL(key) = NULL;
 476:	c7 83 e4 0a 01 00 00 	movl   $0x0,0x10ae4(%ebx)
 47d:	00 00 00 
            return PK_MEM2;
 480:	b8 05 00 00 00       	mov    $0x5,%eax
 485:	eb d9                	jmp    460 <_decrypt+0x1e0>

    if (GLOBAL(newzip)) { /* this is first encrypted member in this zipfile */
        GLOBAL(newzip) = FALSE;
        if (passwrd != (char *)NULL) { /* user gave password on command line */
            if (!GLOBAL(key)) {
                if ((GLOBAL(key) = (char *)malloc(strlen(passwrd)+1)) ==
 487:	8b 44 24 54          	mov    0x54(%esp),%eax
 48b:	89 04 24             	mov    %eax,(%esp)
 48e:	e8 00 00 00 00       	call   493 <_decrypt+0x213>
 493:	40                   	inc    %eax
 494:	89 04 24             	mov    %eax,(%esp)
 497:	e8 00 00 00 00       	call   49c <_decrypt+0x21c>
 49c:	89 83 e4 0a 01 00    	mov    %eax,0x10ae4(%ebx)
 4a2:	85 c0                	test   %eax,%eax
 4a4:	74 b5                	je     45b <_decrypt+0x1db>
                    (char *)NULL)
                    return PK_MEM2;
                strcpy(GLOBAL(key), passwrd);
 4a6:	8b 4c 24 54          	mov    0x54(%esp),%ecx
 4aa:	89 04 24             	mov    %eax,(%esp)
 4ad:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 4b1:	e8 00 00 00 00       	call   4b6 <_decrypt+0x236>
                GLOBAL(nopwd) = TRUE;  /* inhibit password prompting! */
 4b6:	c7 83 e8 0a 01 00 01 	movl   $0x1,0x10ae8(%ebx)
 4bd:	00 00 00 
 4c0:	e9 6f fe ff ff       	jmp    334 <_decrypt+0xb4>
 4c5:	90                   	nop
 4c6:	90                   	nop
 4c7:	90                   	nop
 4c8:	90                   	nop
 4c9:	90                   	nop
 4ca:	90                   	nop
 4cb:	90                   	nop
 4cc:	90                   	nop
 4cd:	90                   	nop
 4ce:	90                   	nop
 4cf:	90                   	nop

explode.o:     file format pe-i386


Disassembly of section .text:

00000000 <_get_tree>:
unsigned *l;            /* bit lengths */
unsigned n;             /* number expected */
/* Get the bit lengths for a code representation from the compressed
   stream.  If get_tree() returns 4, then there is an error in the data.
   Otherwise zero is returned. */
{
       0:	55                   	push   %ebp
       1:	57                   	push   %edi
       2:	56                   	push   %esi
       3:	53                   	push   %ebx
       4:	83 ec 2c             	sub    $0x2c,%esp
       7:	89 d5                	mov    %edx,%ebp
  unsigned j;           /* number of codes */
  unsigned b;           /* bit length for those codes */


  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
       9:	8b 90 ec 08 01 00    	mov    0x108ec(%eax),%edx
unsigned *l;            /* bit lengths */
unsigned n;             /* number expected */
/* Get the bit lengths for a code representation from the compressed
   stream.  If get_tree() returns 4, then there is an error in the data.
   Otherwise zero is returned. */
{
       f:	89 c7                	mov    %eax,%edi
      11:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  unsigned j;           /* number of codes */
  unsigned b;           /* bit length for those codes */


  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
      15:	85 d2                	test   %edx,%edx
      17:	8d 42 ff             	lea    -0x1(%edx),%eax
      1a:	89 87 ec 08 01 00    	mov    %eax,0x108ec(%edi)
      20:	0f 8e b4 00 00 00    	jle    da <_get_tree+0xda>
      26:	8b 97 e8 08 01 00    	mov    0x108e8(%edi),%edx
      2c:	8d 4a 01             	lea    0x1(%edx),%ecx
      2f:	89 8f e8 08 01 00    	mov    %ecx,0x108e8(%edi)
      35:	0f b6 32             	movzbl (%edx),%esi
      38:	81 e6 ff 00 00 00    	and    $0xff,%esi
      3e:	8d 76 01             	lea    0x1(%esi),%esi
      41:	89 74 24 1c          	mov    %esi,0x1c(%esp)
unsigned *l;            /* bit lengths */
unsigned n;             /* number expected */
/* Get the bit lengths for a code representation from the compressed
   stream.  If get_tree() returns 4, then there is an error in the data.
   Otherwise zero is returned. */
{
      45:	31 d2                	xor    %edx,%edx

  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
  k = 0;                                /* next code */
  do {
    b = ((j = NEXTBYTE) & 0xf) + 1;     /* bits in code (1..16) */
      47:	85 c0                	test   %eax,%eax
unsigned *l;            /* bit lengths */
unsigned n;             /* number expected */
/* Get the bit lengths for a code representation from the compressed
   stream.  If get_tree() returns 4, then there is an error in the data.
   Otherwise zero is returned. */
{
      49:	89 d6                	mov    %edx,%esi

  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
  k = 0;                                /* next code */
  do {
    b = ((j = NEXTBYTE) & 0xf) + 1;     /* bits in code (1..16) */
      4b:	8d 50 ff             	lea    -0x1(%eax),%edx
      4e:	89 97 ec 08 01 00    	mov    %edx,0x108ec(%edi)
      54:	7e 5d                	jle    b3 <_get_tree+0xb3>
      56:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
      5c:	8d 50 01             	lea    0x1(%eax),%edx
      5f:	89 97 e8 08 01 00    	mov    %edx,0x108e8(%edi)
      65:	8a 18                	mov    (%eax),%bl
      67:	81 e3 ff 00 00 00    	and    $0xff,%ebx
      6d:	89 d8                	mov    %ebx,%eax
      6f:	89 c3                	mov    %eax,%ebx
    j = ((j & 0xf0) >> 4) + 1;          /* codes with those bits (1..16) */
      71:	25 f0 00 00 00       	and    $0xf0,%eax
      76:	89 c1                	mov    %eax,%ecx

  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
  k = 0;                                /* next code */
  do {
    b = ((j = NEXTBYTE) & 0xf) + 1;     /* bits in code (1..16) */
      78:	83 e3 0f             	and    $0xf,%ebx
    j = ((j & 0xf0) >> 4) + 1;          /* codes with those bits (1..16) */
      7b:	c1 e9 04             	shr    $0x4,%ecx

  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
  k = 0;                                /* next code */
  do {
    b = ((j = NEXTBYTE) & 0xf) + 1;     /* bits in code (1..16) */
      7e:	43                   	inc    %ebx
    j = ((j & 0xf0) >> 4) + 1;          /* codes with those bits (1..16) */
    if (k + j > n)
      7f:	8d 44 0e 01          	lea    0x1(%esi,%ecx,1),%eax
      83:	3b 44 24 18          	cmp    0x18(%esp),%eax
      87:	77 3a                	ja     c3 <_get_tree+0xc3>
      89:	41                   	inc    %ecx
      8a:	8d 54 b5 00          	lea    0x0(%ebp,%esi,4),%edx
      8e:	31 c0                	xor    %eax,%eax
      return 4;                         /* don't overflow l[] */
    do {
      l[k++] = b;
      90:	89 1c 82             	mov    %ebx,(%edx,%eax,4)
      93:	40                   	inc    %eax
    } while (--j);
      94:	39 c8                	cmp    %ecx,%eax
      96:	75 f8                	jne    90 <_get_tree+0x90>
      98:	01 c6                	add    %eax,%esi
  } while (--i);
      9a:	ff 4c 24 1c          	decl   0x1c(%esp)
      9e:	74 1d                	je     bd <_get_tree+0xbd>
      a0:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax

  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
  k = 0;                                /* next code */
  do {
    b = ((j = NEXTBYTE) & 0xf) + 1;     /* bits in code (1..16) */
      a6:	85 c0                	test   %eax,%eax
      a8:	8d 50 ff             	lea    -0x1(%eax),%edx
      ab:	89 97 ec 08 01 00    	mov    %edx,0x108ec(%edi)
      b1:	7f a3                	jg     56 <_get_tree+0x56>
      b3:	89 3c 24             	mov    %edi,(%esp)
      b6:	e8 00 00 00 00       	call   bb <_get_tree+0xbb>
      bb:	eb b2                	jmp    6f <_get_tree+0x6f>
      return 4;                         /* don't overflow l[] */
    do {
      l[k++] = b;
    } while (--j);
  } while (--i);
  return k != n ? 4 : 0;                /* should have read n of them */
      bd:	39 74 24 18          	cmp    %esi,0x18(%esp)
      c1:	74 0d                	je     d0 <_get_tree+0xd0>
}
      c3:	83 c4 2c             	add    $0x2c,%esp
  k = 0;                                /* next code */
  do {
    b = ((j = NEXTBYTE) & 0xf) + 1;     /* bits in code (1..16) */
    j = ((j & 0xf0) >> 4) + 1;          /* codes with those bits (1..16) */
    if (k + j > n)
      return 4;                         /* don't overflow l[] */
      c6:	b8 04 00 00 00       	mov    $0x4,%eax
    do {
      l[k++] = b;
    } while (--j);
  } while (--i);
  return k != n ? 4 : 0;                /* should have read n of them */
}
      cb:	5b                   	pop    %ebx
      cc:	5e                   	pop    %esi
      cd:	5f                   	pop    %edi
      ce:	5d                   	pop    %ebp
      cf:	c3                   	ret    
      d0:	83 c4 2c             	add    $0x2c,%esp
      return 4;                         /* don't overflow l[] */
    do {
      l[k++] = b;
    } while (--j);
  } while (--i);
  return k != n ? 4 : 0;                /* should have read n of them */
      d3:	31 c0                	xor    %eax,%eax
}
      d5:	5b                   	pop    %ebx
      d6:	5e                   	pop    %esi
      d7:	5f                   	pop    %edi
      d8:	5d                   	pop    %ebp
      d9:	c3                   	ret    
  unsigned j;           /* number of codes */
  unsigned b;           /* bit length for those codes */


  /* get bit lengths */
  i = NEXTBYTE + 1;                     /* length/count pairs to read */
      da:	89 3c 24             	mov    %edi,(%esp)
      dd:	e8 00 00 00 00       	call   e2 <_get_tree+0xe2>
      e2:	40                   	inc    %eax
      e3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      e7:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
      ed:	e9 53 ff ff ff       	jmp    45 <_get_tree+0x45>
      f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
      f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000100 <_explode>:
   the tables needed to decode them (using huft_build() from inflate.c),
   and call the appropriate routine for the type of data in the remainder
   of the stream.  The four routines are nearly identical, differing only
   in whether the literal is decoded or simply read in, and in how many
   bits are read in, uncoded, for the low distance bits. */
{
     100:	55                   	push   %ebp
     101:	57                   	push   %edi
     102:	56                   	push   %esi
     103:	53                   	push   %ebx
     104:	81 ec 9c 04 00 00    	sub    $0x49c,%esp
     10a:	8b b4 24 b0 04 00 00 	mov    0x4b0(%esp),%esi
  unsigned bd;          /* bits for td */
  unsigned bdl;         /* number of uncoded lower distance bits */
  unsigned l[256];      /* bit lengths for codes */

#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
  if (G.redirect_slide)
     111:	8b be a8 00 00 00    	mov    0xa8(%esi),%edi
     117:	85 ff                	test   %edi,%edi
     119:	0f 84 19 01 00 00    	je     238 <_explode+0x138>
    /* For 16-bit systems, it has already been checked at DLL entrance that
     * the buffer size in G.redirect_size does not exceed unsigned range.
     */
    G._wsize = G.redirect_size, redirSlide = G.redirect_buffer;
     11f:	8b 86 b0 00 00 00    	mov    0xb0(%esi),%eax
     125:	89 86 ac 00 00 00    	mov    %eax,0xac(%esi)
     12b:	8b 86 b4 00 00 00    	mov    0xb4(%esi),%eax
     131:	89 86 bc 00 00 00    	mov    %eax,0xbc(%esi)
     I would have to select different bl, bd, and bb values for different
     compressed file sizes.  I was surprised to find out that the values of
     7, 7, and 9 worked best over a very wide range of sizes, except that
     bd = 8 worked marginally better for large compressed sizes. */
  bl = 7;
  bd = (G.csize + G.incnt) > 200000L ? 8 : 7;
     137:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     13d:	8b 9e 90 00 00 00    	mov    0x90(%esi),%ebx
     143:	01 d8                	add    %ebx,%eax
  /* Tune base table sizes.  Note: I thought that to truly optimize speed,
     I would have to select different bl, bd, and bb values for different
     compressed file sizes.  I was surprised to find out that the values of
     7, 7, and 9 worked best over a very wide range of sizes, except that
     bd = 8 worked marginally better for large compressed sizes. */
  bl = 7;
     145:	c7 84 24 88 00 00 00 	movl   $0x7,0x88(%esp)
     14c:	07 00 00 00 
  bd = (G.csize + G.incnt) > 200000L ? 8 : 7;
     150:	3d 40 0d 03 00       	cmp    $0x30d40,%eax
     155:	0f 9f c0             	setg   %al
     158:	25 ff 00 00 00       	and    $0xff,%eax
     15d:	83 c0 07             	add    $0x7,%eax

#ifdef DEBUG
  G.hufts = 0;                    /* initialize huft's malloc'ed */
#endif

  if (G.lrec.general_purpose_bit_flag & 4)
     160:	f6 86 32 09 01 00 04 	testb  $0x4,0x10932(%esi)
     I would have to select different bl, bd, and bb values for different
     compressed file sizes.  I was surprised to find out that the values of
     7, 7, and 9 worked best over a very wide range of sizes, except that
     bd = 8 worked marginally better for large compressed sizes. */
  bl = 7;
  bd = (G.csize + G.incnt) > 200000L ? 8 : 7;
     167:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)

#ifdef DEBUG
  G.hufts = 0;                    /* initialize huft's malloc'ed */
#endif

  if (G.lrec.general_purpose_bit_flag & 4)
     16e:	74 40                	je     1b0 <_explode+0xb0>
  /* With literal tree--minimum match length is 3 */
  {
    bb = 9;                     /* base table size for literals */
    if ((r = get_tree(__G__ l, 256)) != 0)
     170:	8d 9c 24 90 00 00 00 	lea    0x90(%esp),%ebx
     177:	b9 00 01 00 00       	mov    $0x100,%ecx
     17c:	89 da                	mov    %ebx,%edx
     17e:	89 f0                	mov    %esi,%eax
#endif

  if (G.lrec.general_purpose_bit_flag & 4)
  /* With literal tree--minimum match length is 3 */
  {
    bb = 9;                     /* base table size for literals */
     180:	c7 84 24 84 00 00 00 	movl   $0x9,0x84(%esp)
     187:	09 00 00 00 
    if ((r = get_tree(__G__ l, 256)) != 0)
     18b:	e8 70 fe ff ff       	call   0 <_get_tree>
     190:	89 44 24 24          	mov    %eax,0x24(%esp)
     194:	85 c0                	test   %eax,%eax
     196:	0f 84 b7 00 00 00    	je     253 <_explode+0x153>

  huft_free(td);
  huft_free(tl);
  Trace((stderr, "<%u > ", G.hufts));
  return (int)r;
}
     19c:	8b 44 24 24          	mov    0x24(%esp),%eax
     1a0:	81 c4 9c 04 00 00    	add    $0x49c,%esp
     1a6:	5b                   	pop    %ebx
     1a7:	5e                   	pop    %esi
     1a8:	5f                   	pop    %edi
     1a9:	5d                   	pop    %ebp
     1aa:	c3                   	ret    
     1ab:	90                   	nop
     1ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  }
  else
  /* No literal tree--minimum match length is 2 */
  {
    tb = (struct huft *)NULL;
    if ((r = get_tree(__G__ l, 64)) != 0)
     1b0:	8d 9c 24 90 00 00 00 	lea    0x90(%esp),%ebx
     1b7:	b9 40 00 00 00       	mov    $0x40,%ecx
     1bc:	89 da                	mov    %ebx,%edx
     1be:	89 f0                	mov    %esi,%eax
    }
  }
  else
  /* No literal tree--minimum match length is 2 */
  {
    tb = (struct huft *)NULL;
     1c0:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%esp)
     1c7:	00 
    if ((r = get_tree(__G__ l, 64)) != 0)
     1c8:	e8 33 fe ff ff       	call   0 <_get_tree>
     1cd:	89 44 24 24          	mov    %eax,0x24(%esp)
     1d1:	85 c0                	test   %eax,%eax
     1d3:	75 c7                	jne    19c <_explode+0x9c>
      return (int)r;
    if ((r = huft_build(__G__ l, 64, 0, cplen2, extra, &tl, &bl)) != 0)
     1d5:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
     1dc:	c7 44 24 14 00 01 00 	movl   $0x100,0x14(%esp)
     1e3:	00 
     1e4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
     1e8:	8d 44 24 7c          	lea    0x7c(%esp),%eax
     1ec:	89 44 24 18          	mov    %eax,0x18(%esp)
     1f0:	c7 44 24 10 c0 01 00 	movl   $0x1c0,0x10(%esp)
     1f7:	00 
     1f8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     1ff:	00 
     200:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
     207:	00 
     208:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     20c:	89 34 24             	mov    %esi,(%esp)
     20f:	e8 00 00 00 00       	call   214 <_explode+0x114>
     214:	89 44 24 24          	mov    %eax,0x24(%esp)
     218:	85 c0                	test   %eax,%eax
     21a:	0f 84 96 00 00 00    	je     2b6 <_explode+0x1b6>
    {
      if (r == 1)
     220:	48                   	dec    %eax
     221:	0f 85 75 ff ff ff    	jne    19c <_explode+0x9c>
  } else {
    r = explode_nolit(__G__ tl, td, bl, bd, bdl);
  }

  huft_free(td);
  huft_free(tl);
     227:	8b 44 24 7c          	mov    0x7c(%esp),%eax
     22b:	89 04 24             	mov    %eax,(%esp)
     22e:	e8 00 00 00 00       	call   233 <_explode+0x133>
  Trace((stderr, "<%u > ", G.hufts));
  return (int)r;
     233:	e9 64 ff ff ff       	jmp    19c <_explode+0x9c>
    /* For systems using 16-bit ints, reduce the used buffer size below
     * the limit of "unsigned int" numbers range.
     */
    G._wsize = WSIZE>>1, redirSlide = slide;
#else /* !(USE_DEFLATE64 && INT_16BIT) */
    G._wsize = WSIZE, redirSlide = slide;
     238:	8d 86 dc 08 00 00    	lea    0x8dc(%esi),%eax
     23e:	c7 86 ac 00 00 00 00 	movl   $0x10000,0xac(%esi)
     245:	00 01 00 
     248:	89 86 bc 00 00 00    	mov    %eax,0xbc(%esi)
     24e:	e9 e4 fe ff ff       	jmp    137 <_explode+0x37>
  /* With literal tree--minimum match length is 3 */
  {
    bb = 9;                     /* base table size for literals */
    if ((r = get_tree(__G__ l, 256)) != 0)
      return (int)r;
    if ((r = huft_build(__G__ l, 256, 256, NULL, NULL, &tb, &bb)) != 0)
     253:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
     25a:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
     261:	00 
     262:	89 44 24 1c          	mov    %eax,0x1c(%esp)
     266:	8d 44 24 78          	lea    0x78(%esp),%eax
     26a:	89 44 24 18          	mov    %eax,0x18(%esp)
     26e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
     275:	00 
     276:	c7 44 24 0c 00 01 00 	movl   $0x100,0xc(%esp)
     27d:	00 
     27e:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
     285:	00 
     286:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     28a:	89 34 24             	mov    %esi,(%esp)
     28d:	e8 00 00 00 00       	call   292 <_explode+0x192>
     292:	89 44 24 24          	mov    %eax,0x24(%esp)
     296:	85 c0                	test   %eax,%eax
     298:	0f 84 c2 00 00 00    	je     360 <_explode+0x260>
    {
      if (r == 1)
     29e:	48                   	dec    %eax
     29f:	0f 85 f7 fe ff ff    	jne    19c <_explode+0x9c>
    }
    if ((r = huft_build(__G__ l, 64, 0, cplen3, extra, &tl, &bl)) != 0)
    {
      if (r == 1)
        huft_free(tl);
      huft_free(tb);
     2a5:	8b 44 24 78          	mov    0x78(%esp),%eax
     2a9:	89 04 24             	mov    %eax,(%esp)
     2ac:	e8 00 00 00 00       	call   2b1 <_explode+0x1b1>
      return (int)r;
     2b1:	e9 e6 fe ff ff       	jmp    19c <_explode+0x9c>
        huft_free(tl);
      return (int)r;
    }
  }

  if ((r = get_tree(__G__ l, 64)) != 0) {
     2b6:	b9 40 00 00 00       	mov    $0x40,%ecx
     2bb:	89 da                	mov    %ebx,%edx
     2bd:	89 f0                	mov    %esi,%eax
     2bf:	e8 3c fd ff ff       	call   0 <_get_tree>
     2c4:	89 44 24 24          	mov    %eax,0x24(%esp)
     2c8:	85 c0                	test   %eax,%eax
     2ca:	0f 85 20 03 00 00    	jne    5f0 <_explode+0x4f0>
    return (int)r;
  }
  if (G.lrec.general_purpose_bit_flag & 2)      /* true if 8K */
  {
    bdl = 7;
    r = huft_build(__G__ l, 64, 0, cpdist8, extra, &td, &bd);
     2d0:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
  if ((r = get_tree(__G__ l, 64)) != 0) {
    huft_free(tl);
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }
  if (G.lrec.general_purpose_bit_flag & 2)      /* true if 8K */
     2d7:	f6 86 32 09 01 00 02 	testb  $0x2,0x10932(%esi)
  {
    bdl = 7;
    r = huft_build(__G__ l, 64, 0, cpdist8, extra, &td, &bd);
     2de:	89 44 24 1c          	mov    %eax,0x1c(%esp)
     2e2:	8d 84 24 80 00 00 00 	lea    0x80(%esp),%eax
     2e9:	89 44 24 18          	mov    %eax,0x18(%esp)
     2ed:	c7 44 24 14 00 01 00 	movl   $0x100,0x14(%esp)
     2f4:	00 
  if ((r = get_tree(__G__ l, 64)) != 0) {
    huft_free(tl);
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }
  if (G.lrec.general_purpose_bit_flag & 2)      /* true if 8K */
     2f5:	0f 85 e5 00 00 00    	jne    3e0 <_explode+0x2e0>
    r = huft_build(__G__ l, 64, 0, cpdist8, extra, &td, &bd);
  }
  else                                          /* else 4K */
  {
    bdl = 6;
    r = huft_build(__G__ l, 64, 0, cpdist4, extra, &td, &bd);
     2fb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     2ff:	c7 44 24 10 80 00 00 	movl   $0x80,0x10(%esp)
     306:	00 
     307:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     30e:	00 
     30f:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
     316:	00 
     317:	89 34 24             	mov    %esi,(%esp)
     31a:	e8 00 00 00 00       	call   31f <_explode+0x21f>
    bdl = 7;
    r = huft_build(__G__ l, 64, 0, cpdist8, extra, &td, &bd);
  }
  else                                          /* else 4K */
  {
    bdl = 6;
     31f:	c7 44 24 34 06 00 00 	movl   $0x6,0x34(%esp)
     326:	00 
    r = huft_build(__G__ l, 64, 0, cpdist4, extra, &td, &bd);
     327:	89 c3                	mov    %eax,%ebx
  }
  if (r != 0)
     329:	85 db                	test   %ebx,%ebx
     32b:	0f 84 e2 00 00 00    	je     413 <_explode+0x313>
  {
    if (r == 1)
     331:	83 fb 01             	cmp    $0x1,%ebx
     334:	0f 84 35 0c 00 00    	je     f6f <_explode+0xe6f>
      huft_free(td);
    huft_free(tl);
     33a:	8b 44 24 7c          	mov    0x7c(%esp),%eax
     33e:	89 04 24             	mov    %eax,(%esp)
     341:	e8 00 00 00 00       	call   346 <_explode+0x246>
    if (tb != (struct huft *)NULL) huft_free(tb);
     346:	8b 44 24 78          	mov    0x78(%esp),%eax
     34a:	85 c0                	test   %eax,%eax
     34c:	74 08                	je     356 <_explode+0x256>
     34e:	89 04 24             	mov    %eax,(%esp)
     351:	e8 00 00 00 00       	call   356 <_explode+0x256>
    return (int)r;
     356:	89 5c 24 24          	mov    %ebx,0x24(%esp)
     35a:	e9 3d fe ff ff       	jmp    19c <_explode+0x9c>
     35f:	90                   	nop
    {
      if (r == 1)
        huft_free(tb);
      return (int)r;
    }
    if ((r = get_tree(__G__ l, 64)) != 0) {
     360:	b9 40 00 00 00       	mov    $0x40,%ecx
     365:	89 da                	mov    %ebx,%edx
     367:	89 f0                	mov    %esi,%eax
     369:	e8 92 fc ff ff       	call   0 <_get_tree>
     36e:	89 44 24 24          	mov    %eax,0x24(%esp)
     372:	85 c0                	test   %eax,%eax
     374:	0f 85 2b ff ff ff    	jne    2a5 <_explode+0x1a5>
      huft_free(tb);
      return (int)r;
    }
    if ((r = huft_build(__G__ l, 64, 0, cplen3, extra, &tl, &bl)) != 0)
     37a:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
     381:	c7 44 24 14 00 01 00 	movl   $0x100,0x14(%esp)
     388:	00 
     389:	89 44 24 1c          	mov    %eax,0x1c(%esp)
     38d:	8d 44 24 7c          	lea    0x7c(%esp),%eax
     391:	89 44 24 18          	mov    %eax,0x18(%esp)
     395:	c7 44 24 10 40 01 00 	movl   $0x140,0x10(%esp)
     39c:	00 
     39d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     3a4:	00 
     3a5:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
     3ac:	00 
     3ad:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     3b1:	89 34 24             	mov    %esi,(%esp)
     3b4:	e8 00 00 00 00       	call   3b9 <_explode+0x2b9>
     3b9:	89 44 24 24          	mov    %eax,0x24(%esp)
     3bd:	85 c0                	test   %eax,%eax
     3bf:	0f 84 f1 fe ff ff    	je     2b6 <_explode+0x1b6>
    {
      if (r == 1)
     3c5:	48                   	dec    %eax
     3c6:	0f 85 d9 fe ff ff    	jne    2a5 <_explode+0x1a5>
        huft_free(tl);
     3cc:	8b 44 24 7c          	mov    0x7c(%esp),%eax
     3d0:	89 04 24             	mov    %eax,(%esp)
     3d3:	e8 00 00 00 00       	call   3d8 <_explode+0x2d8>
     3d8:	e9 c8 fe ff ff       	jmp    2a5 <_explode+0x1a5>
     3dd:	8d 76 00             	lea    0x0(%esi),%esi
    return (int)r;
  }
  if (G.lrec.general_purpose_bit_flag & 2)      /* true if 8K */
  {
    bdl = 7;
    r = huft_build(__G__ l, 64, 0, cpdist8, extra, &td, &bd);
     3e0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     3e4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
     3eb:	00 
     3ec:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     3f3:	00 
     3f4:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
     3fb:	00 
     3fc:	89 34 24             	mov    %esi,(%esp)
     3ff:	e8 00 00 00 00       	call   404 <_explode+0x304>
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }
  if (G.lrec.general_purpose_bit_flag & 2)      /* true if 8K */
  {
    bdl = 7;
     404:	c7 44 24 34 07 00 00 	movl   $0x7,0x34(%esp)
     40b:	00 
    r = huft_build(__G__ l, 64, 0, cpdist8, extra, &td, &bd);
     40c:	89 c3                	mov    %eax,%ebx
     40e:	e9 16 ff ff ff       	jmp    329 <_explode+0x229>
    huft_free(tl);
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }

  if (tb != NULL) {
     413:	8b 44 24 78          	mov    0x78(%esp),%eax
     417:	89 44 24 44          	mov    %eax,0x44(%esp)
     41b:	85 c0                	test   %eax,%eax
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
     41d:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
    huft_free(tl);
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }

  if (tb != NULL) {
     424:	0f 84 c9 07 00 00    	je     bf3 <_explode+0xaf3>
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
     42a:	89 44 24 48          	mov    %eax,0x48(%esp)
  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  mb = mask_bits[bb];           /* precompute masks for speed */
  ml = mask_bits[bl];
  md = mask_bits[bd];
     42e:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
     435:	89 44 24 58          	mov    %eax,0x58(%esp)
  mdl = mask_bits[bdl];
     439:	8b 44 24 34          	mov    0x34(%esp),%eax
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
     43d:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
     444:	8b bc 24 84 00 00 00 	mov    0x84(%esp),%edi
     44b:	8b 8c 24 80 00 00 00 	mov    0x80(%esp),%ecx
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  mb = mask_bits[bb];           /* precompute masks for speed */
  ml = mask_bits[bl];
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
     452:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
     459:	89 5c 24 5c          	mov    %ebx,0x5c(%esp)
     45d:	89 7c 24 4c          	mov    %edi,0x4c(%esp)
     461:	89 4c 24 50          	mov    %ecx,0x50(%esp)


  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  mb = mask_bits[bb];           /* precompute masks for speed */
     465:	8b 3c bd 00 00 00 00 	mov    0x0(,%edi,4),%edi
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
     46c:	8b 4c 24 7c          	mov    0x7c(%esp),%ecx

  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  mb = mask_bits[bb];           /* precompute masks for speed */
  ml = mask_bits[bl];
     470:	8b 1c 9d 00 00 00 00 	mov    0x0(,%ebx,4),%ebx
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
     477:	89 44 24 68          	mov    %eax,0x68(%esp)
  s = G.lrec.ucsize;
     47b:	8b 86 24 09 01 00    	mov    0x10924(%esi),%eax
    if (tb != (struct huft *)NULL) huft_free(tb);
    return (int)r;
  }

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
     481:	89 4c 24 60          	mov    %ecx,0x60(%esp)


  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  mb = mask_bits[bb];           /* precompute masks for speed */
     485:	89 7c 24 54          	mov    %edi,0x54(%esp)
  ml = mask_bits[bl];
     489:	89 5c 24 64          	mov    %ebx,0x64(%esp)
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
     48d:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  while (s > 0)                 /* do until ucsize bytes uncompressed */
     491:	85 c0                	test   %eax,%eax
     493:	0f 84 94 0f 00 00    	je     142d <_explode+0x132d>
     499:	31 ed                	xor    %ebp,%ebp
     49b:	c7 44 24 38 01 00 00 	movl   $0x1,0x38(%esp)
     4a2:	00 
     4a3:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
     4aa:	00 
        n += (unsigned)b & 0xff;
        DUMPBITS(8)
      }

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
     4ab:	89 eb                	mov    %ebp,%ebx
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
     4ad:	85 db                	test   %ebx,%ebx
     4af:	0f 85 19 0b 00 00    	jne    fce <_explode+0xece>
     4b5:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     4bb:	85 c0                	test   %eax,%eax
     4bd:	8d 50 ff             	lea    -0x1(%eax),%edx
     4c0:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     4c6:	0f 8e 14 01 00 00    	jle    5e0 <_explode+0x4e0>
     4cc:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     4d2:	8d 50 01             	lea    0x1(%eax),%edx
     4d5:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     4db:	8a 18                	mov    (%eax),%bl
     4dd:	81 e3 ff 00 00 00    	and    $0xff,%ebx
     4e3:	89 d8                	mov    %ebx,%eax
     4e5:	09 c5                	or     %eax,%ebp
    if (b & 1)                  /* then literal--decode it */
     4e7:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     4ed:	0f 85 7d 00 00 00    	jne    570 <_explode+0x470>
        w = u = 0;
      }
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
     4f3:	d1 ed                	shr    %ebp
     4f5:	bb 07 00 00 00       	mov    $0x7,%ebx
     4fa:	89 6c 24 30          	mov    %ebp,0x30(%esp)
     4fe:	66 90                	xchg   %ax,%ax
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
     500:	8b 44 24 34          	mov    0x34(%esp),%eax
     504:	8b 6c 24 30          	mov    0x30(%esp),%ebp
     508:	88 c1                	mov    %al,%cl
     50a:	29 c3                	sub    %eax,%ebx
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
     50c:	8b 44 24 48          	mov    0x48(%esp),%eax
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
     510:	d3 ed                	shr    %cl,%ebp
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
     512:	39 d8                	cmp    %ebx,%eax
     514:	0f 86 f5 00 00 00    	jbe    60f <_explode+0x50f>
     51a:	89 d9                	mov    %ebx,%ecx
     51c:	89 c3                	mov    %eax,%ebx
     51e:	eb 29                	jmp    549 <_explode+0x449>
     520:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     526:	8d 50 01             	lea    0x1(%eax),%edx
     529:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     52f:	0f b6 38             	movzbl (%eax),%edi
     532:	81 e7 ff 00 00 00    	and    $0xff,%edi
     538:	89 f8                	mov    %edi,%eax
     53a:	d3 e0                	shl    %cl,%eax
     53c:	83 c1 08             	add    $0x8,%ecx
     53f:	09 c5                	or     %eax,%ebp
     541:	39 cb                	cmp    %ecx,%ebx
     543:	0f 86 c4 00 00 00    	jbe    60d <_explode+0x50d>
     549:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     54f:	85 c0                	test   %eax,%eax
     551:	8d 50 ff             	lea    -0x1(%eax),%edx
     554:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     55a:	7f c4                	jg     520 <_explode+0x420>
     55c:	89 34 24             	mov    %esi,(%esp)
     55f:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     563:	e8 00 00 00 00       	call   568 <_explode+0x468>
     568:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     56c:	eb cc                	jmp    53a <_explode+0x43a>
     56e:	66 90                	xchg   %ax,%ax
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--decode it */
     570:	bb 07 00 00 00       	mov    $0x7,%ebx
    {
      DUMPBITS(1)
      s--;
     575:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
      DECODEHUFT(tb, bb, mb)    /* get coded literal */
     579:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--decode it */
    {
      DUMPBITS(1)
     57d:	d1 ed                	shr    %ebp
      s--;
     57f:	49                   	dec    %ecx
     580:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
      DECODEHUFT(tb, bb, mb)    /* get coded literal */
     584:	39 d8                	cmp    %ebx,%eax
     586:	0f 86 9d 01 00 00    	jbe    729 <_explode+0x629>
     58c:	89 d9                	mov    %ebx,%ecx
     58e:	89 c3                	mov    %eax,%ebx
     590:	eb 29                	jmp    5bb <_explode+0x4bb>
     592:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     598:	8d 50 01             	lea    0x1(%eax),%edx
     59b:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     5a1:	0f b6 38             	movzbl (%eax),%edi
     5a4:	81 e7 ff 00 00 00    	and    $0xff,%edi
     5aa:	89 f8                	mov    %edi,%eax
     5ac:	d3 e0                	shl    %cl,%eax
     5ae:	83 c1 08             	add    $0x8,%ecx
     5b1:	09 c5                	or     %eax,%ebp
     5b3:	39 cb                	cmp    %ecx,%ebx
     5b5:	0f 86 6c 01 00 00    	jbe    727 <_explode+0x627>
     5bb:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     5c1:	85 c0                	test   %eax,%eax
     5c3:	8d 50 ff             	lea    -0x1(%eax),%edx
     5c6:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     5cc:	7f c4                	jg     592 <_explode+0x492>
     5ce:	89 34 24             	mov    %esi,(%esp)
     5d1:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     5d5:	e8 00 00 00 00       	call   5da <_explode+0x4da>
     5da:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     5de:	eb cc                	jmp    5ac <_explode+0x4ac>
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
     5e0:	89 34 24             	mov    %esi,(%esp)
     5e3:	e8 00 00 00 00       	call   5e8 <_explode+0x4e8>
     5e8:	e9 f8 fe ff ff       	jmp    4e5 <_explode+0x3e5>
     5ed:	8d 76 00             	lea    0x0(%esi),%esi
      return (int)r;
    }
  }

  if ((r = get_tree(__G__ l, 64)) != 0) {
    huft_free(tl);
     5f0:	8b 44 24 7c          	mov    0x7c(%esp),%eax
     5f4:	89 04 24             	mov    %eax,(%esp)
     5f7:	e8 00 00 00 00       	call   5fc <_explode+0x4fc>
    if (tb != (struct huft *)NULL) huft_free(tb);
     5fc:	8b 44 24 78          	mov    0x78(%esp),%eax
     600:	85 c0                	test   %eax,%eax
     602:	0f 85 23 fc ff ff    	jne    22b <_explode+0x12b>
     608:	e9 8f fb ff ff       	jmp    19c <_explode+0x9c>
     60d:	89 cb                	mov    %ecx,%ebx
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
     60f:	89 e8                	mov    %ebp,%eax
     611:	8b 54 24 58          	mov    0x58(%esp),%edx
     615:	83 f0 ff             	xor    $0xffffffff,%eax
     618:	8b 7c 24 50          	mov    0x50(%esp),%edi
     61c:	21 d0                	and    %edx,%eax
     61e:	8d 14 c7             	lea    (%edi,%eax,8),%edx
     621:	31 c0                	xor    %eax,%eax
     623:	8a 4a 01             	mov    0x1(%edx),%cl
     626:	8a 42 01             	mov    0x1(%edx),%al
     629:	d3 ed                	shr    %cl,%ebp
     62b:	29 c3                	sub    %eax,%ebx
     62d:	31 c9                	xor    %ecx,%ecx
     62f:	8a 02                	mov    (%edx),%al
     631:	88 c1                	mov    %al,%cl
     633:	83 f9 20             	cmp    $0x20,%ecx
     636:	0f 86 2b 02 00 00    	jbe    867 <_explode+0x767>
     63c:	83 f9 63             	cmp    $0x63,%ecx
     63f:	0f 84 ba 00 00 00    	je     6ff <_explode+0x5ff>
     645:	89 c7                	mov    %eax,%edi
     647:	83 e7 1f             	and    $0x1f,%edi
     64a:	39 df                	cmp    %ebx,%edi
     64c:	76 5c                	jbe    6aa <_explode+0x5aa>
     64e:	89 d9                	mov    %ebx,%ecx
     650:	89 d3                	mov    %edx,%ebx
     652:	eb 24                	jmp    678 <_explode+0x578>
     654:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     65a:	8d 50 01             	lea    0x1(%eax),%edx
     65d:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     663:	8a 10                	mov    (%eax),%dl
     665:	81 e2 ff 00 00 00    	and    $0xff,%edx
     66b:	89 d0                	mov    %edx,%eax
     66d:	d3 e0                	shl    %cl,%eax
     66f:	83 c1 08             	add    $0x8,%ecx
     672:	09 c5                	or     %eax,%ebp
     674:	39 cf                	cmp    %ecx,%edi
     676:	76 2e                	jbe    6a6 <_explode+0x5a6>
     678:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     67e:	85 c0                	test   %eax,%eax
     680:	8d 50 ff             	lea    -0x1(%eax),%edx
     683:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     689:	7f c9                	jg     654 <_explode+0x554>
     68b:	89 34 24             	mov    %esi,(%esp)
     68e:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     692:	e8 00 00 00 00       	call   697 <_explode+0x597>
     697:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     69b:	d3 e0                	shl    %cl,%eax
     69d:	83 c1 08             	add    $0x8,%ecx
     6a0:	09 c5                	or     %eax,%ebp
     6a2:	39 cf                	cmp    %ecx,%edi
     6a4:	77 d2                	ja     678 <_explode+0x578>
     6a6:	89 da                	mov    %ebx,%edx
     6a8:	89 cb                	mov    %ecx,%ebx
     6aa:	89 e8                	mov    %ebp,%eax
     6ac:	8b 0c bd 00 00 00 00 	mov    0x0(,%edi,4),%ecx
     6b3:	83 f0 ff             	xor    $0xffffffff,%eax
     6b6:	8b 7a 04             	mov    0x4(%edx),%edi
     6b9:	21 c8                	and    %ecx,%eax
     6bb:	8d 04 c7             	lea    (%edi,%eax,8),%eax
     6be:	89 c2                	mov    %eax,%edx
     6c0:	e9 5c ff ff ff       	jmp    621 <_explode+0x521>
     6c5:	89 da                	mov    %ebx,%edx
     6c7:	89 cb                	mov    %ecx,%ebx
    NEEDBITS(1)
    if (b & 1)                  /* then literal--decode it */
    {
      DUMPBITS(1)
      s--;
      DECODEHUFT(tb, bb, mb)    /* get coded literal */
     6c9:	89 e8                	mov    %ebp,%eax
     6cb:	8b 0c bd 00 00 00 00 	mov    0x0(,%edi,4),%ecx
     6d2:	83 f0 ff             	xor    $0xffffffff,%eax
     6d5:	8b 7a 04             	mov    0x4(%edx),%edi
     6d8:	21 c8                	and    %ecx,%eax
     6da:	8d 04 c7             	lea    (%edi,%eax,8),%eax
     6dd:	89 c2                	mov    %eax,%edx
     6df:	31 c0                	xor    %eax,%eax
     6e1:	8a 42 01             	mov    0x1(%edx),%al
     6e4:	8a 4a 01             	mov    0x1(%edx),%cl
     6e7:	d3 ed                	shr    %cl,%ebp
     6e9:	29 c3                	sub    %eax,%ebx
     6eb:	31 c9                	xor    %ecx,%ecx
     6ed:	8a 02                	mov    (%edx),%al
     6ef:	88 c1                	mov    %al,%cl
     6f1:	83 f9 20             	cmp    $0x20,%ecx
     6f4:	0f 86 d3 00 00 00    	jbe    7cd <_explode+0x6cd>
     6fa:	83 f9 63             	cmp    $0x63,%ecx
     6fd:	75 67                	jne    766 <_explode+0x666>
      redirSlide[w++] = (uch)t->v.n;
      if (w == wszimpl)
      {
        if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
     6ff:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
     706:	00 
    return (int)r;
  }

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
    huft_free(tb);
     707:	8b 44 24 78          	mov    0x78(%esp),%eax
     70b:	89 04 24             	mov    %eax,(%esp)
     70e:	e8 00 00 00 00       	call   713 <_explode+0x613>
  } else {
    r = explode_nolit(__G__ tl, td, bl, bd, bdl);
  }

  huft_free(td);
     713:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
     71a:	89 04 24             	mov    %eax,(%esp)
     71d:	e8 00 00 00 00       	call   722 <_explode+0x622>
     722:	e9 00 fb ff ff       	jmp    227 <_explode+0x127>
     727:	89 cb                	mov    %ecx,%ebx
    NEEDBITS(1)
    if (b & 1)                  /* then literal--decode it */
    {
      DUMPBITS(1)
      s--;
      DECODEHUFT(tb, bb, mb)    /* get coded literal */
     729:	89 e8                	mov    %ebp,%eax
     72b:	8b 54 24 54          	mov    0x54(%esp),%edx
     72f:	83 f0 ff             	xor    $0xffffffff,%eax
     732:	8b 7c 24 44          	mov    0x44(%esp),%edi
     736:	21 d0                	and    %edx,%eax
     738:	8d 04 c7             	lea    (%edi,%eax,8),%eax
     73b:	89 c7                	mov    %eax,%edi
     73d:	8a 40 01             	mov    0x1(%eax),%al
     740:	88 44 24 28          	mov    %al,0x28(%esp)
     744:	31 c0                	xor    %eax,%eax
     746:	8a 44 24 28          	mov    0x28(%esp),%al
     74a:	8a 17                	mov    (%edi),%dl
     74c:	29 c3                	sub    %eax,%ebx
     74e:	31 c0                	xor    %eax,%eax
     750:	8a 4c 24 28          	mov    0x28(%esp),%cl
     754:	88 d0                	mov    %dl,%al
     756:	d3 ed                	shr    %cl,%ebp
     758:	83 f8 20             	cmp    $0x20,%eax
     75b:	76 72                	jbe    7cf <_explode+0x6cf>
     75d:	83 f8 63             	cmp    $0x63,%eax
     760:	74 9d                	je     6ff <_explode+0x5ff>
     762:	88 d0                	mov    %dl,%al
     764:	89 fa                	mov    %edi,%edx
     766:	89 c7                	mov    %eax,%edi
     768:	83 e7 1f             	and    $0x1f,%edi
     76b:	39 df                	cmp    %ebx,%edi
     76d:	0f 86 56 ff ff ff    	jbe    6c9 <_explode+0x5c9>
     773:	89 d9                	mov    %ebx,%ecx
     775:	89 d3                	mov    %edx,%ebx
     777:	eb 2f                	jmp    7a8 <_explode+0x6a8>
     779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     780:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     786:	8d 50 01             	lea    0x1(%eax),%edx
     789:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     78f:	8a 10                	mov    (%eax),%dl
     791:	81 e2 ff 00 00 00    	and    $0xff,%edx
     797:	89 d0                	mov    %edx,%eax
     799:	d3 e0                	shl    %cl,%eax
     79b:	83 c1 08             	add    $0x8,%ecx
     79e:	09 c5                	or     %eax,%ebp
     7a0:	39 cf                	cmp    %ecx,%edi
     7a2:	0f 86 1d ff ff ff    	jbe    6c5 <_explode+0x5c5>
     7a8:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     7ae:	85 c0                	test   %eax,%eax
     7b0:	8d 50 ff             	lea    -0x1(%eax),%edx
     7b3:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     7b9:	7f c5                	jg     780 <_explode+0x680>
     7bb:	89 34 24             	mov    %esi,(%esp)
     7be:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     7c2:	e8 00 00 00 00       	call   7c7 <_explode+0x6c7>
     7c7:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     7cb:	eb cc                	jmp    799 <_explode+0x699>
     7cd:	89 d7                	mov    %edx,%edi
      redirSlide[w++] = (uch)t->v.n;
     7cf:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
     7d5:	8b 57 04             	mov    0x4(%edi),%edx
     7d8:	8b 7c 24 40          	mov    0x40(%esp),%edi
     7dc:	88 14 38             	mov    %dl,(%eax,%edi,1)
      if (w == wszimpl)
     7df:	8d 47 01             	lea    0x1(%edi),%eax
     7e2:	89 44 24 40          	mov    %eax,0x40(%esp)
     7e6:	3b 86 ac 00 00 00    	cmp    0xac(%esi),%eax
     7ec:	0f 84 7d 0b 00 00    	je     136f <_explode+0x126f>
  mb = mask_bits[bb];           /* precompute masks for speed */
  ml = mask_bits[bl];
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
     7f2:	8b 44 24 3c          	mov    0x3c(%esp),%eax
     7f6:	85 c0                	test   %eax,%eax
     7f8:	0f 85 af fc ff ff    	jne    4ad <_explode+0x3ad>
     7fe:	89 dd                	mov    %ebx,%ebp
      } while (n);
    }
  }

  /* flush out redirSlide */
  if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
     800:	8b 44 24 40          	mov    0x40(%esp),%eax
     804:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     80b:	00 
     80c:	89 44 24 08          	mov    %eax,0x8(%esp)
     810:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
     816:	89 34 24             	mov    %esi,(%esp)
     819:	89 44 24 04          	mov    %eax,0x4(%esp)
     81d:	e8 00 00 00 00       	call   822 <_explode+0x722>
     822:	85 c0                	test   %eax,%eax
     824:	0f 85 a5 0b 00 00    	jne    13cf <_explode+0x12cf>
    return retval;
  if (G.csize + G.incnt + (k >> 3))   /* should have read csize bytes, but */
     82a:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
     830:	8b 96 ec 08 01 00    	mov    0x108ec(%esi),%edx
     836:	89 eb                	mov    %ebp,%ebx
     838:	c1 eb 03             	shr    $0x3,%ebx
     83b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
     83e:	01 d9                	add    %ebx,%ecx
     840:	0f 84 c1 fe ff ff    	je     707 <_explode+0x607>
  {                        /* sometimes read one too many:  k>>3 compensates */
    G.used_csize = G.lrec.csize - G.csize - G.incnt - (k >> 3);
     846:	8b be 20 09 01 00    	mov    0x10920(%esi),%edi
     84c:	c7 44 24 24 05 00 00 	movl   $0x5,0x24(%esp)
     853:	00 
     854:	29 c7                	sub    %eax,%edi
     856:	89 f8                	mov    %edi,%eax
     858:	29 d0                	sub    %edx,%eax
     85a:	29 d8                	sub    %ebx,%eax
     85c:	89 86 94 00 00 00    	mov    %eax,0x94(%esi)
     862:	e9 a0 fe ff ff       	jmp    707 <_explode+0x607>
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
     867:	8b 42 04             	mov    0x4(%edx),%eax
     86a:	66 89 44 24 6c       	mov    %ax,0x6c(%esp)
      DECODEHUFT(tl, bl, ml)    /* get coded length */
     86f:	8b 44 24 5c          	mov    0x5c(%esp),%eax
     873:	39 d8                	cmp    %ebx,%eax
     875:	76 55                	jbe    8cc <_explode+0x7cc>
     877:	89 d9                	mov    %ebx,%ecx
     879:	89 c3                	mov    %eax,%ebx
     87b:	eb 28                	jmp    8a5 <_explode+0x7a5>
     87d:	8d 76 00             	lea    0x0(%esi),%esi
     880:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     886:	8d 50 01             	lea    0x1(%eax),%edx
     889:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     88f:	0f b6 38             	movzbl (%eax),%edi
     892:	81 e7 ff 00 00 00    	and    $0xff,%edi
     898:	89 f8                	mov    %edi,%eax
     89a:	d3 e0                	shl    %cl,%eax
     89c:	83 c1 08             	add    $0x8,%ecx
     89f:	09 c5                	or     %eax,%ebp
     8a1:	39 cb                	cmp    %ecx,%ebx
     8a3:	76 25                	jbe    8ca <_explode+0x7ca>
     8a5:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     8ab:	85 c0                	test   %eax,%eax
     8ad:	8d 50 ff             	lea    -0x1(%eax),%edx
     8b0:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     8b6:	7f c8                	jg     880 <_explode+0x780>
     8b8:	89 34 24             	mov    %esi,(%esp)
     8bb:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     8bf:	e8 00 00 00 00       	call   8c4 <_explode+0x7c4>
     8c4:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     8c8:	eb d0                	jmp    89a <_explode+0x79a>
     8ca:	89 cb                	mov    %ecx,%ebx
     8cc:	89 e8                	mov    %ebp,%eax
     8ce:	8b 54 24 64          	mov    0x64(%esp),%edx
     8d2:	83 f0 ff             	xor    $0xffffffff,%eax
     8d5:	8b 7c 24 60          	mov    0x60(%esp),%edi
     8d9:	21 d0                	and    %edx,%eax
     8db:	8d 04 c7             	lea    (%edi,%eax,8),%eax
     8de:	89 c7                	mov    %eax,%edi
     8e0:	8a 40 01             	mov    0x1(%eax),%al
     8e3:	88 44 24 28          	mov    %al,0x28(%esp)
     8e7:	31 c0                	xor    %eax,%eax
     8e9:	8a 44 24 28          	mov    0x28(%esp),%al
     8ed:	8a 17                	mov    (%edi),%dl
     8ef:	29 c3                	sub    %eax,%ebx
     8f1:	31 c0                	xor    %eax,%eax
     8f3:	8a 4c 24 28          	mov    0x28(%esp),%cl
     8f7:	88 d0                	mov    %dl,%al
     8f9:	d3 ed                	shr    %cl,%ebp
     8fb:	83 f8 20             	cmp    $0x20,%eax
     8fe:	0f 86 af 00 00 00    	jbe    9b3 <_explode+0x8b3>
     904:	83 f8 63             	cmp    $0x63,%eax
     907:	0f 84 f2 fd ff ff    	je     6ff <_explode+0x5ff>
     90d:	88 d1                	mov    %dl,%cl
     90f:	89 fa                	mov    %edi,%edx
     911:	89 cf                	mov    %ecx,%edi
     913:	83 e7 1f             	and    $0x1f,%edi
     916:	39 df                	cmp    %ebx,%edi
     918:	76 5c                	jbe    976 <_explode+0x876>
     91a:	89 d9                	mov    %ebx,%ecx
     91c:	89 d3                	mov    %edx,%ebx
     91e:	eb 24                	jmp    944 <_explode+0x844>
     920:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     926:	8d 50 01             	lea    0x1(%eax),%edx
     929:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     92f:	8a 10                	mov    (%eax),%dl
     931:	81 e2 ff 00 00 00    	and    $0xff,%edx
     937:	89 d0                	mov    %edx,%eax
     939:	d3 e0                	shl    %cl,%eax
     93b:	83 c1 08             	add    $0x8,%ecx
     93e:	09 c5                	or     %eax,%ebp
     940:	39 cf                	cmp    %ecx,%edi
     942:	76 2e                	jbe    972 <_explode+0x872>
     944:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     94a:	85 c0                	test   %eax,%eax
     94c:	8d 50 ff             	lea    -0x1(%eax),%edx
     94f:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     955:	7f c9                	jg     920 <_explode+0x820>
     957:	89 34 24             	mov    %esi,(%esp)
     95a:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     95e:	e8 00 00 00 00       	call   963 <_explode+0x863>
     963:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     967:	d3 e0                	shl    %cl,%eax
     969:	83 c1 08             	add    $0x8,%ecx
     96c:	09 c5                	or     %eax,%ebp
     96e:	39 cf                	cmp    %ecx,%edi
     970:	77 d2                	ja     944 <_explode+0x844>
     972:	89 da                	mov    %ebx,%edx
     974:	89 cb                	mov    %ecx,%ebx
     976:	89 e8                	mov    %ebp,%eax
     978:	8b 0c bd 00 00 00 00 	mov    0x0(,%edi,4),%ecx
     97f:	83 f0 ff             	xor    $0xffffffff,%eax
     982:	8b 7a 04             	mov    0x4(%edx),%edi
     985:	21 c8                	and    %ecx,%eax
     987:	8d 04 c7             	lea    (%edi,%eax,8),%eax
     98a:	89 c2                	mov    %eax,%edx
     98c:	31 c0                	xor    %eax,%eax
     98e:	8a 42 01             	mov    0x1(%edx),%al
     991:	8a 4a 01             	mov    0x1(%edx),%cl
     994:	d3 ed                	shr    %cl,%ebp
     996:	29 c3                	sub    %eax,%ebx
     998:	8a 0a                	mov    (%edx),%cl
     99a:	31 c0                	xor    %eax,%eax
     99c:	88 c8                	mov    %cl,%al
     99e:	83 f8 20             	cmp    $0x20,%eax
     9a1:	76 0e                	jbe    9b1 <_explode+0x8b1>
     9a3:	83 f8 63             	cmp    $0x63,%eax
     9a6:	0f 85 65 ff ff ff    	jne    911 <_explode+0x811>
     9ac:	e9 4e fd ff ff       	jmp    6ff <_explode+0x5ff>
     9b1:	89 d7                	mov    %edx,%edi
      n = t->v.n;
     9b3:	31 c9                	xor    %ecx,%ecx
      if (e)                    /* get length extra bits */
     9b5:	85 c0                	test   %eax,%eax
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
      DECODEHUFT(tl, bl, ml)    /* get coded length */
      n = t->v.n;
     9b7:	66 8b 4f 04          	mov    0x4(%edi),%cx
     9bb:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
      if (e)                    /* get length extra bits */
     9bf:	74 56                	je     a17 <_explode+0x917>
      {
        NEEDBITS(8)
     9c1:	83 fb 07             	cmp    $0x7,%ebx
     9c4:	77 3a                	ja     a00 <_explode+0x900>
     9c6:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     9cc:	85 c0                	test   %eax,%eax
     9ce:	8d 50 ff             	lea    -0x1(%eax),%edx
     9d1:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     9d7:	0f 8e 55 06 00 00    	jle    1032 <_explode+0xf32>
     9dd:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     9e3:	8d 50 01             	lea    0x1(%eax),%edx
     9e6:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     9ec:	0f b6 38             	movzbl (%eax),%edi
     9ef:	81 e7 ff 00 00 00    	and    $0xff,%edi
     9f5:	89 f8                	mov    %edi,%eax
     9f7:	88 d9                	mov    %bl,%cl
     9f9:	83 c3 08             	add    $0x8,%ebx
     9fc:	d3 e0                	shl    %cl,%eax
     9fe:	09 c5                	or     %eax,%ebp
        n += (unsigned)b & 0xff;
     a00:	89 e8                	mov    %ebp,%eax
     a02:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
     a06:	25 ff 00 00 00       	and    $0xff,%eax
        DUMPBITS(8)
     a0b:	83 eb 08             	sub    $0x8,%ebx
     a0e:	c1 ed 08             	shr    $0x8,%ebp
      DECODEHUFT(tl, bl, ml)    /* get coded length */
      n = t->v.n;
      if (e)                    /* get length extra bits */
      {
        NEEDBITS(8)
        n += (unsigned)b & 0xff;
     a11:	01 c1                	add    %eax,%ecx
     a13:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
        DUMPBITS(8)
      }

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
     a17:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
     a1b:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
     a1f:	89 f8                	mov    %edi,%eax
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
     a21:	8b 54 24 68          	mov    0x68(%esp),%edx
        n += (unsigned)b & 0xff;
        DUMPBITS(8)
      }

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
     a25:	29 c8                	sub    %ecx,%eax
     a27:	39 f9                	cmp    %edi,%ecx
     a29:	bf 00 00 00 00       	mov    $0x0,%edi
     a2e:	0f 43 c7             	cmovae %edi,%eax
     a31:	89 44 24 3c          	mov    %eax,0x3c(%esp)
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
     a35:	8b 7c 24 40          	mov    0x40(%esp),%edi
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
     a39:	8b 44 24 30          	mov    0x30(%esp),%eax
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
     a3d:	89 6c 24 30          	mov    %ebp,0x30(%esp)
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
     a41:	21 d0                	and    %edx,%eax
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
     a43:	89 fa                	mov    %edi,%edx
     a45:	29 c2                	sub    %eax,%edx
     a47:	31 c0                	xor    %eax,%eax
     a49:	66 8b 44 24 6c       	mov    0x6c(%esp),%ax
     a4e:	89 5c 24 6c          	mov    %ebx,0x6c(%esp)
     a52:	29 c2                	sub    %eax,%edx
     a54:	89 fb                	mov    %edi,%ebx
     a56:	89 54 24 28          	mov    %edx,0x28(%esp)
     a5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
      do {
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
        if (G.redirect_slide) {
     a60:	8b ae a8 00 00 00    	mov    0xa8(%esi),%ebp
     a66:	85 ed                	test   %ebp,%ebp
          /* &= w/ wszimpl not needed and wrong if redirect */
          if (d >= wszimpl)
     a68:	8b ae ac 00 00 00    	mov    0xac(%esi),%ebp

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
      do {
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
        if (G.redirect_slide) {
     a6e:	0f 84 9c 00 00 00    	je     b10 <_explode+0xa10>
          /* &= w/ wszimpl not needed and wrong if redirect */
          if (d >= wszimpl)
     a74:	8b 44 24 28          	mov    0x28(%esp),%eax
     a78:	39 c5                	cmp    %eax,%ebp
     a7a:	0f 86 7f fc ff ff    	jbe    6ff <_explode+0x5ff>
            return 1;
          e = wszimpl - (d > w ? d : w);
     a80:	39 c3                	cmp    %eax,%ebx
     a82:	0f 43 c3             	cmovae %ebx,%eax
     a85:	29 c5                	sub    %eax,%ebp
     a87:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     a8b:	39 c5                	cmp    %eax,%ebp
     a8d:	0f 47 e8             	cmova  %eax,%ebp
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
     a90:	29 e8                	sub    %ebp,%eax
        if (u && w <= d)
     a92:	3b 5c 24 28          	cmp    0x28(%esp),%ebx
          e = wszimpl - (d > w ? d : w);
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
     a96:	89 44 24 2c          	mov    %eax,0x2c(%esp)
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
     a9a:	89 d8                	mov    %ebx,%eax
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
     a9c:	77 0c                	ja     aaa <_explode+0x9aa>
     a9e:	8b 4c 24 38          	mov    0x38(%esp),%ecx
     aa2:	85 c9                	test   %ecx,%ecx
     aa4:	0f 85 86 00 00 00    	jne    b30 <_explode+0xa30>
          w += e;
          d += e;
        }
        else
#ifndef NOMEMCPY
          if (w - d >= e)       /* (this test assumes unsigned comparison) */
     aaa:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     aae:	29 c8                	sub    %ecx,%eax
     ab0:	39 e8                	cmp    %ebp,%eax
     ab2:	0f 83 b8 00 00 00    	jae    b70 <_explode+0xa70>
     ab8:	89 d8                	mov    %ebx,%eax
     aba:	8d 7c 1d 00          	lea    0x0(%ebp,%ebx,1),%edi
     abe:	8b 5c 24 28          	mov    0x28(%esp),%ebx
     ac2:	29 c3                	sub    %eax,%ebx
            d += e;
          }
          else                  /* do it slow to avoid memcpy() overlap */
#endif /* !NOMEMCPY */
            do {
              redirSlide[w++] = redirSlide[d++];
     ac4:	8b 96 bc 00 00 00    	mov    0xbc(%esi),%edx
     aca:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
     acd:	8a 0c 19             	mov    (%ecx,%ebx,1),%cl
     ad0:	88 0c 02             	mov    %cl,(%edx,%eax,1)
     ad3:	40                   	inc    %eax
            } while (--e);
     ad4:	39 f8                	cmp    %edi,%eax
     ad6:	75 ec                	jne    ac4 <_explode+0x9c4>
     ad8:	8b 54 24 28          	mov    0x28(%esp),%edx
     adc:	89 c3                	mov    %eax,%ebx
     ade:	01 ea                	add    %ebp,%edx
     ae0:	89 54 24 28          	mov    %edx,0x28(%esp)
        if (w == wszimpl)
     ae4:	39 9e ac 00 00 00    	cmp    %ebx,0xac(%esi)
     aea:	0f 84 ac 00 00 00    	je     b9c <_explode+0xa9c>
        {
          if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
            return retval;
          w = u = 0;
        }
      } while (n);
     af0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     af4:	85 c0                	test   %eax,%eax
     af6:	0f 85 64 ff ff ff    	jne    a60 <_explode+0x960>
     afc:	89 5c 24 40          	mov    %ebx,0x40(%esp)
     b00:	8b 6c 24 30          	mov    0x30(%esp),%ebp
     b04:	8b 5c 24 6c          	mov    0x6c(%esp),%ebx
     b08:	e9 e5 fc ff ff       	jmp    7f2 <_explode+0x6f2>
     b0d:	8d 76 00             	lea    0x0(%esi),%esi
          if (d >= wszimpl)
            return 1;
          e = wszimpl - (d > w ? d : w);
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
     b10:	8d 45 ff             	lea    -0x1(%ebp),%eax
     b13:	8b 7c 24 28          	mov    0x28(%esp),%edi
     b17:	21 c7                	and    %eax,%edi
     b19:	89 7c 24 28          	mov    %edi,0x28(%esp)
     b1d:	8b 7c 24 28          	mov    0x28(%esp),%edi
     b21:	89 f8                	mov    %edi,%eax
     b23:	39 df                	cmp    %ebx,%edi
     b25:	0f 42 c3             	cmovb  %ebx,%eax
     b28:	29 c5                	sub    %eax,%ebp
     b2a:	e9 58 ff ff ff       	jmp    a87 <_explode+0x987>
     b2f:	90                   	nop
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
     b30:	8b 96 bc 00 00 00    	mov    0xbc(%esi),%edx
     b36:	01 d0                	add    %edx,%eax
     b38:	89 ea                	mov    %ebp,%edx
     b3a:	89 c7                	mov    %eax,%edi
     b3c:	83 fd 04             	cmp    $0x4,%ebp
     b3f:	0f 83 8c 00 00 00    	jae    bd1 <_explode+0xad1>
     b45:	f6 c2 02             	test   $0x2,%dl
     b48:	74 08                	je     b52 <_explode+0xa52>
     b4a:	66 c7 07 00 00       	movw   $0x0,(%edi)
     b4f:	83 c7 02             	add    $0x2,%edi
     b52:	83 e2 01             	and    $0x1,%edx
     b55:	74 03                	je     b5a <_explode+0xa5a>
     b57:	c6 07 00             	movb   $0x0,(%edi)
          w += e;
          d += e;
     b5a:	8b 7c 24 28          	mov    0x28(%esp),%edi
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
          w += e;
     b5e:	01 eb                	add    %ebp,%ebx
          d += e;
     b60:	01 ef                	add    %ebp,%edi
     b62:	89 7c 24 28          	mov    %edi,0x28(%esp)
     b66:	e9 79 ff ff ff       	jmp    ae4 <_explode+0x9e4>
     b6b:	90                   	nop
     b6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        else
#ifndef NOMEMCPY
          if (w - d >= e)       /* (this test assumes unsigned comparison) */
          {
            memcpy(redirSlide + w, redirSlide + d, e);
     b70:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
     b76:	8b 7c 24 28          	mov    0x28(%esp),%edi
     b7a:	89 6c 24 08          	mov    %ebp,0x8(%esp)
     b7e:	8d 14 18             	lea    (%eax,%ebx,1),%edx
     b81:	01 f8                	add    %edi,%eax
     b83:	89 44 24 04          	mov    %eax,0x4(%esp)
     b87:	89 14 24             	mov    %edx,(%esp)
            w += e;
            d += e;
     b8a:	01 ef                	add    %ebp,%edi
        }
        else
#ifndef NOMEMCPY
          if (w - d >= e)       /* (this test assumes unsigned comparison) */
          {
            memcpy(redirSlide + w, redirSlide + d, e);
     b8c:	e8 00 00 00 00       	call   b91 <_explode+0xa91>
            w += e;
     b91:	01 eb                	add    %ebp,%ebx
            d += e;
     b93:	89 7c 24 28          	mov    %edi,0x28(%esp)
     b97:	e9 48 ff ff ff       	jmp    ae4 <_explode+0x9e4>
            do {
              redirSlide[w++] = redirSlide[d++];
            } while (--e);
        if (w == wszimpl)
        {
          if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
     b9c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     ba3:	00 
     ba4:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     ba8:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
     bae:	89 34 24             	mov    %esi,(%esp)
     bb1:	89 44 24 04          	mov    %eax,0x4(%esp)
     bb5:	e8 00 00 00 00       	call   bba <_explode+0xaba>
     bba:	85 c0                	test   %eax,%eax
     bbc:	0f 85 0d 08 00 00    	jne    13cf <_explode+0x12cf>
            return retval;
          w = u = 0;
     bc2:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
     bc9:	00 
     bca:	31 db                	xor    %ebx,%ebx
     bcc:	e9 1f ff ff ff       	jmp    af0 <_explode+0x9f0>
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
     bd1:	a8 01                	test   $0x1,%al
     bd3:	0f 85 dd 07 00 00    	jne    13b6 <_explode+0x12b6>
     bd9:	f7 c7 02 00 00 00    	test   $0x2,%edi
     bdf:	0f 85 c1 07 00 00    	jne    13a6 <_explode+0x12a6>
     be5:	89 d1                	mov    %edx,%ecx
     be7:	31 c0                	xor    %eax,%eax
     be9:	c1 e9 02             	shr    $0x2,%ecx
     bec:	f3 ab                	rep stos %eax,%es:(%edi)
     bee:	e9 52 ff ff ff       	jmp    b45 <_explode+0xa45>

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
    huft_free(tb);
  } else {
    r = explode_nolit(__G__ tl, td, bl, bd, bdl);
     bf3:	89 44 24 44          	mov    %eax,0x44(%esp)

  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
     bf7:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
     bfe:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  mdl = mask_bits[bdl];
     c02:	8b 44 24 34          	mov    0x34(%esp),%eax

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
    huft_free(tb);
  } else {
    r = explode_nolit(__G__ tl, td, bl, bd, bdl);
     c06:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
     c0d:	8b bc 24 80 00 00 00 	mov    0x80(%esp),%edi
  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
     c14:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
    huft_free(tb);
  } else {
    r = explode_nolit(__G__ tl, td, bl, bd, bdl);
     c1b:	89 5c 24 54          	mov    %ebx,0x54(%esp)
     c1f:	89 7c 24 48          	mov    %edi,0x48(%esp)


  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  ml = mask_bits[bl];           /* precompute masks for speed */
     c23:	8b 1c 9d 00 00 00 00 	mov    0x0(,%ebx,4),%ebx

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
    huft_free(tb);
  } else {
    r = explode_nolit(__G__ tl, td, bl, bd, bdl);
     c2a:	8b 7c 24 7c          	mov    0x7c(%esp),%edi
  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
     c2e:	89 44 24 5c          	mov    %eax,0x5c(%esp)
  s = G.lrec.ucsize;
     c32:	8b 86 24 09 01 00    	mov    0x10924(%esi),%eax

  if (tb != NULL) {
    r = explode_lit(__G__ tb, tl, td, bb, bl, bd, bdl);
    huft_free(tb);
  } else {
    r = explode_nolit(__G__ tl, td, bl, bd, bdl);
     c38:	89 7c 24 58          	mov    %edi,0x58(%esp)


  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
  u = 1;                        /* buffer unflushed */
  ml = mask_bits[bl];           /* precompute masks for speed */
     c3c:	89 5c 24 50          	mov    %ebx,0x50(%esp)
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
     c40:	89 44 24 40          	mov    %eax,0x40(%esp)
  while (s > 0)                 /* do until ucsize bytes uncompressed */
     c44:	85 c0                	test   %eax,%eax
     c46:	0f 84 f9 07 00 00    	je     1445 <_explode+0x1345>
     c4c:	c7 44 24 38 01 00 00 	movl   $0x1,0x38(%esp)
     c53:	00 
     c54:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
     c5b:	00 
     c5c:	31 ed                	xor    %ebp,%ebp
     c5e:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
     c65:	00 
  {
    NEEDBITS(1)
     c66:	85 ed                	test   %ebp,%ebp
     c68:	0f 85 ad 01 00 00    	jne    e1b <_explode+0xd1b>
     c6e:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     c74:	85 c0                	test   %eax,%eax
     c76:	8d 50 ff             	lea    -0x1(%eax),%edx
     c79:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     c7f:	0f 8e 89 01 00 00    	jle    e0e <_explode+0xd0e>
     c85:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     c8b:	8d 50 01             	lea    0x1(%eax),%edx
     c8e:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     c94:	8a 18                	mov    (%eax),%bl
     c96:	81 e3 ff 00 00 00    	and    $0xff,%ebx
     c9c:	89 d8                	mov    %ebx,%eax
     c9e:	8b 6c 24 28          	mov    0x28(%esp),%ebp
     ca2:	09 e8                	or     %ebp,%eax
    if (b & 1)                  /* then literal--get eight bits */
     ca4:	a8 01                	test   $0x1,%al
     ca6:	0f 84 e4 00 00 00    	je     d90 <_explode+0xc90>
    {
      DUMPBITS(1)
      s--;
     cac:	ff 4c 24 40          	decl   0x40(%esp)
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--get eight bits */
    {
      DUMPBITS(1)
     cb0:	b9 07 00 00 00       	mov    $0x7,%ecx
     cb5:	d1 e8                	shr    %eax
     cb7:	89 c3                	mov    %eax,%ebx
      s--;
      NEEDBITS(8)
     cb9:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     cbf:	85 c0                	test   %eax,%eax
     cc1:	8d 50 ff             	lea    -0x1(%eax),%edx
     cc4:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     cca:	0f 8e a6 01 00 00    	jle    e76 <_explode+0xd76>
     cd0:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     cd6:	8d 50 01             	lea    0x1(%eax),%edx
     cd9:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     cdf:	0f b6 38             	movzbl (%eax),%edi
     ce2:	81 e7 ff 00 00 00    	and    $0xff,%edi
     ce8:	89 f8                	mov    %edi,%eax
     cea:	d3 e0                	shl    %cl,%eax
     cec:	09 c3                	or     %eax,%ebx
     cee:	83 c1 08             	add    $0x8,%ecx
      redirSlide[w++] = (uch)b;
     cf1:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
     cf5:	8b 96 bc 00 00 00    	mov    0xbc(%esi),%edx
     cfb:	89 f8                	mov    %edi,%eax
     cfd:	40                   	inc    %eax
     cfe:	88 1c 3a             	mov    %bl,(%edx,%edi,1)
      if (w == wszimpl)
     d01:	3b 86 ac 00 00 00    	cmp    0xac(%esi),%eax
     d07:	0f 84 cb 06 00 00    	je     13d8 <_explode+0x12d8>
      {
        if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
          return retval;
        w = u = 0;
      }
      DUMPBITS(8)
     d0d:	c1 eb 08             	shr    $0x8,%ebx
     d10:	8d 69 f8             	lea    -0x8(%ecx),%ebp
     d13:	89 5c 24 28          	mov    %ebx,0x28(%esp)
     d17:	89 44 24 3c          	mov    %eax,0x3c(%esp)
  u = 1;                        /* buffer unflushed */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
     d1b:	8b 44 24 40          	mov    0x40(%esp),%eax
     d1f:	85 c0                	test   %eax,%eax
     d21:	0f 85 3f ff ff ff    	jne    c66 <_explode+0xb66>
      } while (n);
    }
  }

  /* flush out redirSlide */
  if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
     d27:	8b 44 24 3c          	mov    0x3c(%esp),%eax
     d2b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     d32:	00 
     d33:	89 44 24 08          	mov    %eax,0x8(%esp)
     d37:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
     d3d:	89 34 24             	mov    %esi,(%esp)
     d40:	89 44 24 04          	mov    %eax,0x4(%esp)
     d44:	e8 00 00 00 00       	call   d49 <_explode+0xc49>
     d49:	85 c0                	test   %eax,%eax
     d4b:	0f 85 eb 06 00 00    	jne    143c <_explode+0x133c>
    return retval;
  if (G.csize + G.incnt + (k >> 3))   /* should have read csize bytes, but */
     d51:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
     d57:	8b 96 ec 08 01 00    	mov    0x108ec(%esi),%edx
     d5d:	89 eb                	mov    %ebp,%ebx
     d5f:	c1 eb 03             	shr    $0x3,%ebx
     d62:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
     d65:	01 d9                	add    %ebx,%ecx
     d67:	0f 84 a6 f9 ff ff    	je     713 <_explode+0x613>
  {                        /* sometimes read one too many:  k>>3 compensates */
    G.used_csize = G.lrec.csize - G.csize - G.incnt - (k >> 3);
     d6d:	8b be 20 09 01 00    	mov    0x10920(%esi),%edi
     d73:	c7 44 24 24 05 00 00 	movl   $0x5,0x24(%esp)
     d7a:	00 
     d7b:	29 c7                	sub    %eax,%edi
     d7d:	89 f8                	mov    %edi,%eax
     d7f:	29 d0                	sub    %edx,%eax
     d81:	29 d8                	sub    %ebx,%eax
     d83:	89 86 94 00 00 00    	mov    %eax,0x94(%esi)
     d89:	e9 85 f9 ff ff       	jmp    713 <_explode+0x613>
     d8e:	66 90                	xchg   %ax,%ax
      }
      DUMPBITS(8)
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
     d90:	d1 e8                	shr    %eax
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--get eight bits */
     d92:	bb 07 00 00 00       	mov    $0x7,%ebx
      }
      DUMPBITS(8)
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
     d97:	89 44 24 2c          	mov    %eax,0x2c(%esp)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
     d9b:	8b 44 24 34          	mov    0x34(%esp),%eax
     d9f:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
     da3:	88 c1                	mov    %al,%cl
     da5:	29 c3                	sub    %eax,%ebx
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
     da7:	8b 44 24 44          	mov    0x44(%esp),%eax
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
     dab:	d3 ed                	shr    %cl,%ebp
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
     dad:	39 d8                	cmp    %ebx,%eax
     daf:	0f 86 02 01 00 00    	jbe    eb7 <_explode+0xdb7>
     db5:	89 d9                	mov    %ebx,%ecx
     db7:	89 c3                	mov    %eax,%ebx
     db9:	eb 2e                	jmp    de9 <_explode+0xce9>
     dbb:	90                   	nop
     dbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     dc0:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     dc6:	8d 50 01             	lea    0x1(%eax),%edx
     dc9:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     dcf:	0f b6 38             	movzbl (%eax),%edi
     dd2:	81 e7 ff 00 00 00    	and    $0xff,%edi
     dd8:	89 f8                	mov    %edi,%eax
     dda:	d3 e0                	shl    %cl,%eax
     ddc:	83 c1 08             	add    $0x8,%ecx
     ddf:	09 c5                	or     %eax,%ebp
     de1:	39 cb                	cmp    %ecx,%ebx
     de3:	0f 86 cc 00 00 00    	jbe    eb5 <_explode+0xdb5>
     de9:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     def:	85 c0                	test   %eax,%eax
     df1:	8d 50 ff             	lea    -0x1(%eax),%edx
     df4:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     dfa:	7f c4                	jg     dc0 <_explode+0xcc0>
     dfc:	89 34 24             	mov    %esi,(%esp)
     dff:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     e03:	e8 00 00 00 00       	call   e08 <_explode+0xd08>
     e08:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     e0c:	eb cc                	jmp    dda <_explode+0xcda>
  md = mask_bits[bd];
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
     e0e:	89 34 24             	mov    %esi,(%esp)
     e11:	e8 00 00 00 00       	call   e16 <_explode+0xd16>
     e16:	e9 83 fe ff ff       	jmp    c9e <_explode+0xb9e>
    if (b & 1)                  /* then literal--get eight bits */
     e1b:	f6 44 24 28 01       	testb  $0x1,0x28(%esp)
     e20:	75 73                	jne    e95 <_explode+0xd95>
      }
      DUMPBITS(8)
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
     e22:	8b 44 24 28          	mov    0x28(%esp),%eax
     e26:	8d 5d ff             	lea    -0x1(%ebp),%ebx
     e29:	d1 e8                	shr    %eax
      NEEDBITS(bdl)             /* get distance low bits */
     e2b:	39 5c 24 34          	cmp    %ebx,0x34(%esp)
      }
      DUMPBITS(8)
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
     e2f:	89 44 24 2c          	mov    %eax,0x2c(%esp)
      NEEDBITS(bdl)             /* get distance low bits */
     e33:	0f 86 62 ff ff ff    	jbe    d9b <_explode+0xc9b>
     e39:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     e3f:	85 c0                	test   %eax,%eax
     e41:	8d 50 ff             	lea    -0x1(%eax),%edx
     e44:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     e4a:	7e 3f                	jle    e8b <_explode+0xd8b>
     e4c:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     e52:	8d 50 01             	lea    0x1(%eax),%edx
     e55:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     e5b:	0f b6 38             	movzbl (%eax),%edi
     e5e:	81 e7 ff 00 00 00    	and    $0xff,%edi
     e64:	89 f8                	mov    %edi,%eax
     e66:	88 d9                	mov    %bl,%cl
     e68:	83 c3 08             	add    $0x8,%ebx
     e6b:	d3 e0                	shl    %cl,%eax
     e6d:	09 44 24 2c          	or     %eax,0x2c(%esp)
     e71:	e9 25 ff ff ff       	jmp    d9b <_explode+0xc9b>
    NEEDBITS(1)
    if (b & 1)                  /* then literal--get eight bits */
    {
      DUMPBITS(1)
      s--;
      NEEDBITS(8)
     e76:	89 34 24             	mov    %esi,(%esp)
     e79:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     e7d:	e8 00 00 00 00       	call   e82 <_explode+0xd82>
     e82:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     e86:	e9 5f fe ff ff       	jmp    cea <_explode+0xbea>
      DUMPBITS(8)
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
     e8b:	89 34 24             	mov    %esi,(%esp)
     e8e:	e8 00 00 00 00       	call   e93 <_explode+0xd93>
     e93:	eb d1                	jmp    e66 <_explode+0xd66>
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--get eight bits */
    {
      DUMPBITS(1)
      s--;
     e95:	8b 7c 24 40          	mov    0x40(%esp),%edi
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--get eight bits */
    {
      DUMPBITS(1)
     e99:	8b 5c 24 28          	mov    0x28(%esp),%ebx
      s--;
     e9d:	4f                   	dec    %edi
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--get eight bits */
    {
      DUMPBITS(1)
     e9e:	8d 4d ff             	lea    -0x1(%ebp),%ecx
     ea1:	d1 eb                	shr    %ebx
      s--;
     ea3:	89 7c 24 40          	mov    %edi,0x40(%esp)
      NEEDBITS(8)
     ea7:	83 f9 07             	cmp    $0x7,%ecx
     eaa:	0f 86 09 fe ff ff    	jbe    cb9 <_explode+0xbb9>
     eb0:	e9 3c fe ff ff       	jmp    cf1 <_explode+0xbf1>
     eb5:	89 cb                	mov    %ecx,%ebx
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
     eb7:	89 e8                	mov    %ebp,%eax
     eb9:	8b 54 24 4c          	mov    0x4c(%esp),%edx
     ebd:	83 f0 ff             	xor    $0xffffffff,%eax
     ec0:	8b 7c 24 48          	mov    0x48(%esp),%edi
     ec4:	21 d0                	and    %edx,%eax
     ec6:	8d 14 c7             	lea    (%edi,%eax,8),%edx
     ec9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     ed0:	31 c0                	xor    %eax,%eax
     ed2:	8a 4a 01             	mov    0x1(%edx),%cl
     ed5:	8a 42 01             	mov    0x1(%edx),%al
     ed8:	d3 ed                	shr    %cl,%ebp
     eda:	29 c3                	sub    %eax,%ebx
     edc:	31 c9                	xor    %ecx,%ecx
     ede:	8a 02                	mov    (%edx),%al
     ee0:	88 c1                	mov    %al,%cl
     ee2:	83 f9 20             	cmp    $0x20,%ecx
     ee5:	0f 86 54 01 00 00    	jbe    103f <_explode+0xf3f>
     eeb:	83 f9 63             	cmp    $0x63,%ecx
     eee:	0f 84 cd 00 00 00    	je     fc1 <_explode+0xec1>
     ef4:	89 c7                	mov    %eax,%edi
     ef6:	83 e7 1f             	and    $0x1f,%edi
     ef9:	39 df                	cmp    %ebx,%edi
     efb:	76 57                	jbe    f54 <_explode+0xe54>
     efd:	89 d9                	mov    %ebx,%ecx
     eff:	89 d3                	mov    %edx,%ebx
     f01:	eb 24                	jmp    f27 <_explode+0xe27>
     f03:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     f09:	8d 50 01             	lea    0x1(%eax),%edx
     f0c:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     f12:	8a 10                	mov    (%eax),%dl
     f14:	81 e2 ff 00 00 00    	and    $0xff,%edx
     f1a:	89 d0                	mov    %edx,%eax
     f1c:	d3 e0                	shl    %cl,%eax
     f1e:	83 c1 08             	add    $0x8,%ecx
     f21:	09 c5                	or     %eax,%ebp
     f23:	39 cf                	cmp    %ecx,%edi
     f25:	76 29                	jbe    f50 <_explode+0xe50>
     f27:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     f2d:	85 c0                	test   %eax,%eax
     f2f:	8d 50 ff             	lea    -0x1(%eax),%edx
     f32:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     f38:	7f c9                	jg     f03 <_explode+0xe03>
     f3a:	89 34 24             	mov    %esi,(%esp)
     f3d:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     f41:	e8 00 00 00 00       	call   f46 <_explode+0xe46>
     f46:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     f4a:	eb d0                	jmp    f1c <_explode+0xe1c>
     f4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     f50:	89 da                	mov    %ebx,%edx
     f52:	89 cb                	mov    %ecx,%ebx
     f54:	89 e8                	mov    %ebp,%eax
     f56:	8b 0c bd 00 00 00 00 	mov    0x0(,%edi,4),%ecx
     f5d:	83 f0 ff             	xor    $0xffffffff,%eax
     f60:	8b 7a 04             	mov    0x4(%edx),%edi
     f63:	21 c8                	and    %ecx,%eax
     f65:	8d 04 c7             	lea    (%edi,%eax,8),%eax
     f68:	89 c2                	mov    %eax,%edx
     f6a:	e9 61 ff ff ff       	jmp    ed0 <_explode+0xdd0>
    r = huft_build(__G__ l, 64, 0, cpdist4, extra, &td, &bd);
  }
  if (r != 0)
  {
    if (r == 1)
      huft_free(td);
     f6f:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
     f76:	89 04 24             	mov    %eax,(%esp)
     f79:	e8 00 00 00 00       	call   f7e <_explode+0xe7e>
     f7e:	e9 b7 f3 ff ff       	jmp    33a <_explode+0x23a>
     f83:	89 ea                	mov    %ebp,%edx
     f85:	89 cd                	mov    %ecx,%ebp
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
      DECODEHUFT(tl, bl, ml)    /* get coded length */
     f87:	89 d8                	mov    %ebx,%eax
     f89:	8b 0c bd 00 00 00 00 	mov    0x0(,%edi,4),%ecx
     f90:	83 f0 ff             	xor    $0xffffffff,%eax
     f93:	8b 7a 04             	mov    0x4(%edx),%edi
     f96:	21 c8                	and    %ecx,%eax
     f98:	8d 04 c7             	lea    (%edi,%eax,8),%eax
     f9b:	89 c2                	mov    %eax,%edx
     f9d:	31 c0                	xor    %eax,%eax
     f9f:	8a 42 01             	mov    0x1(%edx),%al
     fa2:	8a 4a 01             	mov    0x1(%edx),%cl
     fa5:	d3 eb                	shr    %cl,%ebx
     fa7:	29 c5                	sub    %eax,%ebp
     fa9:	8a 0a                	mov    (%edx),%cl
     fab:	31 c0                	xor    %eax,%eax
     fad:	88 c8                	mov    %cl,%al
     faf:	83 f8 20             	cmp    $0x20,%eax
     fb2:	0f 86 89 01 00 00    	jbe    1141 <_explode+0x1041>
     fb8:	83 f8 63             	cmp    $0x63,%eax
     fbb:	0f 85 20 01 00 00    	jne    10e1 <_explode+0xfe1>
      s--;
      NEEDBITS(8)
      redirSlide[w++] = (uch)b;
      if (w == wszimpl)
      {
        if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
     fc1:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
     fc8:	00 
     fc9:	e9 45 f7 ff ff       	jmp    713 <_explode+0x613>
     fce:	4b                   	dec    %ebx
  mdl = mask_bits[bdl];
  s = G.lrec.ucsize;
  while (s > 0)                 /* do until ucsize bytes uncompressed */
  {
    NEEDBITS(1)
    if (b & 1)                  /* then literal--decode it */
     fcf:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     fd5:	0f 85 9a f5 ff ff    	jne    575 <_explode+0x475>
        w = u = 0;
      }
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
     fdb:	d1 ed                	shr    %ebp
      NEEDBITS(bdl)             /* get distance low bits */
     fdd:	39 5c 24 34          	cmp    %ebx,0x34(%esp)
        w = u = 0;
      }
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
     fe1:	89 6c 24 30          	mov    %ebp,0x30(%esp)
      NEEDBITS(bdl)             /* get distance low bits */
     fe5:	0f 86 15 f5 ff ff    	jbe    500 <_explode+0x400>
     feb:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     ff1:	85 c0                	test   %eax,%eax
     ff3:	8d 50 ff             	lea    -0x1(%eax),%edx
     ff6:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     ffc:	7e 2a                	jle    1028 <_explode+0xf28>
     ffe:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
    1004:	8d 50 01             	lea    0x1(%eax),%edx
    1007:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
    100d:	0f b6 38             	movzbl (%eax),%edi
    1010:	81 e7 ff 00 00 00    	and    $0xff,%edi
    1016:	89 f8                	mov    %edi,%eax
    1018:	88 d9                	mov    %bl,%cl
    101a:	83 c3 08             	add    $0x8,%ebx
    101d:	d3 e0                	shl    %cl,%eax
    101f:	09 44 24 30          	or     %eax,0x30(%esp)
    1023:	e9 d8 f4 ff ff       	jmp    500 <_explode+0x400>
    1028:	89 34 24             	mov    %esi,(%esp)
    102b:	e8 00 00 00 00       	call   1030 <_explode+0xf30>
    1030:	eb e6                	jmp    1018 <_explode+0xf18>
      d = w - d - t->v.n;       /* construct offset */
      DECODEHUFT(tl, bl, ml)    /* get coded length */
      n = t->v.n;
      if (e)                    /* get length extra bits */
      {
        NEEDBITS(8)
    1032:	89 34 24             	mov    %esi,(%esp)
    1035:	e8 00 00 00 00       	call   103a <_explode+0xf3a>
    103a:	e9 b8 f9 ff ff       	jmp    9f7 <_explode+0x8f7>
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
    103f:	8b 42 04             	mov    0x4(%edx),%eax
    1042:	66 89 44 24 60       	mov    %ax,0x60(%esp)
      DECODEHUFT(tl, bl, ml)    /* get coded length */
    1047:	8b 44 24 54          	mov    0x54(%esp),%eax
    104b:	39 d8                	cmp    %ebx,%eax
    104d:	76 52                	jbe    10a1 <_explode+0xfa1>
    104f:	89 d9                	mov    %ebx,%ecx
    1051:	89 c3                	mov    %eax,%ebx
    1053:	eb 25                	jmp    107a <_explode+0xf7a>
    1055:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
    105b:	8d 50 01             	lea    0x1(%eax),%edx
    105e:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
    1064:	0f b6 38             	movzbl (%eax),%edi
    1067:	81 e7 ff 00 00 00    	and    $0xff,%edi
    106d:	89 f8                	mov    %edi,%eax
    106f:	d3 e0                	shl    %cl,%eax
    1071:	83 c1 08             	add    $0x8,%ecx
    1074:	09 c5                	or     %eax,%ebp
    1076:	39 cb                	cmp    %ecx,%ebx
    1078:	76 25                	jbe    109f <_explode+0xf9f>
    107a:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
    1080:	85 c0                	test   %eax,%eax
    1082:	8d 50 ff             	lea    -0x1(%eax),%edx
    1085:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
    108b:	7f c8                	jg     1055 <_explode+0xf55>
    108d:	89 34 24             	mov    %esi,(%esp)
    1090:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    1094:	e8 00 00 00 00       	call   1099 <_explode+0xf99>
    1099:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    109d:	eb d0                	jmp    106f <_explode+0xf6f>
    109f:	89 cb                	mov    %ecx,%ebx
    10a1:	89 e8                	mov    %ebp,%eax
    10a3:	8b 54 24 50          	mov    0x50(%esp),%edx
    10a7:	83 f0 ff             	xor    $0xffffffff,%eax
    10aa:	8b 7c 24 58          	mov    0x58(%esp),%edi
    10ae:	21 d0                	and    %edx,%eax
    10b0:	8d 3c c7             	lea    (%edi,%eax,8),%edi
    10b3:	31 c0                	xor    %eax,%eax
    10b5:	8a 47 01             	mov    0x1(%edi),%al
    10b8:	8a 4f 01             	mov    0x1(%edi),%cl
    10bb:	29 c3                	sub    %eax,%ebx
    10bd:	31 c0                	xor    %eax,%eax
    10bf:	d3 ed                	shr    %cl,%ebp
    10c1:	89 6c 24 28          	mov    %ebp,0x28(%esp)
    10c5:	89 dd                	mov    %ebx,%ebp
    10c7:	8a 1f                	mov    (%edi),%bl
    10c9:	88 d8                	mov    %bl,%al
    10cb:	83 f8 20             	cmp    $0x20,%eax
    10ce:	76 77                	jbe    1147 <_explode+0x1047>
    10d0:	83 f8 63             	cmp    $0x63,%eax
    10d3:	0f 84 e8 fe ff ff    	je     fc1 <_explode+0xec1>
    10d9:	88 d9                	mov    %bl,%cl
    10db:	89 fa                	mov    %edi,%edx
    10dd:	8b 5c 24 28          	mov    0x28(%esp),%ebx
    10e1:	89 cf                	mov    %ecx,%edi
    10e3:	83 e7 1f             	and    $0x1f,%edi
    10e6:	39 ef                	cmp    %ebp,%edi
    10e8:	0f 86 99 fe ff ff    	jbe    f87 <_explode+0xe87>
    10ee:	89 e9                	mov    %ebp,%ecx
    10f0:	89 d5                	mov    %edx,%ebp
    10f2:	eb 28                	jmp    111c <_explode+0x101c>
    10f4:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
    10fa:	8d 50 01             	lea    0x1(%eax),%edx
    10fd:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
    1103:	8a 10                	mov    (%eax),%dl
    1105:	81 e2 ff 00 00 00    	and    $0xff,%edx
    110b:	89 d0                	mov    %edx,%eax
    110d:	d3 e0                	shl    %cl,%eax
    110f:	83 c1 08             	add    $0x8,%ecx
    1112:	09 c3                	or     %eax,%ebx
    1114:	39 cf                	cmp    %ecx,%edi
    1116:	0f 86 67 fe ff ff    	jbe    f83 <_explode+0xe83>
    111c:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
    1122:	85 c0                	test   %eax,%eax
    1124:	8d 50 ff             	lea    -0x1(%eax),%edx
    1127:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
    112d:	7f c5                	jg     10f4 <_explode+0xff4>
    112f:	89 34 24             	mov    %esi,(%esp)
    1132:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    1136:	e8 00 00 00 00       	call   113b <_explode+0x103b>
    113b:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    113f:	eb cc                	jmp    110d <_explode+0x100d>
    1141:	89 5c 24 28          	mov    %ebx,0x28(%esp)
    1145:	89 d7                	mov    %edx,%edi
      n = t->v.n;
    1147:	31 db                	xor    %ebx,%ebx
      if (e)                    /* get length extra bits */
    1149:	85 c0                	test   %eax,%eax
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
      DECODEHUFT(tl, bl, ml)    /* get coded length */
      n = t->v.n;
    114b:	66 8b 5f 04          	mov    0x4(%edi),%bx
    114f:	89 5c 24 30          	mov    %ebx,0x30(%esp)
      if (e)                    /* get length extra bits */
    1153:	74 5e                	je     11b3 <_explode+0x10b3>
      {
        NEEDBITS(8)
    1155:	83 fd 07             	cmp    $0x7,%ebp
    1158:	77 3b                	ja     1195 <_explode+0x1095>
    115a:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
    1160:	85 c0                	test   %eax,%eax
    1162:	8d 50 ff             	lea    -0x1(%eax),%edx
    1165:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
    116b:	0f 8e 51 02 00 00    	jle    13c2 <_explode+0x12c2>
    1171:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
    1177:	8d 50 01             	lea    0x1(%eax),%edx
    117a:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
    1180:	8a 18                	mov    (%eax),%bl
    1182:	81 e3 ff 00 00 00    	and    $0xff,%ebx
    1188:	89 d8                	mov    %ebx,%eax
    118a:	89 e9                	mov    %ebp,%ecx
    118c:	83 c5 08             	add    $0x8,%ebp
    118f:	d3 e0                	shl    %cl,%eax
    1191:	09 44 24 28          	or     %eax,0x28(%esp)
        n += (unsigned)b & 0xff;
    1195:	8b 5c 24 28          	mov    0x28(%esp),%ebx
    1199:	31 c0                	xor    %eax,%eax
    119b:	88 d8                	mov    %bl,%al
    119d:	8b 4c 24 30          	mov    0x30(%esp),%ecx
    11a1:	01 c1                	add    %eax,%ecx
        DUMPBITS(8)
    11a3:	89 d8                	mov    %ebx,%eax
    11a5:	c1 e8 08             	shr    $0x8,%eax
      DECODEHUFT(tl, bl, ml)    /* get coded length */
      n = t->v.n;
      if (e)                    /* get length extra bits */
      {
        NEEDBITS(8)
        n += (unsigned)b & 0xff;
    11a8:	89 4c 24 30          	mov    %ecx,0x30(%esp)
        DUMPBITS(8)
    11ac:	89 44 24 28          	mov    %eax,0x28(%esp)
    11b0:	83 ed 08             	sub    $0x8,%ebp
      }

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
    11b3:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    11b7:	8b 7c 24 30          	mov    0x30(%esp),%edi
    11bb:	89 d8                	mov    %ebx,%eax
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
    11bd:	8b 54 24 5c          	mov    0x5c(%esp),%edx
        n += (unsigned)b & 0xff;
        DUMPBITS(8)
      }

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
    11c1:	29 f8                	sub    %edi,%eax
    11c3:	39 df                	cmp    %ebx,%edi
    11c5:	bb 00 00 00 00       	mov    $0x0,%ebx
    11ca:	0f 43 c3             	cmovae %ebx,%eax
    11cd:	89 44 24 40          	mov    %eax,0x40(%esp)
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
    11d1:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
    11d5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
    11d9:	89 6c 24 3c          	mov    %ebp,0x3c(%esp)
    }
    else                        /* else distance/length */
    {
      DUMPBITS(1)
      NEEDBITS(bdl)             /* get distance low bits */
      d = (unsigned)b & mdl;
    11dd:	21 d0                	and    %edx,%eax
      DUMPBITS(bdl)
      DECODEHUFT(td, bd, md)    /* get coded distance high bits */
      d = w - d - t->v.n;       /* construct offset */
    11df:	89 da                	mov    %ebx,%edx
    11e1:	29 c2                	sub    %eax,%edx
    11e3:	31 c0                	xor    %eax,%eax
    11e5:	66 8b 44 24 60       	mov    0x60(%esp),%ax
    11ea:	29 c2                	sub    %eax,%edx
    11ec:	89 54 24 2c          	mov    %edx,0x2c(%esp)

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
      do {
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
        if (G.redirect_slide) {
    11f0:	8b ae a8 00 00 00    	mov    0xa8(%esi),%ebp
    11f6:	85 ed                	test   %ebp,%ebp
          /* &= w/ wszimpl not needed and wrong if redirect */
          if (d >= wszimpl)
    11f8:	8b ae ac 00 00 00    	mov    0xac(%esi),%ebp

      /* do the copy */
      s = (s > (ulg)n ? s - (ulg)n : 0);
      do {
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
        if (G.redirect_slide) {
    11fe:	0f 84 91 00 00 00    	je     1295 <_explode+0x1195>
          /* &= w/ wszimpl not needed and wrong if redirect */
          if (d >= wszimpl)
    1204:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    1208:	39 c5                	cmp    %eax,%ebp
    120a:	0f 86 b1 fd ff ff    	jbe    fc1 <_explode+0xec1>
            return 1;
          e = wszimpl - (d > w ? d : w);
    1210:	39 c3                	cmp    %eax,%ebx
    1212:	0f 43 c3             	cmovae %ebx,%eax
    1215:	29 c5                	sub    %eax,%ebp
    1217:	8b 44 24 30          	mov    0x30(%esp),%eax
    121b:	39 c5                	cmp    %eax,%ebp
    121d:	0f 47 e8             	cmova  %eax,%ebp
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
    1220:	29 e8                	sub    %ebp,%eax
        if (u && w <= d)
    1222:	3b 5c 24 2c          	cmp    0x2c(%esp),%ebx
          e = wszimpl - (d > w ? d : w);
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
    1226:	89 44 24 30          	mov    %eax,0x30(%esp)
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
    122a:	89 d8                	mov    %ebx,%eax
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
    122c:	77 08                	ja     1236 <_explode+0x1136>
    122e:	8b 4c 24 38          	mov    0x38(%esp),%ecx
    1232:	85 c9                	test   %ecx,%ecx
    1234:	75 7e                	jne    12b4 <_explode+0x11b4>
          w += e;
          d += e;
        }
        else
#ifndef NOMEMCPY
          if (w - d >= e)       /* (this test assumes unsigned comparison) */
    1236:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    123a:	29 f8                	sub    %edi,%eax
    123c:	39 c5                	cmp    %eax,%ebp
    123e:	0f 86 a8 00 00 00    	jbe    12ec <_explode+0x11ec>
    1244:	89 d8                	mov    %ebx,%eax
    1246:	8d 7c 1d 00          	lea    0x0(%ebp,%ebx,1),%edi
    124a:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
    124e:	29 c3                	sub    %eax,%ebx
            d += e;
          }
          else                  /* do it slow to avoid memcpy() overlap */
#endif /* !NOMEMCPY */
            do {
              redirSlide[w++] = redirSlide[d++];
    1250:	8b 96 bc 00 00 00    	mov    0xbc(%esi),%edx
    1256:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    1259:	8a 0c 19             	mov    (%ecx,%ebx,1),%cl
    125c:	88 0c 02             	mov    %cl,(%edx,%eax,1)
    125f:	40                   	inc    %eax
            } while (--e);
    1260:	39 f8                	cmp    %edi,%eax
    1262:	75 ec                	jne    1250 <_explode+0x1150>
    1264:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    1268:	89 c3                	mov    %eax,%ebx
    126a:	01 e9                	add    %ebp,%ecx
    126c:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
        if (w == wszimpl)
    1270:	39 9e ac 00 00 00    	cmp    %ebx,0xac(%esi)
    1276:	0f 84 9c 00 00 00    	je     1318 <_explode+0x1218>
        {
          if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
            return retval;
          w = u = 0;
        }
      } while (n);
    127c:	8b 54 24 30          	mov    0x30(%esp),%edx
    1280:	85 d2                	test   %edx,%edx
    1282:	0f 85 68 ff ff ff    	jne    11f0 <_explode+0x10f0>
    1288:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
    128c:	89 5c 24 3c          	mov    %ebx,0x3c(%esp)
    1290:	e9 86 fa ff ff       	jmp    d1b <_explode+0xc1b>
          if (d >= wszimpl)
            return 1;
          e = wszimpl - (d > w ? d : w);
        } else
#endif
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
    1295:	8d 45 ff             	lea    -0x1(%ebp),%eax
    1298:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    129c:	21 c7                	and    %eax,%edi
    129e:	89 7c 24 2c          	mov    %edi,0x2c(%esp)
    12a2:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    12a6:	89 f8                	mov    %edi,%eax
    12a8:	39 df                	cmp    %ebx,%edi
    12aa:	0f 42 c3             	cmovb  %ebx,%eax
    12ad:	29 c5                	sub    %eax,%ebp
    12af:	e9 63 ff ff ff       	jmp    1217 <_explode+0x1117>
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
    12b4:	8b 96 bc 00 00 00    	mov    0xbc(%esi),%edx
    12ba:	01 d0                	add    %edx,%eax
    12bc:	89 ea                	mov    %ebp,%edx
    12be:	89 c7                	mov    %eax,%edi
    12c0:	83 fd 04             	cmp    $0x4,%ebp
    12c3:	0f 83 84 00 00 00    	jae    134d <_explode+0x124d>
    12c9:	f6 c2 02             	test   $0x2,%dl
    12cc:	74 08                	je     12d6 <_explode+0x11d6>
    12ce:	66 c7 07 00 00       	movw   $0x0,(%edi)
    12d3:	83 c7 02             	add    $0x2,%edi
    12d6:	83 e2 01             	and    $0x1,%edx
    12d9:	74 03                	je     12de <_explode+0x11de>
    12db:	c6 07 00             	movb   $0x0,(%edi)
          w += e;
          d += e;
    12de:	8b 44 24 2c          	mov    0x2c(%esp),%eax
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
          w += e;
    12e2:	01 eb                	add    %ebp,%ebx
          d += e;
    12e4:	01 e8                	add    %ebp,%eax
    12e6:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    12ea:	eb 84                	jmp    1270 <_explode+0x1170>
        }
        else
#ifndef NOMEMCPY
          if (w - d >= e)       /* (this test assumes unsigned comparison) */
          {
            memcpy(redirSlide + w, redirSlide + d, e);
    12ec:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
    12f2:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    12f6:	89 6c 24 08          	mov    %ebp,0x8(%esp)
    12fa:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    12fd:	01 f8                	add    %edi,%eax
    12ff:	89 44 24 04          	mov    %eax,0x4(%esp)
    1303:	89 14 24             	mov    %edx,(%esp)
            w += e;
            d += e;
    1306:	01 ef                	add    %ebp,%edi
        }
        else
#ifndef NOMEMCPY
          if (w - d >= e)       /* (this test assumes unsigned comparison) */
          {
            memcpy(redirSlide + w, redirSlide + d, e);
    1308:	e8 00 00 00 00       	call   130d <_explode+0x120d>
            w += e;
    130d:	01 eb                	add    %ebp,%ebx
            d += e;
    130f:	89 7c 24 2c          	mov    %edi,0x2c(%esp)
    1313:	e9 58 ff ff ff       	jmp    1270 <_explode+0x1170>
            do {
              redirSlide[w++] = redirSlide[d++];
            } while (--e);
        if (w == wszimpl)
        {
          if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
    1318:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    131f:	00 
    1320:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    1324:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
    132a:	89 34 24             	mov    %esi,(%esp)
    132d:	89 44 24 04          	mov    %eax,0x4(%esp)
    1331:	e8 00 00 00 00       	call   1336 <_explode+0x1236>
    1336:	85 c0                	test   %eax,%eax
    1338:	0f 85 fe 00 00 00    	jne    143c <_explode+0x133c>
            return retval;
          w = u = 0;
    133e:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
    1345:	00 
    1346:	31 db                	xor    %ebx,%ebx
    1348:	e9 2f ff ff ff       	jmp    127c <_explode+0x117c>
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
    134d:	a8 01                	test   $0x1,%al
    134f:	0f 85 cc 00 00 00    	jne    1421 <_explode+0x1321>
    1355:	f7 c7 02 00 00 00    	test   $0x2,%edi
    135b:	0f 85 b0 00 00 00    	jne    1411 <_explode+0x1311>
    1361:	89 d1                	mov    %edx,%ecx
    1363:	31 c0                	xor    %eax,%eax
    1365:	c1 e9 02             	shr    $0x2,%ecx
    1368:	f3 ab                	rep stos %eax,%es:(%edi)
    136a:	e9 5a ff ff ff       	jmp    12c9 <_explode+0x11c9>
      s--;
      DECODEHUFT(tb, bb, mb)    /* get coded literal */
      redirSlide[w++] = (uch)t->v.n;
      if (w == wszimpl)
      {
        if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
    136f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1376:	00 
    1377:	89 44 24 08          	mov    %eax,0x8(%esp)
    137b:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
    1381:	89 34 24             	mov    %esi,(%esp)
    1384:	89 44 24 04          	mov    %eax,0x4(%esp)
    1388:	e8 00 00 00 00       	call   138d <_explode+0x128d>
    138d:	85 c0                	test   %eax,%eax
    138f:	75 3e                	jne    13cf <_explode+0x12cf>
          return retval;
        w = u = 0;
    1391:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
    1398:	00 
    1399:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
    13a0:	00 
    13a1:	e9 4c f4 ff ff       	jmp    7f2 <_explode+0x6f2>
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
    13a6:	66 c7 07 00 00       	movw   $0x0,(%edi)
    13ab:	83 ea 02             	sub    $0x2,%edx
    13ae:	83 c7 02             	add    $0x2,%edi
    13b1:	e9 2f f8 ff ff       	jmp    be5 <_explode+0xae5>
    13b6:	c6 00 00             	movb   $0x0,(%eax)
    13b9:	47                   	inc    %edi
    13ba:	8d 55 ff             	lea    -0x1(%ebp),%edx
    13bd:	e9 17 f8 ff ff       	jmp    bd9 <_explode+0xad9>
      d = w - d - t->v.n;       /* construct offset */
      DECODEHUFT(tl, bl, ml)    /* get coded length */
      n = t->v.n;
      if (e)                    /* get length extra bits */
      {
        NEEDBITS(8)
    13c2:	89 34 24             	mov    %esi,(%esp)
    13c5:	e8 00 00 00 00       	call   13ca <_explode+0x12ca>
    13ca:	e9 bb fd ff ff       	jmp    118a <_explode+0x108a>
      } while (n);
    }
  }

  /* flush out redirSlide */
  if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
    13cf:	89 44 24 24          	mov    %eax,0x24(%esp)
    13d3:	e9 2f f3 ff ff       	jmp    707 <_explode+0x607>
      s--;
      NEEDBITS(8)
      redirSlide[w++] = (uch)b;
      if (w == wszimpl)
      {
        if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
    13d8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    13df:	00 
    13e0:	89 44 24 08          	mov    %eax,0x8(%esp)
    13e4:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
    13ea:	89 34 24             	mov    %esi,(%esp)
    13ed:	89 44 24 04          	mov    %eax,0x4(%esp)
    13f1:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    13f5:	e8 00 00 00 00       	call   13fa <_explode+0x12fa>
    13fa:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    13fe:	85 c0                	test   %eax,%eax
    1400:	75 3a                	jne    143c <_explode+0x133c>
          return retval;
        w = u = 0;
    1402:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
    1409:	00 
    140a:	31 c0                	xor    %eax,%eax
    140c:	e9 fc f8 ff ff       	jmp    d0d <_explode+0xc0d>
          e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
        if (e > n) e = n;
        n -= e;
        if (u && w <= d)
        {
          memzero(redirSlide + w, e);
    1411:	66 c7 07 00 00       	movw   $0x0,(%edi)
    1416:	83 ea 02             	sub    $0x2,%edx
    1419:	83 c7 02             	add    $0x2,%edi
    141c:	e9 40 ff ff ff       	jmp    1361 <_explode+0x1261>
    1421:	c6 00 00             	movb   $0x0,(%eax)
    1424:	47                   	inc    %edi
    1425:	8d 55 ff             	lea    -0x1(%ebp),%edx
    1428:	e9 28 ff ff ff       	jmp    1355 <_explode+0x1255>
  unsigned u;           /* true if unflushed */
  int retval = 0;       /* error code returned: initialized to "no error" */


  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
    142d:	31 ed                	xor    %ebp,%ebp
    142f:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
    1436:	00 
    1437:	e9 c4 f3 ff ff       	jmp    800 <_explode+0x700>
      } while (n);
    }
  }

  /* flush out redirSlide */
  if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
    143c:	89 44 24 24          	mov    %eax,0x24(%esp)
    1440:	e9 ce f2 ff ff       	jmp    713 <_explode+0x613>
  unsigned u;           /* true if unflushed */
  int retval = 0;       /* error code returned: initialized to "no error" */


  /* explode the coded data */
  b = k = w = 0;                /* initialize bit buffer, window */
    1445:	31 ed                	xor    %ebp,%ebp
    1447:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
    144e:	00 
    144f:	e9 d3 f8 ff ff       	jmp    d27 <_explode+0xc27>
    1454:	90                   	nop
    1455:	90                   	nop
    1456:	90                   	nop
    1457:	90                   	nop
    1458:	90                   	nop
    1459:	90                   	nop
    145a:	90                   	nop
    145b:	90                   	nop
    145c:	90                   	nop
    145d:	90                   	nop
    145e:	90                   	nop
    145f:	90                   	nop

extract.o:     file format pe-i386


Disassembly of section .text:

00000000 <_dircomp>:

static int Cdecl dircomp(a, b)  /* used by qsort(); swiped from Zip */
    ZCONST zvoid *a, *b;
{
    /* order is significant:  this sorts in reverse order (deepest first) */
    return strcmp((*(direntry **)b)->fn, (*(direntry **)a)->fn);
       0:	8b 54 24 04          	mov    0x4(%esp),%edx
/*  Function dircomp()  */
/************************/

static int Cdecl dircomp(a, b)  /* used by qsort(); swiped from Zip */
    ZCONST zvoid *a, *b;
{
       4:	8b 44 24 08          	mov    0x8(%esp),%eax
    /* order is significant:  this sorts in reverse order (deepest first) */
    return strcmp((*(direntry **)b)->fn, (*(direntry **)a)->fn);
       8:	8b 12                	mov    (%edx),%edx
       a:	8b 52 04             	mov    0x4(%edx),%edx
       d:	89 54 24 08          	mov    %edx,0x8(%esp)
      11:	8b 00                	mov    (%eax),%eax
      13:	8b 40 04             	mov    0x4(%eax),%eax
      16:	89 44 24 04          	mov    %eax,0x4(%esp)
      1a:	e9 00 00 00 00       	jmp    1f <_dircomp+0x1f>
      1f:	90                   	nop

00000020 <_memextract>:
    __GDEF                                        /*  extra field block; */
    uch *tgt;                                     /*  return PK-type error */
    ulg tgtsize;                                  /*  level */
    ZCONST uch *src;
    ulg srcsize;
{
      20:	55                   	push   %ebp
      21:	57                   	push   %edi
      22:	56                   	push   %esi
      23:	53                   	push   %ebx
      24:	83 ec 3c             	sub    $0x3c,%esp
      27:	8b 6c 24 50          	mov    0x50(%esp),%ebp
      2b:	8b 5c 24 5c          	mov    0x5c(%esp),%ebx
    long old_csize=G.csize;
      2f:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
    uch *old_inptr=G.inptr;
      35:	8b bd e8 08 01 00    	mov    0x108e8(%ebp),%edi
    uch *tgt;                                     /*  return PK-type error */
    ulg tgtsize;                                  /*  level */
    ZCONST uch *src;
    ulg srcsize;
{
    long old_csize=G.csize;
      3b:	89 44 24 24          	mov    %eax,0x24(%esp)
    uch *old_inptr=G.inptr;
    int  old_incnt=G.incnt;
      3f:	8b 85 ec 08 01 00    	mov    0x108ec(%ebp),%eax
    int  r, error=PK_OK;
    ush  method;
    ulg  extra_field_crc;


    method = makeword(src);
      45:	89 1c 24             	mov    %ebx,(%esp)
    ZCONST uch *src;
    ulg srcsize;
{
    long old_csize=G.csize;
    uch *old_inptr=G.inptr;
    int  old_incnt=G.incnt;
      48:	89 44 24 28          	mov    %eax,0x28(%esp)
    int  r, error=PK_OK;
    ush  method;
    ulg  extra_field_crc;


    method = makeword(src);
      4c:	e8 00 00 00 00       	call   51 <_memextract+0x31>
      51:	89 c6                	mov    %eax,%esi
    extra_field_crc = makelong(src+2);
      53:	8d 43 02             	lea    0x2(%ebx),%eax
      56:	89 04 24             	mov    %eax,(%esp)

    /* compressed extra field exists completely in memory at this location: */
    G.inptr = (uch *)src + (2 + 4);     /* method and extra_field_crc */
      59:	83 c3 06             	add    $0x6,%ebx
    ush  method;
    ulg  extra_field_crc;


    method = makeword(src);
    extra_field_crc = makelong(src+2);
      5c:	e8 00 00 00 00       	call   61 <_memextract+0x41>

    /* compressed extra field exists completely in memory at this location: */
    G.inptr = (uch *)src + (2 + 4);     /* method and extra_field_crc */
    G.incnt = (int)(G.csize = (long)(srcsize - (2 + 4)));
    G.mem_mode = TRUE;
    G.outbufptr = tgt;
      61:	8b 54 24 54          	mov    0x54(%esp),%edx
    ush  method;
    ulg  extra_field_crc;


    method = makeword(src);
    extra_field_crc = makelong(src+2);
      65:	89 44 24 2c          	mov    %eax,0x2c(%esp)

    /* compressed extra field exists completely in memory at this location: */
    G.inptr = (uch *)src + (2 + 4);     /* method and extra_field_crc */
    G.incnt = (int)(G.csize = (long)(srcsize - (2 + 4)));
      69:	8b 44 24 60          	mov    0x60(%esp),%eax
      6d:	83 e8 06             	sub    $0x6,%eax
    G.mem_mode = TRUE;
    G.outbufptr = tgt;
    G.outsize = tgtsize;
      70:	8b 4c 24 58          	mov    0x58(%esp),%ecx

    method = makeword(src);
    extra_field_crc = makelong(src+2);

    /* compressed extra field exists completely in memory at this location: */
    G.inptr = (uch *)src + (2 + 4);     /* method and extra_field_crc */
      74:	89 9d e8 08 01 00    	mov    %ebx,0x108e8(%ebp)
    G.incnt = (int)(G.csize = (long)(srcsize - (2 + 4)));
      7a:	89 85 90 00 00 00    	mov    %eax,0x90(%ebp)
      80:	89 85 ec 08 01 00    	mov    %eax,0x108ec(%ebp)
    G.mem_mode = TRUE;
      86:	c7 85 a0 09 01 00 01 	movl   $0x1,0x109a0(%ebp)
      8d:	00 00 00 
    G.outbufptr = tgt;
      90:	89 95 a4 09 01 00    	mov    %edx,0x109a4(%ebp)
    G.outsize = tgtsize;
      96:	89 8d a8 09 01 00    	mov    %ecx,0x109a8(%ebp)

    switch (method) {
      9c:	66 85 f6             	test   %si,%si
      9f:	0f 84 eb 00 00 00    	je     190 <_memextract+0x170>
      a5:	8d 46 f8             	lea    -0x8(%esi),%eax
      a8:	66 83 f8 01          	cmp    $0x1,%ax
      ac:	76 42                	jbe    f0 <_memextract+0xd0>
            }
            if (G.outcnt == 0L)   /* inflate's final FLUSH sets outcnt */
                break;
            break;
        default:
            if (uO.tflag)
      ae:	8b 4d 44             	mov    0x44(%ebp),%ecx
      b1:	85 c9                	test   %ecx,%ecx
      b3:	0f 84 b7 01 00 00    	je     270 <_memextract+0x250>
                error = PK_ERR | ((int)method << 8);
      b9:	31 c0                	xor    %eax,%eax
      bb:	66 89 f0             	mov    %si,%ax
      be:	c1 e0 08             	shl    $0x8,%eax
      c1:	83 c8 02             	or     $0x2,%eax
                error = PK_ERR;  /* GRR:  should be passed on up via SetEAs() */
            }
            break;
    }

    G.inptr = old_inptr;
      c4:	89 bd e8 08 01 00    	mov    %edi,0x108e8(%ebp)
    G.incnt = old_incnt;
    G.csize = old_csize;
      ca:	8b 54 24 24          	mov    0x24(%esp),%edx
            }
            break;
    }

    G.inptr = old_inptr;
    G.incnt = old_incnt;
      ce:	8b 7c 24 28          	mov    0x28(%esp),%edi
    G.csize = old_csize;
      d2:	89 95 90 00 00 00    	mov    %edx,0x90(%ebp)
            }
            break;
    }

    G.inptr = old_inptr;
    G.incnt = old_incnt;
      d8:	89 bd ec 08 01 00    	mov    %edi,0x108ec(%ebp)
    G.csize = old_csize;
    G.mem_mode = FALSE;
      de:	c7 85 a0 09 01 00 00 	movl   $0x0,0x109a0(%ebp)
      e5:	00 00 00 
            }
        }
    }
    return error;

} /* end function memextract() */
      e8:	83 c4 3c             	add    $0x3c,%esp
      eb:	5b                   	pop    %ebx
      ec:	5e                   	pop    %esi
      ed:	5f                   	pop    %edi
      ee:	5d                   	pop    %ebp
      ef:	c3                   	ret    
        case DEFLATED:
#ifdef USE_DEFLATE64
        case ENHDEFLATED:
#endif
            G.outcnt = 0L;
            if ((r = UZinflate(__G__ (method == ENHDEFLATED))) != 0) {
      f0:	31 c0                	xor    %eax,%eax
            break;
        case DEFLATED:
#ifdef USE_DEFLATE64
        case ENHDEFLATED:
#endif
            G.outcnt = 0L;
      f2:	c7 85 dc 09 01 00 00 	movl   $0x0,0x109dc(%ebp)
      f9:	00 00 00 
            if ((r = UZinflate(__G__ (method == ENHDEFLATED))) != 0) {
      fc:	66 83 fe 09          	cmp    $0x9,%si
     100:	89 2c 24             	mov    %ebp,(%esp)
     103:	0f 94 c0             	sete   %al
     106:	89 44 24 04          	mov    %eax,0x4(%esp)
     10a:	e8 00 00 00 00       	call   10f <_memextract+0xef>
     10f:	89 c3                	mov    %eax,%ebx
     111:	85 c0                	test   %eax,%eax
     113:	0f 84 3f 01 00 00    	je     258 <_memextract+0x238>
                if (!uO.tflag)
     119:	8b 75 44             	mov    0x44(%ebp),%esi
     11c:	85 f6                	test   %esi,%esi
     11e:	75 56                	jne    176 <_memextract+0x156>
                    Info(slide, 0x401, ((char *)slide,
     120:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
     126:	b9 40 05 00 00       	mov    $0x540,%ecx
     12b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
     12f:	b8 5c 05 00 00       	mov    $0x55c,%eax
     134:	83 fb 03             	cmp    $0x3,%ebx
     137:	8d b5 dc 08 00 00    	lea    0x8dc(%ebp),%esi
     13d:	0f 45 c1             	cmovne %ecx,%eax
     140:	c7 44 24 0c 38 05 00 	movl   $0x538,0xc(%esp)
     147:	00 
     148:	89 44 24 08          	mov    %eax,0x8(%esp)
     14c:	c7 44 24 04 74 05 00 	movl   $0x574,0x4(%esp)
     153:	00 
     154:	89 34 24             	mov    %esi,(%esp)
     157:	e8 00 00 00 00       	call   15c <_memextract+0x13c>
     15c:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     163:	00 
     164:	89 44 24 08          	mov    %eax,0x8(%esp)
     168:	89 74 24 04          	mov    %esi,0x4(%esp)
     16c:	89 2c 24             	mov    %ebp,(%esp)
     16f:	ff 54 24 2c          	call   *0x2c(%esp)
     173:	83 ec 10             	sub    $0x10,%esp
                      LoadFarStringSmall(ErrUnzipNoFile), r == 3?
                      LoadFarString(NotEnoughMem) :
                      LoadFarString(InvalidComprData),
                      LoadFarStringSmall2(Inflate)));
                error = (r == 3)? PK_MEM3 : PK_ERR;
     176:	31 c0                	xor    %eax,%eax
     178:	83 fb 03             	cmp    $0x3,%ebx
     17b:	0f 94 c0             	sete   %al
     17e:	8d 04 85 02 00 00 00 	lea    0x2(,%eax,4),%eax
     185:	e9 3a ff ff ff       	jmp    c4 <_memextract+0xa4>
     18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    G.outbufptr = tgt;
    G.outsize = tgtsize;

    switch (method) {
        case STORED:
            memcpy((char *)tgt, (char *)G.inptr, (extent)G.incnt);
     190:	89 44 24 08          	mov    %eax,0x8(%esp)
     194:	8b 44 24 54          	mov    0x54(%esp),%eax
     198:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     19c:	89 04 24             	mov    %eax,(%esp)
     19f:	e8 00 00 00 00       	call   1a4 <_memextract+0x184>
            G.outcnt = G.csize;   /* for CRC calculation */
     1a4:	8b 85 90 00 00 00    	mov    0x90(%ebp),%eax
     1aa:	89 85 dc 09 01 00    	mov    %eax,0x109dc(%ebp)
                error = PK_ERR;  /* GRR:  should be passed on up via SetEAs() */
            }
            break;
    }

    G.inptr = old_inptr;
     1b0:	89 bd e8 08 01 00    	mov    %edi,0x108e8(%ebp)
    G.incnt = old_incnt;
    G.csize = old_csize;
     1b6:	8b 54 24 24          	mov    0x24(%esp),%edx
            }
            break;
    }

    G.inptr = old_inptr;
    G.incnt = old_incnt;
     1ba:	8b 7c 24 28          	mov    0x28(%esp),%edi
    G.csize = old_csize;
     1be:	89 95 90 00 00 00    	mov    %edx,0x90(%ebp)
            }
            break;
    }

    G.inptr = old_inptr;
    G.incnt = old_incnt;
     1c4:	89 bd ec 08 01 00    	mov    %edi,0x108ec(%ebp)
    G.csize = old_csize;
    G.mem_mode = FALSE;
     1ca:	c7 85 a0 09 01 00 00 	movl   $0x0,0x109a0(%ebp)
     1d1:	00 00 00 

    if (!error) {
        register ulg crcval = crc32(CRCVAL_INITIAL, tgt, (extent)G.outcnt);
     1d4:	89 44 24 08          	mov    %eax,0x8(%esp)
     1d8:	8b 44 24 54          	mov    0x54(%esp),%eax
     1dc:	89 44 24 04          	mov    %eax,0x4(%esp)
     1e0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     1e7:	e8 00 00 00 00       	call   1ec <_memextract+0x1cc>
     1ec:	89 c1                	mov    %eax,%ecx

        if (crcval != extra_field_crc) {
     1ee:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
     1f2:	74 6f                	je     263 <_memextract+0x243>
            if (uO.tflag)
     1f4:	8b 55 44             	mov    0x44(%ebp),%edx
                error = PK_ERR | (DEFLATED << 8);  /* kludge for now */
     1f7:	b8 02 08 00 00       	mov    $0x802,%eax

    if (!error) {
        register ulg crcval = crc32(CRCVAL_INITIAL, tgt, (extent)G.outcnt);

        if (crcval != extra_field_crc) {
            if (uO.tflag)
     1fc:	85 d2                	test   %edx,%edx
     1fe:	0f 85 e4 fe ff ff    	jne    e8 <_memextract+0xc8>
                error = PK_ERR | (DEFLATED << 8);  /* kludge for now */
            else {
                Info(slide, 0x401, ((char *)slide,
     204:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     208:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
     20e:	89 44 24 10          	mov    %eax,0x10(%esp)
     212:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     216:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
     21c:	8d b5 dc 08 00 00    	lea    0x8dc(%ebp),%esi
     222:	89 44 24 08          	mov    %eax,0x8(%esp)
     226:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
     22d:	00 
     22e:	89 34 24             	mov    %esi,(%esp)
     231:	e8 00 00 00 00       	call   236 <_memextract+0x216>
     236:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     23d:	00 
     23e:	89 44 24 08          	mov    %eax,0x8(%esp)
     242:	89 74 24 04          	mov    %esi,0x4(%esp)
     246:	89 2c 24             	mov    %ebp,(%esp)
     249:	ff d3                	call   *%ebx
                  LoadFarString(BadExtraFieldCRC), G.zipfn, crcval,
                  extra_field_crc));
                error = PK_ERR;
     24b:	b8 02 00 00 00       	mov    $0x2,%eax

        if (crcval != extra_field_crc) {
            if (uO.tflag)
                error = PK_ERR | (DEFLATED << 8);  /* kludge for now */
            else {
                Info(slide, 0x401, ((char *)slide,
     250:	83 ec 10             	sub    $0x10,%esp
     253:	e9 90 fe ff ff       	jmp    e8 <_memextract+0xc8>
     258:	8b 85 dc 09 01 00    	mov    0x109dc(%ebp),%eax
     25e:	e9 4d ff ff ff       	jmp    1b0 <_memextract+0x190>
     263:	31 c0                	xor    %eax,%eax
     265:	e9 7e fe ff ff       	jmp    e8 <_memextract+0xc8>
     26a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            break;
        default:
            if (uO.tflag)
                error = PK_ERR | ((int)method << 8);
            else {
                Info(slide, 0x401, ((char *)slide,
     270:	31 c9                	xor    %ecx,%ecx
     272:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
     278:	66 89 f1             	mov    %si,%cx
     27b:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
     281:	89 4c 24 08          	mov    %ecx,0x8(%esp)
     285:	c7 44 24 04 c0 02 00 	movl   $0x2c0,0x4(%esp)
     28c:	00 
     28d:	89 1c 24             	mov    %ebx,(%esp)
     290:	89 44 24 2c          	mov    %eax,0x2c(%esp)
     294:	e8 00 00 00 00       	call   299 <_memextract+0x279>
     299:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     2a0:	00 
     2a1:	89 44 24 08          	mov    %eax,0x8(%esp)
     2a5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     2a9:	89 2c 24             	mov    %ebp,(%esp)
     2ac:	ff 54 24 2c          	call   *0x2c(%esp)
                  LoadFarString(UnsupportedExtraField), method));
                error = PK_ERR;  /* GRR:  should be passed on up via SetEAs() */
     2b0:	b8 02 00 00 00       	mov    $0x2,%eax
            break;
        default:
            if (uO.tflag)
                error = PK_ERR | ((int)method << 8);
            else {
                Info(slide, 0x401, ((char *)slide,
     2b5:	83 ec 10             	sub    $0x10,%esp
     2b8:	e9 07 fe ff ff       	jmp    c4 <_memextract+0xa4>
     2bd:	8d 76 00             	lea    0x0(%esi),%esi

000002c0 <_test_compr_eb.part.0>:
/******************************/
/*  Function test_compr_eb()  */
/******************************/

#ifdef PROTO
static int test_compr_eb(
     2c0:	55                   	push   %ebp
     2c1:	57                   	push   %edi
     2c2:	56                   	push   %esi
     2c3:	53                   	push   %ebx
     2c4:	83 ec 3c             	sub    $0x3c,%esp
     2c7:	89 c5                	mov    %eax,%ebp

    if (compr_offset < 4)                /* field is not compressed: */
        return PK_OK;                    /* do nothing and signal OK */

    if ((eb_size < (EB_UCSIZE_P + 4)) ||
        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) > 0L &&
     2c9:	8d 42 04             	lea    0x4(%edx),%eax
/******************************/
/*  Function test_compr_eb()  */
/******************************/

#ifdef PROTO
static int test_compr_eb(
     2cc:	89 d6                	mov    %edx,%esi
    int r;

    if (compr_offset < 4)                /* field is not compressed: */
        return PK_OK;                    /* do nothing and signal OK */

    if ((eb_size < (EB_UCSIZE_P + 4)) ||
     2ce:	89 04 24             	mov    %eax,(%esp)
/******************************/
/*  Function test_compr_eb()  */
/******************************/

#ifdef PROTO
static int test_compr_eb(
     2d1:	89 cf                	mov    %ecx,%edi
    int r;

    if (compr_offset < 4)                /* field is not compressed: */
        return PK_OK;                    /* do nothing and signal OK */

    if ((eb_size < (EB_UCSIZE_P + 4)) ||
     2d3:	e8 00 00 00 00       	call   2d8 <_test_compr_eb.part.0+0x18>
     2d8:	89 c3                	mov    %eax,%ebx
     2da:	85 c0                	test   %eax,%eax
     2dc:	74 18                	je     2f6 <_test_compr_eb.part.0+0x36>
        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) > 0L &&
         eb_size <= (compr_offset + EB_CMPRHEADLEN)))
     2de:	8b 44 24 50          	mov    0x50(%esp),%eax
     2e2:	8d 48 06             	lea    0x6(%eax),%ecx
        return IZ_EF_TRUNC;               /* no compressed data! */
     2e5:	b8 4f 00 00 00       	mov    $0x4f,%eax

    if (compr_offset < 4)                /* field is not compressed: */
        return PK_OK;                    /* do nothing and signal OK */

    if ((eb_size < (EB_UCSIZE_P + 4)) ||
        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) > 0L &&
     2ea:	39 f9                	cmp    %edi,%ecx
     2ec:	72 08                	jb     2f6 <_test_compr_eb.part.0+0x36>
        r = (*test_uc_ebdata)(__G__ eb, eb_size, eb_ucptr, eb_ucsize);

    free(eb_ucptr);
    return r;

} /* end function test_compr_eb() */
     2ee:	83 c4 3c             	add    $0x3c,%esp
     2f1:	5b                   	pop    %ebx
     2f2:	5e                   	pop    %esi
     2f3:	5f                   	pop    %edi
     2f4:	5d                   	pop    %ebp
     2f5:	c3                   	ret    
    if ((eb_size < (EB_UCSIZE_P + 4)) ||
        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) > 0L &&
         eb_size <= (compr_offset + EB_CMPRHEADLEN)))
        return IZ_EF_TRUNC;               /* no compressed data! */

    if (
     2f6:	89 1c 24             	mov    %ebx,(%esp)
     2f9:	e8 00 00 00 00       	call   2fe <_test_compr_eb.part.0+0x3e>
     2fe:	89 c1                	mov    %eax,%ecx
#ifdef INT_16BIT
        (((ulg)(extent)eb_ucsize) != eb_ucsize) ||
#endif
        (eb_ucptr = (uch *)malloc((extent)eb_ucsize)) == (uch *)NULL)
        return PK_MEM4;
     300:	b8 07 00 00 00       	mov    $0x7,%eax
    if ((eb_size < (EB_UCSIZE_P + 4)) ||
        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) > 0L &&
         eb_size <= (compr_offset + EB_CMPRHEADLEN)))
        return IZ_EF_TRUNC;               /* no compressed data! */

    if (
     305:	85 c9                	test   %ecx,%ecx
     307:	74 e5                	je     2ee <_test_compr_eb.part.0+0x2e>
        (eb_ucptr = (uch *)malloc((extent)eb_ucsize)) == (uch *)NULL)
        return PK_MEM4;

    r = memextract(__G__ eb_ucptr, eb_ucsize,
                   eb + (EB_HEADSIZE + compr_offset),
                   (ulg)(eb_size - compr_offset));
     309:	8b 54 24 50          	mov    0x50(%esp),%edx
     30d:	89 f8                	mov    %edi,%eax
     30f:	29 d0                	sub    %edx,%eax
        (((ulg)(extent)eb_ucsize) != eb_ucsize) ||
#endif
        (eb_ucptr = (uch *)malloc((extent)eb_ucsize)) == (uch *)NULL)
        return PK_MEM4;

    r = memextract(__G__ eb_ucptr, eb_ucsize,
     311:	89 4c 24 04          	mov    %ecx,0x4(%esp)
     315:	89 44 24 10          	mov    %eax,0x10(%esp)
     319:	8b 44 24 50          	mov    0x50(%esp),%eax
     31d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     321:	89 2c 24             	mov    %ebp,(%esp)
     324:	8d 44 06 04          	lea    0x4(%esi,%eax,1),%eax
     328:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
     32c:	89 44 24 0c          	mov    %eax,0xc(%esp)
     330:	e8 eb fc ff ff       	call   20 <_memextract>
                   eb + (EB_HEADSIZE + compr_offset),
                   (ulg)(eb_size - compr_offset));

    if (r == PK_OK && test_uc_ebdata != NULL)
     335:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
     339:	85 c0                	test   %eax,%eax
     33b:	75 23                	jne    360 <_test_compr_eb.part.0+0xa0>
     33d:	8b 54 24 54          	mov    0x54(%esp),%edx
     341:	85 d2                	test   %edx,%edx
     343:	74 1b                	je     360 <_test_compr_eb.part.0+0xa0>
        r = (*test_uc_ebdata)(__G__ eb, eb_size, eb_ucptr, eb_ucsize);
     345:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     349:	89 5c 24 10          	mov    %ebx,0x10(%esp)
     34d:	89 7c 24 08          	mov    %edi,0x8(%esp)
     351:	89 74 24 04          	mov    %esi,0x4(%esp)
     355:	89 2c 24             	mov    %ebp,(%esp)
     358:	ff 54 24 54          	call   *0x54(%esp)
     35c:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx

    free(eb_ucptr);
     360:	89 0c 24             	mov    %ecx,(%esp)
     363:	89 44 24 2c          	mov    %eax,0x2c(%esp)
     367:	e8 00 00 00 00       	call   36c <_test_compr_eb.part.0+0xac>
    return r;
     36c:	8b 44 24 2c          	mov    0x2c(%esp),%eax

} /* end function test_compr_eb() */
     370:	83 c4 3c             	add    $0x3c,%esp
     373:	5b                   	pop    %ebx
     374:	5e                   	pop    %esi
     375:	5f                   	pop    %edi
     376:	5d                   	pop    %ebp
     377:	c3                   	ret    
     378:	90                   	nop
     379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000380 <_memflush>:

int memflush(__G__ rawbuf, size)
    __GDEF
    ZCONST uch *rawbuf;
    ulg size;
{
     380:	56                   	push   %esi
     381:	53                   	push   %ebx
     382:	83 ec 14             	sub    $0x14,%esp
    if (size > G.outsize)
        /* Here, PK_DISK is a bit off-topic, but in the sense of marking
           "overflow of output space", its use may be tolerated. */
        return PK_DISK;   /* more data than output buffer can hold */
     385:	b8 32 00 00 00       	mov    $0x32,%eax

int memflush(__G__ rawbuf, size)
    __GDEF
    ZCONST uch *rawbuf;
    ulg size;
{
     38a:	8b 5c 24 20          	mov    0x20(%esp),%ebx
     38e:	8b 74 24 28          	mov    0x28(%esp),%esi
    if (size > G.outsize)
     392:	39 b3 a8 09 01 00    	cmp    %esi,0x109a8(%ebx)
     398:	73 06                	jae    3a0 <_memflush+0x20>
    G.outsize -= size;
    G.outcnt += size;

    return 0;

} /* end function memflush() */
     39a:	83 c4 14             	add    $0x14,%esp
     39d:	5b                   	pop    %ebx
     39e:	5e                   	pop    %esi
     39f:	c3                   	ret    
           "overflow of output space", its use may be tolerated. */
        return PK_DISK;   /* more data than output buffer can hold */



    memcpy((char *)G.outbufptr, (char *)rawbuf, (extent)size);
     3a0:	8b 83 a4 09 01 00    	mov    0x109a4(%ebx),%eax
     3a6:	8b 54 24 24          	mov    0x24(%esp),%edx
     3aa:	89 74 24 08          	mov    %esi,0x8(%esp)
     3ae:	89 54 24 04          	mov    %edx,0x4(%esp)
     3b2:	89 04 24             	mov    %eax,(%esp)
     3b5:	e8 00 00 00 00       	call   3ba <_memflush+0x3a>
    G.outbufptr += (unsigned int)size;
     3ba:	8b 83 a4 09 01 00    	mov    0x109a4(%ebx),%eax
    G.outsize -= size;
     3c0:	8b 93 a8 09 01 00    	mov    0x109a8(%ebx),%edx
    G.outcnt += size;
     3c6:	8b 8b dc 09 01 00    	mov    0x109dc(%ebx),%ecx
        return PK_DISK;   /* more data than output buffer can hold */



    memcpy((char *)G.outbufptr, (char *)rawbuf, (extent)size);
    G.outbufptr += (unsigned int)size;
     3cc:	01 f0                	add    %esi,%eax
    G.outsize -= size;
     3ce:	29 f2                	sub    %esi,%edx
    G.outcnt += size;
     3d0:	01 f1                	add    %esi,%ecx
        return PK_DISK;   /* more data than output buffer can hold */



    memcpy((char *)G.outbufptr, (char *)rawbuf, (extent)size);
    G.outbufptr += (unsigned int)size;
     3d2:	89 83 a4 09 01 00    	mov    %eax,0x109a4(%ebx)
    G.outsize -= size;
     3d8:	89 93 a8 09 01 00    	mov    %edx,0x109a8(%ebx)
    G.outcnt += size;
     3de:	89 8b dc 09 01 00    	mov    %ecx,0x109dc(%ebx)

    return 0;

} /* end function memflush() */
     3e4:	83 c4 14             	add    $0x14,%esp
    memcpy((char *)G.outbufptr, (char *)rawbuf, (extent)size);
    G.outbufptr += (unsigned int)size;
    G.outsize -= size;
    G.outcnt += size;

    return 0;
     3e7:	31 c0                	xor    %eax,%eax

} /* end function memflush() */
     3e9:	5b                   	pop    %ebx
     3ea:	5e                   	pop    %esi
     3eb:	c3                   	ret    
     3ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000003f0 <_extract_izvms_block>:
    ZCONST uch *ebdata;
    unsigned size;
    unsigned *retlen;
    ZCONST uch *init;
    unsigned needlen;
{
     3f0:	55                   	push   %ebp
     3f1:	57                   	push   %edi
     3f2:	56                   	push   %esi
     3f3:	53                   	push   %ebx
     3f4:	83 ec 2c             	sub    $0x2c,%esp
    uch *ucdata;       /* Pointer to block allocated */
    int cmptype;
    unsigned usiz, csiz;

    cmptype = (makeword(ebdata+EB_IZVMS_FLGS) & EB_IZVMS_BCMASK);
     3f7:	8b 44 24 44          	mov    0x44(%esp),%eax
    ZCONST uch *ebdata;
    unsigned size;
    unsigned *retlen;
    ZCONST uch *init;
    unsigned needlen;
{
     3fb:	8b 6c 24 4c          	mov    0x4c(%esp),%ebp
    uch *ucdata;       /* Pointer to block allocated */
    int cmptype;
    unsigned usiz, csiz;

    cmptype = (makeword(ebdata+EB_IZVMS_FLGS) & EB_IZVMS_BCMASK);
     3ff:	83 c0 04             	add    $0x4,%eax
     402:	89 04 24             	mov    %eax,(%esp)
     405:	e8 00 00 00 00       	call   40a <_extract_izvms_block+0x1a>
    csiz = size - EB_IZVMS_HLEN;
     40a:	8b 74 24 48          	mov    0x48(%esp),%esi
     40e:	83 ee 0c             	sub    $0xc,%esi
    usiz = (cmptype == EB_IZVMS_BCSTOR ?
            csiz : makeword(ebdata+EB_IZVMS_UCSIZ));
     411:	83 e0 07             	and    $0x7,%eax
     414:	89 f7                	mov    %esi,%edi
     416:	89 c3                	mov    %eax,%ebx
     418:	0f 85 f3 00 00 00    	jne    511 <_extract_izvms_block+0x121>

    if (retlen)
     41e:	85 ed                	test   %ebp,%ebp
     420:	74 03                	je     425 <_extract_izvms_block+0x35>
        *retlen = usiz;
     422:	89 7d 00             	mov    %edi,0x0(%ebp)

    if ((ucdata = (uch *)malloc(MAX(needlen, usiz))) == NULL)
     425:	89 f8                	mov    %edi,%eax
     427:	3b 7c 24 54          	cmp    0x54(%esp),%edi
     42b:	0f 42 44 24 54       	cmovb  0x54(%esp),%eax
     430:	89 04 24             	mov    %eax,(%esp)
     433:	e8 00 00 00 00       	call   438 <_extract_izvms_block+0x48>
     438:	89 c5                	mov    %eax,%ebp
     43a:	85 c0                	test   %eax,%eax
     43c:	0f 84 24 01 00 00    	je     566 <_extract_izvms_block+0x176>
        return NULL;

    if (init && (usiz < needlen))
     442:	3b 7c 24 54          	cmp    0x54(%esp),%edi
     446:	73 08                	jae    450 <_extract_izvms_block+0x60>
     448:	8b 44 24 50          	mov    0x50(%esp),%eax
     44c:	85 c0                	test   %eax,%eax
     44e:	75 43                	jne    493 <_extract_izvms_block+0xa3>
        memcpy((char *)ucdata, (ZCONST char *)init, needlen);

    switch (cmptype)
     450:	66 83 fb 01          	cmp    $0x1,%bx
     454:	74 5b                	je     4b1 <_extract_izvms_block+0xc1>
     456:	0f 82 94 00 00 00    	jb     4f0 <_extract_izvms_block+0x100>
     45c:	66 83 fb 02          	cmp    $0x2,%bx
     460:	0f 85 ca 00 00 00    	jne    530 <_extract_izvms_block+0x140>
            break;
        case EB_IZVMS_BC00:
            decompress_bits(ucdata, usiz, ebdata+EB_IZVMS_HLEN);
            break;
        case EB_IZVMS_BCDEFL:
            memextract(__G__ ucdata, (ulg)usiz,
     466:	8b 44 24 44          	mov    0x44(%esp),%eax
     46a:	89 74 24 10          	mov    %esi,0x10(%esp)
     46e:	83 c0 0c             	add    $0xc,%eax
     471:	89 7c 24 08          	mov    %edi,0x8(%esp)
     475:	89 44 24 0c          	mov    %eax,0xc(%esp)
     479:	8b 44 24 40          	mov    0x40(%esp),%eax
     47d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     481:	89 04 24             	mov    %eax,(%esp)
     484:	e8 97 fb ff ff       	call   20 <_memextract>
                       ebdata+EB_IZVMS_HLEN, (ulg)csiz);
            break;
     489:	89 e8                	mov    %ebp,%eax
            free(ucdata);
            ucdata = NULL;
    }
    return ucdata;

} /* end of extract_izvms_block */
     48b:	83 c4 2c             	add    $0x2c,%esp
     48e:	5b                   	pop    %ebx
     48f:	5e                   	pop    %esi
     490:	5f                   	pop    %edi
     491:	5d                   	pop    %ebp
     492:	c3                   	ret    

    if ((ucdata = (uch *)malloc(MAX(needlen, usiz))) == NULL)
        return NULL;

    if (init && (usiz < needlen))
        memcpy((char *)ucdata, (ZCONST char *)init, needlen);
     493:	8b 44 24 54          	mov    0x54(%esp),%eax
     497:	89 2c 24             	mov    %ebp,(%esp)
     49a:	89 44 24 08          	mov    %eax,0x8(%esp)
     49e:	8b 44 24 50          	mov    0x50(%esp),%eax
     4a2:	89 44 24 04          	mov    %eax,0x4(%esp)
     4a6:	e8 00 00 00 00       	call   4ab <_extract_izvms_block+0xbb>

    switch (cmptype)
     4ab:	66 83 fb 01          	cmp    $0x1,%bx
     4af:	75 a5                	jne    456 <_extract_izvms_block+0x66>
    {
        case EB_IZVMS_BCSTOR: /* The simplest case */
            memcpy(ucdata, ebdata+EB_IZVMS_HLEN, usiz);
            break;
        case EB_IZVMS_BC00:
            decompress_bits(ucdata, usiz, ebdata+EB_IZVMS_HLEN);
     4b1:	8b 44 24 44          	mov    0x44(%esp),%eax
     4b5:	8d 55 01             	lea    0x1(%ebp),%edx
     4b8:	8d 5c 3d 01          	lea    0x1(%ebp,%edi,1),%ebx
    uch *outptr;        /* Pointer into output block */
    unsigned needlen;   /* Size of uncompressed block */
    ZCONST uch *bitptr; /* Pointer into compressed data */
{
    ulg bitbuf = 0;
    int bitcnt = 0;
     4bc:	31 c9                	xor    %ecx,%ecx
    {
        case EB_IZVMS_BCSTOR: /* The simplest case */
            memcpy(ucdata, ebdata+EB_IZVMS_HLEN, usiz);
            break;
        case EB_IZVMS_BC00:
            decompress_bits(ucdata, usiz, ebdata+EB_IZVMS_HLEN);
     4be:	8d 70 0c             	lea    0xc(%eax),%esi
static void decompress_bits(outptr, needlen, bitptr)
    uch *outptr;        /* Pointer into output block */
    unsigned needlen;   /* Size of uncompressed block */
    ZCONST uch *bitptr; /* Pointer into compressed data */
{
    ulg bitbuf = 0;
     4c1:	31 c0                	xor    %eax,%eax

#define _FILL   {       bitbuf |= (*bitptr++) << bitcnt;\
                        bitcnt += 8;                    \
                }

    while (needlen--)
     4c3:	39 da                	cmp    %ebx,%edx
     4c5:	74 c2                	je     489 <_extract_izvms_block+0x99>
    {
        if (bitcnt <= 0)
     4c7:	85 c9                	test   %ecx,%ecx
     4c9:	0f 8e 81 00 00 00    	jle    550 <_extract_izvms_block+0x160>
            _FILL;

        if (bitbuf & 1)
     4cf:	a8 01                	test   $0x1,%al
     4d1:	74 6f                	je     542 <_extract_izvms_block+0x152>
        {
            bitbuf >>= 1;
            if ((bitcnt -= 1) < 8)
                _FILL;
     4d3:	0f b6 3e             	movzbl (%esi),%edi
            _FILL;

        if (bitbuf & 1)
        {
            bitbuf >>= 1;
            if ((bitcnt -= 1) < 8)
     4d6:	49                   	dec    %ecx
                _FILL;
     4d7:	81 e7 ff 00 00 00    	and    $0xff,%edi
        if (bitcnt <= 0)
            _FILL;

        if (bitbuf & 1)
        {
            bitbuf >>= 1;
     4dd:	d1 e8                	shr    %eax
            if ((bitcnt -= 1) < 8)
                _FILL;
            *outptr++ = (uch)bitbuf;
            bitcnt -= 8;
            bitbuf >>= 8;
     4df:	46                   	inc    %esi

        if (bitbuf & 1)
        {
            bitbuf >>= 1;
            if ((bitcnt -= 1) < 8)
                _FILL;
     4e0:	d3 e7                	shl    %cl,%edi
     4e2:	09 f8                	or     %edi,%eax
     4e4:	42                   	inc    %edx
            *outptr++ = (uch)bitbuf;
     4e5:	88 42 fe             	mov    %al,-0x2(%edx)
            bitcnt -= 8;
            bitbuf >>= 8;
     4e8:	c1 e8 08             	shr    $0x8,%eax
     4eb:	eb d6                	jmp    4c3 <_extract_izvms_block+0xd3>
     4ed:	8d 76 00             	lea    0x0(%esi),%esi
        memcpy((char *)ucdata, (ZCONST char *)init, needlen);

    switch (cmptype)
    {
        case EB_IZVMS_BCSTOR: /* The simplest case */
            memcpy(ucdata, ebdata+EB_IZVMS_HLEN, usiz);
     4f0:	8b 44 24 44          	mov    0x44(%esp),%eax
     4f4:	89 7c 24 08          	mov    %edi,0x8(%esp)
     4f8:	83 c0 0c             	add    $0xc,%eax
     4fb:	89 2c 24             	mov    %ebp,(%esp)
     4fe:	89 44 24 04          	mov    %eax,0x4(%esp)
     502:	e8 00 00 00 00       	call   507 <_extract_izvms_block+0x117>
            free(ucdata);
            ucdata = NULL;
    }
    return ucdata;

} /* end of extract_izvms_block */
     507:	83 c4 2c             	add    $0x2c,%esp

    switch (cmptype)
    {
        case EB_IZVMS_BCSTOR: /* The simplest case */
            memcpy(ucdata, ebdata+EB_IZVMS_HLEN, usiz);
            break;
     50a:	89 e8                	mov    %ebp,%eax
            free(ucdata);
            ucdata = NULL;
    }
    return ucdata;

} /* end of extract_izvms_block */
     50c:	5b                   	pop    %ebx
     50d:	5e                   	pop    %esi
     50e:	5f                   	pop    %edi
     50f:	5d                   	pop    %ebp
     510:	c3                   	ret    
    unsigned usiz, csiz;

    cmptype = (makeword(ebdata+EB_IZVMS_FLGS) & EB_IZVMS_BCMASK);
    csiz = size - EB_IZVMS_HLEN;
    usiz = (cmptype == EB_IZVMS_BCSTOR ?
            csiz : makeword(ebdata+EB_IZVMS_UCSIZ));
     511:	8b 44 24 44          	mov    0x44(%esp),%eax
     515:	31 ff                	xor    %edi,%edi
     517:	83 c0 06             	add    $0x6,%eax
     51a:	89 04 24             	mov    %eax,(%esp)
     51d:	e8 00 00 00 00       	call   522 <_extract_izvms_block+0x132>
     522:	66 89 c7             	mov    %ax,%di
     525:	e9 f4 fe ff ff       	jmp    41e <_extract_izvms_block+0x2e>
     52a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        case EB_IZVMS_BCDEFL:
            memextract(__G__ ucdata, (ulg)usiz,
                       ebdata+EB_IZVMS_HLEN, (ulg)csiz);
            break;
        default:
            free(ucdata);
     530:	89 2c 24             	mov    %ebp,(%esp)
     533:	e8 00 00 00 00       	call   538 <_extract_izvms_block+0x148>
            ucdata = NULL;
    }
    return ucdata;

} /* end of extract_izvms_block */
     538:	83 c4 2c             	add    $0x2c,%esp
            memextract(__G__ ucdata, (ulg)usiz,
                       ebdata+EB_IZVMS_HLEN, (ulg)csiz);
            break;
        default:
            free(ucdata);
            ucdata = NULL;
     53b:	31 c0                	xor    %eax,%eax
    }
    return ucdata;

} /* end of extract_izvms_block */
     53d:	5b                   	pop    %ebx
     53e:	5e                   	pop    %esi
     53f:	5f                   	pop    %edi
     540:	5d                   	pop    %ebp
     541:	c3                   	ret    
            bitcnt -= 8;
            bitbuf >>= 8;
        }
        else
        {
            *outptr++ = '\0';
     542:	c6 42 ff 00          	movb   $0x0,-0x1(%edx)
            bitcnt -= 1;
     546:	49                   	dec    %ecx
            bitbuf >>= 1;
     547:	d1 e8                	shr    %eax
     549:	42                   	inc    %edx
     54a:	e9 74 ff ff ff       	jmp    4c3 <_extract_izvms_block+0xd3>
     54f:	90                   	nop
                }

    while (needlen--)
    {
        if (bitcnt <= 0)
            _FILL;
     550:	0f b6 3e             	movzbl (%esi),%edi
     553:	81 e7 ff 00 00 00    	and    $0xff,%edi
     559:	46                   	inc    %esi
     55a:	d3 e7                	shl    %cl,%edi
     55c:	09 f8                	or     %edi,%eax
     55e:	83 c1 08             	add    $0x8,%ecx
     561:	e9 69 ff ff ff       	jmp    4cf <_extract_izvms_block+0xdf>

    if (retlen)
        *retlen = usiz;

    if ((ucdata = (uch *)malloc(MAX(needlen, usiz))) == NULL)
        return NULL;
     566:	31 c0                	xor    %eax,%eax
     568:	e9 1e ff ff ff       	jmp    48b <_extract_izvms_block+0x9b>
     56d:	8d 76 00             	lea    0x0(%esi),%esi

00000570 <_fnfilter>:
/*************************/

char *fnfilter(raw, space)         /* convert name to safely printable form */
    ZCONST char *raw;
    uch *space;
{
     570:	57                   	push   %edi
     571:	56                   	push   %esi
     572:	53                   	push   %ebx
     573:	83 ec 10             	sub    $0x10,%esp
        if (*r < 32) {
            *s++ = '^', *s++ = (uch)(64 + *r++);
        } else {
#ifdef _MBCS
            unsigned i;
            for (i = CLEN(r); i > 0; i--)
     576:	8b 35 00 00 00 00    	mov    0x0,%esi
/*************************/

char *fnfilter(raw, space)         /* convert name to safely printable form */
    ZCONST char *raw;
    uch *space;
{
     57c:	8b 5c 24 20          	mov    0x20(%esp),%ebx
#ifndef NATIVE   /* ASCII:  filter ANSI escape codes, etc. */
    ZCONST uch *r=(ZCONST uch *)raw;
    uch *s=space;
     580:	8b 7c 24 24          	mov    0x24(%esp),%edi

    while (*r) {
     584:	8a 03                	mov    (%ebx),%al
     586:	84 c0                	test   %al,%al
     588:	74 1a                	je     5a4 <_fnfilter+0x34>
                *s++ = '_';
                continue;
            }
        } else
#endif
        if (*r < 32) {
     58a:	3c 1f                	cmp    $0x1f,%al
     58c:	77 24                	ja     5b2 <_fnfilter+0x42>
            *s++ = '^', *s++ = (uch)(64 + *r++);
     58e:	c6 07 5e             	movb   $0x5e,(%edi)
     591:	43                   	inc    %ebx
     592:	8a 43 ff             	mov    -0x1(%ebx),%al
     595:	83 c7 02             	add    $0x2,%edi
     598:	83 c0 40             	add    $0x40,%eax
     59b:	88 47 ff             	mov    %al,-0x1(%edi)
{
#ifndef NATIVE   /* ASCII:  filter ANSI escape codes, etc. */
    ZCONST uch *r=(ZCONST uch *)raw;
    uch *s=space;

    while (*r) {
     59e:	8a 03                	mov    (%ebx),%al
     5a0:	84 c0                	test   %al,%al
     5a2:	75 e6                	jne    58a <_fnfilter+0x1a>
#else
            *s++ = *r++;
#endif
         }
    }
    *s = '\0';
     5a4:	c6 07 00             	movb   $0x0,(%edi)

#else /* NATIVE:  EBCDIC or whatever */
    return (char *)raw;
#endif

} /* end function fnfilter() */
     5a7:	8b 44 24 24          	mov    0x24(%esp),%eax
     5ab:	83 c4 10             	add    $0x10,%esp
     5ae:	5b                   	pop    %ebx
     5af:	5e                   	pop    %esi
     5b0:	5f                   	pop    %edi
     5b1:	c3                   	ret    
        if (*r < 32) {
            *s++ = '^', *s++ = (uch)(64 + *r++);
        } else {
#ifdef _MBCS
            unsigned i;
            for (i = CLEN(r); i > 0; i--)
     5b2:	8b 06                	mov    (%esi),%eax
     5b4:	89 1c 24             	mov    %ebx,(%esp)
     5b7:	89 44 24 04          	mov    %eax,0x4(%esp)
     5bb:	e8 00 00 00 00       	call   5c0 <_fnfilter+0x50>
     5c0:	85 c0                	test   %eax,%eax
     5c2:	74 c0                	je     584 <_fnfilter+0x14>
     5c4:	31 d2                	xor    %edx,%edx
                *s++ = *r++;
     5c6:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
     5c9:	88 0c 17             	mov    %cl,(%edi,%edx,1)
     5cc:	42                   	inc    %edx
        if (*r < 32) {
            *s++ = '^', *s++ = (uch)(64 + *r++);
        } else {
#ifdef _MBCS
            unsigned i;
            for (i = CLEN(r); i > 0; i--)
     5cd:	39 d0                	cmp    %edx,%eax
     5cf:	75 f5                	jne    5c6 <_fnfilter+0x56>
     5d1:	01 c7                	add    %eax,%edi
     5d3:	01 c3                	add    %eax,%ebx
     5d5:	eb ad                	jmp    584 <_fnfilter+0x14>
     5d7:	89 f6                	mov    %esi,%esi
     5d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000005e0 <_store_info>:
/*  Function store_info()  */
/***************************/

static int store_info(__G)   /* return 0 if skipping, 1 if OK */
    __GDEF
{
     5e0:	55                   	push   %ebp
     5e1:	57                   	push   %edi
     5e2:	56                   	push   %esi
     5e3:	53                   	push   %ebx
     5e4:	83 ec 3c             	sub    $0x3c,%esp
     5e7:	89 c3                	mov    %eax,%ebx

/*---------------------------------------------------------------------------
    Check central directory info for version/compatibility requirements.
  ---------------------------------------------------------------------------*/

    G.pInfo->encrypted = G.crec.general_purpose_bit_flag & 1;   /* bit field */
     5e9:	8b 88 d8 08 00 00    	mov    0x8d8(%eax),%ecx
     5ef:	8a 80 40 09 01 00    	mov    0x10940(%eax),%al
     5f5:	83 e0 01             	and    $0x1,%eax
     5f8:	8a 51 18             	mov    0x18(%ecx),%dl
     5fb:	83 e2 fe             	and    $0xfffffffe,%edx
     5fe:	09 d0                	or     %edx,%eax
     600:	88 41 18             	mov    %al,0x18(%ecx)
    G.pInfo->ExtLocHdr = (G.crec.general_purpose_bit_flag & 8) == 8;  /* bit */
     603:	8b 8b d8 08 00 00    	mov    0x8d8(%ebx),%ecx
     609:	8b 83 40 09 01 00    	mov    0x10940(%ebx),%eax
     60f:	66 c1 e8 03          	shr    $0x3,%ax
     613:	8a 51 18             	mov    0x18(%ecx),%dl
     616:	83 e0 01             	and    $0x1,%eax
     619:	83 e2 fd             	and    $0xfffffffd,%edx
     61c:	01 c0                	add    %eax,%eax
     61e:	09 d0                	or     %edx,%eax
     620:	88 41 18             	mov    %al,0x18(%ecx)
    G.pInfo->textfile = G.crec.internal_file_attributes & 1;    /* bit field */
     623:	8b 8b d8 08 00 00    	mov    0x8d8(%ebx),%ecx
     629:	8a 83 5c 09 01 00    	mov    0x1095c(%ebx),%al
     62f:	83 e0 01             	and    $0x1,%eax
     632:	c1 e0 02             	shl    $0x2,%eax
     635:	8a 51 18             	mov    0x18(%ecx),%dl
     638:	83 e2 fb             	and    $0xfffffffb,%edx
     63b:	09 d0                	or     %edx,%eax
     63d:	88 41 18             	mov    %al,0x18(%ecx)
    G.pInfo->crc = G.crec.crc32;
     640:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
     646:	8b 93 48 09 01 00    	mov    0x10948(%ebx),%edx
     64c:	89 50 0c             	mov    %edx,0xc(%eax)
    G.pInfo->compr_size = G.crec.csize;
     64f:	8b 93 4c 09 01 00    	mov    0x1094c(%ebx),%edx
     655:	89 50 04             	mov    %edx,0x4(%eax)
    G.pInfo->uncompr_size = G.crec.ucsize;
     658:	8b 93 50 09 01 00    	mov    0x10950(%ebx),%edx
     65e:	89 50 08             	mov    %edx,0x8(%eax)

    switch (uO.aflag) {
     661:	8b 53 10             	mov    0x10(%ebx),%edx
     664:	85 d2                	test   %edx,%edx
     666:	0f 84 a8 01 00 00    	je     814 <_store_info+0x234>
     66c:	4a                   	dec    %edx
     66d:	74 33                	je     6a2 <_store_info+0xc2>
            break;
        case 1:
            G.pInfo->textmode = G.pInfo->textfile;   /* auto-convert mode */
            break;
        default:  /* case 2: */
            G.pInfo->textmode = TRUE;
     66f:	80 48 18 08          	orb    $0x8,0x18(%eax)
            break;
    }

    if (G.crec.version_needed_to_extract[1] == VMS_) {
     673:	80 bb 3f 09 01 00 02 	cmpb   $0x2,0x1093f(%ebx)
        if (G.crec.version_needed_to_extract[0] > VMS_UNZIP_VERSION) {
     67a:	8a 93 3e 09 01 00    	mov    0x1093e(%ebx),%dl
        default:  /* case 2: */
            G.pInfo->textmode = TRUE;
            break;
    }

    if (G.crec.version_needed_to_extract[1] == VMS_) {
     680:	74 43                	je     6c5 <_store_info+0xe5>
            if ((*G.answerbuf != 'y') && (*G.answerbuf != 'Y'))
                return 0;
        }
#endif /* !VMS */
    /* usual file type:  don't need VMS to extract */
    } else if (G.crec.version_needed_to_extract[0] > UNZIP_VERSION) {
     682:	80 fa 15             	cmp    $0x15,%dl
     685:	0f 86 d8 00 00 00    	jbe    763 <_store_info+0x183>
        if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2)))
     68b:	8b 73 38             	mov    0x38(%ebx),%esi
     68e:	85 f6                	test   %esi,%esi
     690:	0f 84 ef 02 00 00    	je     985 <_store_info+0x3a5>
                Info(slide, 0x401, ((char *)slide, LoadFarString(VersionMsg),
                  FnFilter1(G.filename), "VMS",
                  G.crec.version_needed_to_extract[0] / 10,
                  G.crec.version_needed_to_extract[0] % 10,
                  VMS_UNZIP_VERSION / 10, VMS_UNZIP_VERSION % 10));
            return 0;
     696:	31 f6                	xor    %esi,%esi

    G.pInfo->diskstart = G.crec.disk_number_start;
    G.pInfo->offset = (Z_OFF_T)G.crec.relative_offset_local_header;
    return 1;

} /* end function store_info() */
     698:	83 c4 3c             	add    $0x3c,%esp
     69b:	89 f0                	mov    %esi,%eax
     69d:	5b                   	pop    %ebx
     69e:	5e                   	pop    %esi
     69f:	5f                   	pop    %edi
     6a0:	5d                   	pop    %ebp
     6a1:	c3                   	ret    
    switch (uO.aflag) {
        case 0:
            G.pInfo->textmode = FALSE;   /* bit field */
            break;
        case 1:
            G.pInfo->textmode = G.pInfo->textfile;   /* auto-convert mode */
     6a2:	0f b6 78 18          	movzbl 0x18(%eax),%edi
     6a6:	89 f9                	mov    %edi,%ecx
     6a8:	8d 14 3f             	lea    (%edi,%edi,1),%edx
     6ab:	83 e1 f7             	and    $0xfffffff7,%ecx
     6ae:	83 e2 08             	and    $0x8,%edx
     6b1:	09 ca                	or     %ecx,%edx
     6b3:	88 50 18             	mov    %dl,0x18(%eax)
        default:  /* case 2: */
            G.pInfo->textmode = TRUE;
            break;
    }

    if (G.crec.version_needed_to_extract[1] == VMS_) {
     6b6:	80 bb 3f 09 01 00 02 	cmpb   $0x2,0x1093f(%ebx)
        if (G.crec.version_needed_to_extract[0] > VMS_UNZIP_VERSION) {
     6bd:	8a 93 3e 09 01 00    	mov    0x1093e(%ebx),%dl
        default:  /* case 2: */
            G.pInfo->textmode = TRUE;
            break;
    }

    if (G.crec.version_needed_to_extract[1] == VMS_) {
     6c3:	75 bd                	jne    682 <_store_info+0xa2>
        if (G.crec.version_needed_to_extract[0] > VMS_UNZIP_VERSION) {
     6c5:	80 fa 2a             	cmp    $0x2a,%dl
     6c8:	0f 87 b2 01 00 00    	ja     880 <_store_info+0x2a0>
                  G.crec.version_needed_to_extract[0] % 10,
                  VMS_UNZIP_VERSION / 10, VMS_UNZIP_VERSION % 10));
            return 0;
        }
#ifndef VMS   /* won't be able to use extra field, but still have data */
        else if (!uO.tflag && !IS_OVERWRT_ALL) { /* if -o, extract anyway */
     6ce:	8b 43 44             	mov    0x44(%ebx),%eax
     6d1:	85 c0                	test   %eax,%eax
     6d3:	0f 85 8a 00 00 00    	jne    763 <_store_info+0x183>
     6d9:	83 7b 78 01          	cmpl   $0x1,0x78(%ebx)
     6dd:	0f 84 80 00 00 00    	je     763 <_store_info+0x183>
            Info(slide, 0x481, ((char *)slide, LoadFarString(VMSFormatQuery),
     6e3:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     6e9:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     6ef:	89 44 24 04          	mov    %eax,0x4(%esp)
     6f3:	8d 83 e0 09 01 00    	lea    0x109e0(%ebx),%eax
     6f9:	89 04 24             	mov    %eax,(%esp)
     6fc:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     702:	e8 69 fe ff ff       	call   570 <_fnfilter>
     707:	c7 44 24 04 40 07 00 	movl   $0x740,0x4(%esp)
     70e:	00 
     70f:	89 44 24 08          	mov    %eax,0x8(%esp)
     713:	89 34 24             	mov    %esi,(%esp)
     716:	e8 00 00 00 00       	call   71b <_store_info+0x13b>
     71b:	c7 44 24 0c 81 04 00 	movl   $0x481,0xc(%esp)
     722:	00 
     723:	89 44 24 08          	mov    %eax,0x8(%esp)
     727:	89 74 24 04          	mov    %esi,0x4(%esp)
     72b:	89 1c 24             	mov    %ebx,(%esp)
     72e:	ff d7                	call   *%edi
              FnFilter1(G.filename)));
            fgets(G.answerbuf, 9, stdin);
     730:	a1 00 00 00 00       	mov    0x0,%eax
                  VMS_UNZIP_VERSION / 10, VMS_UNZIP_VERSION % 10));
            return 0;
        }
#ifndef VMS   /* won't be able to use extra field, but still have data */
        else if (!uO.tflag && !IS_OVERWRT_ALL) { /* if -o, extract anyway */
            Info(slide, 0x481, ((char *)slide, LoadFarString(VMSFormatQuery),
     735:	83 ec 10             	sub    $0x10,%esp
              FnFilter1(G.filename)));
            fgets(G.answerbuf, 9, stdin);
     738:	89 44 24 08          	mov    %eax,0x8(%esp)
     73c:	8d 83 cc 00 00 00    	lea    0xcc(%ebx),%eax
     742:	c7 44 24 04 09 00 00 	movl   $0x9,0x4(%esp)
     749:	00 
     74a:	89 04 24             	mov    %eax,(%esp)
     74d:	e8 00 00 00 00       	call   752 <_store_info+0x172>
            if ((*G.answerbuf != 'y') && (*G.answerbuf != 'Y'))
     752:	8a 83 cc 00 00 00    	mov    0xcc(%ebx),%al
     758:	83 e0 df             	and    $0xffffffdf,%eax
     75b:	3c 59                	cmp    $0x59,%al
     75d:	0f 85 33 ff ff ff    	jne    696 <_store_info+0xb6>
              G.crec.version_needed_to_extract[0] % 10,
              UNZIP_VERSION / 10, UNZIP_VERSION % 10));
        return 0;
    }

    if UNKN_COMPR {
     763:	66 8b 83 42 09 01 00 	mov    0x10942(%ebx),%ax
     76a:	66 83 f8 09          	cmp    $0x9,%ax
     76e:	89 c7                	mov    %eax,%edi
     770:	0f 97 c2             	seta   %dl
     773:	66 83 f8 07          	cmp    $0x7,%ax
     777:	0f 94 c0             	sete   %al
     77a:	08 c2                	or     %al,%dl
     77c:	75 0f                	jne    78d <_store_info+0x1ad>
     77e:	89 f8                	mov    %edi,%eax
     780:	83 e8 02             	sub    $0x2,%eax
     783:	66 83 f8 03          	cmp    $0x3,%ax
     787:	0f 87 93 00 00 00    	ja     820 <_store_info+0x240>
        if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))) {
     78d:	8b 73 38             	mov    0x38(%ebx),%esi
     790:	85 f6                	test   %esi,%esi
     792:	0f 85 fe fe ff ff    	jne    696 <_store_info+0xb6>
#ifndef SFX
            if (G.crec.compression_method < NUM_METHODS)
     798:	66 83 ff 0c          	cmp    $0xc,%di
                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgName),
     79c:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
     7a2:	89 44 24 28          	mov    %eax,0x28(%esp)
    }

    if UNKN_COMPR {
        if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))) {
#ifndef SFX
            if (G.crec.compression_method < NUM_METHODS)
     7a6:	0f 87 78 01 00 00    	ja     924 <_store_info+0x344>
                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgName),
     7ac:	89 f9                	mov    %edi,%ecx
     7ae:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     7b4:	31 ff                	xor    %edi,%edi
     7b6:	89 44 24 04          	mov    %eax,0x4(%esp)
     7ba:	66 89 cf             	mov    %cx,%di
     7bd:	8d 83 e0 09 01 00    	lea    0x109e0(%ebx),%eax
     7c3:	89 04 24             	mov    %eax,(%esp)
     7c6:	8b 2c bd c0 0b 00 00 	mov    0xbc0(,%edi,4),%ebp
     7cd:	e8 9e fd ff ff       	call   570 <_fnfilter>
     7d2:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     7d8:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
     7dc:	89 44 24 08          	mov    %eax,0x8(%esp)
     7e0:	c7 44 24 04 40 0c 00 	movl   $0xc40,0x4(%esp)
     7e7:	00 
     7e8:	89 3c 24             	mov    %edi,(%esp)
     7eb:	e8 00 00 00 00       	call   7f0 <_store_info+0x210>
     7f0:	89 7c 24 04          	mov    %edi,0x4(%esp)
     7f4:	89 1c 24             	mov    %ebx,(%esp)
     7f7:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     7fe:	00 
     7ff:	89 44 24 08          	mov    %eax,0x8(%esp)
     803:	ff 54 24 28          	call   *0x28(%esp)

    G.pInfo->diskstart = G.crec.disk_number_start;
    G.pInfo->offset = (Z_OFF_T)G.crec.relative_offset_local_header;
    return 1;

} /* end function store_info() */
     807:	89 f0                	mov    %esi,%eax

    if UNKN_COMPR {
        if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))) {
#ifndef SFX
            if (G.crec.compression_method < NUM_METHODS)
                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgName),
     809:	83 ec 10             	sub    $0x10,%esp

    G.pInfo->diskstart = G.crec.disk_number_start;
    G.pInfo->offset = (Z_OFF_T)G.crec.relative_offset_local_header;
    return 1;

} /* end function store_info() */
     80c:	83 c4 3c             	add    $0x3c,%esp
     80f:	5b                   	pop    %ebx
     810:	5e                   	pop    %esi
     811:	5f                   	pop    %edi
     812:	5d                   	pop    %ebp
     813:	c3                   	ret    
    G.pInfo->compr_size = G.crec.csize;
    G.pInfo->uncompr_size = G.crec.ucsize;

    switch (uO.aflag) {
        case 0:
            G.pInfo->textmode = FALSE;   /* bit field */
     814:	80 60 18 f7          	andb   $0xf7,0x18(%eax)
            break;
     818:	e9 56 fe ff ff       	jmp    673 <_store_info+0x93>
     81d:	8d 76 00             	lea    0x0(%esi),%esi
    }
#endif /* !CRYPT */

#ifndef SFX
    /* store a copy of the central header filename for later comparison */
    if ((G.pInfo->cfilname = zfmalloc(strlen(G.filename) + 1)) == NULL) {
     820:	8d b3 e0 09 01 00    	lea    0x109e0(%ebx),%esi
     826:	8b bb d8 08 00 00    	mov    0x8d8(%ebx),%edi
     82c:	89 34 24             	mov    %esi,(%esp)
     82f:	e8 00 00 00 00       	call   834 <_store_info+0x254>
     834:	40                   	inc    %eax
     835:	89 04 24             	mov    %eax,(%esp)
     838:	e8 00 00 00 00       	call   83d <_store_info+0x25d>
     83d:	89 47 1c             	mov    %eax,0x1c(%edi)
     840:	85 c0                	test   %eax,%eax
     842:	0f 84 d8 01 00 00    	je     a20 <_store_info+0x440>
        Info(slide, 0x401, ((char *)slide, LoadFarString(WarnNoMemCFName),
          FnFilter1(G.filename)));
    } else
        zfstrcpy(G.pInfo->cfilname, G.filename);
     848:	89 74 24 04          	mov    %esi,0x4(%esp)
     84c:	89 04 24             	mov    %eax,(%esp)
     84f:	e8 00 00 00 00       	call   854 <_store_info+0x274>
#endif /* !SFX */

    /* map whatever file attributes we have into the local format */
    mapattr(__G);   /* GRR:  worry about return value later */
     854:	89 1c 24             	mov    %ebx,(%esp)

    G.pInfo->diskstart = G.crec.disk_number_start;
    G.pInfo->offset = (Z_OFF_T)G.crec.relative_offset_local_header;
    return 1;
     857:	be 01 00 00 00       	mov    $0x1,%esi
    } else
        zfstrcpy(G.pInfo->cfilname, G.filename);
#endif /* !SFX */

    /* map whatever file attributes we have into the local format */
    mapattr(__G);   /* GRR:  worry about return value later */
     85c:	e8 00 00 00 00       	call   861 <_store_info+0x281>

    G.pInfo->diskstart = G.crec.disk_number_start;
     861:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
     867:	66 8b 93 5a 09 01 00 	mov    0x1095a(%ebx),%dx
     86e:	66 89 50 10          	mov    %dx,0x10(%eax)
    G.pInfo->offset = (Z_OFF_T)G.crec.relative_offset_local_header;
     872:	8b 93 64 09 01 00    	mov    0x10964(%ebx),%edx
     878:	89 10                	mov    %edx,(%eax)
    return 1;
     87a:	e9 19 fe ff ff       	jmp    698 <_store_info+0xb8>
     87f:	90                   	nop
            break;
    }

    if (G.crec.version_needed_to_extract[1] == VMS_) {
        if (G.crec.version_needed_to_extract[0] > VMS_UNZIP_VERSION) {
            if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2)))
     880:	8b 73 38             	mov    0x38(%ebx),%esi
     883:	85 f6                	test   %esi,%esi
     885:	0f 85 0b fe ff ff    	jne    696 <_store_info+0xb6>
                Info(slide, 0x401, ((char *)slide, LoadFarString(VersionMsg),
     88b:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
     891:	88 54 24 2f          	mov    %dl,0x2f(%esp)
     895:	89 44 24 28          	mov    %eax,0x28(%esp)
     899:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     89f:	89 44 24 04          	mov    %eax,0x4(%esp)
     8a3:	8d 83 e0 09 01 00    	lea    0x109e0(%ebx),%eax
     8a9:	89 04 24             	mov    %eax,(%esp)
     8ac:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     8b2:	e8 b9 fc ff ff       	call   570 <_fnfilter>
     8b7:	8a 54 24 2f          	mov    0x2f(%esp),%dl
     8bb:	89 d5                	mov    %edx,%ebp
     8bd:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
     8c4:	00 
     8c5:	81 e5 ff 00 00 00    	and    $0xff,%ebp
     8cb:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
     8d2:	00 
     8d3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     8da:	00 
     8db:	89 44 24 08          	mov    %eax,0x8(%esp)
     8df:	8d 4c ad 00          	lea    0x0(%ebp,%ebp,4),%ecx
     8e3:	c7 44 24 04 c0 0c 00 	movl   $0xcc0,0x4(%esp)
     8ea:	00 
     8eb:	89 3c 24             	mov    %edi,(%esp)
     8ee:	8d 4c cd 00          	lea    0x0(%ebp,%ecx,8),%ecx
     8f2:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
     8f5:	66 c1 e9 0b          	shr    $0xb,%cx
     8f9:	88 4c 24 2f          	mov    %cl,0x2f(%esp)
     8fd:	8d 2c 89             	lea    (%ecx,%ecx,4),%ebp
     900:	01 ed                	add    %ebp,%ebp
     902:	89 e9                	mov    %ebp,%ecx
     904:	29 ca                	sub    %ecx,%edx
     906:	88 d1                	mov    %dl,%cl
     908:	31 d2                	xor    %edx,%edx
     90a:	88 ca                	mov    %cl,%dl
     90c:	31 c9                	xor    %ecx,%ecx
     90e:	8a 4c 24 2f          	mov    0x2f(%esp),%cl
     912:	89 54 24 14          	mov    %edx,0x14(%esp)
     916:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     91a:	e8 00 00 00 00       	call   91f <_store_info+0x33f>
     91f:	e9 cc fe ff ff       	jmp    7f0 <_store_info+0x210>
                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgName),
                  FnFilter1(G.filename),
                  LoadFarStringSmall(ComprNames[G.crec.compression_method])));
            else
#endif
                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgNum),
     924:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     92a:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     930:	89 44 24 04          	mov    %eax,0x4(%esp)
     934:	8d 83 e0 09 01 00    	lea    0x109e0(%ebx),%eax
     93a:	89 04 24             	mov    %eax,(%esp)
     93d:	e8 2e fc ff ff       	call   570 <_fnfilter>
     942:	89 f9                	mov    %edi,%ecx
     944:	31 ff                	xor    %edi,%edi
     946:	89 2c 24             	mov    %ebp,(%esp)
     949:	66 89 cf             	mov    %cx,%di
     94c:	89 44 24 08          	mov    %eax,0x8(%esp)
     950:	89 7c 24 0c          	mov    %edi,0xc(%esp)
     954:	c7 44 24 04 80 0c 00 	movl   $0xc80,0x4(%esp)
     95b:	00 
     95c:	e8 00 00 00 00       	call   961 <_store_info+0x381>
     961:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     965:	89 1c 24             	mov    %ebx,(%esp)
     968:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     96f:	00 
     970:	89 44 24 08          	mov    %eax,0x8(%esp)
     974:	ff 54 24 28          	call   *0x28(%esp)

    G.pInfo->diskstart = G.crec.disk_number_start;
    G.pInfo->offset = (Z_OFF_T)G.crec.relative_offset_local_header;
    return 1;

} /* end function store_info() */
     978:	89 f0                	mov    %esi,%eax
                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgName),
                  FnFilter1(G.filename),
                  LoadFarStringSmall(ComprNames[G.crec.compression_method])));
            else
#endif
                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgNum),
     97a:	83 ec 10             	sub    $0x10,%esp

    G.pInfo->diskstart = G.crec.disk_number_start;
    G.pInfo->offset = (Z_OFF_T)G.crec.relative_offset_local_header;
    return 1;

} /* end function store_info() */
     97d:	83 c4 3c             	add    $0x3c,%esp
     980:	5b                   	pop    %ebx
     981:	5e                   	pop    %esi
     982:	5f                   	pop    %edi
     983:	5d                   	pop    %ebp
     984:	c3                   	ret    
        }
#endif /* !VMS */
    /* usual file type:  don't need VMS to extract */
    } else if (G.crec.version_needed_to_extract[0] > UNZIP_VERSION) {
        if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2)))
            Info(slide, 0x401, ((char *)slide, LoadFarString(VersionMsg),
     985:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
     98b:	88 54 24 2f          	mov    %dl,0x2f(%esp)
     98f:	89 44 24 28          	mov    %eax,0x28(%esp)
     993:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     999:	89 44 24 04          	mov    %eax,0x4(%esp)
     99d:	8d 83 e0 09 01 00    	lea    0x109e0(%ebx),%eax
     9a3:	89 04 24             	mov    %eax,(%esp)
     9a6:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     9ac:	e8 bf fb ff ff       	call   570 <_fnfilter>
     9b1:	8a 54 24 2f          	mov    0x2f(%esp),%dl
     9b5:	89 d5                	mov    %edx,%ebp
     9b7:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
     9be:	00 
     9bf:	81 e5 ff 00 00 00    	and    $0xff,%ebp
     9c5:	c7 44 24 18 02 00 00 	movl   $0x2,0x18(%esp)
     9cc:	00 
     9cd:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
     9d4:	00 
     9d5:	89 44 24 08          	mov    %eax,0x8(%esp)
     9d9:	8d 4c ad 00          	lea    0x0(%ebp,%ebp,4),%ecx
     9dd:	c7 44 24 04 c0 0c 00 	movl   $0xcc0,0x4(%esp)
     9e4:	00 
     9e5:	89 3c 24             	mov    %edi,(%esp)
     9e8:	8d 4c cd 00          	lea    0x0(%ebp,%ecx,8),%ecx
     9ec:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
     9ef:	66 c1 e9 0b          	shr    $0xb,%cx
     9f3:	88 4c 24 2f          	mov    %cl,0x2f(%esp)
     9f7:	8d 2c 89             	lea    (%ecx,%ecx,4),%ebp
     9fa:	8d 4c 2d 00          	lea    0x0(%ebp,%ebp,1),%ecx
     9fe:	29 ca                	sub    %ecx,%edx
     a00:	88 d1                	mov    %dl,%cl
     a02:	31 d2                	xor    %edx,%edx
     a04:	88 ca                	mov    %cl,%dl
     a06:	31 c9                	xor    %ecx,%ecx
     a08:	8a 4c 24 2f          	mov    0x2f(%esp),%cl
     a0c:	89 54 24 14          	mov    %edx,0x14(%esp)
     a10:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     a14:	e8 00 00 00 00       	call   a19 <_store_info+0x439>
     a19:	e9 d2 fd ff ff       	jmp    7f0 <_store_info+0x210>
     a1e:	66 90                	xchg   %ax,%ax
#endif /* !CRYPT */

#ifndef SFX
    /* store a copy of the central header filename for later comparison */
    if ((G.pInfo->cfilname = zfmalloc(strlen(G.filename) + 1)) == NULL) {
        Info(slide, 0x401, ((char *)slide, LoadFarString(WarnNoMemCFName),
     a20:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     a26:	89 34 24             	mov    %esi,(%esp)
     a29:	89 44 24 04          	mov    %eax,0x4(%esp)
     a2d:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     a33:	e8 38 fb ff ff       	call   570 <_fnfilter>
     a38:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     a3e:	89 44 24 08          	mov    %eax,0x8(%esp)
     a42:	c7 44 24 04 60 0b 00 	movl   $0xb60,0x4(%esp)
     a49:	00 
     a4a:	89 34 24             	mov    %esi,(%esp)
     a4d:	e8 00 00 00 00       	call   a52 <_store_info+0x472>
     a52:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     a59:	00 
     a5a:	89 44 24 08          	mov    %eax,0x8(%esp)
     a5e:	89 74 24 04          	mov    %esi,0x4(%esp)
     a62:	89 1c 24             	mov    %ebx,(%esp)
     a65:	ff d7                	call   *%edi
     a67:	83 ec 10             	sub    $0x10,%esp
     a6a:	e9 e5 fd ff ff       	jmp    854 <_store_info+0x274>
     a6f:	90                   	nop

00000a70 <_extract_or_test_files>:
/*  Function extract_or_test_files()  */
/**************************************/

int extract_or_test_files(__G)    /* return PK-type error code */
     __GDEF
{
     a70:	55                   	push   %ebp
     a71:	57                   	push   %edi
     a72:	56                   	push   %esi
     a73:	53                   	push   %ebx
     a74:	81 ec bc 00 00 00    	sub    $0xbc,%esp
     a7a:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp
    ing around that we can afford to be lenient if an error occurs in one of
    the member files:  we should still be able to go find the other members,
    since we know the offset of each from the beginning of the zipfile.
  ---------------------------------------------------------------------------*/

    G.pInfo = G.info;
     a81:	8d 85 d8 00 00 00    	lea    0xd8(%ebp),%eax
#ifndef SFX
    G.reported_backslash = FALSE;
#endif

    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */
    if (G.filespecs > 0  &&
     a87:	8b 55 6c             	mov    0x6c(%ebp),%edx
    ing around that we can afford to be lenient if an error occurs in one of
    the member files:  we should still be able to go find the other members,
    since we know the offset of each from the beginning of the zipfile.
  ---------------------------------------------------------------------------*/

    G.pInfo = G.info;
     a8a:	89 44 24 6c          	mov    %eax,0x6c(%esp)
     a8e:	89 85 d8 08 00 00    	mov    %eax,0x8d8(%ebp)

#if CRYPT
    G.newzip = TRUE;
     a94:	c7 85 84 00 00 00 01 	movl   $0x1,0x84(%ebp)
     a9b:	00 00 00 
#endif
#ifndef SFX
    G.reported_backslash = FALSE;
     a9e:	c7 85 ac 09 01 00 00 	movl   $0x0,0x109ac(%ebp)
     aa5:	00 00 00 
#endif

    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */
    if (G.filespecs > 0  &&
     aa8:	85 d2                	test   %edx,%edx
     aaa:	0f 85 3e 2b 00 00    	jne    35ee <_extract_or_test_files+0x2b7e>
    uch *cd_inptr;
    int cd_incnt;
    ulg filnum=0L, blknum=0L;
    int reached_end, no_endsig_found;
    int error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
     ab0:	c7 44 24 7c 00 00 00 	movl   $0x0,0x7c(%esp)
     ab7:	00 
    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */
    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.filespecs;  ++i)
            fn_matched[i] = FALSE;
    if (G.xfilespecs > 0  &&
     ab8:	8b 55 70             	mov    0x70(%ebp),%edx
     abb:	85 d2                	test   %edx,%edx
     abd:	0f 85 f7 2a 00 00    	jne    35ba <_extract_or_test_files+0x2b4a>
    uch *cd_inptr;
    int cd_incnt;
    ulg filnum=0L, blknum=0L;
    int reached_end, no_endsig_found;
    int error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
     ac3:	c7 84 24 84 00 00 00 	movl   $0x0,0x84(%esp)
     aca:	00 00 00 00 
     ace:	8d 85 c8 00 00 00    	lea    0xc8(%ebp),%eax
     ad4:	c7 84 24 88 00 00 00 	movl   $0x1,0x88(%esp)
     adb:	01 00 00 00 
     adf:	89 44 24 44          	mov    %eax,0x44(%esp)
                }
            }
            break;

        default:   /* should never get to this point */
            Info(slide, 0x401, ((char *)slide,
     ae3:	8d 85 dc 08 00 00    	lea    0x8dc(%ebp),%eax
     ae9:	89 44 24 40          	mov    %eax,0x40(%esp)
                break;
            case EF_PKVMS:
                if (makelong(ef+EB_HEADSIZE) !=
                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),
                          (extent)(ebLen-4)))
                    Info(slide, 1, ((char *)slide,
     aed:	83 e0 01             	and    $0x1,%eax
    unsigned members_processed;
    ulg num_skipped=0L, num_bad_pwd=0L;
    Z_OFF_T old_extra_bytes = 0L;
#ifdef SET_DIR_ATTRIB
    unsigned num_dirs=0;
    direntry *dirlist=(direntry *)NULL, **sorted_dirlist=(direntry **)NULL;
     af0:	c7 84 24 98 00 00 00 	movl   $0x0,0x98(%esp)
     af7:	00 00 00 00 
    int *fn_matched=NULL, *xn_matched=NULL;
    unsigned members_processed;
    ulg num_skipped=0L, num_bad_pwd=0L;
    Z_OFF_T old_extra_bytes = 0L;
#ifdef SET_DIR_ATTRIB
    unsigned num_dirs=0;
     afb:	c7 84 24 90 00 00 00 	movl   $0x0,0x90(%esp)
     b02:	00 00 00 00 
    ulg filnum=0L, blknum=0L;
    int reached_end, no_endsig_found;
    int error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
    unsigned members_processed;
    ulg num_skipped=0L, num_bad_pwd=0L;
     b06:	c7 84 24 94 00 00 00 	movl   $0x0,0x94(%esp)
     b0d:	00 00 00 00 
{
    unsigned i, j;
    Z_OFF_T cd_bufstart;
    uch *cd_inptr;
    int cd_incnt;
    ulg filnum=0L, blknum=0L;
     b11:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
     b18:	00 
    int reached_end, no_endsig_found;
    int error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
    unsigned members_processed;
    ulg num_skipped=0L, num_bad_pwd=0L;
    Z_OFF_T old_extra_bytes = 0L;
     b19:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
     b20:	00 
    ulg filnum=0L, blknum=0L;
    int reached_end, no_endsig_found;
    int error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
    unsigned members_processed;
    ulg num_skipped=0L, num_bad_pwd=0L;
     b21:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%esp)
     b28:	00 
    not have gotten to this routine unless this is also the disk on which
    the central directory starts.  In practice, this had better be the ONLY
    disk in the archive, but we'll add multi-disk support soon.
  ---------------------------------------------------------------------------*/

    members_processed = 0;
     b29:	c7 44 24 58 00 00 00 	movl   $0x0,0x58(%esp)
     b30:	00 
    Z_OFF_T cd_bufstart;
    uch *cd_inptr;
    int cd_incnt;
    ulg filnum=0L, blknum=0L;
    int reached_end, no_endsig_found;
    int error, error_in_archive=PK_COOL;
     b31:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
     b38:	00 
    the central directory starts.  In practice, this had better be the ONLY
    disk in the archive, but we'll add multi-disk support soon.
  ---------------------------------------------------------------------------*/

    members_processed = 0;
    no_endsig_found = FALSE;
     b39:	c7 84 24 9c 00 00 00 	movl   $0x0,0x9c(%esp)
     b40:	00 00 00 00 
                break;
            case EF_PKVMS:
                if (makelong(ef+EB_HEADSIZE) !=
                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),
                          (extent)(ebLen-4)))
                    Info(slide, 1, ((char *)slide,
     b44:	89 44 24 60          	mov    %eax,0x60(%esp)
    uch *cd_inptr;
    int cd_incnt;
    ulg filnum=0L, blknum=0L;
    int reached_end, no_endsig_found;
    int error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
     b48:	8b 44 24 6c          	mov    0x6c(%esp),%eax
     b4c:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
     b53:	00 
     b54:	8d 9d e0 09 01 00    	lea    0x109e0(%ebp),%ebx
     b5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
         */

        while ((j < DIR_BLKSIZ)) {
            G.pInfo = &G.info[j];

            if (readbuf(__G__ G.sig, 4) == 0) {
     b60:	8b 7c 24 44          	mov    0x44(%esp),%edi
         * attributes, case-conversion and text-conversion flags until block
         * size is reached.
         */

        while ((j < DIR_BLKSIZ)) {
            G.pInfo = &G.info[j];
     b64:	89 85 d8 08 00 00    	mov    %eax,0x8d8(%ebp)

            if (readbuf(__G__ G.sig, 4) == 0) {
     b6a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     b71:	00 
     b72:	89 7c 24 04          	mov    %edi,0x4(%esp)
     b76:	89 2c 24             	mov    %ebp,(%esp)
     b79:	e8 00 00 00 00       	call   b7e <_extract_or_test_files+0x10e>
     b7e:	85 c0                	test   %eax,%eax
     b80:	0f 84 14 14 00 00    	je     1f9a <_extract_or_test_files+0x152a>
                error_in_archive = PK_EOF;
                reached_end = TRUE;     /* ...so no more left to do */
                break;
            }
            if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a new entry? */
     b86:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     b8d:	00 
     b8e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     b95:	00 
     b96:	89 3c 24             	mov    %edi,(%esp)
     b99:	e8 00 00 00 00       	call   b9e <_extract_or_test_files+0x12e>
     b9e:	85 c0                	test   %eax,%eax
     ba0:	0f 85 51 1a 00 00    	jne    25f7 <_extract_or_test_files+0x1b87>
                }
                reached_end = TRUE;     /* ...so no more left to do */
                break;
            }
            /* process_cdir_file_hdr() sets pInfo->hostnum, pInfo->lcflag */
            if ((error = process_cdir_file_hdr(__G)) != PK_COOL) {
     ba6:	89 2c 24             	mov    %ebp,(%esp)
     ba9:	e8 00 00 00 00       	call   bae <_extract_or_test_files+0x13e>
     bae:	85 c0                	test   %eax,%eax
     bb0:	0f 85 2d 1a 00 00    	jne    25e3 <_extract_or_test_files+0x1b73>
                error_in_archive = error;   /* only PK_EOF defined */
                reached_end = TRUE;     /* ...so no more left to do */
                break;
            }
            if ((error = do_string(__G__ G.crec.filename_length, DS_FN)) !=
     bb6:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
     bbd:	00 
     bbe:	31 c0                	xor    %eax,%eax
     bc0:	66 8b 85 54 09 01 00 	mov    0x10954(%ebp),%ax
     bc7:	89 2c 24             	mov    %ebp,(%esp)
     bca:	89 44 24 04          	mov    %eax,0x4(%esp)
     bce:	e8 00 00 00 00       	call   bd3 <_extract_or_test_files+0x163>
     bd3:	85 c0                	test   %eax,%eax
     bd5:	74 14                	je     beb <_extract_or_test_files+0x17b>
     bd7:	8b 4c 24 50          	mov    0x50(%esp),%ecx
     bdb:	39 c1                	cmp    %eax,%ecx
     bdd:	0f 4c c8             	cmovl  %eax,%ecx
     be0:	89 4c 24 50          	mov    %ecx,0x50(%esp)
                 PK_COOL)
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal:  no more left to do */
     be4:	48                   	dec    %eax
     be5:	0f 8f a5 1a 00 00    	jg     2690 <_extract_or_test_files+0x1c20>
                      FnFilter1(G.filename), "central"));
                    reached_end = TRUE;
                    break;
                }
            }
            if ((error = do_string(__G__ G.crec.extra_field_length,
     beb:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
     bf2:	00 
     bf3:	31 c0                	xor    %eax,%eax
     bf5:	66 8b 85 56 09 01 00 	mov    0x10956(%ebp),%ax
     bfc:	89 2c 24             	mov    %ebp,(%esp)
     bff:	89 44 24 04          	mov    %eax,0x4(%esp)
     c03:	e8 00 00 00 00       	call   c08 <_extract_or_test_files+0x198>
     c08:	85 c0                	test   %eax,%eax
     c0a:	74 14                	je     c20 <_extract_or_test_files+0x1b0>
     c0c:	8b 4c 24 50          	mov    0x50(%esp),%ecx
     c10:	39 c1                	cmp    %eax,%ecx
     c12:	0f 4c c8             	cmovl  %eax,%ecx
     c15:	89 4c 24 50          	mov    %ecx,0x50(%esp)
                EXTRA_FIELD)) != 0)
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal */
     c19:	48                   	dec    %eax
     c1a:	0f 8f c4 1b 00 00    	jg     27e4 <_extract_or_test_files+0x1d74>
#ifdef AMIGA
            G.filenote_slot = j;
            if ((error = do_string(__G__ G.crec.file_comment_length,
                                   uO.N_flag ? FILENOTE : SKIP)) != PK_COOL)
#else
            if ((error = do_string(__G__ G.crec.file_comment_length, SKIP))
     c20:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c27:	00 
     c28:	31 c0                	xor    %eax,%eax
     c2a:	66 8b 85 58 09 01 00 	mov    0x10958(%ebp),%ax
     c31:	89 2c 24             	mov    %ebp,(%esp)
     c34:	89 44 24 04          	mov    %eax,0x4(%esp)
     c38:	e8 00 00 00 00       	call   c3d <_extract_or_test_files+0x1cd>
     c3d:	85 c0                	test   %eax,%eax
     c3f:	74 14                	je     c55 <_extract_or_test_files+0x1e5>
     c41:	8b 54 24 50          	mov    0x50(%esp),%edx
     c45:	39 c2                	cmp    %eax,%edx
     c47:	0f 4c d0             	cmovl  %eax,%edx
     c4a:	89 54 24 50          	mov    %edx,0x50(%esp)
                != PK_COOL)
#endif
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal */
     c4e:	48                   	dec    %eax
     c4f:	0f 8f 44 1e 00 00    	jg     2a99 <_extract_or_test_files+0x2029>
                      FnFilter1(G.filename)));
                    reached_end = TRUE;
                    break;
                }
            }
            if (G.process_all_files) {
     c55:	8b 45 74             	mov    0x74(%ebp),%eax
     c58:	85 c0                	test   %eax,%eax
     c5a:	0f 85 c2 00 00 00    	jne    d22 <_extract_or_test_files+0x2b2>
                else
                    ++num_skipped;
            } else {
                int   do_this_file;

                if (G.filespecs == 0)
     c60:	8b 45 6c             	mov    0x6c(%ebp),%eax
     c63:	85 c0                	test   %eax,%eax
     c65:	74 49                	je     cb0 <_extract_or_test_files+0x240>
     c67:	31 ff                	xor    %edi,%edi
     c69:	eb 0f                	jmp    c7a <_extract_or_test_files+0x20a>
     c6b:	90                   	nop
     c6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                    do_this_file = TRUE;
                else {  /* check if this entry matches an `include' argument */
                    do_this_file = FALSE;
                    for (i = 0; i < G.filespecs; i++)
     c70:	47                   	inc    %edi
     c71:	39 7d 6c             	cmp    %edi,0x6c(%ebp)
     c74:	0f 86 85 00 00 00    	jbe    cff <_extract_or_test_files+0x28f>
                        if (match(G.filename, G.pfnames[i], uO.C_flag WISEP)) {
     c7a:	8b 45 18             	mov    0x18(%ebp),%eax
     c7d:	8d 34 bd 00 00 00 00 	lea    0x0(,%edi,4),%esi
     c84:	89 44 24 08          	mov    %eax,0x8(%esp)
     c88:	8b 85 c0 00 00 00    	mov    0xc0(%ebp),%eax
     c8e:	8b 04 30             	mov    (%eax,%esi,1),%eax
     c91:	89 1c 24             	mov    %ebx,(%esp)
     c94:	89 44 24 04          	mov    %eax,0x4(%esp)
     c98:	e8 00 00 00 00       	call   c9d <_extract_or_test_files+0x22d>
     c9d:	85 c0                	test   %eax,%eax
     c9f:	74 cf                	je     c70 <_extract_or_test_files+0x200>
                            do_this_file = TRUE;  /* ^-- ignore case or not? */
                            if (fn_matched)
     ca1:	8b 44 24 7c          	mov    0x7c(%esp),%eax
     ca5:	85 c0                	test   %eax,%eax
     ca7:	74 07                	je     cb0 <_extract_or_test_files+0x240>
                                fn_matched[i] = TRUE;
     ca9:	c7 04 30 01 00 00 00 	movl   $0x1,(%eax,%esi,1)
                            break;       /* found match, so stop looping */
                        }
                }
                if (do_this_file) {  /* check if this is an excluded file */
                    for (i = 0; i < G.xfilespecs; i++)
     cb0:	8b 4d 70             	mov    0x70(%ebp),%ecx
     cb3:	85 c9                	test   %ecx,%ecx
     cb5:	74 6b                	je     d22 <_extract_or_test_files+0x2b2>
     cb7:	31 ff                	xor    %edi,%edi
     cb9:	eb 0b                	jmp    cc6 <_extract_or_test_files+0x256>
     cbb:	90                   	nop
     cbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     cc0:	47                   	inc    %edi
     cc1:	39 7d 70             	cmp    %edi,0x70(%ebp)
     cc4:	76 5c                	jbe    d22 <_extract_or_test_files+0x2b2>
                        if (match(G.filename, G.pxnames[i], uO.C_flag WISEP)) {
     cc6:	8b 45 18             	mov    0x18(%ebp),%eax
     cc9:	8d 34 bd 00 00 00 00 	lea    0x0(,%edi,4),%esi
     cd0:	89 44 24 08          	mov    %eax,0x8(%esp)
     cd4:	8b 85 c4 00 00 00    	mov    0xc4(%ebp),%eax
     cda:	8b 04 30             	mov    (%eax,%esi,1),%eax
     cdd:	89 1c 24             	mov    %ebx,(%esp)
     ce0:	89 44 24 04          	mov    %eax,0x4(%esp)
     ce4:	e8 00 00 00 00       	call   ce9 <_extract_or_test_files+0x279>
     ce9:	85 c0                	test   %eax,%eax
     ceb:	74 d3                	je     cc0 <_extract_or_test_files+0x250>
                            do_this_file = FALSE; /* ^-- ignore case or not? */
                            if (xn_matched)
     ced:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
     cf4:	85 c0                	test   %eax,%eax
     cf6:	74 07                	je     cff <_extract_or_test_files+0x28f>
                                xn_matched[i] = TRUE;
     cf8:	c7 04 30 01 00 00 00 	movl   $0x1,(%eax,%esi,1)
                    else
                        ++num_skipped;  /* unsupp. compression or encryption */
                }
            } /* end if (process_all_files) */

            members_processed++;
     cff:	8b 74 24 58          	mov    0x58(%esp),%esi
     d03:	46                   	inc    %esi
     d04:	89 74 24 58          	mov    %esi,0x58(%esp)
         * Loop through files in central directory, storing offsets, file
         * attributes, case-conversion and text-conversion flags until block
         * size is reached.
         */

        while ((j < DIR_BLKSIZ)) {
     d08:	83 7c 24 48 3f       	cmpl   $0x3f,0x48(%esp)
     d0d:	77 3b                	ja     d4a <_extract_or_test_files+0x2da>
     d0f:	8b 44 24 48          	mov    0x48(%esp),%eax
     d13:	c1 e0 05             	shl    $0x5,%eax
     d16:	8d 84 05 d8 00 00 00 	lea    0xd8(%ebp,%eax,1),%eax
     d1d:	e9 3e fe ff ff       	jmp    b60 <_extract_or_test_files+0xf0>
                                xn_matched[i] = TRUE;
                            break;
                        }
                }
                if (do_this_file) {
                    if (store_info(__G))
     d22:	89 e8                	mov    %ebp,%eax
     d24:	e8 b7 f8 ff ff       	call   5e0 <_store_info>
     d29:	85 c0                	test   %eax,%eax
     d2b:	0f 84 1f 02 00 00    	je     f50 <_extract_or_test_files+0x4e0>
                        ++j;            /* file is OK */
     d31:	8b 44 24 48          	mov    0x48(%esp),%eax
                    else
                        ++num_skipped;  /* unsupp. compression or encryption */
                }
            } /* end if (process_all_files) */

            members_processed++;
     d35:	8b 74 24 58          	mov    0x58(%esp),%esi
                            break;
                        }
                }
                if (do_this_file) {
                    if (store_info(__G))
                        ++j;            /* file is OK */
     d39:	40                   	inc    %eax
                    else
                        ++num_skipped;  /* unsupp. compression or encryption */
                }
            } /* end if (process_all_files) */

            members_processed++;
     d3a:	46                   	inc    %esi
                            break;
                        }
                }
                if (do_this_file) {
                    if (store_info(__G))
                        ++j;            /* file is OK */
     d3b:	89 44 24 48          	mov    %eax,0x48(%esp)
                    else
                        ++num_skipped;  /* unsupp. compression or encryption */
                }
            } /* end if (process_all_files) */

            members_processed++;
     d3f:	89 74 24 58          	mov    %esi,0x58(%esp)
         * Loop through files in central directory, storing offsets, file
         * attributes, case-conversion and text-conversion flags until block
         * size is reached.
         */

        while ((j < DIR_BLKSIZ)) {
     d43:	83 7c 24 48 3f       	cmpl   $0x3f,0x48(%esp)
     d48:	76 c5                	jbe    d0f <_extract_or_test_files+0x29f>
            members_processed++;

        } /* end while-loop (adding files to current block) */

        /* save position in central directory so can come back later */
        cd_bufstart = G.cur_zipfile_bufstart;
     d4a:	8b 85 10 09 01 00    	mov    0x10910(%ebp),%eax
     d50:	c7 84 24 80 00 00 00 	movl   $0x0,0x80(%esp)
     d57:	00 00 00 00 
     d5b:	89 44 24 70          	mov    %eax,0x70(%esp)
        cd_inptr = G.inptr;
     d5f:	8b 85 e8 08 01 00    	mov    0x108e8(%ebp),%eax
     d65:	89 44 24 78          	mov    %eax,0x78(%esp)
        cd_incnt = G.incnt;
     d69:	8b 85 ec 08 01 00    	mov    0x108ec(%ebp),%eax
     d6f:	89 44 24 74          	mov    %eax,0x74(%esp)
     d73:	8b 44 24 6c          	mov    0x6c(%esp),%eax
     d77:	8b 4c 24 34          	mov    0x34(%esp),%ecx
     d7b:	89 44 24 38          	mov    %eax,0x38(%esp)
     d7f:	89 44 24 3c          	mov    %eax,0x3c(%esp)
     d83:	8b 44 24 48          	mov    0x48(%esp),%eax
     d87:	01 c8                	add    %ecx,%eax
     d89:	89 44 24 4c          	mov    %eax,0x4c(%esp)
                      LoadFarString(CentSigMsg), j + blknum*DIR_BLKSIZ + 1));
                    Info(slide, 0x401, ((char *)slide,
                      LoadFarString(ReportMsg)));
                    error_in_archive = PK_BADERR;
                }
                reached_end = TRUE;     /* ...so no more left to do */
     d8d:	8b 44 24 50          	mov    0x50(%esp),%eax
     d91:	89 44 24 48          	mov    %eax,0x48(%esp)
     d95:	e9 3b 01 00 00       	jmp    ed5 <_extract_or_test_files+0x465>
     d9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#ifdef USE_STRM_INPUT
            fseek((FILE *)G.zipfd, bufstart, SEEK_SET);
            G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);
#else /* !USE_STRM_INPUT */
            G.cur_zipfile_bufstart =
              lseek(G.zipfd, bufstart, SEEK_SET);
     da0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     da7:	00 
     da8:	89 7c 24 04          	mov    %edi,0x4(%esp)
     dac:	8b 85 08 09 01 00    	mov    0x10908(%ebp),%eax
     db2:	89 04 24             	mov    %eax,(%esp)
     db5:	e8 00 00 00 00       	call   dba <_extract_or_test_files+0x34a>
            Trace((stderr, "debug: bufstart != cur_zipfile_bufstart\n"));
#ifdef USE_STRM_INPUT
            fseek((FILE *)G.zipfd, bufstart, SEEK_SET);
            G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);
#else /* !USE_STRM_INPUT */
            G.cur_zipfile_bufstart =
     dba:	89 85 10 09 01 00    	mov    %eax,0x10910(%ebp)
              lseek(G.zipfd, bufstart, SEEK_SET);
#endif /* ?USE_STRM_INPUT */
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
     dc0:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
     dc7:	00 
     dc8:	8b 85 e4 08 01 00    	mov    0x108e4(%ebp),%eax
     dce:	89 44 24 04          	mov    %eax,0x4(%esp)
     dd2:	8b 85 08 09 01 00    	mov    0x10908(%ebp),%eax
     dd8:	89 04 24             	mov    %eax,(%esp)
     ddb:	e8 00 00 00 00       	call   de0 <_extract_or_test_files+0x370>
     de0:	89 85 ec 08 01 00    	mov    %eax,0x108ec(%ebp)
     de6:	85 c0                	test   %eax,%eax
     de8:	0f 8e 22 10 00 00    	jle    1e10 <_extract_or_test_files+0x13a0>
                Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
                  *pfilnum, "lseek", (long)bufstart));
                error_in_archive = PK_BADERR;
                continue;   /* can still do next file */
            }
            G.inptr = G.inbuf + (int)inbuf_offset;
     dee:	8b 95 e4 08 01 00    	mov    0x108e4(%ebp),%edx
            G.incnt -= (int)inbuf_offset;
     df4:	29 f0                	sub    %esi,%eax
                Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
                  *pfilnum, "lseek", (long)bufstart));
                error_in_archive = PK_BADERR;
                continue;   /* can still do next file */
            }
            G.inptr = G.inbuf + (int)inbuf_offset;
     df6:	01 f2                	add    %esi,%edx
            G.incnt -= (int)inbuf_offset;
     df8:	89 85 ec 08 01 00    	mov    %eax,0x108ec(%ebp)
                Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
                  *pfilnum, "lseek", (long)bufstart));
                error_in_archive = PK_BADERR;
                continue;   /* can still do next file */
            }
            G.inptr = G.inbuf + (int)inbuf_offset;
     dfe:	89 95 e8 08 01 00    	mov    %edx,0x108e8(%ebp)
            G.incnt += (int)(G.inptr-G.inbuf) - (int)inbuf_offset;
            G.inptr = G.inbuf + (int)inbuf_offset;
        }

        /* should be in proper position now, so check for sig */
        if (readbuf(__G__ G.sig, 4) == 0) {  /* bad offset */
     e04:	8b 44 24 44          	mov    0x44(%esp),%eax
     e08:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     e0f:	00 
     e10:	89 44 24 04          	mov    %eax,0x4(%esp)
     e14:	89 2c 24             	mov    %ebp,(%esp)
     e17:	e8 00 00 00 00       	call   e1c <_extract_or_test_files+0x3ac>
     e1c:	85 c0                	test   %eax,%eax
     e1e:	0f 84 e1 01 00 00    	je     1005 <_extract_or_test_files+0x595>
            Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
              *pfilnum, "EOF", (long)request));
            error_in_archive = PK_BADERR;
            continue;   /* but can still try next one */
        }
        if (strncmp(G.sig, local_hdr_sig, 4)) {
     e24:	8b 44 24 44          	mov    0x44(%esp),%eax
     e28:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     e2f:	00 
     e30:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     e37:	00 
     e38:	89 04 24             	mov    %eax,(%esp)
     e3b:	e8 00 00 00 00       	call   e40 <_extract_or_test_files+0x3d0>
     e40:	85 c0                	test   %eax,%eax
     e42:	0f 84 68 01 00 00    	je     fb0 <_extract_or_test_files+0x540>
            Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
     e48:	8b 7c 24 34          	mov    0x34(%esp),%edi
     e4c:	8b 44 24 40          	mov    0x40(%esp),%eax
     e50:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
     e56:	89 5c 24 10          	mov    %ebx,0x10(%esp)
     e5a:	c7 44 24 0c 5c 09 00 	movl   $0x95c,0xc(%esp)
     e61:	00 
     e62:	89 7c 24 08          	mov    %edi,0x8(%esp)
     e66:	c7 44 24 04 20 0a 00 	movl   $0xa20,0x4(%esp)
     e6d:	00 
     e6e:	89 04 24             	mov    %eax,(%esp)
     e71:	e8 00 00 00 00       	call   e76 <_extract_or_test_files+0x406>
     e76:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     e7d:	00 
     e7e:	89 44 24 08          	mov    %eax,0x8(%esp)
     e82:	8b 44 24 40          	mov    0x40(%esp),%eax
     e86:	89 44 24 04          	mov    %eax,0x4(%esp)
     e8a:	89 2c 24             	mov    %ebp,(%esp)
     e8d:	ff d6                	call   *%esi
            /*
                GRRDUMP(G.sig, 4)
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
            if ((*pfilnum == 1 && G.extra_bytes != 0L) ||
     e8f:	89 f8                	mov    %edi,%eax
              *pfilnum, "EOF", (long)request));
            error_in_archive = PK_BADERR;
            continue;   /* but can still try next one */
        }
        if (strncmp(G.sig, local_hdr_sig, 4)) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
     e91:	83 ec 10             	sub    $0x10,%esp
            /*
                GRRDUMP(G.sig, 4)
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
            if ((*pfilnum == 1 && G.extra_bytes != 0L) ||
     e94:	48                   	dec    %eax
     e95:	0f 84 c5 03 00 00    	je     1260 <_extract_or_test_files+0x7f0>
     e9b:	8b bd 14 09 01 00    	mov    0x10914(%ebp),%edi
              *pfilnum, LoadFarStringSmall(LocalHdrSig), (long)request));
            /*
                GRRDUMP(G.sig, 4)
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
     ea1:	c7 44 24 48 02 00 00 	movl   $0x2,0x48(%esp)
     ea8:	00 
            if ((*pfilnum == 1 && G.extra_bytes != 0L) ||
     ea9:	85 ff                	test   %edi,%edi
     eab:	0f 84 bd 03 00 00    	je     126e <_extract_or_test_files+0x7fe>
     eb1:	8b 4c 24 38          	mov    0x38(%esp),%ecx
     eb5:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
     eb9:	83 c1 20             	add    $0x20,%ecx
     ebc:	83 c3 20             	add    $0x20,%ebx
     ebf:	89 4c 24 38          	mov    %ecx,0x38(%esp)
    /*-----------------------------------------------------------------------
        Second loop:  process files in current block, extracting or testing
        each one.
      -----------------------------------------------------------------------*/

    for (i = 0; i < numchunk; ++i) {
     ec3:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
     ec7:	89 5c 24 3c          	mov    %ebx,0x3c(%esp)
     ecb:	39 4c 24 34          	cmp    %ecx,0x34(%esp)
     ecf:	0f 84 12 11 00 00    	je     1fe7 <_extract_or_test_files+0x1577>
        (*pfilnum)++;   /* *pfilnum = i + blknum*DIR_BLKSIZ + 1; */
        G.pInfo = &G.info[i];
     ed5:	8b 44 24 38          	mov    0x38(%esp),%eax
        /* if the target position is not within the current input buffer
         * (either haven't yet read far enough, or (maybe) skipping back-
         * ward), skip to the target position and reset readbuf(). */

        /* seek_zipf(__G__ pInfo->offset);  */
        request = G.pInfo->offset + G.extra_bytes;
     ed9:	8b 9d 14 09 01 00    	mov    0x10914(%ebp),%ebx
        each one.
      -----------------------------------------------------------------------*/

    for (i = 0; i < numchunk; ++i) {
        (*pfilnum)++;   /* *pfilnum = i + blknum*DIR_BLKSIZ + 1; */
        G.pInfo = &G.info[i];
     edf:	89 85 d8 08 00 00    	mov    %eax,0x8d8(%ebp)
        /* if the target position is not within the current input buffer
         * (either haven't yet read far enough, or (maybe) skipping back-
         * ward), skip to the target position and reset readbuf(). */

        /* seek_zipf(__G__ pInfo->offset);  */
        request = G.pInfo->offset + G.extra_bytes;
     ee5:	8b 44 24 3c          	mov    0x3c(%esp),%eax
        Second loop:  process files in current block, extracting or testing
        each one.
      -----------------------------------------------------------------------*/

    for (i = 0; i < numchunk; ++i) {
        (*pfilnum)++;   /* *pfilnum = i + blknum*DIR_BLKSIZ + 1; */
     ee9:	8b 7c 24 34          	mov    0x34(%esp),%edi
        /* if the target position is not within the current input buffer
         * (either haven't yet read far enough, or (maybe) skipping back-
         * ward), skip to the target position and reset readbuf(). */

        /* seek_zipf(__G__ pInfo->offset);  */
        request = G.pInfo->offset + G.extra_bytes;
     eed:	8b 10                	mov    (%eax),%edx
        Second loop:  process files in current block, extracting or testing
        each one.
      -----------------------------------------------------------------------*/

    for (i = 0; i < numchunk; ++i) {
        (*pfilnum)++;   /* *pfilnum = i + blknum*DIR_BLKSIZ + 1; */
     eef:	47                   	inc    %edi
        /* if the target position is not within the current input buffer
         * (either haven't yet read far enough, or (maybe) skipping back-
         * ward), skip to the target position and reset readbuf(). */

        /* seek_zipf(__G__ pInfo->offset);  */
        request = G.pInfo->offset + G.extra_bytes;
     ef0:	01 d3                	add    %edx,%ebx
        Second loop:  process files in current block, extracting or testing
        each one.
      -----------------------------------------------------------------------*/

    for (i = 0; i < numchunk; ++i) {
        (*pfilnum)++;   /* *pfilnum = i + blknum*DIR_BLKSIZ + 1; */
     ef2:	89 7c 24 34          	mov    %edi,0x34(%esp)
         * (either haven't yet read far enough, or (maybe) skipping back-
         * ward), skip to the target position and reset readbuf(). */

        /* seek_zipf(__G__ pInfo->offset);  */
        request = G.pInfo->offset + G.extra_bytes;
        inbuf_offset = request % INBUFSIZ;
     ef6:	89 d8                	mov    %ebx,%eax
        bufstart = request - inbuf_offset;
     ef8:	89 df                	mov    %ebx,%edi
         * (either haven't yet read far enough, or (maybe) skipping back-
         * ward), skip to the target position and reset readbuf(). */

        /* seek_zipf(__G__ pInfo->offset);  */
        request = G.pInfo->offset + G.extra_bytes;
        inbuf_offset = request % INBUFSIZ;
     efa:	c1 f8 1f             	sar    $0x1f,%eax
     efd:	c1 e8 13             	shr    $0x13,%eax
     f00:	8d 34 03             	lea    (%ebx,%eax,1),%esi
     f03:	81 e6 ff 1f 00 00    	and    $0x1fff,%esi
     f09:	29 c6                	sub    %eax,%esi
        bufstart = request - inbuf_offset;
     f0b:	29 f7                	sub    %esi,%edi
        Trace((stderr, "\ndebug: request = %ld, inbuf_offset = %ld\n",
          (long)request, (long)inbuf_offset));
        Trace((stderr,
          "debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          (long)bufstart, (long)G.cur_zipfile_bufstart));
        if (request < 0) {
     f0d:	85 db                	test   %ebx,%ebx
     f0f:	0f 88 df 01 00 00    	js     10f4 <_extract_or_test_files+0x684>
                error_in_archive = PK_BADERR;
                continue;  /* this one hosed; try next */
            }
        }

        if (bufstart != G.cur_zipfile_bufstart) {
     f15:	39 bd 10 09 01 00    	cmp    %edi,0x10910(%ebp)
     f1b:	0f 85 7f fe ff ff    	jne    da0 <_extract_or_test_files+0x330>
                continue;   /* can still do next file */
            }
            G.inptr = G.inbuf + (int)inbuf_offset;
            G.incnt -= (int)inbuf_offset;
        } else {
            G.incnt += (int)(G.inptr-G.inbuf) - (int)inbuf_offset;
     f21:	8b 95 e4 08 01 00    	mov    0x108e4(%ebp),%edx
     f27:	8b 85 e8 08 01 00    	mov    0x108e8(%ebp),%eax
     f2d:	29 d0                	sub    %edx,%eax
     f2f:	8b 8d ec 08 01 00    	mov    0x108ec(%ebp),%ecx
     f35:	29 f0                	sub    %esi,%eax
            G.inptr = G.inbuf + (int)inbuf_offset;
     f37:	01 d6                	add    %edx,%esi
                continue;   /* can still do next file */
            }
            G.inptr = G.inbuf + (int)inbuf_offset;
            G.incnt -= (int)inbuf_offset;
        } else {
            G.incnt += (int)(G.inptr-G.inbuf) - (int)inbuf_offset;
     f39:	01 c1                	add    %eax,%ecx
            G.inptr = G.inbuf + (int)inbuf_offset;
     f3b:	89 b5 e8 08 01 00    	mov    %esi,0x108e8(%ebp)
                continue;   /* can still do next file */
            }
            G.inptr = G.inbuf + (int)inbuf_offset;
            G.incnt -= (int)inbuf_offset;
        } else {
            G.incnt += (int)(G.inptr-G.inbuf) - (int)inbuf_offset;
     f41:	89 8d ec 08 01 00    	mov    %ecx,0x108ec(%ebp)
     f47:	e9 b8 fe ff ff       	jmp    e04 <_extract_or_test_files+0x394>
     f4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                }
                if (do_this_file) {
                    if (store_info(__G))
                        ++j;            /* file is OK */
                    else
                        ++num_skipped;  /* unsupp. compression or encryption */
     f50:	8b 7c 24 68          	mov    0x68(%esp),%edi
     f54:	47                   	inc    %edi
     f55:	89 7c 24 68          	mov    %edi,0x68(%esp)
     f59:	e9 a1 fd ff ff       	jmp    cff <_extract_or_test_files+0x28f>
     f5e:	66 90                	xchg   %ax,%ax
                    *pold_extra_bytes = G.extra_bytes;
                    G.extra_bytes = 0L;
                } else
                    G.extra_bytes = *pold_extra_bytes; /* third attempt */
                if (((error = seek_zipf(__G__ G.pInfo->offset)) != PK_OK) ||
                    (readbuf(__G__ G.sig, 4) == 0)) {  /* bad offset */
     f60:	8b 44 24 44          	mov    0x44(%esp),%eax
     f64:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     f6b:	00 
     f6c:	89 44 24 04          	mov    %eax,0x4(%esp)
     f70:	89 2c 24             	mov    %ebp,(%esp)
     f73:	e8 00 00 00 00       	call   f78 <_extract_or_test_files+0x508>
                if (G.extra_bytes) {
                    *pold_extra_bytes = G.extra_bytes;
                    G.extra_bytes = 0L;
                } else
                    G.extra_bytes = *pold_extra_bytes; /* third attempt */
                if (((error = seek_zipf(__G__ G.pInfo->offset)) != PK_OK) ||
     f78:	85 c0                	test   %eax,%eax
     f7a:	0f 84 1e 05 00 00    	je     149e <_extract_or_test_files+0xa2e>
                        LoadFarString(OffsetMsg), *pfilnum, "EOF",
                        (long)request));
                    error_in_archive = PK_BADERR;
                    continue;   /* but can still try next one */
                }
                if (strncmp(G.sig, local_hdr_sig, 4)) {
     f80:	8b 44 24 44          	mov    0x44(%esp),%eax
     f84:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     f8b:	00 
     f8c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     f93:	00 
     f94:	89 04 24             	mov    %eax,(%esp)
     f97:	e8 00 00 00 00       	call   f9c <_extract_or_test_files+0x52c>
              *pfilnum, LoadFarStringSmall(LocalHdrSig), (long)request));
            /*
                GRRDUMP(G.sig, 4)
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
     f9c:	c7 44 24 48 02 00 00 	movl   $0x2,0x48(%esp)
     fa3:	00 
                        LoadFarString(OffsetMsg), *pfilnum, "EOF",
                        (long)request));
                    error_in_archive = PK_BADERR;
                    continue;   /* but can still try next one */
                }
                if (strncmp(G.sig, local_hdr_sig, 4)) {
     fa4:	85 c0                	test   %eax,%eax
     fa6:	0f 85 d5 0e 00 00    	jne    1e81 <_extract_or_test_files+0x1411>
     fac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                    continue;
                }
            } else
                continue;  /* this one hosed; try next */
        }
        if ((error = process_local_file_hdr(__G)) != PK_COOL) {
     fb0:	89 2c 24             	mov    %ebp,(%esp)
     fb3:	e8 00 00 00 00       	call   fb8 <_extract_or_test_files+0x548>
     fb8:	89 c3                	mov    %eax,%ebx
     fba:	85 c0                	test   %eax,%eax
     fbc:	0f 84 9e 00 00 00    	je     1060 <_extract_or_test_files+0x5f0>
            Info(slide, 0x421, ((char *)slide, LoadFarString(BadLocalHdr),
     fc2:	8b 44 24 34          	mov    0x34(%esp),%eax
     fc6:	8b 7c 24 40          	mov    0x40(%esp),%edi
     fca:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
     fd0:	89 44 24 08          	mov    %eax,0x8(%esp)
     fd4:	c7 44 24 04 3c 09 00 	movl   $0x93c,0x4(%esp)
     fdb:	00 
     fdc:	89 3c 24             	mov    %edi,(%esp)
     fdf:	e8 00 00 00 00       	call   fe4 <_extract_or_test_files+0x574>
     fe4:	c7 44 24 0c 21 04 00 	movl   $0x421,0xc(%esp)
     feb:	00 
                        ++(*pnum_dirs);
                    }
#endif /* SET_DIR_ATTRIB */
                } else if (errcode == MPN_VOL_LABEL) {
#ifdef DOS_OS2_W32
                    Info(slide, 0x401, ((char *)slide,
     fec:	89 44 24 08          	mov    %eax,0x8(%esp)
     ff0:	89 7c 24 04          	mov    %edi,0x4(%esp)
     ff4:	89 2c 24             	mov    %ebp,(%esp)
     ff7:	ff d6                	call   *%esi
     ff9:	83 ec 10             	sub    $0x10,%esp
     ffc:	89 5c 24 48          	mov    %ebx,0x48(%esp)
    1000:	e9 ac fe ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
            G.inptr = G.inbuf + (int)inbuf_offset;
        }

        /* should be in proper position now, so check for sig */
        if (readbuf(__G__ G.sig, 4) == 0) {  /* bad offset */
            Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
    1005:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1009:	8b 44 24 34          	mov    0x34(%esp),%eax
    100d:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    1013:	89 5c 24 10          	mov    %ebx,0x10(%esp)
    1017:	c7 44 24 0c a0 00 00 	movl   $0xa0,0xc(%esp)
    101e:	00 
    101f:	89 44 24 08          	mov    %eax,0x8(%esp)
    1023:	c7 44 24 04 20 0a 00 	movl   $0xa20,0x4(%esp)
    102a:	00 
    102b:	89 3c 24             	mov    %edi,(%esp)
    102e:	e8 00 00 00 00       	call   1033 <_extract_or_test_files+0x5c3>
    1033:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    103a:	00 
    103b:	89 44 24 08          	mov    %eax,0x8(%esp)
    103f:	89 f8                	mov    %edi,%eax
                        (long)request));
                    error_in_archive = PK_BADERR;
                    continue;   /* but can still try next one */
                }
                if (strncmp(G.sig, local_hdr_sig, 4)) {
                    Info(slide, 0x401, ((char *)slide,
    1041:	89 44 24 04          	mov    %eax,0x4(%esp)
    1045:	89 2c 24             	mov    %ebp,(%esp)
    1048:	ff d6                	call   *%esi
    104a:	83 ec 10             	sub    $0x10,%esp
                      LoadFarString(OffsetMsg), *pfilnum,
                      LoadFarStringSmall(LocalHdrSig), (long)request));
                    error_in_archive = PK_BADERR;
    104d:	c7 44 24 48 03 00 00 	movl   $0x3,0x48(%esp)
    1054:	00 
    1055:	e9 57 fe ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
    105a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            Info(slide, 0x421, ((char *)slide, LoadFarString(BadLocalHdr),
              *pfilnum));
            error_in_archive = error;   /* only PK_EOF defined */
            continue;   /* can still try next one */
        }
        if ((error = do_string(__G__ G.lrec.filename_length, DS_FN_L)) !=
    1060:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
    1067:	00 
    1068:	31 c0                	xor    %eax,%eax
    106a:	66 8b 85 36 09 01 00 	mov    0x10936(%ebp),%ax
    1071:	89 2c 24             	mov    %ebp,(%esp)
    1074:	89 44 24 04          	mov    %eax,0x4(%esp)
    1078:	e8 00 00 00 00       	call   107d <_extract_or_test_files+0x60d>
    107d:	85 c0                	test   %eax,%eax
    107f:	0f 84 02 02 00 00    	je     1287 <_extract_or_test_files+0x817>
    1085:	8b 4c 24 48          	mov    0x48(%esp),%ecx
    1089:	39 c1                	cmp    %eax,%ecx
    108b:	0f 4c c8             	cmovl  %eax,%ecx
    108e:	89 4c 24 48          	mov    %ecx,0x48(%esp)
             PK_COOL)
        {
            if (error > error_in_archive)
                error_in_archive = error;
            if (error > PK_WARN) {
    1092:	48                   	dec    %eax
    1093:	0f 8e ee 01 00 00    	jle    1287 <_extract_or_test_files+0x817>
                Info(slide, 0x401, ((char *)slide, LoadFarString(FilNamMsg),
    1099:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    109f:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    10a5:	89 44 24 04          	mov    %eax,0x4(%esp)
    10a9:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    10af:	89 04 24             	mov    %eax,(%esp)
    10b2:	e8 b9 f4 ff ff       	call   570 <_fnfilter>
    10b7:	8b 7c 24 40          	mov    0x40(%esp),%edi
    10bb:	c7 44 24 0c a4 00 00 	movl   $0xa4,0xc(%esp)
    10c2:	00 
    10c3:	89 44 24 08          	mov    %eax,0x8(%esp)
    10c7:	c7 44 24 04 9c 0b 00 	movl   $0xb9c,0x4(%esp)
    10ce:	00 
    10cf:	89 3c 24             	mov    %edi,(%esp)
    10d2:	e8 00 00 00 00       	call   10d7 <_extract_or_test_files+0x667>
                      FnFilter1(G.filename)));
                ++(*pnum_bad_pwd);
            } else {  /* (error > PK_WARN) */
                if (error > error_in_archive)
                    error_in_archive = error;
                Info(slide, 0x401, ((char *)slide,
    10d7:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    10de:	00 
    10df:	89 44 24 08          	mov    %eax,0x8(%esp)
    10e3:	89 7c 24 04          	mov    %edi,0x4(%esp)
    10e7:	89 2c 24             	mov    %ebp,(%esp)
    10ea:	ff d3                	call   *%ebx
    10ec:	83 ec 10             	sub    $0x10,%esp
    10ef:	e9 bd fd ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
          (long)request, (long)inbuf_offset));
        Trace((stderr,
          "debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          (long)bufstart, (long)G.cur_zipfile_bufstart));
        if (request < 0) {
            Info(slide, 0x401, ((char *)slide, LoadFarStringSmall(SeekMsg),
    10f4:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    10fa:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1101:	00 
    1102:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
    1108:	8b 7c 24 40          	mov    0x40(%esp),%edi
    110c:	89 44 24 08          	mov    %eax,0x8(%esp)
    1110:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    1117:	00 
    1118:	89 3c 24             	mov    %edi,(%esp)
    111b:	e8 00 00 00 00       	call   1120 <_extract_or_test_files+0x6b0>
    1120:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1127:	00 
    1128:	89 44 24 08          	mov    %eax,0x8(%esp)
    112c:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1130:	89 2c 24             	mov    %ebp,(%esp)
    1133:	ff d3                	call   *%ebx
    1135:	83 ec 10             	sub    $0x10,%esp
                      G.zipfn, LoadFarString(ReportMsg)));
                    error_in_archive = PK_BADERR;
                    continue;
                }
            } else {
                error_in_archive = PK_BADERR;
    1138:	c7 44 24 48 03 00 00 	movl   $0x3,0x48(%esp)
    113f:	00 
          (long)bufstart, (long)G.cur_zipfile_bufstart));
        if (request < 0) {
            Info(slide, 0x401, ((char *)slide, LoadFarStringSmall(SeekMsg),
              G.zipfn, LoadFarString(ReportMsg)));
            error_in_archive = PK_ERR;
            if (*pfilnum == 1 && G.extra_bytes != 0L) {
    1140:	83 7c 24 34 01       	cmpl   $0x1,0x34(%esp)
    1145:	0f 85 66 fd ff ff    	jne    eb1 <_extract_or_test_files+0x441>
    114b:	8b b5 14 09 01 00    	mov    0x10914(%ebp),%esi
    1151:	85 f6                	test   %esi,%esi
    1153:	0f 84 58 fd ff ff    	je     eb1 <_extract_or_test_files+0x441>
                Info(slide, 0x401, ((char *)slide,
    1159:	8b 5c 24 60          	mov    0x60(%esp),%ebx
    115d:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    1163:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1167:	be d8 00 00 00       	mov    $0xd8,%esi
    116c:	b8 21 00 00 00       	mov    $0x21,%eax
    1171:	85 db                	test   %ebx,%ebx
    1173:	0f 85 ac 1a 00 00    	jne    2c25 <_extract_or_test_files+0x21b5>
    1179:	f7 c7 02 00 00 00    	test   $0x2,%edi
    117f:	0f 85 c3 1a 00 00    	jne    2c48 <_extract_or_test_files+0x21d8>
    1185:	89 c1                	mov    %eax,%ecx
    1187:	c1 e9 02             	shr    $0x2,%ecx
    118a:	a8 02                	test   $0x2,%al
    118c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    118e:	74 0b                	je     119b <_extract_or_test_files+0x72b>
    1190:	66 8b 0e             	mov    (%esi),%cx
    1193:	66 89 0f             	mov    %cx,(%edi)
    1196:	b9 02 00 00 00       	mov    $0x2,%ecx
    119b:	a8 01                	test   $0x1,%al
    119d:	74 06                	je     11a5 <_extract_or_test_files+0x735>
    119f:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    11a2:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    11a5:	8b 44 24 40          	mov    0x40(%esp),%eax
    11a9:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    11b0:	00 
    11b1:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
    11b8:	00 
    11b9:	89 44 24 04          	mov    %eax,0x4(%esp)
    11bd:	89 2c 24             	mov    %ebp,(%esp)
    11c0:	ff d2                	call   *%edx
                  LoadFarString(AttemptRecompensate)));
                *pold_extra_bytes = G.extra_bytes;
    11c2:	8b 85 14 09 01 00    	mov    0x10914(%ebp),%eax
        if (request < 0) {
            Info(slide, 0x401, ((char *)slide, LoadFarStringSmall(SeekMsg),
              G.zipfn, LoadFarString(ReportMsg)));
            error_in_archive = PK_ERR;
            if (*pfilnum == 1 && G.extra_bytes != 0L) {
                Info(slide, 0x401, ((char *)slide,
    11c8:	83 ec 10             	sub    $0x10,%esp
                  LoadFarString(AttemptRecompensate)));
                *pold_extra_bytes = G.extra_bytes;
                G.extra_bytes = 0L;
    11cb:	c7 85 14 09 01 00 00 	movl   $0x0,0x10914(%ebp)
    11d2:	00 00 00 
              G.zipfn, LoadFarString(ReportMsg)));
            error_in_archive = PK_ERR;
            if (*pfilnum == 1 && G.extra_bytes != 0L) {
                Info(slide, 0x401, ((char *)slide,
                  LoadFarString(AttemptRecompensate)));
                *pold_extra_bytes = G.extra_bytes;
    11d5:	89 44 24 54          	mov    %eax,0x54(%esp)
                G.extra_bytes = 0L;
                request = G.pInfo->offset;  /* could also check if != 0 */
    11d9:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
          "debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          (long)bufstart, (long)G.cur_zipfile_bufstart));
        if (request < 0) {
            Info(slide, 0x401, ((char *)slide, LoadFarStringSmall(SeekMsg),
              G.zipfn, LoadFarString(ReportMsg)));
            error_in_archive = PK_ERR;
    11df:	c7 44 24 48 02 00 00 	movl   $0x2,0x48(%esp)
    11e6:	00 
            if (*pfilnum == 1 && G.extra_bytes != 0L) {
                Info(slide, 0x401, ((char *)slide,
                  LoadFarString(AttemptRecompensate)));
                *pold_extra_bytes = G.extra_bytes;
                G.extra_bytes = 0L;
                request = G.pInfo->offset;  /* could also check if != 0 */
    11e7:	8b 18                	mov    (%eax),%ebx
                inbuf_offset = request % INBUFSIZ;
    11e9:	89 d8                	mov    %ebx,%eax
                bufstart = request - inbuf_offset;
    11eb:	89 df                	mov    %ebx,%edi
                Info(slide, 0x401, ((char *)slide,
                  LoadFarString(AttemptRecompensate)));
                *pold_extra_bytes = G.extra_bytes;
                G.extra_bytes = 0L;
                request = G.pInfo->offset;  /* could also check if != 0 */
                inbuf_offset = request % INBUFSIZ;
    11ed:	c1 f8 1f             	sar    $0x1f,%eax
    11f0:	c1 e8 13             	shr    $0x13,%eax
    11f3:	8d 34 03             	lea    (%ebx,%eax,1),%esi
    11f6:	81 e6 ff 1f 00 00    	and    $0x1fff,%esi
    11fc:	29 c6                	sub    %eax,%esi
                bufstart = request - inbuf_offset;
    11fe:	29 f7                	sub    %esi,%edi
                  (long)request, (long)inbuf_offset));
                Trace((stderr,
                  "debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n",
                  (long)bufstart, (long)G.cur_zipfile_bufstart));
                /* try again */
                if (request < 0) {
    1200:	85 db                	test   %ebx,%ebx
    1202:	0f 89 0d fd ff ff    	jns    f15 <_extract_or_test_files+0x4a5>
                    Trace((stderr,
                      "debug: recompensated request still < 0\n"));
                    Info(slide, 0x401, ((char *)slide,
    1208:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    120e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1215:	00 
    1216:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
    121c:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1220:	89 44 24 08          	mov    %eax,0x8(%esp)
    1224:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    122b:	00 
    122c:	89 3c 24             	mov    %edi,(%esp)
    122f:	e8 00 00 00 00       	call   1234 <_extract_or_test_files+0x7c4>
            G.cur_zipfile_bufstart =
              lseek(G.zipfd, bufstart, SEEK_SET);
#endif /* ?USE_STRM_INPUT */
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            {
                Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
    1234:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    123b:	00 
    123c:	89 44 24 08          	mov    %eax,0x8(%esp)
    1240:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1244:	89 2c 24             	mov    %ebp,(%esp)
    1247:	ff d3                	call   *%ebx
    1249:	83 ec 10             	sub    $0x10,%esp
                  *pfilnum, "lseek", (long)bufstart));
                error_in_archive = PK_BADERR;
    124c:	c7 44 24 48 03 00 00 	movl   $0x3,0x48(%esp)
    1253:	00 
    1254:	e9 58 fc ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
    1259:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            /*
                GRRDUMP(G.sig, 4)
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
            if ((*pfilnum == 1 && G.extra_bytes != 0L) ||
    1260:	8b 85 14 09 01 00    	mov    0x10914(%ebp),%eax
    1266:	85 c0                	test   %eax,%eax
    1268:	0f 85 83 01 00 00    	jne    13f1 <_extract_or_test_files+0x981>
                (G.extra_bytes == 0L && *pold_extra_bytes != 0L)) {
    126e:	8b 74 24 54          	mov    0x54(%esp),%esi
    1272:	85 f6                	test   %esi,%esi
    1274:	0f 85 77 01 00 00    	jne    13f1 <_extract_or_test_files+0x981>
              *pfilnum, LoadFarStringSmall(LocalHdrSig), (long)request));
            /*
                GRRDUMP(G.sig, 4)
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
    127a:	c7 44 24 48 02 00 00 	movl   $0x2,0x48(%esp)
    1281:	00 
    1282:	e9 2a fc ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
                  FnFilter1(G.filename), "local"));
                continue;   /* go on to next one */
            }
        }
#ifndef SFX
        if (G.pInfo->cfilname != (char Far *)NULL) {
    1287:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    128d:	8b 58 1c             	mov    0x1c(%eax),%ebx
    1290:	85 db                	test   %ebx,%ebx
    1292:	74 2f                	je     12c3 <_extract_or_test_files+0x853>
            if (zfstrcmp(G.pInfo->cfilname, G.filename) != 0) {
    1294:	8d b5 e0 09 01 00    	lea    0x109e0(%ebp),%esi
    129a:	89 1c 24             	mov    %ebx,(%esp)
    129d:	89 74 24 04          	mov    %esi,0x4(%esp)
    12a1:	e8 00 00 00 00       	call   12a6 <_extract_or_test_files+0x836>
    12a6:	85 c0                	test   %eax,%eax
    12a8:	0f 85 ea 0b 00 00    	jne    1e98 <_extract_or_test_files+0x1428>
#  undef    cFile_PrintBuf
                zfstrcpy(G.filename, G.pInfo->cfilname);
                if (error_in_archive < PK_WARN)
                    error_in_archive = PK_WARN;
            }
            zffree(G.pInfo->cfilname);
    12ae:	89 1c 24             	mov    %ebx,(%esp)
    12b1:	e8 00 00 00 00       	call   12b6 <_extract_or_test_files+0x846>
            G.pInfo->cfilname = (char Far *)NULL;
    12b6:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    12bc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
        }
#endif /* !SFX */
        if (G.lrec.compression_method == STORED) {
    12c3:	66 83 bd 34 09 01 00 	cmpw   $0x0,0x10934(%ebp)
    12ca:	00 
    12cb:	0f 85 88 00 00 00    	jne    1359 <_extract_or_test_files+0x8e9>
            ulg csiz_decrypted = G.lrec.csize;
    12d1:	8b 9d 20 09 01 00    	mov    0x10920(%ebp),%ebx

            if (G.pInfo->encrypted)
                csiz_decrypted -= 12;
    12d7:	f6 40 18 01          	testb  $0x1,0x18(%eax)
    12db:	8d 53 f4             	lea    -0xc(%ebx),%edx
            if (G.lrec.ucsize != csiz_decrypted) {
    12de:	8b bd 24 09 01 00    	mov    0x10924(%ebp),%edi
#endif /* !SFX */
        if (G.lrec.compression_method == STORED) {
            ulg csiz_decrypted = G.lrec.csize;

            if (G.pInfo->encrypted)
                csiz_decrypted -= 12;
    12e4:	0f 45 da             	cmovne %edx,%ebx
            if (G.lrec.ucsize != csiz_decrypted) {
    12e7:	39 df                	cmp    %ebx,%edi
    12e9:	74 6e                	je     1359 <_extract_or_test_files+0x8e9>
                Info(slide, 0x401, ((char *)slide,
    12eb:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    12f1:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    12f7:	89 44 24 04          	mov    %eax,0x4(%esp)
    12fb:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    1301:	89 04 24             	mov    %eax,(%esp)
    1304:	e8 67 f2 ff ff       	call   570 <_fnfilter>
    1309:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    130d:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1311:	89 5c 24 10          	mov    %ebx,0x10(%esp)
    1315:	89 44 24 08          	mov    %eax,0x8(%esp)
    1319:	c7 44 24 04 a0 0a 00 	movl   $0xaa0,0x4(%esp)
    1320:	00 
    1321:	89 3c 24             	mov    %edi,(%esp)
    1324:	e8 00 00 00 00       	call   1329 <_extract_or_test_files+0x8b9>
    1329:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1330:	00 
    1331:	89 44 24 08          	mov    %eax,0x8(%esp)
    1335:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1339:	89 2c 24             	mov    %ebp,(%esp)
    133c:	ff d6                	call   *%esi
                  LoadFarStringSmall2(WrnStorUCSizCSizDiff),
                  FnFilter1(G.filename), G.lrec.ucsize, csiz_decrypted));
                G.lrec.ucsize = csiz_decrypted;
                if (error_in_archive < PK_WARN)
                    error_in_archive = PK_WARN;
    133e:	b8 01 00 00 00       	mov    $0x1,%eax
            ulg csiz_decrypted = G.lrec.csize;

            if (G.pInfo->encrypted)
                csiz_decrypted -= 12;
            if (G.lrec.ucsize != csiz_decrypted) {
                Info(slide, 0x401, ((char *)slide,
    1343:	83 ec 10             	sub    $0x10,%esp
                  LoadFarStringSmall2(WrnStorUCSizCSizDiff),
                  FnFilter1(G.filename), G.lrec.ucsize, csiz_decrypted));
                G.lrec.ucsize = csiz_decrypted;
    1346:	89 9d 24 09 01 00    	mov    %ebx,0x10924(%ebp)
                if (error_in_archive < PK_WARN)
                    error_in_archive = PK_WARN;
    134c:	8b 4c 24 48          	mov    0x48(%esp),%ecx
    1350:	85 c9                	test   %ecx,%ecx
    1352:	0f 4f c1             	cmovg  %ecx,%eax
    1355:	89 44 24 48          	mov    %eax,0x48(%esp)
            }
        }
        if (G.extra_field != (uch *)NULL) {
    1359:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
    135f:	85 c0                	test   %eax,%eax
    1361:	74 12                	je     1375 <_extract_or_test_files+0x905>
            free(G.extra_field);
    1363:	89 04 24             	mov    %eax,(%esp)
    1366:	e8 00 00 00 00       	call   136b <_extract_or_test_files+0x8fb>
            G.extra_field = (uch *)NULL;
    136b:	c7 85 18 09 01 00 00 	movl   $0x0,0x10918(%ebp)
    1372:	00 00 00 
        }
        if ((error =
    1375:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    137c:	00 
             do_string(__G__ G.lrec.extra_field_length, EXTRA_FIELD)) != 0)
    137d:	31 c0                	xor    %eax,%eax
    137f:	66 8b 85 38 09 01 00 	mov    0x10938(%ebp),%ax
        }
        if (G.extra_field != (uch *)NULL) {
            free(G.extra_field);
            G.extra_field = (uch *)NULL;
        }
        if ((error =
    1386:	89 2c 24             	mov    %ebp,(%esp)
             do_string(__G__ G.lrec.extra_field_length, EXTRA_FIELD)) != 0)
    1389:	89 44 24 04          	mov    %eax,0x4(%esp)
        }
        if (G.extra_field != (uch *)NULL) {
            free(G.extra_field);
            G.extra_field = (uch *)NULL;
        }
        if ((error =
    138d:	e8 00 00 00 00       	call   1392 <_extract_or_test_files+0x922>
    1392:	85 c0                	test   %eax,%eax
    1394:	0f 84 46 01 00 00    	je     14e0 <_extract_or_test_files+0xa70>
    139a:	8b 54 24 48          	mov    0x48(%esp),%edx
    139e:	39 c2                	cmp    %eax,%edx
    13a0:	0f 4c d0             	cmovl  %eax,%edx
    13a3:	89 54 24 48          	mov    %edx,0x48(%esp)
             do_string(__G__ G.lrec.extra_field_length, EXTRA_FIELD)) != 0)
        {
            if (error > error_in_archive)
                error_in_archive = error;
            if (error > PK_WARN) {
    13a7:	48                   	dec    %eax
    13a8:	0f 8e 32 01 00 00    	jle    14e0 <_extract_or_test_files+0xa70>
                Info(slide, 0x401, ((char *)slide,
    13ae:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    13b4:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    13ba:	89 44 24 04          	mov    %eax,0x4(%esp)
    13be:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    13c4:	89 04 24             	mov    %eax,(%esp)
    13c7:	e8 a4 f1 ff ff       	call   570 <_fnfilter>
    13cc:	8b 7c 24 40          	mov    0x40(%esp),%edi
    13d0:	c7 44 24 0c a4 00 00 	movl   $0xa4,0xc(%esp)
    13d7:	00 
    13d8:	89 44 24 08          	mov    %eax,0x8(%esp)
    13dc:	c7 44 24 04 60 0a 00 	movl   $0xa60,0x4(%esp)
    13e3:	00 
    13e4:	89 3c 24             	mov    %edi,(%esp)
    13e7:	e8 00 00 00 00       	call   13ec <_extract_or_test_files+0x97c>
    13ec:	e9 e6 fc ff ff       	jmp    10d7 <_extract_or_test_files+0x667>
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
            if ((*pfilnum == 1 && G.extra_bytes != 0L) ||
                (G.extra_bytes == 0L && *pold_extra_bytes != 0L)) {
                Info(slide, 0x401, ((char *)slide,
    13f1:	8b 4c 24 60          	mov    0x60(%esp),%ecx
    13f5:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    13fb:	8b 7c 24 40          	mov    0x40(%esp),%edi
    13ff:	be d8 00 00 00       	mov    $0xd8,%esi
    1404:	b8 21 00 00 00       	mov    $0x21,%eax
    1409:	85 c9                	test   %ecx,%ecx
    140b:	0f 85 7f 0c 00 00    	jne    2090 <_extract_or_test_files+0x1620>
    1411:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1417:	0f 85 96 0c 00 00    	jne    20b3 <_extract_or_test_files+0x1643>
    141d:	89 c1                	mov    %eax,%ecx
    141f:	c1 e9 02             	shr    $0x2,%ecx
    1422:	a8 02                	test   $0x2,%al
    1424:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    1426:	74 0b                	je     1433 <_extract_or_test_files+0x9c3>
    1428:	66 8b 0e             	mov    (%esi),%cx
    142b:	66 89 0f             	mov    %cx,(%edi)
    142e:	b9 02 00 00 00       	mov    $0x2,%ecx
    1433:	a8 01                	test   $0x1,%al
    1435:	74 06                	je     143d <_extract_or_test_files+0x9cd>
    1437:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    143a:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    143d:	8b 44 24 40          	mov    0x40(%esp),%eax
    1441:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1448:	00 
    1449:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
    1450:	00 
    1451:	89 44 24 04          	mov    %eax,0x4(%esp)
    1455:	89 2c 24             	mov    %ebp,(%esp)
    1458:	ff d2                	call   *%edx
                  LoadFarString(AttemptRecompensate)));
                if (G.extra_bytes) {
    145a:	8b 85 14 09 01 00    	mov    0x10914(%ebp),%eax
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
            if ((*pfilnum == 1 && G.extra_bytes != 0L) ||
                (G.extra_bytes == 0L && *pold_extra_bytes != 0L)) {
                Info(slide, 0x401, ((char *)slide,
    1460:	83 ec 10             	sub    $0x10,%esp
                  LoadFarString(AttemptRecompensate)));
                if (G.extra_bytes) {
    1463:	85 c0                	test   %eax,%eax
    1465:	0f 84 d8 09 00 00    	je     1e43 <_extract_or_test_files+0x13d3>
                    *pold_extra_bytes = G.extra_bytes;
                    G.extra_bytes = 0L;
    146b:	c7 85 14 09 01 00 00 	movl   $0x0,0x10914(%ebp)
    1472:	00 00 00 
    1475:	89 44 24 54          	mov    %eax,0x54(%esp)
                } else
                    G.extra_bytes = *pold_extra_bytes; /* third attempt */
                if (((error = seek_zipf(__G__ G.pInfo->offset)) != PK_OK) ||
    1479:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    147f:	8b 00                	mov    (%eax),%eax
    1481:	89 2c 24             	mov    %ebp,(%esp)
    1484:	89 44 24 04          	mov    %eax,0x4(%esp)
    1488:	e8 00 00 00 00       	call   148d <_extract_or_test_files+0xa1d>
    148d:	85 c0                	test   %eax,%eax
    148f:	0f 84 cb fa ff ff    	je     f60 <_extract_or_test_files+0x4f0>
                    (readbuf(__G__ G.sig, 4) == 0)) {  /* bad offset */
                    if (error != PK_BADERR)
    1495:	83 f8 03             	cmp    $0x3,%eax
    1498:	0f 84 ae fd ff ff    	je     124c <_extract_or_test_files+0x7dc>
                      Info(slide, 0x401, ((char *)slide,
    149e:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    14a4:	89 5c 24 10          	mov    %ebx,0x10(%esp)
    14a8:	c7 44 24 0c a0 00 00 	movl   $0xa0,0xc(%esp)
    14af:	00 
                        (long)request));
                    error_in_archive = PK_BADERR;
                    continue;   /* but can still try next one */
                }
                if (strncmp(G.sig, local_hdr_sig, 4)) {
                    Info(slide, 0x401, ((char *)slide,
    14b0:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    14b4:	8b 44 24 34          	mov    0x34(%esp),%eax
    14b8:	89 44 24 08          	mov    %eax,0x8(%esp)
    14bc:	c7 44 24 04 20 0a 00 	movl   $0xa20,0x4(%esp)
    14c3:	00 
    14c4:	89 1c 24             	mov    %ebx,(%esp)
    14c7:	e8 00 00 00 00       	call   14cc <_extract_or_test_files+0xa5c>
    14cc:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    14d3:	00 
    14d4:	89 44 24 08          	mov    %eax,0x8(%esp)
    14d8:	89 d8                	mov    %ebx,%eax
    14da:	e9 62 fb ff ff       	jmp    1041 <_extract_or_test_files+0x5d1>
    14df:	90                   	nop
                continue;   /* go on */
            }
        }

#if CRYPT
        if (G.pInfo->encrypted &&
    14e0:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    14e6:	f6 40 18 01          	testb  $0x1,0x18(%eax)
    14ea:	0f 85 42 0a 00 00    	jne    1f32 <_extract_or_test_files+0x14c2>
         * fflag/uflag/overwrite_all/etc. (we couldn't do this in upper
         * loop because we don't store the possibly renamed filename[] in
         * info[])
         */
#ifdef DLL
        if (!uO.tflag && !uO.cflag && !G.redirect_data)
    14f0:	8b 7d 44             	mov    0x44(%ebp),%edi
    14f3:	85 ff                	test   %edi,%edi
    14f5:	0f 85 c9 00 00 00    	jne    15c4 <_extract_or_test_files+0xb54>
    14fb:	8b 75 14             	mov    0x14(%ebp),%esi
    14fe:	85 f6                	test   %esi,%esi
    1500:	0f 85 be 00 00 00    	jne    15c4 <_extract_or_test_files+0xb54>
    1506:	8b 9d a0 00 00 00    	mov    0xa0(%ebp),%ebx
    150c:	85 db                	test   %ebx,%ebx
    150e:	0f 85 b0 00 00 00    	jne    15c4 <_extract_or_test_files+0xb54>
    1514:	31 ff                	xor    %edi,%edi
            /* for files from DOS FAT, check for use of backslash instead
             *  of slash as directory separator (bug in some zipper(s); so
             *  far, not a problem in HPFS, NTFS or VFAT systems)
             */
#ifndef SFX
            if (G.pInfo->hostnum == FS_FAT_ && !MBSCHR(G.filename, '/')) {
    1516:	8d b5 e0 09 01 00    	lea    0x109e0(%ebp),%esi
    151c:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    1522:	80 78 13 00          	cmpb   $0x0,0x13(%eax)
    1526:	0f 84 ca 11 00 00    	je     26f6 <_extract_or_test_files+0x1c86>
                    }
                } while (*PREINCSTR(p));
            }
#endif /* !SFX */

            if (!renamed) {
    152c:	85 ff                	test   %edi,%edi
    152e:	75 0d                	jne    153d <_extract_or_test_files+0xacd>
               /* remove absolute path specs */
               if (G.filename[0] == '/') {
    1530:	80 bd e0 09 01 00 2f 	cmpb   $0x2f,0x109e0(%ebp)
    1537:	0f 84 91 1f 00 00    	je     34ce <_extract_or_test_files+0x2a5e>
                   } while (G.filename[0] == '/');
               }
            }

            /* mapname can create dirs if not freshening or if renamed */
            error = mapname(__G__ renamed);
    153d:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1541:	89 2c 24             	mov    %ebp,(%esp)
    1544:	e8 00 00 00 00       	call   1549 <_extract_or_test_files+0xad9>
            if ((errcode = error & ~MPN_MASK) != PK_OK &&
    1549:	89 c3                	mov    %eax,%ebx
    154b:	81 e3 ff 80 ff ff    	and    $0xffff80ff,%ebx
    1551:	0f 84 c7 0e 00 00    	je     241e <_extract_or_test_files+0x19ae>
    1557:	3b 5c 24 48          	cmp    0x48(%esp),%ebx
    155b:	0f 8e bd 0e 00 00    	jle    241e <_extract_or_test_files+0x19ae>
                error_in_archive < errcode)
                error_in_archive = errcode;
            if ((errcode = error & MPN_MASK) > MPN_INF_TRUNC) {
    1561:	25 00 7f 00 00       	and    $0x7f00,%eax
    1566:	3d 00 01 00 00       	cmp    $0x100,%eax
    156b:	7e 2f                	jle    159c <_extract_or_test_files+0xb2c>
                if (errcode == MPN_CREATED_DIR) {
    156d:	3d 00 10 00 00       	cmp    $0x1000,%eax
    1572:	0f 84 0e 1a 00 00    	je     2f86 <_extract_or_test_files+0x2516>
                        d_entry->next = (*pdirlist);
                        (*pdirlist) = d_entry;
                        ++(*pnum_dirs);
                    }
#endif /* SET_DIR_ATTRIB */
                } else if (errcode == MPN_VOL_LABEL) {
    1578:	3d 00 11 00 00       	cmp    $0x1100,%eax
    157d:	0f 84 6c 15 00 00    	je     2aef <_extract_or_test_files+0x207f>
#else
                    Info(slide, 1, ((char *)slide,
                      LoadFarString(SkipVolumeLabel),
                      FnFilter1(G.filename), ""));
#endif
                } else if (errcode > MPN_INF_SKIP &&
    1583:	83 fb 01             	cmp    $0x1,%ebx
    1586:	7f 0b                	jg     1593 <_extract_or_test_files+0xb23>
    1588:	3d 00 02 00 00       	cmp    $0x200,%eax
    158d:	0f 8f e7 fc ff ff    	jg     127a <_extract_or_test_files+0x80a>
    1593:	89 5c 24 48          	mov    %ebx,0x48(%esp)
    1597:	e9 15 f9 ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
            }

#ifdef QDOS
            QFilename(__G__ G.filename);
#endif
            switch (check_for_newer(__G__ G.filename)) {
    159c:	89 74 24 04          	mov    %esi,0x4(%esp)
    15a0:	89 2c 24             	mov    %ebp,(%esp)
    15a3:	e8 00 00 00 00       	call   15a8 <_extract_or_test_files+0xb38>
    15a8:	85 c0                	test   %eax,%eax
    15aa:	0f 84 e9 1d 00 00    	je     3399 <_extract_or_test_files+0x2929>
    15b0:	83 f8 01             	cmp    $0x1,%eax
    15b3:	0f 84 1e 1d 00 00    	je     32d7 <_extract_or_test_files+0x2867>
    15b9:	40                   	inc    %eax
    15ba:	0f 84 fb 1c 00 00    	je     32bb <_extract_or_test_files+0x284b>
                    }
                    break;
                }
            if (query) {
#ifdef WINDLL
                switch (G.lpUserFunctions->replace != NULL ?
    15c0:	89 5c 24 48          	mov    %ebx,0x48(%esp)
                continue;
            }
        } /* end if (extracting to disk) */

#ifdef DLL
        if ((G.statreportcb != NULL) &&
    15c4:	8b 85 54 0b 01 00    	mov    0x10b54(%ebp),%eax
    15ca:	85 c0                	test   %eax,%eax
    15cc:	74 34                	je     1602 <_extract_or_test_files+0xb92>
            (*G.statreportcb)(__G__ UZ_ST_START_EXTRACT, G.zipfn,
                              G.filename, NULL)) {
    15ce:	8d 95 e0 09 01 00    	lea    0x109e0(%ebp),%edx
            }
        } /* end if (extracting to disk) */

#ifdef DLL
        if ((G.statreportcb != NULL) &&
            (*G.statreportcb)(__G__ UZ_ST_START_EXTRACT, G.zipfn,
    15d4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    15db:	00 
                              G.filename, NULL)) {
    15dc:	89 54 24 0c          	mov    %edx,0xc(%esp)
            }
        } /* end if (extracting to disk) */

#ifdef DLL
        if ((G.statreportcb != NULL) &&
            (*G.statreportcb)(__G__ UZ_ST_START_EXTRACT, G.zipfn,
    15e0:	8b 95 04 09 01 00    	mov    0x10904(%ebp),%edx
    15e6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    15ed:	00 
    15ee:	89 54 24 08          	mov    %edx,0x8(%esp)
    15f2:	89 2c 24             	mov    %ebp,(%esp)
    15f5:	ff d0                	call   *%eax
    15f7:	83 ec 14             	sub    $0x14,%esp
                continue;
            }
        } /* end if (extracting to disk) */

#ifdef DLL
        if ((G.statreportcb != NULL) &&
    15fa:	85 c0                	test   %eax,%eax
    15fc:	0f 85 b0 02 00 00    	jne    18b2 <_extract_or_test_files+0xe42>
        G.symlnk = TRUE;
    else
        G.symlnk = FALSE;
#endif /* SYMLINKS */

    if (uO.tflag) {
    1602:	8b 4d 44             	mov    0x44(%ebp),%ecx
        UserStop();
#endif
#ifdef AMIGA
        G.filenote_slot = i;
#endif
        G.disk_full = 0;
    1605:	c7 85 b0 09 01 00 00 	movl   $0x0,0x109b0(%ebp)
    160c:	00 00 00 

/*---------------------------------------------------------------------------
    Initialize variables, buffers, etc.
  ---------------------------------------------------------------------------*/

    G.bits_left = 0;
    160f:	c7 85 f4 08 01 00 00 	movl   $0x0,0x108f4(%ebp)
    1616:	00 00 00 
    G.bitbuf = 0L;       /* unreduce and unshrink only */
    1619:	c7 85 f0 08 01 00 00 	movl   $0x0,0x108f0(%ebp)
    1620:	00 00 00 
    G.zipeof = 0;
    1623:	c7 85 f8 08 01 00 00 	movl   $0x0,0x108f8(%ebp)
    162a:	00 00 00 
    G.newfile = TRUE;
    162d:	c7 85 b4 09 01 00 01 	movl   $0x1,0x109b4(%ebp)
    1634:	00 00 00 
    G.crc32val = CRCVAL_INITIAL;
    1637:	c7 85 e0 08 01 00 00 	movl   $0x0,0x108e0(%ebp)
    163e:	00 00 00 
        G.symlnk = TRUE;
    else
        G.symlnk = FALSE;
#endif /* SYMLINKS */

    if (uO.tflag) {
    1641:	85 c9                	test   %ecx,%ecx
    1643:	0f 84 09 08 00 00    	je     1e52 <_extract_or_test_files+0x13e2>
        if (!uO.qflag)
    1649:	8b 55 38             	mov    0x38(%ebp),%edx
    164c:	85 d2                	test   %edx,%edx
    164e:	0f 84 8f 0a 00 00    	je     20e3 <_extract_or_test_files+0x1673>

/*---------------------------------------------------------------------------
    Unpack the file.
  ---------------------------------------------------------------------------*/

    defer_leftover_input(__G);    /* so NEXTBYTE bounds check will work */
    1654:	89 2c 24             	mov    %ebp,(%esp)
    1657:	e8 00 00 00 00       	call   165c <_extract_or_test_files+0xbec>
    switch (G.lrec.compression_method) {
    165c:	8b 85 34 09 01 00    	mov    0x10934(%ebp),%eax
    1662:	66 83 f8 09          	cmp    $0x9,%ax
    1666:	0f 87 3f 07 00 00    	ja     1dab <_extract_or_test_files+0x133b>
    166c:	31 d2                	xor    %edx,%edx
    166e:	66 89 c2             	mov    %ax,%dx
    1671:	ff 24 95 58 02 00 00 	jmp    *0x258(,%edx,4)

        case DEFLATED:
#ifdef USE_DEFLATE64
        case ENHDEFLATED:
#endif
            if (!uO.tflag && QCOND2) {
    1678:	8b 4d 44             	mov    0x44(%ebp),%ecx
    167b:	85 c9                	test   %ecx,%ecx
    167d:	0f 85 8d 00 00 00    	jne    1710 <_extract_or_test_files+0xca0>
    1683:	8b 55 38             	mov    0x38(%ebp),%edx
    1686:	85 d2                	test   %edx,%edx
    1688:	0f 85 82 00 00 00    	jne    1710 <_extract_or_test_files+0xca0>
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    168e:	8b 45 14             	mov    0x14(%ebp),%eax
    1691:	bb 58 00 00 00       	mov    $0x58,%ebx
    1696:	85 c0                	test   %eax,%eax
    1698:	b8 12 00 00 00       	mov    $0x12,%eax
    169d:	0f 44 d8             	cmove  %eax,%ebx
    16a0:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    16a6:	89 c7                	mov    %eax,%edi
    16a8:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    16ac:	0f 84 00 1e 00 00    	je     34b2 <_extract_or_test_files+0x2a42>
    16b2:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    16b8:	89 44 24 04          	mov    %eax,0x4(%esp)
    16bc:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    16c2:	89 04 24             	mov    %eax,(%esp)
    16c5:	e8 a6 ee ff ff       	call   570 <_fnfilter>
    16ca:	89 5c 24 14          	mov    %ebx,0x14(%esp)
    16ce:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    16d2:	89 7c 24 10          	mov    %edi,0x10(%esp)
    16d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
    16da:	c7 44 24 08 c7 00 00 	movl   $0xc7,0x8(%esp)
    16e1:	00 
    16e2:	c7 44 24 04 0c 0a 00 	movl   $0xa0c,0x4(%esp)
    16e9:	00 
    16ea:	89 1c 24             	mov    %ebx,(%esp)
    16ed:	e8 00 00 00 00       	call   16f2 <_extract_or_test_files+0xc82>
    16f2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    16f9:	00 
    16fa:	89 44 24 08          	mov    %eax,0x8(%esp)
    16fe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1702:	89 2c 24             	mov    %ebp,(%esp)
    1705:	ff d6                	call   *%esi
    1707:	8b 85 34 09 01 00    	mov    0x10934(%ebp),%eax
    170d:	83 ec 10             	sub    $0x10,%esp
                  "" : (G.pInfo->textfile? txt : bin), uO.cflag? NEWLINE : ""));
            }
#ifndef USE_ZLIB  /* zlib's function is called inflate(), too */
#  define UZinflate inflate
#endif
            if ((r = UZinflate(__G__
    1710:	66 83 f8 09          	cmp    $0x9,%ax
    1714:	89 2c 24             	mov    %ebp,(%esp)
    1717:	0f 94 c0             	sete   %al
    171a:	25 ff 00 00 00       	and    $0xff,%eax
    171f:	89 44 24 04          	mov    %eax,0x4(%esp)
    1723:	e8 00 00 00 00       	call   1728 <_extract_or_test_files+0xcb8>
    1728:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    172c:	85 c0                	test   %eax,%eax
    172e:	0f 84 51 05 00 00    	je     1c85 <_extract_or_test_files+0x1215>
                               (G.lrec.compression_method == ENHDEFLATED)))
                != 0) {
                if (r < PK_DISK) {
    1734:	83 f8 31             	cmp    $0x31,%eax
    1737:	7f 77                	jg     17b0 <_extract_or_test_files+0xd40>
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    1739:	8b 45 38             	mov    0x38(%ebp),%eax
                        Info(slide, 0x401, ((char *)slide,
    173c:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
#endif
            if ((r = UZinflate(__G__
                               (G.lrec.compression_method == ENHDEFLATED)))
                != 0) {
                if (r < PK_DISK) {
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    1742:	85 c0                	test   %eax,%eax
    1744:	0f 85 15 1d 00 00    	jne    345f <_extract_or_test_files+0x29ef>
                          LoadFarString(NotEnoughMem) :
                          LoadFarString(InvalidComprData),
                          LoadFarStringSmall2(Inflate),
                          FnFilter1(G.filename)));
                    else
                        Info(slide, 0x401, ((char *)slide,
    174a:	ba 40 05 00 00       	mov    $0x540,%edx
    174f:	b8 5c 05 00 00       	mov    $0x55c,%eax
    1754:	83 7c 24 5c 03       	cmpl   $0x3,0x5c(%esp)
    1759:	c7 44 24 0c 38 05 00 	movl   $0x538,0xc(%esp)
    1760:	00 
    1761:	0f 45 c2             	cmovne %edx,%eax
    1764:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1768:	89 44 24 08          	mov    %eax,0x8(%esp)
    176c:	c7 44 24 04 74 05 00 	movl   $0x574,0x4(%esp)
    1773:	00 
    1774:	89 3c 24             	mov    %edi,(%esp)
    1777:	e8 00 00 00 00       	call   177c <_extract_or_test_files+0xd0c>
    177c:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1783:	00 
    1784:	89 44 24 08          	mov    %eax,0x8(%esp)
    1788:	89 7c 24 04          	mov    %edi,0x4(%esp)
    178c:	89 2c 24             	mov    %ebp,(%esp)
    178f:	ff d3                	call   *%ebx
                          LoadFarStringSmall(ErrUnzipNoFile), r == 3?
                          LoadFarString(NotEnoughMem) :
                          LoadFarString(InvalidComprData),
                          LoadFarStringSmall2(Inflate)));
                    error = (r == 3)? PK_MEM3 : PK_ERR;
    1791:	31 c0                	xor    %eax,%eax
                          LoadFarString(NotEnoughMem) :
                          LoadFarString(InvalidComprData),
                          LoadFarStringSmall2(Inflate),
                          FnFilter1(G.filename)));
                    else
                        Info(slide, 0x401, ((char *)slide,
    1793:	83 ec 10             	sub    $0x10,%esp
                          LoadFarStringSmall(ErrUnzipNoFile), r == 3?
                          LoadFarString(NotEnoughMem) :
                          LoadFarString(InvalidComprData),
                          LoadFarStringSmall2(Inflate)));
                    error = (r == 3)? PK_MEM3 : PK_ERR;
    1796:	83 7c 24 5c 03       	cmpl   $0x3,0x5c(%esp)
    179b:	0f 94 c0             	sete   %al
    179e:	8d 04 85 02 00 00 00 	lea    0x2(,%eax,4),%eax
    17a5:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    17a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#ifdef VMS                  /* VMS:  required even for stdout! (final flush) */
    if (!uO.tflag)           /* don't close NULL file */
        close_outfile(__G);
#else
#ifdef DLL
    if (!uO.tflag && (!uO.cflag || G.redirect_data)) {
    17b0:	8b 45 44             	mov    0x44(%ebp),%eax
    17b3:	85 c0                	test   %eax,%eax
    17b5:	75 1d                	jne    17d4 <_extract_or_test_files+0xd64>
    17b7:	8b 7d 14             	mov    0x14(%ebp),%edi
    17ba:	85 ff                	test   %edi,%edi
    17bc:	0f 84 06 09 00 00    	je     20c8 <_extract_or_test_files+0x1658>
    17c2:	8b b5 a0 00 00 00    	mov    0xa0(%ebp),%esi
    17c8:	85 f6                	test   %esi,%esi
    17ca:	74 08                	je     17d4 <_extract_or_test_files+0xd64>
        if (G.redirect_data)
            FINISH_REDIRECT();
    17cc:	89 2c 24             	mov    %ebp,(%esp)
    17cf:	e8 00 00 00 00       	call   17d4 <_extract_or_test_files+0xd64>
#endif /* VMS */

            /* GRR: CONVERT close_outfile() TO NON-VOID:  CHECK FOR ERRORS! */


    if (G.disk_full) {            /* set by flush() */
    17d4:	8b 85 b0 09 01 00    	mov    0x109b0(%ebp),%eax
    17da:	85 c0                	test   %eax,%eax
    17dc:	0f 84 22 08 00 00    	je     2004 <_extract_or_test_files+0x1594>
        if (G.disk_full > 1) {
    17e2:	48                   	dec    %eax
    17e3:	0f 8e 65 09 00 00    	jle    214e <_extract_or_test_files+0x16de>
            if (unlink(G.filename) != 0)
                Trace((stderr, "extract.c:  could not delete %s\n",
                  FnFilter1(G.filename)));
#else
            /* warn user about the incomplete file */
            Info(slide, 0x421, ((char *)slide, LoadFarString(FileTruncated),
    17e9:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    17ef:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    17f5:	89 44 24 04          	mov    %eax,0x4(%esp)
    17f9:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    17ff:	89 04 24             	mov    %eax,(%esp)
    1802:	e8 69 ed ff ff       	call   570 <_fnfilter>
    1807:	8b 7c 24 40          	mov    0x40(%esp),%edi
    180b:	89 44 24 08          	mov    %eax,0x8(%esp)
    180f:	c7 44 24 04 00 05 00 	movl   $0x500,0x4(%esp)
    1816:	00 
    1817:	89 3c 24             	mov    %edi,(%esp)
    181a:	e8 00 00 00 00       	call   181f <_extract_or_test_files+0xdaf>
    181f:	c7 44 24 0c 21 04 00 	movl   $0x421,0xc(%esp)
    1826:	00 
    1827:	89 44 24 08          	mov    %eax,0x8(%esp)
    182b:	89 7c 24 04          	mov    %edi,0x4(%esp)
    182f:	89 2c 24             	mov    %ebp,(%esp)
    1832:	ff d3                	call   *%ebx
    1834:	83 ec 10             	sub    $0x10,%esp
              FnFilter1(G.filename)));
#endif
            error = PK_DISK;
    1837:	c7 44 24 5c 32 00 00 	movl   $0x32,0x5c(%esp)
    183e:	00 
            error = PK_WARN;
        }
    }

    if (error > PK_WARN) {/* don't print redundant CRC error if error already */
        undefer_input(__G);
    183f:	89 2c 24             	mov    %ebp,(%esp)
    1842:	e8 00 00 00 00       	call   1847 <_extract_or_test_files+0xdd7>
    1847:	8b 54 24 5c          	mov    0x5c(%esp),%edx
    184b:	8b 44 24 48          	mov    0x48(%esp),%eax
    184f:	39 d0                	cmp    %edx,%eax
    1851:	0f 4d d0             	cmovge %eax,%edx
    1854:	89 54 24 48          	mov    %edx,0x48(%esp)
        G.disk_full = 0;
        if ((error = extract_or_test_member(__G)) != PK_COOL) {
            if (error > error_in_archive)
                error_in_archive = error;       /* ...and keep going */
#ifdef DLL
            if (G.disk_full > 1 || error_in_archive == IZ_CTRLC) {
    1858:	83 bd b0 09 01 00 01 	cmpl   $0x1,0x109b0(%ebp)
    185f:	0f 8f 8a 07 00 00    	jg     1fef <_extract_or_test_files+0x157f>
    1865:	83 fa 50             	cmp    $0x50,%edx
    1868:	0f 84 8d 07 00 00    	je     1ffb <_extract_or_test_files+0x158b>
#endif
                return error_in_archive;        /* (unless disk full) */
            }
        }
#ifdef DLL
        if ((G.statreportcb != NULL) &&
    186e:	8b 85 54 0b 01 00    	mov    0x10b54(%ebp),%eax
    1874:	85 c0                	test   %eax,%eax
    1876:	0f 84 35 f6 ff ff    	je     eb1 <_extract_or_test_files+0x441>
            (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,
                              G.filename, (zvoid *)&G.lrec.ucsize)) {
    187c:	8d 95 24 09 01 00    	lea    0x10924(%ebp),%edx
    1882:	89 54 24 10          	mov    %edx,0x10(%esp)
    1886:	8d 95 e0 09 01 00    	lea    0x109e0(%ebp),%edx
    188c:	89 54 24 0c          	mov    %edx,0xc(%esp)
                return error_in_archive;        /* (unless disk full) */
            }
        }
#ifdef DLL
        if ((G.statreportcb != NULL) &&
            (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,
    1890:	8b 95 04 09 01 00    	mov    0x10904(%ebp),%edx
    1896:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
    189d:	00 
    189e:	89 54 24 08          	mov    %edx,0x8(%esp)
    18a2:	89 2c 24             	mov    %ebp,(%esp)
    18a5:	ff d0                	call   *%eax
    18a7:	83 ec 14             	sub    $0x14,%esp
#endif
                return error_in_archive;        /* (unless disk full) */
            }
        }
#ifdef DLL
        if ((G.statreportcb != NULL) &&
    18aa:	85 c0                	test   %eax,%eax
    18ac:	0f 84 ff f5 ff ff    	je     eb1 <_extract_or_test_files+0x441>
    18b2:	b8 50 00 00 00       	mov    $0x50,%eax
    18b7:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    18bb:	39 c1                	cmp    %eax,%ecx
    18bd:	0f 4d c1             	cmovge %ecx,%eax
    18c0:	89 44 24 50          	mov    %eax,0x50(%esp)
                        error_in_archive);
        if (error != PK_COOL) {
            if (error > error_in_archive)
                error_in_archive = error;
            /* ...and keep going (unless disk full or user break) */
            if (G.disk_full > 1 || error_in_archive == IZ_CTRLC) {
    18c4:	83 bd b0 09 01 00 01 	cmpl   $0x1,0x109b0(%ebp)
    18cb:	0f 8f 8c 13 00 00    	jg     2c5d <_extract_or_test_files+0x21ed>
    18d1:	83 f8 50             	cmp    $0x50,%eax
    18d4:	0f 84 83 13 00 00    	je     2c5d <_extract_or_test_files+0x21ed>
#ifdef USE_STRM_INPUT
        fseek((FILE *)G.zipfd, cd_bufstart, SEEK_SET);
        G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);
#else /* !USE_STRM_INPUT */
        G.cur_zipfile_bufstart =
          lseek(G.zipfd, cd_bufstart, SEEK_SET);
    18da:	8b 44 24 70          	mov    0x70(%esp),%eax
    18de:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    18e5:	00 
    18e6:	89 44 24 04          	mov    %eax,0x4(%esp)
    18ea:	8b 85 08 09 01 00    	mov    0x10908(%ebp),%eax
    18f0:	89 04 24             	mov    %eax,(%esp)
    18f3:	e8 00 00 00 00       	call   18f8 <_extract_or_test_files+0xe88>

#ifdef USE_STRM_INPUT
        fseek((FILE *)G.zipfd, cd_bufstart, SEEK_SET);
        G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);
#else /* !USE_STRM_INPUT */
        G.cur_zipfile_bufstart =
    18f8:	89 85 10 09 01 00    	mov    %eax,0x10910(%ebp)
          lseek(G.zipfd, cd_bufstart, SEEK_SET);
#endif /* ?USE_STRM_INPUT */
        read(G.zipfd, (char *)G.inbuf, INBUFSIZ);  /* been here before... */
    18fe:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
    1905:	00 
    1906:	8b 85 e4 08 01 00    	mov    0x108e4(%ebp),%eax
    190c:	89 44 24 04          	mov    %eax,0x4(%esp)
    1910:	8b 85 08 09 01 00    	mov    0x10908(%ebp),%eax
    1916:	89 04 24             	mov    %eax,(%esp)
    1919:	e8 00 00 00 00       	call   191e <_extract_or_test_files+0xeae>
        G.inptr = cd_inptr;
    191e:	8b 44 24 78          	mov    0x78(%esp),%eax
    1922:	89 85 e8 08 01 00    	mov    %eax,0x108e8(%ebp)
        G.incnt = cd_incnt;
    1928:	8b 44 24 74          	mov    0x74(%esp),%eax
    192c:	89 85 ec 08 01 00    	mov    %eax,0x108ec(%ebp)
    1932:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
    1939:	83 c0 40             	add    $0x40,%eax
    193c:	89 84 24 88 00 00 00 	mov    %eax,0x88(%esp)
  ---------------------------------------------------------------------------*/

    members_processed = 0;
    no_endsig_found = FALSE;
    reached_end = FALSE;
    while (!reached_end) {
    1943:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    194a:	85 c0                	test   %eax,%eax
    194c:	0f 84 f6 f1 ff ff    	je     b48 <_extract_or_test_files+0xd8>
    Go back through saved list of directories, sort and set times/perms/UIDs
    and GIDs from the deepest level on up.
  ---------------------------------------------------------------------------*/

#ifdef SET_DIR_ATTRIB
    if (num_dirs > 0) {
    1952:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
    1959:	c7 44 24 38 01 00 00 	movl   $0x1,0x38(%esp)
    1960:	00 
    1961:	85 c0                	test   %eax,%eax
    1963:	0f 84 0b 13 00 00    	je     2c74 <_extract_or_test_files+0x2204>
        sorted_dirlist = (direntry **)malloc(num_dirs*sizeof(direntry *));
    1969:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
    1970:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    1977:	89 1c 24             	mov    %ebx,(%esp)
    197a:	e8 00 00 00 00       	call   197f <_extract_or_test_files+0xf0f>
    197f:	89 c7                	mov    %eax,%edi
        if (sorted_dirlist == (direntry **)NULL) {
    1981:	85 c0                	test   %eax,%eax
    1983:	0f 84 e0 20 00 00    	je     3a69 <_extract_or_test_files+0x2ff9>
                free(d);
            }
        } else {
            ulg ndirs_fail = 0;

            if (num_dirs == 1)
    1989:	83 bc 24 90 00 00 00 	cmpl   $0x1,0x90(%esp)
    1990:	01 
    1991:	0f 84 ff 1d 00 00    	je     3796 <_extract_or_test_files+0x2d26>
    1997:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
    199a:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
                sorted_dirlist[0] = dirlist;
            else {
                for (i = 0;  i < num_dirs;  ++i) {
                    sorted_dirlist[i] = dirlist;
    19a1:	89 08                	mov    %ecx,(%eax)
    19a3:	83 c0 04             	add    $0x4,%eax
                    dirlist = dirlist->next;
    19a6:	8b 09                	mov    (%ecx),%ecx
            ulg ndirs_fail = 0;

            if (num_dirs == 1)
                sorted_dirlist[0] = dirlist;
            else {
                for (i = 0;  i < num_dirs;  ++i) {
    19a8:	39 d0                	cmp    %edx,%eax
    19aa:	75 f5                	jne    19a1 <_extract_or_test_files+0xf31>
                    sorted_dirlist[i] = dirlist;
                    dirlist = dirlist->next;
                }
                qsort((char *)sorted_dirlist, num_dirs, sizeof(direntry *),
    19ac:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
    19b3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    19ba:	00 
    19bb:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    19c2:	00 
    19c3:	89 44 24 04          	mov    %eax,0x4(%esp)
    19c7:	89 3c 24             	mov    %edi,(%esp)
    19ca:	e8 00 00 00 00       	call   19cf <_extract_or_test_files+0xf5f>
                direntry *d = sorted_dirlist[i];

                Trace((stderr, "dir = %s\n", d->fn));
                if ((error = set_direc_attribs(__G__ d)) != PK_OK) {
                    ndirs_fail++;
                    Info(slide, 0x201, ((char *)slide,
    19cf:	8d 85 dc 08 00 00    	lea    0x8dc(%ebp),%eax
            if (error > error_in_archive)
                error_in_archive = error;
            /* ...and keep going (unless disk full or user break) */
            if (G.disk_full > 1 || error_in_archive == IZ_CTRLC) {
                /* clear reached_end to signal premature stop ... */
                reached_end = FALSE;
    19d5:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
    19dc:	00 
    19dd:	31 db                	xor    %ebx,%ebx
                direntry *d = sorted_dirlist[i];

                Trace((stderr, "dir = %s\n", d->fn));
                if ((error = set_direc_attribs(__G__ d)) != PK_OK) {
                    ndirs_fail++;
                    Info(slide, 0x201, ((char *)slide,
    19df:	89 44 24 40          	mov    %eax,0x40(%esp)
    19e3:	eb 16                	jmp    19fb <_extract_or_test_files+0xf8b>
                      LoadFarString(DirlistSetAttrFailed), d->fn));
                    if (!error_in_archive)
                        error_in_archive = error;
                }
                free(d);
    19e5:	89 34 24             	mov    %esi,(%esp)
                qsort((char *)sorted_dirlist, num_dirs, sizeof(direntry *),
                  dircomp);
            }

            Trace((stderr, "setting directory times/perms/attributes\n"));
            for (i = 0;  i < num_dirs;  ++i) {
    19e8:	43                   	inc    %ebx
                    Info(slide, 0x201, ((char *)slide,
                      LoadFarString(DirlistSetAttrFailed), d->fn));
                    if (!error_in_archive)
                        error_in_archive = error;
                }
                free(d);
    19e9:	e8 00 00 00 00       	call   19ee <_extract_or_test_files+0xf7e>
                qsort((char *)sorted_dirlist, num_dirs, sizeof(direntry *),
                  dircomp);
            }

            Trace((stderr, "setting directory times/perms/attributes\n"));
            for (i = 0;  i < num_dirs;  ++i) {
    19ee:	3b 9c 24 90 00 00 00 	cmp    0x90(%esp),%ebx
    19f5:	0f 84 9a 1c 00 00    	je     3695 <_extract_or_test_files+0x2c25>
                direntry *d = sorted_dirlist[i];
    19fb:	8b 34 9f             	mov    (%edi,%ebx,4),%esi

                Trace((stderr, "dir = %s\n", d->fn));
                if ((error = set_direc_attribs(__G__ d)) != PK_OK) {
    19fe:	89 2c 24             	mov    %ebp,(%esp)
    1a01:	89 74 24 04          	mov    %esi,0x4(%esp)
    1a05:	e8 00 00 00 00       	call   1a0a <_extract_or_test_files+0xf9a>
    1a0a:	85 c0                	test   %eax,%eax
    1a0c:	74 d7                	je     19e5 <_extract_or_test_files+0xf75>
    1a0e:	89 44 24 48          	mov    %eax,0x48(%esp)
                    ndirs_fail++;
    1a12:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    1a16:	40                   	inc    %eax
    1a17:	89 44 24 3c          	mov    %eax,0x3c(%esp)
                    Info(slide, 0x201, ((char *)slide,
    1a1b:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    1a21:	89 44 24 44          	mov    %eax,0x44(%esp)
    1a25:	8b 46 04             	mov    0x4(%esi),%eax
    1a28:	89 44 24 08          	mov    %eax,0x8(%esp)
    1a2c:	8b 44 24 40          	mov    0x40(%esp),%eax
    1a30:	c7 44 24 04 40 08 00 	movl   $0x840,0x4(%esp)
    1a37:	00 
    1a38:	89 04 24             	mov    %eax,(%esp)
    1a3b:	e8 00 00 00 00       	call   1a40 <_extract_or_test_files+0xfd0>
    1a40:	c7 44 24 0c 01 02 00 	movl   $0x201,0xc(%esp)
    1a47:	00 
    1a48:	89 44 24 08          	mov    %eax,0x8(%esp)
    1a4c:	8b 44 24 40          	mov    0x40(%esp),%eax
    1a50:	89 44 24 04          	mov    %eax,0x4(%esp)
    1a54:	89 2c 24             	mov    %ebp,(%esp)
    1a57:	ff 54 24 44          	call   *0x44(%esp)
    1a5b:	83 ec 10             	sub    $0x10,%esp
                      LoadFarString(DirlistSetAttrFailed), d->fn));
                    if (!error_in_archive)
    1a5e:	8b 44 24 50          	mov    0x50(%esp),%eax
    1a62:	8b 4c 24 48          	mov    0x48(%esp),%ecx
    1a66:	85 c0                	test   %eax,%eax
    1a68:	0f 45 c8             	cmovne %eax,%ecx
    1a6b:	89 4c 24 50          	mov    %ecx,0x50(%esp)
    1a6f:	e9 71 ff ff ff       	jmp    19e5 <_extract_or_test_files+0xf75>
            }
            break;
#endif /* !COPYRIGHT_CLEAN */

        case IMPLODED:
            if (!uO.tflag && QCOND2) {
    1a74:	8b 45 44             	mov    0x44(%ebp),%eax
    1a77:	85 c0                	test   %eax,%eax
    1a79:	0f 85 83 00 00 00    	jne    1b02 <_extract_or_test_files+0x1092>
    1a7f:	8b 45 38             	mov    0x38(%ebp),%eax
    1a82:	85 c0                	test   %eax,%eax
    1a84:	75 7c                	jne    1b02 <_extract_or_test_files+0x1092>
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    1a86:	8b 7d 14             	mov    0x14(%ebp),%edi
    1a89:	b8 12 00 00 00       	mov    $0x12,%eax
    1a8e:	bb 58 00 00 00       	mov    $0x58,%ebx
    1a93:	85 ff                	test   %edi,%edi
    1a95:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    1a9b:	89 c7                	mov    %eax,%edi
    1a9d:	0f 44 d8             	cmove  %eax,%ebx
    1aa0:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    1aa4:	0f 84 99 19 00 00    	je     3443 <_extract_or_test_files+0x29d3>
    1aaa:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    1ab0:	89 44 24 04          	mov    %eax,0x4(%esp)
    1ab4:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    1aba:	89 04 24             	mov    %eax,(%esp)
    1abd:	e8 ae ea ff ff       	call   570 <_fnfilter>
    1ac2:	89 5c 24 14          	mov    %ebx,0x14(%esp)
    1ac6:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    1aca:	89 7c 24 10          	mov    %edi,0x10(%esp)
    1ace:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1ad2:	c7 44 24 08 b7 00 00 	movl   $0xb7,0x8(%esp)
    1ad9:	00 
    1ada:	c7 44 24 04 0c 0a 00 	movl   $0xa0c,0x4(%esp)
    1ae1:	00 
    1ae2:	89 1c 24             	mov    %ebx,(%esp)
    1ae5:	e8 00 00 00 00       	call   1aea <_extract_or_test_files+0x107a>
    1aea:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1af1:	00 
    1af2:	89 44 24 08          	mov    %eax,0x8(%esp)
    1af6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1afa:	89 2c 24             	mov    %ebp,(%esp)
    1afd:	ff d6                	call   *%esi
    1aff:	83 ec 10             	sub    $0x10,%esp
                  "explod", FnFilter1(G.filename),
                  (uO.aflag != 1 /* && G.pInfo->textfile==G.pInfo->textmode */)?
                  "" : (G.pInfo->textfile? txt : bin), uO.cflag? NEWLINE : ""));
            }
            if (((r = explode(__G)) != 0) && (r != 5)) { /* treat 5 specially */
    1b02:	89 2c 24             	mov    %ebp,(%esp)
    1b05:	e8 00 00 00 00       	call   1b0a <_extract_or_test_files+0x109a>
    1b0a:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    1b0e:	85 c0                	test   %eax,%eax
    1b10:	0f 84 6f 01 00 00    	je     1c85 <_extract_or_test_files+0x1215>
    1b16:	83 f8 05             	cmp    $0x5,%eax
    1b19:	0f 84 29 10 00 00    	je     2b48 <_extract_or_test_files+0x20d8>
                if (r < PK_DISK) {
    1b1f:	83 f8 31             	cmp    $0x31,%eax
    1b22:	0f 8f 88 fc ff ff    	jg     17b0 <_extract_or_test_files+0xd40>
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    1b28:	8b 5d 38             	mov    0x38(%ebp),%ebx
    1b2b:	85 db                	test   %ebx,%ebx
                        Info(slide, 0x401, ((char *)slide,
    1b2d:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
                  (uO.aflag != 1 /* && G.pInfo->textfile==G.pInfo->textmode */)?
                  "" : (G.pInfo->textfile? txt : bin), uO.cflag? NEWLINE : ""));
            }
            if (((r = explode(__G)) != 0) && (r != 5)) { /* treat 5 specially */
                if (r < PK_DISK) {
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    1b33:	0f 85 15 1a 00 00    	jne    354e <_extract_or_test_files+0x2ade>
                          LoadFarString(NotEnoughMem) :
                          LoadFarString(InvalidComprData),
                          LoadFarStringSmall2(Explode),
                          FnFilter1(G.filename)));
                    else
                        Info(slide, 0x401, ((char *)slide,
    1b39:	ba 40 05 00 00       	mov    $0x540,%edx
    1b3e:	b8 5c 05 00 00       	mov    $0x55c,%eax
    1b43:	83 7c 24 5c 03       	cmpl   $0x3,0x5c(%esp)
    1b48:	c7 44 24 0c 30 05 00 	movl   $0x530,0xc(%esp)
    1b4f:	00 
    1b50:	0f 45 c2             	cmovne %edx,%eax
    1b53:	e9 0c fc ff ff       	jmp    1764 <_extract_or_test_files+0xcf4>
  ---------------------------------------------------------------------------*/

    defer_leftover_input(__G);    /* so NEXTBYTE bounds check will work */
    switch (G.lrec.compression_method) {
        case STORED:
            if (!uO.tflag && QCOND2) {
    1b58:	8b 45 44             	mov    0x44(%ebp),%eax
    1b5b:	85 c0                	test   %eax,%eax
    1b5d:	0f 85 83 00 00 00    	jne    1be6 <_extract_or_test_files+0x1176>
    1b63:	8b 45 38             	mov    0x38(%ebp),%eax
    1b66:	85 c0                	test   %eax,%eax
    1b68:	75 7c                	jne    1be6 <_extract_or_test_files+0x1176>
                if (G.symlnk)   /* can also be deflated, but rarer... */
                    Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
                      "link", FnFilter1(G.filename), "", ""));
                else
#endif /* SYMLINKS */
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    1b6a:	8b 45 14             	mov    0x14(%ebp),%eax
    1b6d:	bf 58 00 00 00       	mov    $0x58,%edi
    1b72:	85 c0                	test   %eax,%eax
    1b74:	b8 12 00 00 00       	mov    $0x12,%eax
    1b79:	0f 44 f8             	cmove  %eax,%edi
    1b7c:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    1b82:	89 c3                	mov    %eax,%ebx
    1b84:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    1b88:	0f 84 86 18 00 00    	je     3414 <_extract_or_test_files+0x29a4>
    1b8e:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    1b94:	89 44 24 04          	mov    %eax,0x4(%esp)
    1b98:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    1b9e:	89 04 24             	mov    %eax,(%esp)
    1ba1:	e8 ca e9 ff ff       	call   570 <_fnfilter>
    1ba6:	89 5c 24 10          	mov    %ebx,0x10(%esp)
    1baa:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    1bae:	89 7c 24 14          	mov    %edi,0x14(%esp)
    1bb2:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1bb6:	c7 44 24 08 af 00 00 	movl   $0xaf,0x8(%esp)
    1bbd:	00 
    1bbe:	c7 44 24 04 0c 0a 00 	movl   $0xa0c,0x4(%esp)
    1bc5:	00 
    1bc6:	89 1c 24             	mov    %ebx,(%esp)
    1bc9:	e8 00 00 00 00       	call   1bce <_extract_or_test_files+0x115e>
    1bce:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1bd5:	00 
    1bd6:	89 44 24 08          	mov    %eax,0x8(%esp)
    1bda:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1bde:	89 2c 24             	mov    %ebp,(%esp)
    1be1:	ff d6                	call   *%esi
    1be3:	83 ec 10             	sub    $0x10,%esp
                  (uO.aflag != 1 /* && G.pInfo->textfile==G.pInfo->textmode */)?
                  "" : (G.lrec.ucsize == 0L? nul : (G.pInfo->textfile? txt :
                  bin)), uO.cflag? NEWLINE : ""));
            }
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
            if (G.redirect_slide) {
    1be6:	8b 8d a8 00 00 00    	mov    0xa8(%ebp),%ecx
    1bec:	85 c9                	test   %ecx,%ecx
    1bee:	0f 84 0c 09 00 00    	je     2500 <_extract_or_test_files+0x1a90>
                wsize = G.redirect_size; redirSlide = G.redirect_buffer;
    1bf4:	8b 85 b4 00 00 00    	mov    0xb4(%ebp),%eax
    1bfa:	8b 9d b0 00 00 00    	mov    0xb0(%ebp),%ebx
    1c00:	89 85 bc 00 00 00    	mov    %eax,0xbc(%ebp)
            } else {
                wsize = WSIZE; redirSlide = slide;
            }
#endif
            G.outptr = redirSlide;
    1c06:	89 85 d8 09 01 00    	mov    %eax,0x109d8(%ebp)
            G.outcnt = 0L;
    1c0c:	c7 85 dc 09 01 00 00 	movl   $0x0,0x109dc(%ebp)
    1c13:	00 00 00 
    1c16:	eb 3f                	jmp    1c57 <_extract_or_test_files+0x11e7>
            while ((b = NEXTBYTE) != EOF) {
    1c18:	8b 85 e8 08 01 00    	mov    0x108e8(%ebp),%eax
    1c1e:	8d 50 01             	lea    0x1(%eax),%edx
    1c21:	89 95 e8 08 01 00    	mov    %edx,0x108e8(%ebp)
    1c27:	8a 08                	mov    (%eax),%cl
    1c29:	81 e1 ff 00 00 00    	and    $0xff,%ecx
    1c2f:	89 c8                	mov    %ecx,%eax
                *G.outptr++ = (uch)b;
    1c31:	8b 95 d8 09 01 00    	mov    0x109d8(%ebp),%edx
    1c37:	8d 4a 01             	lea    0x1(%edx),%ecx
    1c3a:	89 8d d8 09 01 00    	mov    %ecx,0x109d8(%ebp)
    1c40:	88 02                	mov    %al,(%edx)
                if (++G.outcnt == wsize) {
    1c42:	8b 85 dc 09 01 00    	mov    0x109dc(%ebp),%eax
    1c48:	40                   	inc    %eax
    1c49:	89 85 dc 09 01 00    	mov    %eax,0x109dc(%ebp)
    1c4f:	39 d8                	cmp    %ebx,%eax
    1c51:	0f 84 51 06 00 00    	je     22a8 <_extract_or_test_files+0x1838>
                wsize = WSIZE; redirSlide = slide;
            }
#endif
            G.outptr = redirSlide;
            G.outcnt = 0L;
            while ((b = NEXTBYTE) != EOF) {
    1c57:	8b 85 ec 08 01 00    	mov    0x108ec(%ebp),%eax
    1c5d:	85 c0                	test   %eax,%eax
    1c5f:	8d 50 ff             	lea    -0x1(%eax),%edx
    1c62:	89 95 ec 08 01 00    	mov    %edx,0x108ec(%ebp)
    1c68:	7f ae                	jg     1c18 <_extract_or_test_files+0x11a8>
    1c6a:	89 2c 24             	mov    %ebp,(%esp)
    1c6d:	e8 00 00 00 00       	call   1c72 <_extract_or_test_files+0x1202>
    1c72:	83 f8 ff             	cmp    $0xffffffff,%eax
    1c75:	75 ba                	jne    1c31 <_extract_or_test_files+0x11c1>
                    G.outptr = redirSlide;
                    G.outcnt = 0L;
                    if (error != PK_COOL || G.disk_full) break;
                }
            }
            if (G.outcnt)          /* flush final (partial) buffer */
    1c77:	8b 85 dc 09 01 00    	mov    0x109dc(%ebp),%eax
    1c7d:	85 c0                	test   %eax,%eax
    1c7f:	0f 85 34 0b 00 00    	jne    27b9 <_extract_or_test_files+0x1d49>
                          LoadFarString(NotEnoughMem) :
                          LoadFarString(InvalidComprData),
                          LoadFarStringSmall2(Inflate),
                          FnFilter1(G.filename)));
                    else
                        Info(slide, 0x401, ((char *)slide,
    1c85:	c7 44 24 5c 00 00 00 	movl   $0x0,0x5c(%esp)
    1c8c:	00 
    1c8d:	e9 1e fb ff ff       	jmp    17b0 <_extract_or_test_files+0xd40>
            break;

#ifndef SFX
#ifndef LZW_CLEAN
        case SHRUNK:
            if (!uO.tflag && QCOND2) {
    1c92:	8b 45 44             	mov    0x44(%ebp),%eax
    1c95:	85 c0                	test   %eax,%eax
    1c97:	0f 85 83 00 00 00    	jne    1d20 <_extract_or_test_files+0x12b0>
    1c9d:	8b 45 38             	mov    0x38(%ebp),%eax
    1ca0:	85 c0                	test   %eax,%eax
    1ca2:	75 7c                	jne    1d20 <_extract_or_test_files+0x12b0>
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    1ca4:	8b 45 14             	mov    0x14(%ebp),%eax
    1ca7:	bb 58 00 00 00       	mov    $0x58,%ebx
    1cac:	85 c0                	test   %eax,%eax
    1cae:	b8 12 00 00 00       	mov    $0x12,%eax
    1cb3:	0f 44 d8             	cmove  %eax,%ebx
    1cb6:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    1cbc:	89 c7                	mov    %eax,%edi
    1cbe:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    1cc2:	0f 84 30 17 00 00    	je     33f8 <_extract_or_test_files+0x2988>
    1cc8:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    1cce:	89 44 24 04          	mov    %eax,0x4(%esp)
    1cd2:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    1cd8:	89 04 24             	mov    %eax,(%esp)
    1cdb:	e8 90 e8 ff ff       	call   570 <_fnfilter>
    1ce0:	89 5c 24 14          	mov    %ebx,0x14(%esp)
    1ce4:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    1ce8:	89 7c 24 10          	mov    %edi,0x10(%esp)
    1cec:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1cf0:	c7 44 24 08 24 05 00 	movl   $0x524,0x8(%esp)
    1cf7:	00 
    1cf8:	c7 44 24 04 0c 0a 00 	movl   $0xa0c,0x4(%esp)
    1cff:	00 
    1d00:	89 1c 24             	mov    %ebx,(%esp)
    1d03:	e8 00 00 00 00       	call   1d08 <_extract_or_test_files+0x1298>
    1d08:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1d0f:	00 
    1d10:	89 44 24 08          	mov    %eax,0x8(%esp)
    1d14:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1d18:	89 2c 24             	mov    %ebp,(%esp)
    1d1b:	ff d6                	call   *%esi
    1d1d:	83 ec 10             	sub    $0x10,%esp
                  LoadFarStringSmall(Unshrink), FnFilter1(G.filename),
                  (uO.aflag != 1 /* && G.pInfo->textfile==G.pInfo->textmode */)?
                  "" : (G.pInfo->textfile? txt : bin), uO.cflag? NEWLINE : ""));
            }
            if ((r = unshrink(__G)) != PK_COOL) {
    1d20:	89 2c 24             	mov    %ebp,(%esp)
    1d23:	e8 00 00 00 00       	call   1d28 <_extract_or_test_files+0x12b8>
    1d28:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    1d2c:	85 c0                	test   %eax,%eax
    1d2e:	0f 84 51 ff ff ff    	je     1c85 <_extract_or_test_files+0x1215>
                if (r < PK_DISK) {
    1d34:	83 f8 31             	cmp    $0x31,%eax
    1d37:	0f 8f 73 fa ff ff    	jg     17b0 <_extract_or_test_files+0xd40>
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    1d3d:	8b 45 38             	mov    0x38(%ebp),%eax
                        Info(slide, 0x401, ((char *)slide,
    1d40:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
                  (uO.aflag != 1 /* && G.pInfo->textfile==G.pInfo->textmode */)?
                  "" : (G.pInfo->textfile? txt : bin), uO.cflag? NEWLINE : ""));
            }
            if ((r = unshrink(__G)) != PK_COOL) {
                if (r < PK_DISK) {
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    1d46:	85 c0                	test   %eax,%eax
    1d48:	0f 84 ae 0e 00 00    	je     2bfc <_extract_or_test_files+0x218c>
                        Info(slide, 0x401, ((char *)slide,
    1d4e:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    1d54:	89 44 24 04          	mov    %eax,0x4(%esp)
    1d58:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    1d5e:	89 04 24             	mov    %eax,(%esp)
    1d61:	e8 0a e8 ff ff       	call   570 <_fnfilter>
    1d66:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1d6a:	89 44 24 10          	mov    %eax,0x10(%esp)
    1d6e:	c7 44 24 0c 24 05 00 	movl   $0x524,0xc(%esp)
    1d75:	00 
    1d76:	c7 44 24 08 5c 05 00 	movl   $0x55c,0x8(%esp)
    1d7d:	00 
    1d7e:	c7 44 24 04 88 05 00 	movl   $0x588,0x4(%esp)
    1d85:	00 
    1d86:	89 3c 24             	mov    %edi,(%esp)
    1d89:	e8 00 00 00 00       	call   1d8e <_extract_or_test_files+0x131e>
                          LoadFarStringSmall(ErrUnzipFile),
                          LoadFarString(NotEnoughMem),
                          LoadFarStringSmall2(Unshrink),
                          FnFilter1(G.filename)));
                    else
                        Info(slide, 0x401, ((char *)slide,
    1d8e:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1d95:	00 
    1d96:	89 44 24 08          	mov    %eax,0x8(%esp)
    1d9a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1d9e:	89 2c 24             	mov    %ebp,(%esp)
    1da1:	ff d3                	call   *%ebx
    1da3:	83 ec 10             	sub    $0x10,%esp
    1da6:	e9 05 fa ff ff       	jmp    17b0 <_extract_or_test_files+0xd40>
                }
            }
            break;

        default:   /* should never get to this point */
            Info(slide, 0x401, ((char *)slide,
    1dab:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    1db1:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1db7:	89 44 24 04          	mov    %eax,0x4(%esp)
    1dbb:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    1dc1:	89 04 24             	mov    %eax,(%esp)
    1dc4:	e8 a7 e7 ff ff       	call   570 <_fnfilter>
    1dc9:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1dcd:	89 44 24 08          	mov    %eax,0x8(%esp)
    1dd1:	c7 44 24 04 c0 04 00 	movl   $0x4c0,0x4(%esp)
    1dd8:	00 
    1dd9:	89 3c 24             	mov    %edi,(%esp)
    1ddc:	e8 00 00 00 00       	call   1de1 <_extract_or_test_files+0x1371>
    1de1:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1de8:	00 
    1de9:	89 44 24 08          	mov    %eax,0x8(%esp)
    1ded:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1df1:	89 2c 24             	mov    %ebp,(%esp)
    1df4:	ff d3                	call   *%ebx
    1df6:	83 ec 10             	sub    $0x10,%esp
              LoadFarString(FileUnknownCompMethod), FnFilter1(G.filename)));
            /* close and delete file before return? */
            undefer_input(__G);
    1df9:	89 2c 24             	mov    %ebp,(%esp)
    1dfc:	e8 00 00 00 00       	call   1e01 <_extract_or_test_files+0x1391>
            return PK_WARN;
    1e01:	ba 01 00 00 00       	mov    $0x1,%edx
    1e06:	e9 40 fa ff ff       	jmp    184b <_extract_or_test_files+0xddb>
    1e0b:	90                   	nop
    1e0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            G.cur_zipfile_bufstart =
              lseek(G.zipfd, bufstart, SEEK_SET);
#endif /* ?USE_STRM_INPUT */
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            {
                Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
    1e10:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1e16:	8b 44 24 34          	mov    0x34(%esp),%eax
    1e1a:	89 7c 24 10          	mov    %edi,0x10(%esp)
    1e1e:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1e22:	c7 44 24 0c 9a 00 00 	movl   $0x9a,0xc(%esp)
    1e29:	00 
    1e2a:	89 44 24 08          	mov    %eax,0x8(%esp)
    1e2e:	c7 44 24 04 20 0a 00 	movl   $0xa20,0x4(%esp)
    1e35:	00 
    1e36:	89 3c 24             	mov    %edi,(%esp)
    1e39:	e8 00 00 00 00       	call   1e3e <_extract_or_test_files+0x13ce>
    1e3e:	e9 f1 f3 ff ff       	jmp    1234 <_extract_or_test_files+0x7c4>
                  LoadFarString(AttemptRecompensate)));
                if (G.extra_bytes) {
                    *pold_extra_bytes = G.extra_bytes;
                    G.extra_bytes = 0L;
                } else
                    G.extra_bytes = *pold_extra_bytes; /* third attempt */
    1e43:	8b 44 24 54          	mov    0x54(%esp),%eax
    1e47:	89 85 14 09 01 00    	mov    %eax,0x10914(%ebp)
    1e4d:	e9 27 f6 ff ff       	jmp    1479 <_extract_or_test_files+0xa09>
        if (!uO.qflag)
            Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg), "test",
              FnFilter1(G.filename), "", ""));
    } else {
#ifdef DLL
        if (uO.cflag && !G.redirect_data)
    1e52:	8b 45 14             	mov    0x14(%ebp),%eax
    1e55:	85 c0                	test   %eax,%eax
    1e57:	74 0e                	je     1e67 <_extract_or_test_files+0x13f7>
    1e59:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
    1e5f:	85 c0                	test   %eax,%eax
    1e61:	0f 84 90 04 00 00    	je     22f7 <_extract_or_test_files+0x1887>
#endif /* ?DOS_FLX_NLM_OS2_W32 */
#ifdef VMS
            if (open_outfile(__G))   /* VMS:  required even for stdout! */
                return PK_DISK;
#endif
        } else if (open_outfile(__G))
    1e67:	89 2c 24             	mov    %ebp,(%esp)
    1e6a:	e8 00 00 00 00       	call   1e6f <_extract_or_test_files+0x13ff>
            return PK_DISK;
    1e6f:	ba 32 00 00 00       	mov    $0x32,%edx
#endif /* ?DOS_FLX_NLM_OS2_W32 */
#ifdef VMS
            if (open_outfile(__G))   /* VMS:  required even for stdout! */
                return PK_DISK;
#endif
        } else if (open_outfile(__G))
    1e74:	85 c0                	test   %eax,%eax
    1e76:	0f 85 cf f9 ff ff    	jne    184b <_extract_or_test_files+0xddb>
    1e7c:	e9 d3 f7 ff ff       	jmp    1654 <_extract_or_test_files+0xbe4>
                        (long)request));
                    error_in_archive = PK_BADERR;
                    continue;   /* but can still try next one */
                }
                if (strncmp(G.sig, local_hdr_sig, 4)) {
                    Info(slide, 0x401, ((char *)slide,
    1e81:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    1e87:	89 5c 24 10          	mov    %ebx,0x10(%esp)
    1e8b:	c7 44 24 0c 5c 09 00 	movl   $0x95c,0xc(%esp)
    1e92:	00 
    1e93:	e9 18 f6 ff ff       	jmp    14b0 <_extract_or_test_files+0xa40>
                zfstrcpy((char Far *)temp_cfilnam, G.pInfo->cfilname);
#    define  cFile_PrintBuf  temp_cfilnam
#  else
#    define  cFile_PrintBuf  G.pInfo->cfilname
#  endif
                Info(slide, 0x401, ((char *)slide,
    1e98:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    1e9e:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1ea4:	89 44 24 04          	mov    %eax,0x4(%esp)
    1ea8:	89 34 24             	mov    %esi,(%esp)
    1eab:	e8 c0 e6 ff ff       	call   570 <_fnfilter>
    1eb0:	89 c7                	mov    %eax,%edi
    1eb2:	8d 85 dc c8 00 00    	lea    0xc8dc(%ebp),%eax
    1eb8:	89 44 24 04          	mov    %eax,0x4(%esp)
    1ebc:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    1ec2:	8b 40 1c             	mov    0x1c(%eax),%eax
    1ec5:	89 04 24             	mov    %eax,(%esp)
    1ec8:	e8 a3 e6 ff ff       	call   570 <_fnfilter>
    1ecd:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    1ed1:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1ed5:	89 44 24 08          	mov    %eax,0x8(%esp)
    1ed9:	c7 44 24 04 00 0b 00 	movl   $0xb00,0x4(%esp)
    1ee0:	00 
    1ee1:	89 3c 24             	mov    %edi,(%esp)
    1ee4:	e8 00 00 00 00       	call   1ee9 <_extract_or_test_files+0x1479>
    1ee9:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1ef0:	00 
    1ef1:	89 44 24 08          	mov    %eax,0x8(%esp)
    1ef5:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1ef9:	89 2c 24             	mov    %ebp,(%esp)
    1efc:	ff d3                	call   *%ebx
                  LoadFarStringSmall2(LvsCFNamMsg),
                  FnFilter2(cFile_PrintBuf), FnFilter1(G.filename)));
#  undef    cFile_PrintBuf
                zfstrcpy(G.filename, G.pInfo->cfilname);
    1efe:	8b 9d d8 08 00 00    	mov    0x8d8(%ebp),%ebx
                zfstrcpy((char Far *)temp_cfilnam, G.pInfo->cfilname);
#    define  cFile_PrintBuf  temp_cfilnam
#  else
#    define  cFile_PrintBuf  G.pInfo->cfilname
#  endif
                Info(slide, 0x401, ((char *)slide,
    1f04:	83 ec 10             	sub    $0x10,%esp
                  LoadFarStringSmall2(LvsCFNamMsg),
                  FnFilter2(cFile_PrintBuf), FnFilter1(G.filename)));
#  undef    cFile_PrintBuf
                zfstrcpy(G.filename, G.pInfo->cfilname);
    1f07:	8b 43 1c             	mov    0x1c(%ebx),%eax
    1f0a:	89 44 24 04          	mov    %eax,0x4(%esp)
    1f0e:	89 34 24             	mov    %esi,(%esp)
    1f11:	e8 00 00 00 00       	call   1f16 <_extract_or_test_files+0x14a6>
                if (error_in_archive < PK_WARN)
    1f16:	8b 44 24 48          	mov    0x48(%esp),%eax
    1f1a:	8b 5b 1c             	mov    0x1c(%ebx),%ebx
    1f1d:	85 c0                	test   %eax,%eax
    1f1f:	0f 8f 89 f3 ff ff    	jg     12ae <_extract_or_test_files+0x83e>
                    error_in_archive = PK_WARN;
    1f25:	c7 44 24 48 01 00 00 	movl   $0x1,0x48(%esp)
    1f2c:	00 
    1f2d:	e9 7c f3 ff ff       	jmp    12ae <_extract_or_test_files+0x83e>
                continue;   /* go on */
            }
        }

#if CRYPT
        if (G.pInfo->encrypted &&
    1f32:	8b 45 08             	mov    0x8(%ebp),%eax
    1f35:	89 2c 24             	mov    %ebp,(%esp)
    1f38:	89 44 24 04          	mov    %eax,0x4(%esp)
    1f3c:	e8 00 00 00 00       	call   1f41 <_extract_or_test_files+0x14d1>
    1f41:	85 c0                	test   %eax,%eax
    1f43:	0f 84 a7 f5 ff ff    	je     14f0 <_extract_or_test_files+0xa80>
            (error = decrypt(__G__ uO.pwdarg)) != PK_COOL) {
            if (error == PK_WARN) {
    1f49:	83 f8 01             	cmp    $0x1,%eax
    1f4c:	0f 84 f3 06 00 00    	je     2645 <_extract_or_test_files+0x1bd5>
    1f52:	8b 54 24 48          	mov    0x48(%esp),%edx
                      FnFilter1(G.filename)));
                ++(*pnum_bad_pwd);
            } else {  /* (error > PK_WARN) */
                if (error > error_in_archive)
                    error_in_archive = error;
                Info(slide, 0x401, ((char *)slide,
    1f56:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1f5c:	39 c2                	cmp    %eax,%edx
    1f5e:	0f 4d c2             	cmovge %edx,%eax
    1f61:	89 44 24 48          	mov    %eax,0x48(%esp)
    1f65:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    1f6b:	89 44 24 04          	mov    %eax,0x4(%esp)
    1f6f:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    1f75:	89 04 24             	mov    %eax,(%esp)
    1f78:	e8 f3 e5 ff ff       	call   570 <_fnfilter>
    1f7d:	8b 7c 24 40          	mov    0x40(%esp),%edi
    1f81:	89 44 24 08          	mov    %eax,0x8(%esp)
    1f85:	c7 44 24 04 00 07 00 	movl   $0x700,0x4(%esp)
    1f8c:	00 
    1f8d:	89 3c 24             	mov    %edi,(%esp)
    1f90:	e8 00 00 00 00       	call   1f95 <_extract_or_test_files+0x1525>
    1f95:	e9 3d f1 ff ff       	jmp    10d7 <_extract_or_test_files+0x667>

        while ((j < DIR_BLKSIZ)) {
            G.pInfo = &G.info[j];

            if (readbuf(__G__ G.sig, 4) == 0) {
                error_in_archive = PK_EOF;
    1f9a:	c7 44 24 50 33 00 00 	movl   $0x33,0x50(%esp)
    1fa1:	00 
                reached_end = TRUE;     /* ...so no more left to do */
    1fa2:	c7 84 24 80 00 00 00 	movl   $0x1,0x80(%esp)
    1fa9:	01 00 00 00 
            members_processed++;

        } /* end while-loop (adding files to current block) */

        /* save position in central directory so can come back later */
        cd_bufstart = G.cur_zipfile_bufstart;
    1fad:	8b 85 10 09 01 00    	mov    0x10910(%ebp),%eax
    /*-----------------------------------------------------------------------
        Second loop:  process files in current block, extracting or testing
        each one.
      -----------------------------------------------------------------------*/

    for (i = 0; i < numchunk; ++i) {
    1fb3:	8b 5c 24 48          	mov    0x48(%esp),%ebx
            members_processed++;

        } /* end while-loop (adding files to current block) */

        /* save position in central directory so can come back later */
        cd_bufstart = G.cur_zipfile_bufstart;
    1fb7:	89 44 24 70          	mov    %eax,0x70(%esp)
        cd_inptr = G.inptr;
    1fbb:	8b 85 e8 08 01 00    	mov    0x108e8(%ebp),%eax
    1fc1:	89 44 24 78          	mov    %eax,0x78(%esp)
        cd_incnt = G.incnt;
    1fc5:	8b 85 ec 08 01 00    	mov    0x108ec(%ebp),%eax
    1fcb:	89 44 24 74          	mov    %eax,0x74(%esp)
    /*-----------------------------------------------------------------------
        Second loop:  process files in current block, extracting or testing
        each one.
      -----------------------------------------------------------------------*/

    for (i = 0; i < numchunk; ++i) {
    1fcf:	85 db                	test   %ebx,%ebx
    1fd1:	0f 85 9c ed ff ff    	jne    d73 <_extract_or_test_files+0x303>
    1fd7:	8b 44 24 50          	mov    0x50(%esp),%eax
    1fdb:	89 44 24 48          	mov    %eax,0x48(%esp)
    1fdf:	8b 44 24 34          	mov    0x34(%esp),%eax
    1fe3:	89 44 24 4c          	mov    %eax,0x4c(%esp)
    1fe7:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    1feb:	89 44 24 34          	mov    %eax,0x34(%esp)
                        &filnum, &num_bad_pwd, &old_extra_bytes,
#ifdef SET_DIR_ATTRIB
                        &num_dirs, &dirlist,
#endif
                        error_in_archive);
        if (error != PK_COOL) {
    1fef:	8b 54 24 48          	mov    0x48(%esp),%edx
    1ff3:	85 d2                	test   %edx,%edx
    1ff5:	0f 84 df f8 ff ff    	je     18da <_extract_or_test_files+0xe6a>
    1ffb:	8b 44 24 48          	mov    0x48(%esp),%eax
    1fff:	e9 b3 f8 ff ff       	jmp    18b7 <_extract_or_test_files+0xe47>
        } else {
            error = PK_WARN;
        }
    }

    if (error > PK_WARN) {/* don't print redundant CRC error if error already */
    2004:	83 7c 24 5c 01       	cmpl   $0x1,0x5c(%esp)
    2009:	0f 8f 30 f8 ff ff    	jg     183f <_extract_or_test_files+0xdcf>
        undefer_input(__G);
        return error;
    }
    if (G.crc32val != G.lrec.crc32) {
    200f:	8b 85 e0 08 01 00    	mov    0x108e0(%ebp),%eax
    2015:	8b 95 2c 09 01 00    	mov    0x1092c(%ebp),%edx
    201b:	39 d0                	cmp    %edx,%eax
    201d:	0f 84 47 01 00 00    	je     216a <_extract_or_test_files+0x16fa>
        /* if quiet enough, we haven't output the filename yet:  do it */
        if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    2023:	8b 4d 38             	mov    0x38(%ebp),%ecx
    2026:	85 c9                	test   %ecx,%ecx
    2028:	0f 85 56 05 00 00    	jne    2584 <_extract_or_test_files+0x1b14>
            Info(slide, 0x401, ((char *)slide, "%-22s ",
              FnFilter1(G.filename)));
        Info(slide, 0x401, ((char *)slide, LoadFarString(BadCRC), G.crc32val,
    202e:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2032:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2038:	89 54 24 0c          	mov    %edx,0xc(%esp)
    203c:	89 44 24 08          	mov    %eax,0x8(%esp)
    2040:	c7 44 24 04 80 04 00 	movl   $0x480,0x4(%esp)
    2047:	00 
    2048:	89 3c 24             	mov    %edi,(%esp)
    204b:	e8 00 00 00 00       	call   2050 <_extract_or_test_files+0x15e0>
    2050:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    2057:	00 
    2058:	89 44 24 08          	mov    %eax,0x8(%esp)
    205c:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2060:	89 2c 24             	mov    %ebp,(%esp)
    2063:	ff d3                	call   *%ebx
          G.lrec.crc32));
#if CRYPT
        if (G.pInfo->encrypted)
    2065:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    if (G.crc32val != G.lrec.crc32) {
        /* if quiet enough, we haven't output the filename yet:  do it */
        if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
            Info(slide, 0x401, ((char *)slide, "%-22s ",
              FnFilter1(G.filename)));
        Info(slide, 0x401, ((char *)slide, LoadFarString(BadCRC), G.crc32val,
    206b:	83 ec 10             	sub    $0x10,%esp
          G.lrec.crc32));
#if CRYPT
        if (G.pInfo->encrypted)
    206e:	f6 40 18 01          	testb  $0x1,0x18(%eax)
    2072:	0f 85 9c 04 00 00    	jne    2514 <_extract_or_test_files+0x1aa4>
    } else {
        if (QCOND2 && !error)   /* GRR:  is stdout reset to text mode yet? */
            Info(slide, 0, ((char *)slide, "\n"));
    }

    undefer_input(__G);
    2078:	89 2c 24             	mov    %ebp,(%esp)
    207b:	e8 00 00 00 00       	call   2080 <_extract_or_test_files+0x1610>
    2080:	ba 02 00 00 00       	mov    $0x2,%edx
    2085:	e9 c1 f7 ff ff       	jmp    184b <_extract_or_test_files+0xddb>
    208a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                GRRDUMP(local_hdr_sig, 4)
             */
            error_in_archive = PK_ERR;
            if ((*pfilnum == 1 && G.extra_bytes != 0L) ||
                (G.extra_bytes == 0L && *pold_extra_bytes != 0L)) {
                Info(slide, 0x401, ((char *)slide,
    2090:	a0 d8 00 00 00       	mov    0xd8,%al
    2095:	be d9 00 00 00       	mov    $0xd9,%esi
    209a:	88 07                	mov    %al,(%edi)
    209c:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    20a2:	b8 20 00 00 00       	mov    $0x20,%eax
    20a7:	f7 c7 02 00 00 00    	test   $0x2,%edi
    20ad:	0f 84 6a f3 ff ff    	je     141d <_extract_or_test_files+0x9ad>
    20b3:	66 8b 0e             	mov    (%esi),%cx
    20b6:	83 c7 02             	add    $0x2,%edi
    20b9:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    20bd:	83 c6 02             	add    $0x2,%esi
    20c0:	83 e8 02             	sub    $0x2,%eax
    20c3:	e9 55 f3 ff ff       	jmp    141d <_extract_or_test_files+0x9ad>
    if (!uO.tflag)           /* don't close NULL file */
        close_outfile(__G);
#else
#ifdef DLL
    if (!uO.tflag && (!uO.cflag || G.redirect_data)) {
        if (G.redirect_data)
    20c8:	8b 9d a0 00 00 00    	mov    0xa0(%ebp),%ebx
    20ce:	85 db                	test   %ebx,%ebx
    20d0:	0f 85 f6 f6 ff ff    	jne    17cc <_extract_or_test_files+0xd5c>
            FINISH_REDIRECT();
        else
            close_outfile(__G);
    20d6:	89 2c 24             	mov    %ebp,(%esp)
    20d9:	e8 00 00 00 00       	call   20de <_extract_or_test_files+0x166e>
    20de:	e9 f1 f6 ff ff       	jmp    17d4 <_extract_or_test_files+0xd64>
        G.symlnk = FALSE;
#endif /* SYMLINKS */

    if (uO.tflag) {
        if (!uO.qflag)
            Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg), "test",
    20e3:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    20e9:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    20ef:	89 44 24 04          	mov    %eax,0x4(%esp)
    20f3:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    20f9:	89 04 24             	mov    %eax,(%esp)
    20fc:	e8 6f e4 ff ff       	call   570 <_fnfilter>
    2101:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2105:	c7 44 24 14 12 00 00 	movl   $0x12,0x14(%esp)
    210c:	00 
    210d:	c7 44 24 10 12 00 00 	movl   $0x12,0x10(%esp)
    2114:	00 
    2115:	89 44 24 0c          	mov    %eax,0xc(%esp)
    2119:	c7 44 24 08 aa 00 00 	movl   $0xaa,0x8(%esp)
    2120:	00 
    2121:	c7 44 24 04 0c 0a 00 	movl   $0xa0c,0x4(%esp)
    2128:	00 
    2129:	89 3c 24             	mov    %edi,(%esp)
    212c:	e8 00 00 00 00       	call   2131 <_extract_or_test_files+0x16c1>
    2131:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2138:	00 
    2139:	89 44 24 08          	mov    %eax,0x8(%esp)
    213d:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2141:	89 2c 24             	mov    %ebp,(%esp)
    2144:	ff d3                	call   *%ebx
    2146:	83 ec 10             	sub    $0x10,%esp
    2149:	e9 06 f5 ff ff       	jmp    1654 <_extract_or_test_files+0xbe4>

    if (error > PK_WARN) {/* don't print redundant CRC error if error already */
        undefer_input(__G);
        return error;
    }
    if (G.crc32val != G.lrec.crc32) {
    214e:	8b 85 e0 08 01 00    	mov    0x108e0(%ebp),%eax
    2154:	8b 95 2c 09 01 00    	mov    0x1092c(%ebp),%edx
            Info(slide, 0x421, ((char *)slide, LoadFarString(FileTruncated),
              FnFilter1(G.filename)));
#endif
            error = PK_DISK;
        } else {
            error = PK_WARN;
    215a:	c7 44 24 5c 01 00 00 	movl   $0x1,0x5c(%esp)
    2161:	00 

    if (error > PK_WARN) {/* don't print redundant CRC error if error already */
        undefer_input(__G);
        return error;
    }
    if (G.crc32val != G.lrec.crc32) {
    2162:	39 d0                	cmp    %edx,%eax
    2164:	0f 85 b9 fe ff ff    	jne    2023 <_extract_or_test_files+0x15b3>
#if CRYPT
        if (G.pInfo->encrypted)
            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybeBadPasswd)));
#endif
        error = PK_ERR;
    } else if (uO.tflag) {
    216a:	8b 45 44             	mov    0x44(%ebp),%eax
    216d:	85 c0                	test   %eax,%eax
    216f:	0f 84 ef 04 00 00    	je     2664 <_extract_or_test_files+0x1bf4>
#ifndef SFX
        if (G.extra_field) {
    2175:	8b 9d 18 09 01 00    	mov    0x10918(%ebp),%ebx
    217b:	85 db                	test   %ebx,%ebx
    217d:	0f 84 4d 0e 00 00    	je     2fd0 <_extract_or_test_files+0x2560>
            if ((r = TestExtraField(__G__ G.extra_field,
    2183:	31 c0                	xor    %eax,%eax
    2185:	66 8b 85 38 09 01 00 	mov    0x10938(%ebp),%ax
    218c:	89 44 24 64          	mov    %eax,0x64(%esp)
    int r;

    /* we know the regular compressed file data tested out OK, or else we
     * wouldn't be here ==> print filename if any extra-field errors found
     */
    while (ef_len >= EB_HEADSIZE) {
    2190:	83 f8 03             	cmp    $0x3,%eax
    2193:	0f 86 d1 0e 00 00    	jbe    306a <_extract_or_test_files+0x25fa>
    2199:	89 ac 24 d0 00 00 00 	mov    %ebp,0xd0(%esp)
    21a0:	eb 35                	jmp    21d7 <_extract_or_test_files+0x1767>
            Info(slide, 1, ((char *)slide, LoadFarString(InconsistEFlength),
              ebLen, (ef_len - EB_HEADSIZE)));
            return PK_ERR;
        }

        switch (ebID) {
    21a2:	66 83 fe 0c          	cmp    $0xc,%si
    21a6:	0f 84 c4 01 00 00    	je     2370 <_extract_or_test_files+0x1900>
    21ac:	66 81 fe 4d 33       	cmp    $0x334d,%si
    21b1:	0f 84 25 09 00 00    	je     2adc <_extract_or_test_files+0x206c>
    21b7:	66 83 fe 09          	cmp    $0x9,%si
    21bb:	74 6d                	je     222a <_extract_or_test_files+0x17ba>
    21bd:	8b 44 24 64          	mov    0x64(%esp),%eax
            case EF_AV:
            default:
                break;
        }
        ef_len -= (ebLen + EB_HEADSIZE);
        ef += (ebLen + EB_HEADSIZE);
    21c1:	8d 5c 2b 04          	lea    0x4(%ebx,%ebp,1),%ebx
    21c5:	29 e8                	sub    %ebp,%eax
            case EF_THEOS:
            case EF_AV:
            default:
                break;
        }
        ef_len -= (ebLen + EB_HEADSIZE);
    21c7:	83 e8 04             	sub    $0x4,%eax
    21ca:	89 44 24 64          	mov    %eax,0x64(%esp)
    int r;

    /* we know the regular compressed file data tested out OK, or else we
     * wouldn't be here ==> print filename if any extra-field errors found
     */
    while (ef_len >= EB_HEADSIZE) {
    21ce:	83 f8 03             	cmp    $0x3,%eax
    21d1:	0f 86 8c 0e 00 00    	jbe    3063 <_extract_or_test_files+0x25f3>
        ebID = makeword(ef);
    21d7:	89 1c 24             	mov    %ebx,(%esp)
        ebLen = (unsigned)makeword(ef+EB_LEN);
    21da:	31 ed                	xor    %ebp,%ebp

    /* we know the regular compressed file data tested out OK, or else we
     * wouldn't be here ==> print filename if any extra-field errors found
     */
    while (ef_len >= EB_HEADSIZE) {
        ebID = makeword(ef);
    21dc:	e8 00 00 00 00       	call   21e1 <_extract_or_test_files+0x1771>
    21e1:	89 c6                	mov    %eax,%esi
        ebLen = (unsigned)makeword(ef+EB_LEN);
    21e3:	8d 43 02             	lea    0x2(%ebx),%eax
    21e6:	89 04 24             	mov    %eax,(%esp)
    21e9:	e8 00 00 00 00       	call   21ee <_extract_or_test_files+0x177e>
    21ee:	66 89 c5             	mov    %ax,%bp

        if (ebLen > (ef_len - EB_HEADSIZE)) {
    21f1:	8b 44 24 64          	mov    0x64(%esp),%eax
    21f5:	8d 78 fc             	lea    -0x4(%eax),%edi
    21f8:	39 fd                	cmp    %edi,%ebp
    21fa:	0f 87 c1 0e 00 00    	ja     30c1 <_extract_or_test_files+0x2651>
            Info(slide, 1, ((char *)slide, LoadFarString(InconsistEFlength),
              ebLen, (ef_len - EB_HEADSIZE)));
            return PK_ERR;
        }

        switch (ebID) {
    2200:	66 81 fe 53 44       	cmp    $0x4453,%si
    2205:	0f 84 12 01 00 00    	je     231d <_extract_or_test_files+0x18ad>
    220b:	76 95                	jbe    21a2 <_extract_or_test_files+0x1732>
    220d:	66 81 fe 42 65       	cmp    $0x6542,%si
    2212:	0f 84 03 06 00 00    	je     281b <_extract_or_test_files+0x1dab>
    2218:	66 81 fe 41 74       	cmp    $0x7441,%si
    221d:	0f 84 f8 05 00 00    	je     281b <_extract_or_test_files+0x1dab>
    2223:	66 81 fe 41 4c       	cmp    $0x4c41,%si
    2228:	75 93                	jne    21bd <_extract_or_test_files+0x174d>
            case EF_BEOS:
            case EF_ATHEOS:
                switch (ebID) {
                  case EF_OS2:
                  case EF_ACL:
                    eb_cmpr_offs = EB_OS2_HLEN;
    222a:	be 04 00 00 00       	mov    $0x4,%esi
    int r;

    if (compr_offset < 4)                /* field is not compressed: */
        return PK_OK;                    /* do nothing and signal OK */

    if ((eb_size < (EB_UCSIZE_P + 4)) ||
    222f:	83 fd 03             	cmp    $0x3,%ebp
    2232:	0f 87 00 06 00 00    	ja     2838 <_extract_or_test_files+0x1dc8>
    2238:	89 ac 24 8c 00 00 00 	mov    %ebp,0x8c(%esp)
    223f:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp
                        eb_cmpr_offs = EB_BEOS_HLEN;
                    break;
                }
                if ((r = test_compr_eb(__G__ ef, ebLen, eb_cmpr_offs, NULL))
                    != PK_OK) {
                    if (uO.qflag)
    2246:	8b 45 38             	mov    0x38(%ebp),%eax
    2249:	85 c0                	test   %eax,%eax
    224b:	0f 85 28 0c 00 00    	jne    2e79 <_extract_or_test_files+0x2409>
    2251:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
                        Info(slide, 1, ((char *)slide, "%-22s ",
                          FnFilter1(G.filename)));
                    switch (r) {
                        case IZ_EF_TRUNC:
                            Info(slide, 1, ((char *)slide,
    2258:	8b 7c 24 40          	mov    0x40(%esp),%edi
    225c:	83 e8 06             	sub    $0x6,%eax
    225f:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2265:	29 f0                	sub    %esi,%eax
    2267:	c7 44 24 0c c5 00 00 	movl   $0xc5,0xc(%esp)
    226e:	00 
    226f:	89 44 24 08          	mov    %eax,0x8(%esp)
    2273:	c7 44 24 04 40 04 00 	movl   $0x440,0x4(%esp)
    227a:	00 
    227b:	89 3c 24             	mov    %edi,(%esp)
    227e:	e8 00 00 00 00       	call   2283 <_extract_or_test_files+0x1813>
    2283:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    228a:	00 
    228b:	89 44 24 08          	mov    %eax,0x8(%esp)
    228f:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2293:	89 2c 24             	mov    %ebp,(%esp)
    2296:	ff d3                	call   *%ebx
    2298:	83 ec 10             	sub    $0x10,%esp
    229b:	c7 44 24 64 4f 00 00 	movl   $0x4f,0x64(%esp)
    22a2:	00 
    22a3:	e9 79 06 00 00       	jmp    2921 <_extract_or_test_files+0x1eb1>
            G.outptr = redirSlide;
            G.outcnt = 0L;
            while ((b = NEXTBYTE) != EOF) {
                *G.outptr++ = (uch)b;
                if (++G.outcnt == wsize) {
                    error = flush(__G__ redirSlide, G.outcnt, 0);
    22a8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    22af:	00 
    22b0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    22b4:	8b 85 bc 00 00 00    	mov    0xbc(%ebp),%eax
    22ba:	89 2c 24             	mov    %ebp,(%esp)
    22bd:	89 44 24 04          	mov    %eax,0x4(%esp)
    22c1:	e8 00 00 00 00       	call   22c6 <_extract_or_test_files+0x1856>
                    G.outptr = redirSlide;
    22c6:	8b 95 bc 00 00 00    	mov    0xbc(%ebp),%edx
    22cc:	89 95 d8 09 01 00    	mov    %edx,0x109d8(%ebp)
                    G.outcnt = 0L;
    22d2:	c7 85 dc 09 01 00 00 	movl   $0x0,0x109dc(%ebp)
    22d9:	00 00 00 
                    if (error != PK_COOL || G.disk_full) break;
    22dc:	85 c0                	test   %eax,%eax
    22de:	75 0e                	jne    22ee <_extract_or_test_files+0x187e>
    22e0:	8b 95 b0 09 01 00    	mov    0x109b0(%ebp),%edx
    22e6:	85 d2                	test   %edx,%edx
    22e8:	0f 84 69 f9 ff ff    	je     1c57 <_extract_or_test_files+0x11e7>
    22ee:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    22f2:	e9 b9 f4 ff ff       	jmp    17b0 <_extract_or_test_files+0xd40>
#endif
        {
#if (defined(OS2) && defined(__IBMC__) && (__IBMC__ >= 200))
            G.outfile = freopen("", "wb", stdout);   /* VAC++ ignores setmode */
#else
            G.outfile = stdout;
    22f7:	a1 00 00 00 00       	mov    0x0,%eax
    22fc:	8d 50 20             	lea    0x20(%eax),%edx
    22ff:	89 95 c8 09 01 00    	mov    %edx,0x109c8(%ebp)
#endif
#ifdef DOS_FLX_NLM_OS2_W32
#if (defined(__HIGHC__) && !defined(FLEXOS))
            setmode(G.outfile, _BINARY);
#else /* !(defined(__HIGHC__) && !defined(FLEXOS)) */
            setmode(fileno(G.outfile), O_BINARY);
    2305:	c7 44 24 04 00 80 00 	movl   $0x8000,0x4(%esp)
    230c:	00 
    230d:	8b 40 30             	mov    0x30(%eax),%eax
    2310:	89 04 24             	mov    %eax,(%esp)
    2313:	e8 00 00 00 00       	call   2318 <_extract_or_test_files+0x18a8>
    2318:	e9 37 f3 ff ff       	jmp    1654 <_extract_or_test_files+0xbe4>
                }
                break;

            case EF_NTSD:
                Trace((stderr, "ebID: %i / ebLen: %u\n", ebID, ebLen));
                r = ebLen < EB_NTSD_L_LEN ? IZ_EF_TRUNC :
    231d:	83 fd 04             	cmp    $0x4,%ebp
    2320:	0f 86 01 01 00 00    	jbe    2427 <_extract_or_test_files+0x19b7>
                    ((ef[EB_HEADSIZE+EB_NTSD_VERSION] > EB_NTSD_MAX_VER) ?
                     (PK_WARN | 0x4000) :
    2326:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
    232a:	0f 85 00 06 00 00    	jne    2930 <_extract_or_test_files+0x1ec0>
    2330:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    2337:	00 
    2338:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
    233f:	89 e9                	mov    %ebp,%ecx
    2341:	89 da                	mov    %ebx,%edx
    2343:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
    234a:	e8 71 df ff ff       	call   2c0 <_test_compr_eb.part.0>
                     test_compr_eb(__G__ ef, ebLen, EB_NTSD_L_LEN, TEST_NTSD));
                if (r != PK_OK) {
    234f:	85 c0                	test   %eax,%eax
    2351:	0f 84 66 fe ff ff    	je     21bd <_extract_or_test_files+0x174d>
    2357:	89 ac 24 8c 00 00 00 	mov    %ebp,0x8c(%esp)
    235e:	89 44 24 64          	mov    %eax,0x64(%esp)
    2362:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp
    2369:	e9 cf 00 00 00       	jmp    243d <_extract_or_test_files+0x19cd>
    236e:	66 90                	xchg   %ax,%ax
                    }
                    return r;
                }
                break;
            case EF_PKVMS:
                if (makelong(ef+EB_HEADSIZE) !=
    2370:	8d 43 04             	lea    0x4(%ebx),%eax
    2373:	89 04 24             	mov    %eax,(%esp)
    2376:	e8 00 00 00 00       	call   237b <_extract_or_test_files+0x190b>
                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),
    237b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
                    }
                    return r;
                }
                break;
            case EF_PKVMS:
                if (makelong(ef+EB_HEADSIZE) !=
    2382:	89 c6                	mov    %eax,%esi
                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),
    2384:	8d 45 fc             	lea    -0x4(%ebp),%eax
    2387:	89 44 24 08          	mov    %eax,0x8(%esp)
    238b:	8d 43 08             	lea    0x8(%ebx),%eax
    238e:	89 44 24 04          	mov    %eax,0x4(%esp)
    2392:	e8 00 00 00 00       	call   2397 <_extract_or_test_files+0x1927>
                    }
                    return r;
                }
                break;
            case EF_PKVMS:
                if (makelong(ef+EB_HEADSIZE) !=
    2397:	39 c6                	cmp    %eax,%esi
    2399:	0f 84 1e fe ff ff    	je     21bd <_extract_or_test_files+0x174d>
                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),
                          (extent)(ebLen-4)))
                    Info(slide, 1, ((char *)slide,
    239f:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
    23a6:	8b 4c 24 60          	mov    0x60(%esp),%ecx
    23aa:	8b 7c 24 40          	mov    0x40(%esp),%edi
    23ae:	be fc 00 00 00       	mov    $0xfc,%esi
    23b3:	8b 90 44 0b 01 00    	mov    0x10b44(%eax),%edx
    23b9:	85 c9                	test   %ecx,%ecx
    23bb:	b8 22 00 00 00       	mov    $0x22,%eax
    23c0:	0f 85 59 12 00 00    	jne    361f <_extract_or_test_files+0x2baf>
    23c6:	f7 c7 02 00 00 00    	test   $0x2,%edi
    23cc:	0f 85 d3 11 00 00    	jne    35a5 <_extract_or_test_files+0x2b35>
    23d2:	89 c1                	mov    %eax,%ecx
    23d4:	c1 e9 02             	shr    $0x2,%ecx
    23d7:	a8 02                	test   $0x2,%al
    23d9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    23db:	74 0b                	je     23e8 <_extract_or_test_files+0x1978>
    23dd:	66 8b 0e             	mov    (%esi),%cx
    23e0:	66 89 0f             	mov    %cx,(%edi)
    23e3:	b9 02 00 00 00       	mov    $0x2,%ecx
    23e8:	a8 01                	test   $0x1,%al
    23ea:	74 06                	je     23f2 <_extract_or_test_files+0x1982>
    23ec:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    23ef:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    23f2:	8b 44 24 40          	mov    0x40(%esp),%eax
    23f6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    23fd:	00 
    23fe:	89 44 24 04          	mov    %eax,0x4(%esp)
    2402:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
    2409:	c7 44 24 08 21 00 00 	movl   $0x21,0x8(%esp)
    2410:	00 
    2411:	89 04 24             	mov    %eax,(%esp)
    2414:	ff d2                	call   *%edx
    2416:	83 ec 10             	sub    $0x10,%esp
    2419:	e9 9f fd ff ff       	jmp    21bd <_extract_or_test_files+0x174d>
               }
            }

            /* mapname can create dirs if not freshening or if renamed */
            error = mapname(__G__ renamed);
            if ((errcode = error & ~MPN_MASK) != PK_OK &&
    241e:	8b 5c 24 48          	mov    0x48(%esp),%ebx
    2422:	e9 3a f1 ff ff       	jmp    1561 <_extract_or_test_files+0xaf1>
    2427:	89 ac 24 8c 00 00 00 	mov    %ebp,0x8c(%esp)
                }
                break;

            case EF_NTSD:
                Trace((stderr, "ebID: %i / ebLen: %u\n", ebID, ebLen));
                r = ebLen < EB_NTSD_L_LEN ? IZ_EF_TRUNC :
    242e:	c7 44 24 64 4f 00 00 	movl   $0x4f,0x64(%esp)
    2435:	00 
    2436:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp
                    ((ef[EB_HEADSIZE+EB_NTSD_VERSION] > EB_NTSD_MAX_VER) ?
                     (PK_WARN | 0x4000) :
                     test_compr_eb(__G__ ef, ebLen, EB_NTSD_L_LEN, TEST_NTSD));
                if (r != PK_OK) {
                    if (uO.qflag)
    243d:	8b 75 38             	mov    0x38(%ebp),%esi
    2440:	85 f6                	test   %esi,%esi
    2442:	0f 85 09 05 00 00    	jne    2951 <_extract_or_test_files+0x1ee1>
                        Info(slide, 1, ((char *)slide, "%-22s ",
                          FnFilter1(G.filename)));
                    switch (r) {
    2448:	8b 44 24 64          	mov    0x64(%esp),%eax
    244c:	83 f8 07             	cmp    $0x7,%eax
    244f:	0f 8f 57 05 00 00    	jg     29ac <_extract_or_test_files+0x1f3c>
    2455:	83 f8 06             	cmp    $0x6,%eax
    2458:	0f 8d d6 19 00 00    	jge    3e34 <_extract_or_test_files+0x33c4>
    245e:	83 f8 01             	cmp    $0x1,%eax
    2461:	0f 84 39 19 00 00    	je     3da0 <_extract_or_test_files+0x3330>
    2467:	83 f8 02             	cmp    $0x2,%eax
    246a:	0f 85 b0 17 00 00    	jne    3c20 <_extract_or_test_files+0x31b0>
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(InvalidSecurityEAs)));
                            break;
#endif
                        case PK_ERR:
                            Info(slide, 1, ((char *)slide,
    2470:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    2474:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    247a:	89 cf                	mov    %ecx,%edi
    247c:	be 20 01 00 00       	mov    $0x120,%esi
    2481:	b8 22 00 00 00       	mov    $0x22,%eax
    2486:	f6 c1 01             	test   $0x1,%cl
    2489:	74 17                	je     24a2 <_extract_or_test_files+0x1a32>
    248b:	a0 20 01 00 00       	mov    0x120,%al
    2490:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    2496:	88 01                	mov    %al,(%ecx)
    2498:	be 21 01 00 00       	mov    $0x121,%esi
    249d:	b8 21 00 00 00       	mov    $0x21,%eax
    24a2:	f7 c7 02 00 00 00    	test   $0x2,%edi
    24a8:	74 10                	je     24ba <_extract_or_test_files+0x1a4a>
    24aa:	66 8b 0e             	mov    (%esi),%cx
    24ad:	83 c7 02             	add    $0x2,%edi
    24b0:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    24b4:	83 c6 02             	add    $0x2,%esi
    24b7:	83 e8 02             	sub    $0x2,%eax
    24ba:	89 c1                	mov    %eax,%ecx
    24bc:	c1 e9 02             	shr    $0x2,%ecx
    24bf:	a8 02                	test   $0x2,%al
    24c1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    24c3:	74 0b                	je     24d0 <_extract_or_test_files+0x1a60>
    24c5:	66 8b 0e             	mov    (%esi),%cx
    24c8:	66 89 0f             	mov    %cx,(%edi)
    24cb:	b9 02 00 00 00       	mov    $0x2,%ecx
    24d0:	a8 01                	test   $0x1,%al
    24d2:	74 06                	je     24da <_extract_or_test_files+0x1a6a>
    24d4:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    24d7:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    24da:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    24e1:	00 
    24e2:	c7 44 24 08 21 00 00 	movl   $0x21,0x8(%esp)
    24e9:	00 
                              LoadFarString(InvalidComprDataEAs)));
                            break;
                        case PK_MEM3:
                        case PK_MEM4:
                            Info(slide, 1, ((char *)slide,
    24ea:	8b 44 24 40          	mov    0x40(%esp),%eax
    24ee:	89 2c 24             	mov    %ebp,(%esp)
    24f1:	89 44 24 04          	mov    %eax,0x4(%esp)
    24f5:	ff d2                	call   *%edx
    24f7:	83 ec 10             	sub    $0x10,%esp
    24fa:	e9 20 0c 00 00       	jmp    311f <_extract_or_test_files+0x26af>
    24ff:	90                   	nop
            }
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
            if (G.redirect_slide) {
                wsize = G.redirect_size; redirSlide = G.redirect_buffer;
            } else {
                wsize = WSIZE; redirSlide = slide;
    2500:	8b 44 24 40          	mov    0x40(%esp),%eax
    2504:	bb 00 00 01 00       	mov    $0x10000,%ebx
    2509:	89 85 bc 00 00 00    	mov    %eax,0xbc(%ebp)
    250f:	e9 f2 f6 ff ff       	jmp    1c06 <_extract_or_test_files+0x1196>
              FnFilter1(G.filename)));
        Info(slide, 0x401, ((char *)slide, LoadFarString(BadCRC), G.crc32val,
          G.lrec.crc32));
#if CRYPT
        if (G.pInfo->encrypted)
            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybeBadPasswd)));
    2514:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    2518:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    251e:	89 cf                	mov    %ecx,%edi
    2520:	be 44 01 00 00       	mov    $0x144,%esi
    2525:	b8 29 00 00 00       	mov    $0x29,%eax
    252a:	f6 c1 01             	test   $0x1,%cl
    252d:	0f 85 0f 11 00 00    	jne    3642 <_extract_or_test_files+0x2bd2>
    2533:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2539:	0f 85 26 11 00 00    	jne    3665 <_extract_or_test_files+0x2bf5>
    253f:	89 c1                	mov    %eax,%ecx
    2541:	c1 e9 02             	shr    $0x2,%ecx
    2544:	a8 02                	test   $0x2,%al
    2546:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    2548:	74 0b                	je     2555 <_extract_or_test_files+0x1ae5>
    254a:	66 8b 0e             	mov    (%esi),%cx
    254d:	66 89 0f             	mov    %cx,(%edi)
    2550:	b9 02 00 00 00       	mov    $0x2,%ecx
    2555:	a8 01                	test   $0x1,%al
    2557:	74 06                	je     255f <_extract_or_test_files+0x1aef>
    2559:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    255c:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    255f:	8b 44 24 40          	mov    0x40(%esp),%eax
    2563:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    256a:	00 
    256b:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
    2572:	00 
    2573:	89 44 24 04          	mov    %eax,0x4(%esp)
    2577:	89 2c 24             	mov    %ebp,(%esp)
    257a:	ff d2                	call   *%edx
    257c:	83 ec 10             	sub    $0x10,%esp
    257f:	e9 f4 fa ff ff       	jmp    2078 <_extract_or_test_files+0x1608>
        return error;
    }
    if (G.crc32val != G.lrec.crc32) {
        /* if quiet enough, we haven't output the filename yet:  do it */
        if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
            Info(slide, 0x401, ((char *)slide, "%-22s ",
    2584:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    258a:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2590:	89 44 24 04          	mov    %eax,0x4(%esp)
    2594:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    259a:	89 04 24             	mov    %eax,(%esp)
    259d:	e8 ce df ff ff       	call   570 <_fnfilter>
    25a2:	8b 7c 24 40          	mov    0x40(%esp),%edi
    25a6:	89 44 24 08          	mov    %eax,0x8(%esp)
    25aa:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
    25b1:	00 
    25b2:	89 3c 24             	mov    %edi,(%esp)
    25b5:	e8 00 00 00 00       	call   25ba <_extract_or_test_files+0x1b4a>
    25ba:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    25c1:	00 
    25c2:	89 44 24 08          	mov    %eax,0x8(%esp)
    25c6:	89 7c 24 04          	mov    %edi,0x4(%esp)
    25ca:	89 2c 24             	mov    %ebp,(%esp)
    25cd:	ff d3                	call   *%ebx
    25cf:	8b 95 2c 09 01 00    	mov    0x1092c(%ebp),%edx
    25d5:	83 ec 10             	sub    $0x10,%esp
    25d8:	8b 85 e0 08 01 00    	mov    0x108e0(%ebp),%eax
    25de:	e9 4b fa ff ff       	jmp    202e <_extract_or_test_files+0x15be>
    25e3:	89 44 24 50          	mov    %eax,0x50(%esp)
                break;
            }
            /* process_cdir_file_hdr() sets pInfo->hostnum, pInfo->lcflag */
            if ((error = process_cdir_file_hdr(__G)) != PK_COOL) {
                error_in_archive = error;   /* only PK_EOF defined */
                reached_end = TRUE;     /* ...so no more left to do */
    25e7:	c7 84 24 80 00 00 00 	movl   $0x1,0x80(%esp)
    25ee:	01 00 00 00 
    25f2:	e9 b6 f9 ff ff       	jmp    1fad <_extract_or_test_files+0x153d>
            if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a new entry? */
                /* no new central directory entry
                 * -> is the number of processed entries compatible with the
                 *    number of entries as stored in the end_central record?
                 */
                if ((members_processed & (unsigned)0xFFFF) ==
    25f7:	8b 44 24 58          	mov    0x58(%esp),%eax
    25fb:	66 39 85 6e 09 01 00 	cmp    %ax,0x1096e(%ebp)
    2602:	0f 85 08 04 00 00    	jne    2a10 <_extract_or_test_files+0x1fa0>
                    (unsigned)G.ecrec.total_entries_central_dir) {
                    /* yes, so look if we ARE back at the end_central record
                     */
                    no_endsig_found =
                      (strncmp(G.sig, end_central_sig, 4) != 0);
    2608:	8b 44 24 44          	mov    0x44(%esp),%eax
    260c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    2613:	00 
    2614:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    261b:	00 
    261c:	89 04 24             	mov    %eax,(%esp)
    261f:	e8 00 00 00 00       	call   2624 <_extract_or_test_files+0x1bb4>
                      LoadFarString(CentSigMsg), j + blknum*DIR_BLKSIZ + 1));
                    Info(slide, 0x401, ((char *)slide,
                      LoadFarString(ReportMsg)));
                    error_in_archive = PK_BADERR;
                }
                reached_end = TRUE;     /* ...so no more left to do */
    2624:	c7 84 24 80 00 00 00 	movl   $0x1,0x80(%esp)
    262b:	01 00 00 00 
                if ((members_processed & (unsigned)0xFFFF) ==
                    (unsigned)G.ecrec.total_entries_central_dir) {
                    /* yes, so look if we ARE back at the end_central record
                     */
                    no_endsig_found =
                      (strncmp(G.sig, end_central_sig, 4) != 0);
    262f:	85 c0                	test   %eax,%eax
                 */
                if ((members_processed & (unsigned)0xFFFF) ==
                    (unsigned)G.ecrec.total_entries_central_dir) {
                    /* yes, so look if we ARE back at the end_central record
                     */
                    no_endsig_found =
    2631:	0f 95 c0             	setne  %al
    2634:	25 ff 00 00 00       	and    $0xff,%eax
    2639:	89 84 24 9c 00 00 00 	mov    %eax,0x9c(%esp)
    2640:	e9 68 f9 ff ff       	jmp    1fad <_extract_or_test_files+0x153d>

#if CRYPT
        if (G.pInfo->encrypted &&
            (error = decrypt(__G__ uO.pwdarg)) != PK_COOL) {
            if (error == PK_WARN) {
                if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2)))
    2645:	8b 45 38             	mov    0x38(%ebp),%eax
    2648:	85 c0                	test   %eax,%eax
    264a:	0f 84 c0 09 00 00    	je     3010 <_extract_or_test_files+0x25a0>
                    Info(slide, 0x401, ((char *)slide,
                      LoadFarString(SkipIncorrectPasswd),
                      FnFilter1(G.filename)));
                ++(*pnum_bad_pwd);
    2650:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
    2657:	40                   	inc    %eax
    2658:	89 84 24 94 00 00 00 	mov    %eax,0x94(%esp)
    265f:	e9 4d e8 ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
        } else
#endif /* !SFX */
        if (!uO.qflag)
            Info(slide, 0, ((char *)slide, " OK\n"));
    } else {
        if (QCOND2 && !error)   /* GRR:  is stdout reset to text mode yet? */
    2664:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    2668:	0b 45 38             	or     0x38(%ebp),%eax
    266b:	0f 84 18 0a 00 00    	je     3089 <_extract_or_test_files+0x2619>
            Info(slide, 0, ((char *)slide, "\n"));
    }

    undefer_input(__G);
    2671:	89 2c 24             	mov    %ebp,(%esp)
    2674:	e8 00 00 00 00       	call   2679 <_extract_or_test_files+0x1c09>
#endif
#ifdef AMIGA
        G.filenote_slot = i;
#endif
        G.disk_full = 0;
        if ((error = extract_or_test_member(__G)) != PK_COOL) {
    2679:	8b 74 24 5c          	mov    0x5c(%esp),%esi
    267d:	85 f6                	test   %esi,%esi
    267f:	0f 84 e9 f1 ff ff    	je     186e <_extract_or_test_files+0xdfe>
    2685:	8b 54 24 5c          	mov    0x5c(%esp),%edx
    2689:	e9 bd f1 ff ff       	jmp    184b <_extract_or_test_files+0xddb>
    268e:	66 90                	xchg   %ax,%ax
                 PK_COOL)
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal:  no more left to do */
                    Info(slide, 0x401, ((char *)slide,
    2690:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2696:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    269c:	89 44 24 04          	mov    %eax,0x4(%esp)
    26a0:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    26a6:	89 04 24             	mov    %eax,(%esp)
    26a9:	e8 c2 de ff ff       	call   570 <_fnfilter>
    26ae:	c7 44 24 0c 92 00 00 	movl   $0x92,0xc(%esp)
    26b5:	00 
    26b6:	89 44 24 08          	mov    %eax,0x8(%esp)
    26ba:	c7 44 24 04 9c 0b 00 	movl   $0xb9c,0x4(%esp)
    26c1:	00 
                EXTRA_FIELD)) != 0)
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal */
                    Info(slide, 0x401, ((char *)slide,
    26c2:	8b 7c 24 40          	mov    0x40(%esp),%edi
    26c6:	89 3c 24             	mov    %edi,(%esp)
    26c9:	e8 00 00 00 00       	call   26ce <_extract_or_test_files+0x1c5e>
    26ce:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    26d5:	00 
#endif
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal */
                    Info(slide, 0x421, ((char *)slide,
    26d6:	89 44 24 08          	mov    %eax,0x8(%esp)
    26da:	89 7c 24 04          	mov    %edi,0x4(%esp)
    26de:	89 2c 24             	mov    %ebp,(%esp)
    26e1:	ff d3                	call   *%ebx
    26e3:	83 ec 10             	sub    $0x10,%esp
                      LoadFarString(BadFileCommLength),
                      FnFilter1(G.filename)));
                    reached_end = TRUE;
    26e6:	c7 84 24 80 00 00 00 	movl   $0x1,0x80(%esp)
    26ed:	01 00 00 00 
                    break;
    26f1:	e9 b7 f8 ff ff       	jmp    1fad <_extract_or_test_files+0x153d>
            /* for files from DOS FAT, check for use of backslash instead
             *  of slash as directory separator (bug in some zipper(s); so
             *  far, not a problem in HPFS, NTFS or VFAT systems)
             */
#ifndef SFX
            if (G.pInfo->hostnum == FS_FAT_ && !MBSCHR(G.filename, '/')) {
    26f6:	c7 44 24 04 2f 00 00 	movl   $0x2f,0x4(%esp)
    26fd:	00 
    26fe:	89 34 24             	mov    %esi,(%esp)
    2701:	e8 00 00 00 00       	call   2706 <_extract_or_test_files+0x1c96>
    2706:	89 f3                	mov    %esi,%ebx
    2708:	85 c0                	test   %eax,%eax
    270a:	0f 85 1c ee ff ff    	jne    152c <_extract_or_test_files+0xabc>
                char *p=G.filename;

                if (*p) do {
    2710:	8a 85 e0 09 01 00    	mov    0x109e0(%ebp),%al
    2716:	84 c0                	test   %al,%al
    2718:	0f 84 0e ee ff ff    	je     152c <_extract_or_test_files+0xabc>
                    if (*p == '\\') {
    271e:	3c 5c                	cmp    $0x5c,%al
    2720:	74 23                	je     2745 <_extract_or_test_files+0x1cd5>
                            if (!error_in_archive)
                                error_in_archive = PK_WARN;
                        }
                        *p = '/';
                    }
                } while (*PREINCSTR(p));
    2722:	a1 00 00 00 00       	mov    0x0,%eax
    2727:	8b 00                	mov    (%eax),%eax
    2729:	89 1c 24             	mov    %ebx,(%esp)
    272c:	89 44 24 04          	mov    %eax,0x4(%esp)
    2730:	e8 00 00 00 00       	call   2735 <_extract_or_test_files+0x1cc5>
    2735:	01 c3                	add    %eax,%ebx
    2737:	8a 03                	mov    (%ebx),%al
    2739:	84 c0                	test   %al,%al
    273b:	0f 84 eb ed ff ff    	je     152c <_extract_or_test_files+0xabc>
#ifndef SFX
            if (G.pInfo->hostnum == FS_FAT_ && !MBSCHR(G.filename, '/')) {
                char *p=G.filename;

                if (*p) do {
                    if (*p == '\\') {
    2741:	3c 5c                	cmp    $0x5c,%al
    2743:	75 dd                	jne    2722 <_extract_or_test_files+0x1cb2>
                        if (!G.reported_backslash) {
    2745:	8b 8d ac 09 01 00    	mov    0x109ac(%ebp),%ecx
    274b:	85 c9                	test   %ecx,%ecx
    274d:	75 62                	jne    27b1 <_extract_or_test_files+0x1d41>
                            Info(slide, 0x21, ((char *)slide,
    274f:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    2755:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    2759:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
    275f:	89 44 24 08          	mov    %eax,0x8(%esp)
    2763:	8b 44 24 40          	mov    0x40(%esp),%eax
    2767:	c7 44 24 04 00 09 00 	movl   $0x900,0x4(%esp)
    276e:	00 
    276f:	89 04 24             	mov    %eax,(%esp)
    2772:	e8 00 00 00 00       	call   2777 <_extract_or_test_files+0x1d07>
    2777:	c7 44 24 0c 21 00 00 	movl   $0x21,0xc(%esp)
    277e:	00 
    277f:	89 44 24 08          	mov    %eax,0x8(%esp)
    2783:	8b 44 24 40          	mov    0x40(%esp),%eax
    2787:	89 44 24 04          	mov    %eax,0x4(%esp)
    278b:	89 2c 24             	mov    %ebp,(%esp)
    278e:	ff 54 24 5c          	call   *0x5c(%esp)
                              LoadFarString(BackslashPathSep), G.zipfn));
                            G.reported_backslash = TRUE;
                            if (!error_in_archive)
                                error_in_archive = PK_WARN;
    2792:	b9 01 00 00 00       	mov    $0x1,%ecx
                char *p=G.filename;

                if (*p) do {
                    if (*p == '\\') {
                        if (!G.reported_backslash) {
                            Info(slide, 0x21, ((char *)slide,
    2797:	83 ec 10             	sub    $0x10,%esp
                              LoadFarString(BackslashPathSep), G.zipfn));
                            G.reported_backslash = TRUE;
    279a:	c7 85 ac 09 01 00 01 	movl   $0x1,0x109ac(%ebp)
    27a1:	00 00 00 
                            if (!error_in_archive)
                                error_in_archive = PK_WARN;
    27a4:	8b 44 24 48          	mov    0x48(%esp),%eax
    27a8:	85 c0                	test   %eax,%eax
    27aa:	0f 45 c8             	cmovne %eax,%ecx
    27ad:	89 4c 24 48          	mov    %ecx,0x48(%esp)
                        }
                        *p = '/';
    27b1:	c6 03 2f             	movb   $0x2f,(%ebx)
    27b4:	e9 69 ff ff ff       	jmp    2722 <_extract_or_test_files+0x1cb2>
                    G.outcnt = 0L;
                    if (error != PK_COOL || G.disk_full) break;
                }
            }
            if (G.outcnt)          /* flush final (partial) buffer */
                flush(__G__ redirSlide, G.outcnt, 0);
    27b9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    27c0:	00 
    27c1:	89 44 24 08          	mov    %eax,0x8(%esp)
    27c5:	8b 85 bc 00 00 00    	mov    0xbc(%ebp),%eax
    27cb:	89 2c 24             	mov    %ebp,(%esp)
    27ce:	89 44 24 04          	mov    %eax,0x4(%esp)
    27d2:	e8 00 00 00 00       	call   27d7 <_extract_or_test_files+0x1d67>
    27d7:	c7 44 24 5c 00 00 00 	movl   $0x0,0x5c(%esp)
    27de:	00 
    27df:	e9 cc ef ff ff       	jmp    17b0 <_extract_or_test_files+0xd40>
                EXTRA_FIELD)) != 0)
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal */
                    Info(slide, 0x401, ((char *)slide,
    27e4:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    27ea:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    27f0:	89 44 24 04          	mov    %eax,0x4(%esp)
    27f4:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    27fa:	89 04 24             	mov    %eax,(%esp)
    27fd:	e8 6e dd ff ff       	call   570 <_fnfilter>
    2802:	c7 44 24 0c 92 00 00 	movl   $0x92,0xc(%esp)
    2809:	00 
    280a:	89 44 24 08          	mov    %eax,0x8(%esp)
    280e:	c7 44 24 04 60 0a 00 	movl   $0xa60,0x4(%esp)
    2815:	00 
    2816:	e9 a7 fe ff ff       	jmp    26c2 <_extract_or_test_files+0x1c52>
                    else
                        eb_cmpr_offs = EB_MAC3_HLEN;
                    break;
                  case EF_BEOS:
                  case EF_ATHEOS:
                    if (ebLen >= EB_BEOS_HLEN &&
    281b:	83 fd 04             	cmp    $0x4,%ebp
    281e:	76 0a                	jbe    282a <_extract_or_test_files+0x1dba>
    2820:	f6 43 08 01          	testb  $0x1,0x8(%ebx)
    2824:	0f 85 d6 0e 00 00    	jne    3700 <_extract_or_test_files+0x2c90>
                        (*(ef+(EB_HEADSIZE+EB_FLGS_OFFS)) & EB_BE_FL_UNCMPR) &&
                        (makelong(ef+EB_HEADSIZE) == ebLen - EB_BEOS_HLEN))
                        eb_cmpr_offs = 0;
                    else
                        eb_cmpr_offs = EB_BEOS_HLEN;
    282a:	be 05 00 00 00       	mov    $0x5,%esi
    int r;

    if (compr_offset < 4)                /* field is not compressed: */
        return PK_OK;                    /* do nothing and signal OK */

    if ((eb_size < (EB_UCSIZE_P + 4)) ||
    282f:	83 fd 03             	cmp    $0x3,%ebp
    2832:	0f 86 00 fa ff ff    	jbe    2238 <_extract_or_test_files+0x17c8>
    2838:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    283f:	00 
    2840:	89 34 24             	mov    %esi,(%esp)
    2843:	89 e9                	mov    %ebp,%ecx
    2845:	89 da                	mov    %ebx,%edx
    2847:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
    284e:	e8 6d da ff ff       	call   2c0 <_test_compr_eb.part.0>
                        eb_cmpr_offs = 0;
                    else
                        eb_cmpr_offs = EB_BEOS_HLEN;
                    break;
                }
                if ((r = test_compr_eb(__G__ ef, ebLen, eb_cmpr_offs, NULL))
    2853:	85 c0                	test   %eax,%eax
    2855:	0f 84 62 f9 ff ff    	je     21bd <_extract_or_test_files+0x174d>
    285b:	89 ac 24 8c 00 00 00 	mov    %ebp,0x8c(%esp)
    2862:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp
    2869:	89 44 24 64          	mov    %eax,0x64(%esp)
                    != PK_OK) {
                    if (uO.qflag)
    286d:	8b 7d 38             	mov    0x38(%ebp),%edi
    2870:	85 ff                	test   %edi,%edi
    2872:	0f 85 09 06 00 00    	jne    2e81 <_extract_or_test_files+0x2411>
                        Info(slide, 1, ((char *)slide, "%-22s ",
                          FnFilter1(G.filename)));
                    switch (r) {
    2878:	8b 44 24 64          	mov    0x64(%esp),%eax
    287c:	83 f8 07             	cmp    $0x7,%eax
    287f:	0f 8f 57 06 00 00    	jg     2edc <_extract_or_test_files+0x246c>
    2885:	83 f8 06             	cmp    $0x6,%eax
    2888:	0f 8d c6 12 00 00    	jge    3b54 <_extract_or_test_files+0x30e4>
    288e:	83 f8 02             	cmp    $0x2,%eax
    2891:	0f 85 50 06 00 00    	jne    2ee7 <_extract_or_test_files+0x2477>
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(TruncEAs),
                              ebLen-(eb_cmpr_offs+EB_CMPRHEADLEN), "\n"));
                            break;
                        case PK_ERR:
                            Info(slide, 1, ((char *)slide,
    2897:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    289b:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    28a1:	89 cf                	mov    %ecx,%edi
    28a3:	be 20 01 00 00       	mov    $0x120,%esi
    28a8:	b8 22 00 00 00       	mov    $0x22,%eax
    28ad:	f6 c1 01             	test   $0x1,%cl
    28b0:	74 17                	je     28c9 <_extract_or_test_files+0x1e59>
    28b2:	a0 20 01 00 00       	mov    0x120,%al
    28b7:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    28bd:	88 01                	mov    %al,(%ecx)
    28bf:	be 21 01 00 00       	mov    $0x121,%esi
    28c4:	b8 21 00 00 00       	mov    $0x21,%eax
                                Info(slide, 1, ((char *)slide,
                                  LoadFarString(UnknErrorEAs)));
                            else {
                                ush m = (ush)(r >> 8);
                                if (m == DEFLATED)            /* GRR KLUDGE! */
                                    Info(slide, 1, ((char *)slide,
    28c9:	f7 c7 02 00 00 00    	test   $0x2,%edi
    28cf:	74 10                	je     28e1 <_extract_or_test_files+0x1e71>
    28d1:	66 8b 0e             	mov    (%esi),%cx
    28d4:	83 c7 02             	add    $0x2,%edi
    28d7:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    28db:	83 c6 02             	add    $0x2,%esi
    28de:	83 e8 02             	sub    $0x2,%eax
    28e1:	89 c1                	mov    %eax,%ecx
    28e3:	c1 e9 02             	shr    $0x2,%ecx
    28e6:	a8 02                	test   $0x2,%al
    28e8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    28ea:	74 0b                	je     28f7 <_extract_or_test_files+0x1e87>
    28ec:	66 8b 0e             	mov    (%esi),%cx
    28ef:	66 89 0f             	mov    %cx,(%edi)
    28f2:	b9 02 00 00 00       	mov    $0x2,%ecx
    28f7:	a8 01                	test   $0x1,%al
    28f9:	74 06                	je     2901 <_extract_or_test_files+0x1e91>
    28fb:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    28fe:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    2901:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    2908:	00 
    2909:	c7 44 24 08 21 00 00 	movl   $0x21,0x8(%esp)
    2910:	00 
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(InvalidComprDataEAs)));
                            break;
                        case PK_MEM3:
                        case PK_MEM4:
                            Info(slide, 1, ((char *)slide,
    2911:	8b 44 24 40          	mov    0x40(%esp),%eax
    2915:	89 2c 24             	mov    %ebp,(%esp)
    2918:	89 44 24 04          	mov    %eax,0x4(%esp)
    291c:	ff d2                	call   *%edx
    291e:	83 ec 10             	sub    $0x10,%esp
                              (int)ef[EB_HEADSIZE+EB_NTSD_VERSION]));
                            r = PK_WARN;
                            break;
                        default:
                            if ((r & 0xff) != PK_ERR)
                                Info(slide, 1, ((char *)slide,
    2921:	8b 5c 24 64          	mov    0x64(%esp),%ebx
    2925:	e9 4d 07 00 00       	jmp    3077 <_extract_or_test_files+0x2607>
    292a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    2930:	89 ac 24 8c 00 00 00 	mov    %ebp,0x8c(%esp)
    2937:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp

            case EF_NTSD:
                Trace((stderr, "ebID: %i / ebLen: %u\n", ebID, ebLen));
                r = ebLen < EB_NTSD_L_LEN ? IZ_EF_TRUNC :
                    ((ef[EB_HEADSIZE+EB_NTSD_VERSION] > EB_NTSD_MAX_VER) ?
                     (PK_WARN | 0x4000) :
    293e:	c7 44 24 64 01 40 00 	movl   $0x4001,0x64(%esp)
    2945:	00 
                     test_compr_eb(__G__ ef, ebLen, EB_NTSD_L_LEN, TEST_NTSD));
                if (r != PK_OK) {
                    if (uO.qflag)
    2946:	8b 75 38             	mov    0x38(%ebp),%esi
    2949:	85 f6                	test   %esi,%esi
    294b:	0f 84 f7 fa ff ff    	je     2448 <_extract_or_test_files+0x19d8>
                        Info(slide, 1, ((char *)slide, "%-22s ",
    2951:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2957:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    295d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2961:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    2967:	89 04 24             	mov    %eax,(%esp)
    296a:	e8 01 dc ff ff       	call   570 <_fnfilter>
    296f:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2973:	89 44 24 08          	mov    %eax,0x8(%esp)
    2977:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
    297e:	00 
    297f:	89 3c 24             	mov    %edi,(%esp)
    2982:	e8 00 00 00 00       	call   2987 <_extract_or_test_files+0x1f17>
    2987:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    298e:	00 
    298f:	89 44 24 08          	mov    %eax,0x8(%esp)
    2993:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2997:	89 2c 24             	mov    %ebp,(%esp)
    299a:	ff d6                	call   *%esi
    299c:	83 ec 10             	sub    $0x10,%esp
                          FnFilter1(G.filename)));
                    switch (r) {
    299f:	8b 44 24 64          	mov    0x64(%esp),%eax
    29a3:	83 f8 07             	cmp    $0x7,%eax
    29a6:	0f 8e a9 fa ff ff    	jle    2455 <_extract_or_test_files+0x19e5>
    29ac:	8b 44 24 64          	mov    0x64(%esp),%eax
    29b0:	83 f8 4f             	cmp    $0x4f,%eax
    29b3:	0f 84 1a 12 00 00    	je     3bd3 <_extract_or_test_files+0x3163>
    29b9:	3d 01 40 00 00       	cmp    $0x4001,%eax
    29be:	0f 85 5c 12 00 00    	jne    3c20 <_extract_or_test_files+0x31b0>
                        case PK_MEM4:
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(NotEnoughMemEAs)));
                            break;
                        case (PK_WARN | 0x4000):
                            Info(slide, 1, ((char *)slide,
    29c4:	31 c0                	xor    %eax,%eax
    29c6:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    29cc:	8a 43 08             	mov    0x8(%ebx),%al
    29cf:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    29d3:	89 1c 24             	mov    %ebx,(%esp)
    29d6:	89 44 24 08          	mov    %eax,0x8(%esp)
    29da:	c7 44 24 04 60 03 00 	movl   $0x360,0x4(%esp)
    29e1:	00 
    29e2:	e8 00 00 00 00       	call   29e7 <_extract_or_test_files+0x1f77>
    29e7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    29eb:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    29f2:	00 
    29f3:	89 44 24 08          	mov    %eax,0x8(%esp)
    29f7:	89 2c 24             	mov    %ebp,(%esp)
                              LoadFarString(UnsuppNTSDVersEAs),
                              (int)ef[EB_HEADSIZE+EB_NTSD_VERSION]));
                            r = PK_WARN;
    29fa:	bb 01 00 00 00       	mov    $0x1,%ebx
                        case PK_MEM4:
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(NotEnoughMemEAs)));
                            break;
                        case (PK_WARN | 0x4000):
                            Info(slide, 1, ((char *)slide,
    29ff:	ff d6                	call   *%esi
    2a01:	83 ec 10             	sub    $0x10,%esp
    2a04:	e9 6e 06 00 00       	jmp    3077 <_extract_or_test_files+0x2607>
    2a09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                      (strncmp(G.sig, end_central_sig, 4) != 0);
                } else {
                    /* no; we have found an error in the central directory
                     * -> report it and stop searching for more Zip entries
                     */
                    Info(slide, 0x401, ((char *)slide,
    2a10:	8b 94 24 88 00 00 00 	mov    0x88(%esp),%edx
    2a17:	8b 44 24 48          	mov    0x48(%esp),%eax
    2a1b:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2a1f:	01 d0                	add    %edx,%eax
    2a21:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2a27:	89 44 24 08          	mov    %eax,0x8(%esp)
    2a2b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    2a32:	00 
    2a33:	89 3c 24             	mov    %edi,(%esp)
    2a36:	e8 00 00 00 00       	call   2a3b <_extract_or_test_files+0x1fcb>
    2a3b:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    2a42:	00 
    2a43:	89 44 24 08          	mov    %eax,0x8(%esp)
    2a47:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2a4b:	89 2c 24             	mov    %ebp,(%esp)
    2a4e:	ff d3                	call   *%ebx
                      LoadFarString(CentSigMsg), j + blknum*DIR_BLKSIZ + 1));
                    Info(slide, 0x401, ((char *)slide,
    2a50:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
                      (strncmp(G.sig, end_central_sig, 4) != 0);
                } else {
                    /* no; we have found an error in the central directory
                     * -> report it and stop searching for more Zip entries
                     */
                    Info(slide, 0x401, ((char *)slide,
    2a56:	83 ec 10             	sub    $0x10,%esp
                      LoadFarString(CentSigMsg), j + blknum*DIR_BLKSIZ + 1));
                    Info(slide, 0x401, ((char *)slide,
    2a59:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    2a60:	00 
    2a61:	89 3c 24             	mov    %edi,(%esp)
    2a64:	e8 00 00 00 00       	call   2a69 <_extract_or_test_files+0x1ff9>
    2a69:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    2a70:	00 
    2a71:	89 44 24 08          	mov    %eax,0x8(%esp)
    2a75:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2a79:	89 2c 24             	mov    %ebp,(%esp)
    2a7c:	ff d3                	call   *%ebx
    2a7e:	83 ec 10             	sub    $0x10,%esp
                      LoadFarString(ReportMsg)));
                    error_in_archive = PK_BADERR;
    2a81:	c7 44 24 50 03 00 00 	movl   $0x3,0x50(%esp)
    2a88:	00 
                }
                reached_end = TRUE;     /* ...so no more left to do */
    2a89:	c7 84 24 80 00 00 00 	movl   $0x1,0x80(%esp)
    2a90:	01 00 00 00 
    2a94:	e9 14 f5 ff ff       	jmp    1fad <_extract_or_test_files+0x153d>
#endif
            {
                if (error > error_in_archive)
                    error_in_archive = error;
                if (error > PK_WARN) {  /* fatal */
                    Info(slide, 0x421, ((char *)slide,
    2a99:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2a9f:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2aa5:	89 44 24 04          	mov    %eax,0x4(%esp)
    2aa9:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    2aaf:	89 04 24             	mov    %eax,(%esp)
    2ab2:	e8 b9 da ff ff       	call   570 <_fnfilter>
    2ab7:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2abb:	89 44 24 08          	mov    %eax,0x8(%esp)
    2abf:	c7 44 24 04 70 09 00 	movl   $0x970,0x4(%esp)
    2ac6:	00 
    2ac7:	89 3c 24             	mov    %edi,(%esp)
    2aca:	e8 00 00 00 00       	call   2acf <_extract_or_test_files+0x205f>
    2acf:	c7 44 24 0c 21 04 00 	movl   $0x421,0xc(%esp)
    2ad6:	00 
    2ad7:	e9 fa fb ff ff       	jmp    26d6 <_extract_or_test_files+0x1c66>
                  case EF_OS2:
                  case EF_ACL:
                    eb_cmpr_offs = EB_OS2_HLEN;
                    break;
                  case EF_MAC3:
                    if (ebLen >= EB_MAC3_HLEN &&
    2adc:	83 fd 0d             	cmp    $0xd,%ebp
    2adf:	0f 87 e5 08 00 00    	ja     33ca <_extract_or_test_files+0x295a>
                        (makeword(ef+(EB_HEADSIZE+EB_FLGS_OFFS))
                         & EB_M3_FL_UNCMPR) &&
                        (makelong(ef+EB_HEADSIZE) == ebLen - EB_MAC3_HLEN))
                        eb_cmpr_offs = 0;
                    else
                        eb_cmpr_offs = EB_MAC3_HLEN;
    2ae5:	be 0e 00 00 00       	mov    $0xe,%esi
    2aea:	e9 40 f7 ff ff       	jmp    222f <_extract_or_test_files+0x17bf>
                        ++(*pnum_dirs);
                    }
#endif /* SET_DIR_ATTRIB */
                } else if (errcode == MPN_VOL_LABEL) {
#ifdef DOS_OS2_W32
                    Info(slide, 0x401, ((char *)slide,
    2aef:	8b 7d 40             	mov    0x40(%ebp),%edi
    2af2:	b8 12 00 00 00       	mov    $0x12,%eax
    2af7:	85 ff                	test   %edi,%edi
    2af9:	bf 07 00 00 00       	mov    $0x7,%edi
    2afe:	0f 44 f8             	cmove  %eax,%edi
    2b01:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2b07:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    2b0d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2b11:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    2b17:	89 04 24             	mov    %eax,(%esp)
    2b1a:	e8 51 da ff ff       	call   570 <_fnfilter>
    2b1f:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    2b23:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2b27:	89 44 24 08          	mov    %eax,0x8(%esp)
    2b2b:	c7 44 24 04 80 08 00 	movl   $0x880,0x4(%esp)
    2b32:	00 
    2b33:	89 3c 24             	mov    %edi,(%esp)
    2b36:	e8 00 00 00 00       	call   2b3b <_extract_or_test_files+0x20cb>
    2b3b:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    2b42:	00 
    2b43:	e9 a4 e4 ff ff       	jmp    fec <_extract_or_test_files+0x57c>
                } else {
                    error = r;
                }
            }
            if (r == 5) {
                int warning = ((ulg)G.used_csize <= G.lrec.csize);
    2b48:	8b bd 94 00 00 00    	mov    0x94(%ebp),%edi
    2b4e:	8b b5 20 09 01 00    	mov    0x10920(%ebp),%esi

                if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    2b54:	8b 55 38             	mov    0x38(%ebp),%edx
                } else {
                    error = r;
                }
            }
            if (r == 5) {
                int warning = ((ulg)G.used_csize <= G.lrec.csize);
    2b57:	39 f7                	cmp    %esi,%edi
    2b59:	0f 96 c3             	setbe  %bl

                if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
    2b5c:	85 d2                	test   %edx,%edx
    2b5e:	0f 85 d4 06 00 00    	jne    3238 <_extract_or_test_files+0x27c8>
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
                      "", warning?  "warning" : "error", G.used_csize,
                      G.lrec.ucsize, warning?  "  " : "", G.lrec.csize,
                      " [", FnFilter1(G.filename), "]"));
                else
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
    2b64:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    2b6a:	84 db                	test   %bl,%bl
    2b6c:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    2b70:	0f 84 fb 03 00 00    	je     2f71 <_extract_or_test_files+0x2501>
    2b76:	8b 8d 24 09 01 00    	mov    0x10924(%ebp),%ecx
    2b7c:	ba 76 00 00 00       	mov    $0x76,%edx
    2b81:	b8 79 00 00 00       	mov    $0x79,%eax
    2b86:	c7 44 24 28 c3 00 00 	movl   $0xc3,0x28(%esp)
    2b8d:	00 
    2b8e:	c7 44 24 24 12 00 00 	movl   $0x12,0x24(%esp)
    2b95:	00 
    2b96:	c7 44 24 20 12 00 00 	movl   $0x12,0x20(%esp)
    2b9d:	00 
    2b9e:	89 74 24 1c          	mov    %esi,0x1c(%esp)
    2ba2:	89 54 24 18          	mov    %edx,0x18(%esp)
    2ba6:	89 4c 24 14          	mov    %ecx,0x14(%esp)
    2baa:	89 7c 24 10          	mov    %edi,0x10(%esp)
    2bae:	89 44 24 0c          	mov    %eax,0xc(%esp)
    2bb2:	c7 44 24 08 c5 00 00 	movl   $0xc5,0x8(%esp)
    2bb9:	00 
    2bba:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2bbe:	c7 44 24 04 a0 09 00 	movl   $0x9a0,0x4(%esp)
    2bc5:	00 
    2bc6:	89 3c 24             	mov    %edi,(%esp)
    2bc9:	e8 00 00 00 00       	call   2bce <_extract_or_test_files+0x215e>
    2bce:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    2bd5:	00 
    2bd6:	89 44 24 08          	mov    %eax,0x8(%esp)
    2bda:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2bde:	89 2c 24             	mov    %ebp,(%esp)
    2be1:	ff 54 24 5c          	call   *0x5c(%esp)
                      "\n", warning? "warning" : "error", G.used_csize,
                      G.lrec.ucsize, warning? "  ":"", G.lrec.csize,
                      "", "", "."));
                error = warning? PK_WARN : PK_ERR;
    2be5:	89 d8                	mov    %ebx,%eax
    2be7:	c1 e0 1f             	shl    $0x1f,%eax
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
                      "", warning?  "warning" : "error", G.used_csize,
                      G.lrec.ucsize, warning?  "  " : "", G.lrec.csize,
                      " [", FnFilter1(G.filename), "]"));
                else
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
    2bea:	83 ec 10             	sub    $0x10,%esp
                      "\n", warning? "warning" : "error", G.used_csize,
                      G.lrec.ucsize, warning? "  ":"", G.lrec.csize,
                      "", "", "."));
                error = warning? PK_WARN : PK_ERR;
    2bed:	c1 f8 1f             	sar    $0x1f,%eax
    2bf0:	83 c0 02             	add    $0x2,%eax
    2bf3:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    2bf7:	e9 b4 eb ff ff       	jmp    17b0 <_extract_or_test_files+0xd40>
                          LoadFarStringSmall(ErrUnzipFile),
                          LoadFarString(NotEnoughMem),
                          LoadFarStringSmall2(Unshrink),
                          FnFilter1(G.filename)));
                    else
                        Info(slide, 0x401, ((char *)slide,
    2bfc:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2c00:	c7 44 24 0c 24 05 00 	movl   $0x524,0xc(%esp)
    2c07:	00 
    2c08:	c7 44 24 08 5c 05 00 	movl   $0x55c,0x8(%esp)
    2c0f:	00 
    2c10:	c7 44 24 04 74 05 00 	movl   $0x574,0x4(%esp)
    2c17:	00 
    2c18:	89 3c 24             	mov    %edi,(%esp)
    2c1b:	e8 00 00 00 00       	call   2c20 <_extract_or_test_files+0x21b0>
    2c20:	e9 69 f1 ff ff       	jmp    1d8e <_extract_or_test_files+0x131e>
        if (request < 0) {
            Info(slide, 0x401, ((char *)slide, LoadFarStringSmall(SeekMsg),
              G.zipfn, LoadFarString(ReportMsg)));
            error_in_archive = PK_ERR;
            if (*pfilnum == 1 && G.extra_bytes != 0L) {
                Info(slide, 0x401, ((char *)slide,
    2c25:	a0 d8 00 00 00       	mov    0xd8,%al
    2c2a:	be d9 00 00 00       	mov    $0xd9,%esi
    2c2f:	88 07                	mov    %al,(%edi)
    2c31:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    2c37:	b8 20 00 00 00       	mov    $0x20,%eax
    2c3c:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2c42:	0f 84 3d e5 ff ff    	je     1185 <_extract_or_test_files+0x715>
    2c48:	66 8b 0e             	mov    (%esi),%cx
    2c4b:	83 c7 02             	add    $0x2,%edi
    2c4e:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    2c52:	83 c6 02             	add    $0x2,%esi
    2c55:	83 e8 02             	sub    $0x2,%eax
    2c58:	e9 28 e5 ff ff       	jmp    1185 <_extract_or_test_files+0x715>
    Go back through saved list of directories, sort and set times/perms/UIDs
    and GIDs from the deepest level on up.
  ---------------------------------------------------------------------------*/

#ifdef SET_DIR_ATTRIB
    if (num_dirs > 0) {
    2c5d:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
            if (error > error_in_archive)
                error_in_archive = error;
            /* ...and keep going (unless disk full or user break) */
            if (G.disk_full > 1 || error_in_archive == IZ_CTRLC) {
                /* clear reached_end to signal premature stop ... */
                reached_end = FALSE;
    2c64:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
    2c6b:	00 
    Go back through saved list of directories, sort and set times/perms/UIDs
    and GIDs from the deepest level on up.
  ---------------------------------------------------------------------------*/

#ifdef SET_DIR_ATTRIB
    if (num_dirs > 0) {
    2c6c:	85 c0                	test   %eax,%eax
    2c6e:	0f 85 f5 ec ff ff    	jne    1969 <_extract_or_test_files+0xef9>
    Check for unmatched filespecs on command line and print warning if any
    found.  Free allocated memory.  (But suppress check when central dir
    scan was interrupted prematurely.)
  ---------------------------------------------------------------------------*/

    if (fn_matched) {
    2c74:	8b 74 24 7c          	mov    0x7c(%esp),%esi
    2c78:	85 f6                	test   %esi,%esi
    2c7a:	0f 84 c3 00 00 00    	je     2d43 <_extract_or_test_files+0x22d3>
        if (reached_end) for (i = 0;  i < G.filespecs;  ++i)
    2c80:	8b 5c 24 38          	mov    0x38(%esp),%ebx
    2c84:	85 db                	test   %ebx,%ebx
    2c86:	0f 84 ab 00 00 00    	je     2d37 <_extract_or_test_files+0x22c7>
    2c8c:	8b 4d 6c             	mov    0x6c(%ebp),%ecx
    2c8f:	85 c9                	test   %ecx,%ecx
    2c91:	0f 84 a0 00 00 00    	je     2d37 <_extract_or_test_files+0x22c7>
            if (!fn_matched[i]) {
#ifdef DLL
                if (!G.redirect_data && !G.redirect_text)
                    Info(slide, 0x401, ((char *)slide,
    2c97:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    found.  Free allocated memory.  (But suppress check when central dir
    scan was interrupted prematurely.)
  ---------------------------------------------------------------------------*/

    if (fn_matched) {
        if (reached_end) for (i = 0;  i < G.filespecs;  ++i)
    2c9d:	31 f6                	xor    %esi,%esi
            if (!fn_matched[i]) {
#ifdef DLL
                if (!G.redirect_data && !G.redirect_text)
                    Info(slide, 0x401, ((char *)slide,
    2c9f:	89 5c 24 3c          	mov    %ebx,0x3c(%esp)
#else
                Info(slide, 1, ((char *)slide,
                  LoadFarString(FilenameNotMatched), G.pfnames[i]));
#endif
                if (error_in_archive <= PK_WARN)
                    error_in_archive = PK_FIND;   /* some files not found */
    2ca3:	bf 0b 00 00 00       	mov    $0xb,%edi
    if (fn_matched) {
        if (reached_end) for (i = 0;  i < G.filespecs;  ++i)
            if (!fn_matched[i]) {
#ifdef DLL
                if (!G.redirect_data && !G.redirect_text)
                    Info(slide, 0x401, ((char *)slide,
    2ca8:	8b 5c 24 50          	mov    0x50(%esp),%ebx
    2cac:	eb 14                	jmp    2cc2 <_extract_or_test_files+0x2252>
                      LoadFarString(FilenameNotMatched), G.pfnames[i]));
                else
                    setFileNotFound(__G);
    2cae:	89 2c 24             	mov    %ebp,(%esp)
    2cb1:	e8 00 00 00 00       	call   2cb6 <_extract_or_test_files+0x2246>
#else
                Info(slide, 1, ((char *)slide,
                  LoadFarString(FilenameNotMatched), G.pfnames[i]));
#endif
                if (error_in_archive <= PK_WARN)
                    error_in_archive = PK_FIND;   /* some files not found */
    2cb6:	83 fb 01             	cmp    $0x1,%ebx
    2cb9:	0f 4e df             	cmovle %edi,%ebx
    found.  Free allocated memory.  (But suppress check when central dir
    scan was interrupted prematurely.)
  ---------------------------------------------------------------------------*/

    if (fn_matched) {
        if (reached_end) for (i = 0;  i < G.filespecs;  ++i)
    2cbc:	46                   	inc    %esi
    2cbd:	39 75 6c             	cmp    %esi,0x6c(%ebp)
    2cc0:	76 71                	jbe    2d33 <_extract_or_test_files+0x22c3>
            if (!fn_matched[i]) {
    2cc2:	8b 54 24 7c          	mov    0x7c(%esp),%edx
    2cc6:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
    2ccd:	8b 14 b2             	mov    (%edx,%esi,4),%edx
    2cd0:	85 d2                	test   %edx,%edx
    2cd2:	75 e8                	jne    2cbc <_extract_or_test_files+0x224c>
#ifdef DLL
                if (!G.redirect_data && !G.redirect_text)
    2cd4:	8b 8d a0 00 00 00    	mov    0xa0(%ebp),%ecx
    2cda:	85 c9                	test   %ecx,%ecx
    2cdc:	75 d0                	jne    2cae <_extract_or_test_files+0x223e>
    2cde:	8b 95 a4 00 00 00    	mov    0xa4(%ebp),%edx
    2ce4:	85 d2                	test   %edx,%edx
    2ce6:	75 c6                	jne    2cae <_extract_or_test_files+0x223e>
                    Info(slide, 0x401, ((char *)slide,
    2ce8:	8b 8d c0 00 00 00    	mov    0xc0(%ebp),%ecx
    2cee:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    2cf4:	89 54 24 40          	mov    %edx,0x40(%esp)
    2cf8:	8b 04 01             	mov    (%ecx,%eax,1),%eax
    2cfb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    2d02:	00 
    2d03:	89 44 24 08          	mov    %eax,0x8(%esp)
    2d07:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    2d0b:	89 04 24             	mov    %eax,(%esp)
    2d0e:	e8 00 00 00 00       	call   2d13 <_extract_or_test_files+0x22a3>
    2d13:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    2d1a:	00 
    2d1b:	89 44 24 08          	mov    %eax,0x8(%esp)
    2d1f:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    2d23:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d27:	89 2c 24             	mov    %ebp,(%esp)
    2d2a:	ff 54 24 40          	call   *0x40(%esp)
    2d2e:	83 ec 10             	sub    $0x10,%esp
    2d31:	eb 83                	jmp    2cb6 <_extract_or_test_files+0x2246>
    2d33:	89 5c 24 50          	mov    %ebx,0x50(%esp)
                  LoadFarString(FilenameNotMatched), G.pfnames[i]));
#endif
                if (error_in_archive <= PK_WARN)
                    error_in_archive = PK_FIND;   /* some files not found */
            }
        free((zvoid *)fn_matched);
    2d37:	8b 44 24 7c          	mov    0x7c(%esp),%eax
    2d3b:	89 04 24             	mov    %eax,(%esp)
    2d3e:	e8 00 00 00 00       	call   2d43 <_extract_or_test_files+0x22d3>
    }
    if (xn_matched) {
    2d43:	8b b4 24 84 00 00 00 	mov    0x84(%esp),%esi
    2d4a:	85 f6                	test   %esi,%esi
    2d4c:	0f 84 8a 00 00 00    	je     2ddc <_extract_or_test_files+0x236c>
        if (reached_end) for (i = 0;  i < G.xfilespecs;  ++i)
    2d52:	8b 5c 24 38          	mov    0x38(%esp),%ebx
    2d56:	85 db                	test   %ebx,%ebx
    2d58:	74 73                	je     2dcd <_extract_or_test_files+0x235d>
    2d5a:	8b 4d 70             	mov    0x70(%ebp),%ecx
    2d5d:	85 c9                	test   %ecx,%ecx
    2d5f:	74 6c                	je     2dcd <_extract_or_test_files+0x235d>
    2d61:	31 ff                	xor    %edi,%edi
            if (!xn_matched[i])
                Info(slide, 0x401, ((char *)slide,
    2d63:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    2d69:	8b b4 24 84 00 00 00 	mov    0x84(%esp),%esi
    2d70:	eb 06                	jmp    2d78 <_extract_or_test_files+0x2308>
                    error_in_archive = PK_FIND;   /* some files not found */
            }
        free((zvoid *)fn_matched);
    }
    if (xn_matched) {
        if (reached_end) for (i = 0;  i < G.xfilespecs;  ++i)
    2d72:	47                   	inc    %edi
    2d73:	39 7d 70             	cmp    %edi,0x70(%ebp)
    2d76:	76 55                	jbe    2dcd <_extract_or_test_files+0x235d>
            if (!xn_matched[i])
    2d78:	8b 14 be             	mov    (%esi,%edi,4),%edx
    2d7b:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
    2d82:	85 d2                	test   %edx,%edx
    2d84:	75 ec                	jne    2d72 <_extract_or_test_files+0x2302>
                Info(slide, 0x401, ((char *)slide,
    2d86:	8b 8d c4 00 00 00    	mov    0xc4(%ebp),%ecx
    2d8c:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    2d92:	89 54 24 3c          	mov    %edx,0x3c(%esp)
                    error_in_archive = PK_FIND;   /* some files not found */
            }
        free((zvoid *)fn_matched);
    }
    if (xn_matched) {
        if (reached_end) for (i = 0;  i < G.xfilespecs;  ++i)
    2d96:	47                   	inc    %edi
            if (!xn_matched[i])
                Info(slide, 0x401, ((char *)slide,
    2d97:	8b 04 01             	mov    (%ecx,%eax,1),%eax
    2d9a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    2da1:	00 
    2da2:	89 44 24 08          	mov    %eax,0x8(%esp)
    2da6:	89 1c 24             	mov    %ebx,(%esp)
    2da9:	e8 00 00 00 00       	call   2dae <_extract_or_test_files+0x233e>
    2dae:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    2db5:	00 
    2db6:	89 44 24 08          	mov    %eax,0x8(%esp)
    2dba:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2dbe:	89 2c 24             	mov    %ebp,(%esp)
    2dc1:	ff 54 24 3c          	call   *0x3c(%esp)
    2dc5:	83 ec 10             	sub    $0x10,%esp
                    error_in_archive = PK_FIND;   /* some files not found */
            }
        free((zvoid *)fn_matched);
    }
    if (xn_matched) {
        if (reached_end) for (i = 0;  i < G.xfilespecs;  ++i)
    2dc8:	39 7d 70             	cmp    %edi,0x70(%ebp)
    2dcb:	77 ab                	ja     2d78 <_extract_or_test_files+0x2308>
            if (!xn_matched[i])
                Info(slide, 0x401, ((char *)slide,
                  LoadFarString(ExclFilenameNotMatched), G.pxnames[i]));
        free((zvoid *)xn_matched);
    2dcd:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
    2dd4:	89 04 24             	mov    %eax,(%esp)
    2dd7:	e8 00 00 00 00       	call   2ddc <_extract_or_test_files+0x236c>
    Now, all locally allocated memory has been released.  When the central
    directory processing has been interrupted prematurely, it is safe to
    return immediately.  All completeness checks and summary messages are
    skipped in this case.
  ---------------------------------------------------------------------------*/
    if (!reached_end)
    2ddc:	8b 44 24 38          	mov    0x38(%esp),%eax
    2de0:	85 c0                	test   %eax,%eax
    2de2:	0f 84 82 00 00 00    	je     2e6a <_extract_or_test_files+0x23fa>
    send the summary to stdout so that people doing the testing in the back-
    ground and redirecting to a file can just do a "tail" on the output file.
  ---------------------------------------------------------------------------*/

#ifndef SFX
    if (no_endsig_found) {                      /* just to make sure */
    2de8:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
    2def:	85 c0                	test   %eax,%eax
    2df1:	0f 85 c1 03 00 00    	jne    31b8 <_extract_or_test_files+0x2748>
    2df7:	83 7c 24 50 01       	cmpl   $0x1,0x50(%esp)
    2dfc:	0f 9e c0             	setle  %al
    2dff:	89 c6                	mov    %eax,%esi
        Info(slide, 0x401, ((char *)slide, LoadFarString(ReportMsg)));
        if (!error_in_archive)       /* don't overwrite stronger error */
            error_in_archive = PK_WARN;
    }
#endif /* !SFX */
    if (uO.tflag) {
    2e01:	8b 7d 44             	mov    0x44(%ebp),%edi
    2e04:	85 ff                	test   %edi,%edi
    2e06:	74 27                	je     2e2f <_extract_or_test_files+0x23bf>
        ulg num = filnum - num_bad_pwd;
    2e08:	8b 44 24 34          	mov    0x34(%esp),%eax
    2e0c:	8b 9c 24 94 00 00 00 	mov    0x94(%esp),%ebx

        if (uO.qflag < 2) {        /* GRR 930710:  was (uO.qflag == 1) */
    2e13:	8b 55 38             	mov    0x38(%ebp),%edx
        if (!error_in_archive)       /* don't overwrite stronger error */
            error_in_archive = PK_WARN;
    }
#endif /* !SFX */
    if (uO.tflag) {
        ulg num = filnum - num_bad_pwd;
    2e16:	29 d8                	sub    %ebx,%eax

        if (uO.qflag < 2) {        /* GRR 930710:  was (uO.qflag == 1) */
    2e18:	83 fa 01             	cmp    $0x1,%edx
    2e1b:	0f 8e 94 09 00 00    	jle    37b5 <_extract_or_test_files+0x2d45>
#if CRYPT
            if (num_bad_pwd > 0L)
                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipBadPasswd)
                  , num_bad_pwd, (num_bad_pwd==1L)? "":"s"));
#endif /* CRYPT */
        } else if ((uO.qflag == 0) && !error_in_archive && (num == 0))
    2e21:	0b 54 24 50          	or     0x50(%esp),%edx
    2e25:	75 08                	jne    2e2f <_extract_or_test_files+0x23bf>
    2e27:	85 c0                	test   %eax,%eax
    2e29:	0f 84 1d 09 00 00    	je     374c <_extract_or_test_files+0x2cdc>
    }

    /* give warning if files not tested or extracted (first condition can still
     * happen if zipfile is empty and no files specified on command line) */

    if ((filnum == 0) && error_in_archive <= PK_WARN) {
    2e2f:	89 f0                	mov    %esi,%eax
    2e31:	84 c0                	test   %al,%al
    2e33:	0f 84 e2 08 00 00    	je     371b <_extract_or_test_files+0x2cab>
    2e39:	8b 7c 24 34          	mov    0x34(%esp),%edi
    2e3d:	85 ff                	test   %edi,%edi
    2e3f:	0f 84 b1 0b 00 00    	je     39f6 <_extract_or_test_files+0x2f86>
            error_in_archive = IZ_UNSUP; /* unsupport. compression/encryption */
        else
            error_in_archive = PK_FIND;  /* no files found at all */
    }
#if CRYPT
    else if ((filnum == num_bad_pwd) && error_in_archive <= PK_WARN)
    2e45:	8b 94 24 94 00 00 00 	mov    0x94(%esp),%edx
    2e4c:	39 54 24 34          	cmp    %edx,0x34(%esp)
    2e50:	0f 84 df 0a 00 00    	je     3935 <_extract_or_test_files+0x2ec5>
        error_in_archive = IZ_BADPWD;    /* bad passwd => all files skipped */
#endif
    else if ((num_skipped > 0L) && error_in_archive <= PK_WARN)
    2e56:	8b 74 24 68          	mov    0x68(%esp),%esi
    2e5a:	85 f6                	test   %esi,%esi
    2e5c:	0f 84 b9 08 00 00    	je     371b <_extract_or_test_files+0x2cab>
    /* give warning if files not tested or extracted (first condition can still
     * happen if zipfile is empty and no files specified on command line) */

    if ((filnum == 0) && error_in_archive <= PK_WARN) {
        if (num_skipped > 0L)
            error_in_archive = IZ_UNSUP; /* unsupport. compression/encryption */
    2e62:	c7 44 24 50 51 00 00 	movl   $0x51,0x50(%esp)
    2e69:	00 
        error_in_archive = PK_WARN;
#endif

    return error_in_archive;

} /* end function extract_or_test_files() */
    2e6a:	8b 44 24 50          	mov    0x50(%esp),%eax
    2e6e:	81 c4 bc 00 00 00    	add    $0xbc,%esp
    2e74:	5b                   	pop    %ebx
    2e75:	5e                   	pop    %esi
    2e76:	5f                   	pop    %edi
    2e77:	5d                   	pop    %ebp
    2e78:	c3                   	ret    
        return PK_OK;                    /* do nothing and signal OK */

    if ((eb_size < (EB_UCSIZE_P + 4)) ||
        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) > 0L &&
         eb_size <= (compr_offset + EB_CMPRHEADLEN)))
        return IZ_EF_TRUNC;               /* no compressed data! */
    2e79:	c7 44 24 64 4f 00 00 	movl   $0x4f,0x64(%esp)
    2e80:	00 
                    break;
                }
                if ((r = test_compr_eb(__G__ ef, ebLen, eb_cmpr_offs, NULL))
                    != PK_OK) {
                    if (uO.qflag)
                        Info(slide, 1, ((char *)slide, "%-22s ",
    2e81:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2e87:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2e8d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2e91:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    2e97:	89 04 24             	mov    %eax,(%esp)
    2e9a:	e8 d1 d6 ff ff       	call   570 <_fnfilter>
    2e9f:	8b 7c 24 40          	mov    0x40(%esp),%edi
    2ea3:	89 44 24 08          	mov    %eax,0x8(%esp)
    2ea7:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
    2eae:	00 
    2eaf:	89 3c 24             	mov    %edi,(%esp)
    2eb2:	e8 00 00 00 00       	call   2eb7 <_extract_or_test_files+0x2447>
    2eb7:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    2ebe:	00 
    2ebf:	89 44 24 08          	mov    %eax,0x8(%esp)
    2ec3:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2ec7:	89 2c 24             	mov    %ebp,(%esp)
    2eca:	ff d3                	call   *%ebx
    2ecc:	83 ec 10             	sub    $0x10,%esp
                          FnFilter1(G.filename)));
                    switch (r) {
    2ecf:	8b 44 24 64          	mov    0x64(%esp),%eax
    2ed3:	83 f8 07             	cmp    $0x7,%eax
    2ed6:	0f 8e a9 f9 ff ff    	jle    2885 <_extract_or_test_files+0x1e15>
    2edc:	83 7c 24 64 4f       	cmpl   $0x4f,0x64(%esp)
    2ee1:	0f 84 6a f3 ff ff    	je     2251 <_extract_or_test_files+0x17e1>
                        case PK_MEM4:
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(NotEnoughMemEAs)));
                            break;
                        default:
                            if ((r & 0xff) != PK_ERR)
    2ee7:	80 7c 24 64 02       	cmpb   $0x2,0x64(%esp)
    2eec:	0f 84 24 0b 00 00    	je     3a16 <_extract_or_test_files+0x2fa6>
                                Info(slide, 1, ((char *)slide,
    2ef2:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    2ef6:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    2efc:	89 cf                	mov    %ecx,%edi
    2efe:	be 70 01 00 00       	mov    $0x170,%esi
    2f03:	b8 27 00 00 00       	mov    $0x27,%eax
    2f08:	f6 c1 01             	test   $0x1,%cl
    2f0b:	74 17                	je     2f24 <_extract_or_test_files+0x24b4>
    2f0d:	a0 70 01 00 00       	mov    0x170,%al
    2f12:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    2f18:	88 01                	mov    %al,(%ecx)
    2f1a:	be 71 01 00 00       	mov    $0x171,%esi
    2f1f:	b8 26 00 00 00       	mov    $0x26,%eax
    2f24:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2f2a:	74 10                	je     2f3c <_extract_or_test_files+0x24cc>
    2f2c:	66 8b 0e             	mov    (%esi),%cx
    2f2f:	83 c7 02             	add    $0x2,%edi
    2f32:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    2f36:	83 c6 02             	add    $0x2,%esi
    2f39:	83 e8 02             	sub    $0x2,%eax
    2f3c:	89 c1                	mov    %eax,%ecx
    2f3e:	c1 e9 02             	shr    $0x2,%ecx
    2f41:	a8 02                	test   $0x2,%al
    2f43:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    2f45:	74 0b                	je     2f52 <_extract_or_test_files+0x24e2>
    2f47:	66 8b 0e             	mov    (%esi),%cx
    2f4a:	66 89 0f             	mov    %cx,(%edi)
    2f4d:	b9 02 00 00 00       	mov    $0x2,%ecx
    2f52:	a8 01                	test   $0x1,%al
    2f54:	74 06                	je     2f5c <_extract_or_test_files+0x24ec>
    2f56:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    2f59:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    2f5c:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    2f63:	00 
    2f64:	c7 44 24 08 26 00 00 	movl   $0x26,0x8(%esp)
    2f6b:	00 
    2f6c:	e9 a0 f9 ff ff       	jmp    2911 <_extract_or_test_files+0x1ea1>
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
                      "", warning?  "warning" : "error", G.used_csize,
                      G.lrec.ucsize, warning?  "  " : "", G.lrec.csize,
                      " [", FnFilter1(G.filename), "]"));
                else
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
    2f71:	8b 8d 24 09 01 00    	mov    0x10924(%ebp),%ecx
    2f77:	ba 12 00 00 00       	mov    $0x12,%edx
    2f7c:	b8 81 00 00 00       	mov    $0x81,%eax
    2f81:	e9 00 fc ff ff       	jmp    2b86 <_extract_or_test_files+0x2116>
            if ((errcode = error & MPN_MASK) > MPN_INF_TRUNC) {
                if (errcode == MPN_CREATED_DIR) {
#ifdef SET_DIR_ATTRIB
                    direntry *d_entry;

                    error = defer_dir_attribs(__G__ &d_entry);
    2f86:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
    2f8d:	89 2c 24             	mov    %ebp,(%esp)
    2f90:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f94:	e8 00 00 00 00       	call   2f99 <_extract_or_test_files+0x2529>
                    if (d_entry == (direntry *)NULL) {
    2f99:	8b 94 24 ac 00 00 00 	mov    0xac(%esp),%edx
    2fa0:	85 d2                	test   %edx,%edx
    2fa2:	0f 84 a4 09 00 00    	je     394c <_extract_or_test_files+0x2edc>
                                 LoadFarString(DirlistEntryNoMem)));
                            if (!error_in_archive)
                                error_in_archive = PK_WARN;
                        }
                    } else {
                        d_entry->next = (*pdirlist);
    2fa8:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
#else
                    Info(slide, 1, ((char *)slide,
                      LoadFarString(SkipVolumeLabel),
                      FnFilter1(G.filename), ""));
#endif
                } else if (errcode > MPN_INF_SKIP &&
    2faf:	89 5c 24 48          	mov    %ebx,0x48(%esp)
                                 LoadFarString(DirlistEntryNoMem)));
                            if (!error_in_archive)
                                error_in_archive = PK_WARN;
                        }
                    } else {
                        d_entry->next = (*pdirlist);
    2fb3:	89 02                	mov    %eax,(%edx)
                        (*pdirlist) = d_entry;
                        ++(*pnum_dirs);
    2fb5:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
    2fbc:	40                   	inc    %eax
    2fbd:	89 94 24 98 00 00 00 	mov    %edx,0x98(%esp)
    2fc4:	89 84 24 90 00 00 00 	mov    %eax,0x90(%esp)
    2fcb:	e9 e1 de ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
            if ((r = TestExtraField(__G__ G.extra_field,
                                    G.lrec.extra_field_length)) > error)
                error = r;
        } else
#endif /* !SFX */
        if (!uO.qflag)
    2fd0:	8b 7d 38             	mov    0x38(%ebp),%edi
    2fd3:	85 ff                	test   %edi,%edi
    2fd5:	0f 85 96 f6 ff ff    	jne    2671 <_extract_or_test_files+0x1c01>
            Info(slide, 0, ((char *)slide, " OK\n"));
    2fdb:	8b 54 24 40          	mov    0x40(%esp),%edx
    2fdf:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    2fe5:	c7 02 20 4f 4b 0a    	movl   $0xa4b4f20,(%edx)
    2feb:	c6 42 04 00          	movb   $0x0,0x4(%edx)
    2fef:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2ff6:	00 
    2ff7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    2ffe:	00 
    2fff:	89 54 24 04          	mov    %edx,0x4(%esp)
    3003:	89 2c 24             	mov    %ebp,(%esp)
    3006:	ff d0                	call   *%eax
    3008:	83 ec 10             	sub    $0x10,%esp
    300b:	e9 61 f6 ff ff       	jmp    2671 <_extract_or_test_files+0x1c01>
#if CRYPT
        if (G.pInfo->encrypted &&
            (error = decrypt(__G__ uO.pwdarg)) != PK_COOL) {
            if (error == PK_WARN) {
                if (!((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2)))
                    Info(slide, 0x401, ((char *)slide,
    3010:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3016:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    301c:	89 44 24 04          	mov    %eax,0x4(%esp)
    3020:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    3026:	89 04 24             	mov    %eax,(%esp)
    3029:	e8 42 d5 ff ff       	call   570 <_fnfilter>
    302e:	8b 7c 24 40          	mov    0x40(%esp),%edi
    3032:	89 44 24 08          	mov    %eax,0x8(%esp)
    3036:	c7 44 24 04 c0 06 00 	movl   $0x6c0,0x4(%esp)
    303d:	00 
    303e:	89 3c 24             	mov    %edi,(%esp)
    3041:	e8 00 00 00 00       	call   3046 <_extract_or_test_files+0x25d6>
    3046:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    304d:	00 
    304e:	89 44 24 08          	mov    %eax,0x8(%esp)
    3052:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3056:	89 2c 24             	mov    %ebp,(%esp)
    3059:	ff d3                	call   *%ebx
    305b:	83 ec 10             	sub    $0x10,%esp
    305e:	e9 ed f5 ff ff       	jmp    2650 <_extract_or_test_files+0x1be0>
    3063:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp
        }
        ef_len -= (ebLen + EB_HEADSIZE);
        ef += (ebLen + EB_HEADSIZE);
    }

    if (!uO.qflag)
    306a:	8b 5d 38             	mov    0x38(%ebp),%ebx
    306d:	85 db                	test   %ebx,%ebx
    306f:	0f 84 0e 01 00 00    	je     3183 <_extract_or_test_files+0x2713>
        Info(slide, 0, ((char *)slide, " OK\n"));

    return PK_COOL;
    3075:	31 db                	xor    %ebx,%ebx
    3077:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    307b:	39 d8                	cmp    %ebx,%eax
    307d:	0f 4d d8             	cmovge %eax,%ebx
    3080:	89 5c 24 5c          	mov    %ebx,0x5c(%esp)
    3084:	e9 e8 f5 ff ff       	jmp    2671 <_extract_or_test_files+0x1c01>
#endif /* !SFX */
        if (!uO.qflag)
            Info(slide, 0, ((char *)slide, " OK\n"));
    } else {
        if (QCOND2 && !error)   /* GRR:  is stdout reset to text mode yet? */
            Info(slide, 0, ((char *)slide, "\n"));
    3089:	8b 54 24 40          	mov    0x40(%esp),%edx
    308d:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    3093:	66 c7 02 0a 00       	movw   $0xa,(%edx)
    3098:	89 54 24 04          	mov    %edx,0x4(%esp)
    309c:	89 2c 24             	mov    %ebp,(%esp)
    309f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    30a6:	00 
    30a7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    30ae:	00 
    30af:	ff d0                	call   *%eax
    30b1:	83 ec 10             	sub    $0x10,%esp
    }

    undefer_input(__G);
    30b4:	89 2c 24             	mov    %ebp,(%esp)
    30b7:	e8 00 00 00 00       	call   30bc <_extract_or_test_files+0x264c>
    30bc:	e9 ad e7 ff ff       	jmp    186e <_extract_or_test_files+0xdfe>
    30c1:	89 ac 24 8c 00 00 00 	mov    %ebp,0x8c(%esp)
    30c8:	8b ac 24 d0 00 00 00 	mov    0xd0(%esp),%ebp
        ebID = makeword(ef);
        ebLen = (unsigned)makeword(ef+EB_LEN);

        if (ebLen > (ef_len - EB_HEADSIZE)) {
           /* Discovered some extra field inconsistency! */
            if (uO.qflag)
    30cf:	8b 45 38             	mov    0x38(%ebp),%eax
    30d2:	85 c0                	test   %eax,%eax
    30d4:	75 5a                	jne    3130 <_extract_or_test_files+0x26c0>
                Info(slide, 1, ((char *)slide, "%-22s ",
                  FnFilter1(G.filename)));
            Info(slide, 1, ((char *)slide, LoadFarString(InconsistEFlength),
    30d6:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    30dc:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
    30e3:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    30e7:	8b 7c 24 40          	mov    0x40(%esp),%edi
    30eb:	89 44 24 08          	mov    %eax,0x8(%esp)
    30ef:	c7 44 24 04 a0 03 00 	movl   $0x3a0,0x4(%esp)
    30f6:	00 
    30f7:	89 3c 24             	mov    %edi,(%esp)
    30fa:	e8 00 00 00 00       	call   30ff <_extract_or_test_files+0x268f>
    30ff:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3106:	00 
    3107:	89 44 24 08          	mov    %eax,0x8(%esp)
    310b:	89 7c 24 04          	mov    %edi,0x4(%esp)
    310f:	89 2c 24             	mov    %ebp,(%esp)
    3112:	ff d3                	call   *%ebx
    3114:	83 ec 10             	sub    $0x10,%esp
              ebLen, (ef_len - EB_HEADSIZE)));
            return PK_ERR;
    3117:	c7 44 24 64 02 00 00 	movl   $0x2,0x64(%esp)
    311e:	00 
    } else {
        if (QCOND2 && !error)   /* GRR:  is stdout reset to text mode yet? */
            Info(slide, 0, ((char *)slide, "\n"));
    }

    undefer_input(__G);
    311f:	89 2c 24             	mov    %ebp,(%esp)
    3122:	e8 00 00 00 00       	call   3127 <_extract_or_test_files+0x26b7>
    3127:	8b 54 24 64          	mov    0x64(%esp),%edx
    312b:	e9 1b e7 ff ff       	jmp    184b <_extract_or_test_files+0xddb>
        ebLen = (unsigned)makeword(ef+EB_LEN);

        if (ebLen > (ef_len - EB_HEADSIZE)) {
           /* Discovered some extra field inconsistency! */
            if (uO.qflag)
                Info(slide, 1, ((char *)slide, "%-22s ",
    3130:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3136:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    313c:	89 44 24 04          	mov    %eax,0x4(%esp)
    3140:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    3146:	89 04 24             	mov    %eax,(%esp)
    3149:	e8 22 d4 ff ff       	call   570 <_fnfilter>
    314e:	8b 74 24 40          	mov    0x40(%esp),%esi
    3152:	89 44 24 08          	mov    %eax,0x8(%esp)
    3156:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
    315d:	00 
    315e:	89 34 24             	mov    %esi,(%esp)
    3161:	e8 00 00 00 00       	call   3166 <_extract_or_test_files+0x26f6>
    3166:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    316d:	00 
    316e:	89 44 24 08          	mov    %eax,0x8(%esp)
    3172:	89 74 24 04          	mov    %esi,0x4(%esp)
    3176:	89 2c 24             	mov    %ebp,(%esp)
    3179:	ff d3                	call   *%ebx
    317b:	83 ec 10             	sub    $0x10,%esp
    317e:	e9 53 ff ff ff       	jmp    30d6 <_extract_or_test_files+0x2666>
        ef_len -= (ebLen + EB_HEADSIZE);
        ef += (ebLen + EB_HEADSIZE);
    }

    if (!uO.qflag)
        Info(slide, 0, ((char *)slide, " OK\n"));
    3183:	8b 54 24 40          	mov    0x40(%esp),%edx
    3187:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    318d:	c7 02 20 4f 4b 0a    	movl   $0xa4b4f20,(%edx)
    3193:	c6 42 04 00          	movb   $0x0,0x4(%edx)
    3197:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    319e:	00 
    319f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    31a6:	00 
    31a7:	89 54 24 04          	mov    %edx,0x4(%esp)
    31ab:	89 2c 24             	mov    %ebp,(%esp)
    31ae:	ff d0                	call   *%eax
    31b0:	83 ec 10             	sub    $0x10,%esp
    31b3:	e9 bf fe ff ff       	jmp    3077 <_extract_or_test_files+0x2607>
    ground and redirecting to a file can just do a "tail" on the output file.
  ---------------------------------------------------------------------------*/

#ifndef SFX
    if (no_endsig_found) {                      /* just to make sure */
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
    31b8:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    31be:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    31c4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    31cb:	00 
    31cc:	89 1c 24             	mov    %ebx,(%esp)
    31cf:	e8 00 00 00 00       	call   31d4 <_extract_or_test_files+0x2764>
    31d4:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    31db:	00 
    31dc:	89 44 24 08          	mov    %eax,0x8(%esp)
    31e0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    31e4:	89 2c 24             	mov    %ebp,(%esp)
    31e7:	ff d6                	call   *%esi
        Info(slide, 0x401, ((char *)slide, LoadFarString(ReportMsg)));
    31e9:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    ground and redirecting to a file can just do a "tail" on the output file.
  ---------------------------------------------------------------------------*/

#ifndef SFX
    if (no_endsig_found) {                      /* just to make sure */
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
    31ef:	83 ec 10             	sub    $0x10,%esp
        Info(slide, 0x401, ((char *)slide, LoadFarString(ReportMsg)));
    31f2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    31f9:	00 
    31fa:	89 1c 24             	mov    %ebx,(%esp)
    31fd:	e8 00 00 00 00       	call   3202 <_extract_or_test_files+0x2792>
    3202:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    3209:	00 
    320a:	89 44 24 08          	mov    %eax,0x8(%esp)
    320e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3212:	89 2c 24             	mov    %ebp,(%esp)
    3215:	ff d6                	call   *%esi
    3217:	83 ec 10             	sub    $0x10,%esp
        if (!error_in_archive)       /* don't overwrite stronger error */
    321a:	8b 44 24 50          	mov    0x50(%esp),%eax
    321e:	85 c0                	test   %eax,%eax
    3220:	0f 85 d1 fb ff ff    	jne    2df7 <_extract_or_test_files+0x2387>
    3226:	be 01 00 00 00       	mov    $0x1,%esi
            error_in_archive = PK_WARN;
    322b:	c7 44 24 50 01 00 00 	movl   $0x1,0x50(%esp)
    3232:	00 
    3233:	e9 c9 fb ff ff       	jmp    2e01 <_extract_or_test_files+0x2391>
            }
            if (r == 5) {
                int warning = ((ulg)G.used_csize <= G.lrec.csize);

                if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
    3238:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    323e:	89 44 24 5c          	mov    %eax,0x5c(%esp)
    3242:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3248:	89 44 24 04          	mov    %eax,0x4(%esp)
    324c:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    3252:	89 04 24             	mov    %eax,(%esp)
    3255:	e8 16 d3 ff ff       	call   570 <_fnfilter>
    325a:	8b 95 20 09 01 00    	mov    0x10920(%ebp),%edx
    3260:	89 54 24 64          	mov    %edx,0x64(%esp)
    3264:	84 db                	test   %bl,%bl
    3266:	0f 84 0e 04 00 00    	je     367a <_extract_or_test_files+0x2c0a>
    326c:	8b b5 24 09 01 00    	mov    0x10924(%ebp),%esi
    3272:	8b 8d 94 00 00 00    	mov    0x94(%ebp),%ecx
    3278:	ba 76 00 00 00       	mov    $0x76,%edx
    327d:	bf 79 00 00 00       	mov    $0x79,%edi
    3282:	89 44 24 24          	mov    %eax,0x24(%esp)
    3286:	8b 44 24 64          	mov    0x64(%esp),%eax
    328a:	c7 44 24 28 be 00 00 	movl   $0xbe,0x28(%esp)
    3291:	00 
    3292:	c7 44 24 20 c0 00 00 	movl   $0xc0,0x20(%esp)
    3299:	00 
    329a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    329e:	89 54 24 18          	mov    %edx,0x18(%esp)
    32a2:	89 74 24 14          	mov    %esi,0x14(%esp)
    32a6:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    32aa:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    32ae:	c7 44 24 08 12 00 00 	movl   $0x12,0x8(%esp)
    32b5:	00 
    32b6:	e9 ff f8 ff ff       	jmp    2bba <_extract_or_test_files+0x214a>
            }

#ifdef QDOS
            QFilename(__G__ G.filename);
#endif
            switch (check_for_newer(__G__ G.filename)) {
    32bb:	89 5c 24 48          	mov    %ebx,0x48(%esp)
                case DOES_NOT_EXIST:
#ifdef NOVELL_BUG_FAILSAFE
                    G.dne = TRUE;   /* stat() says file DOES NOT EXIST */
#endif
                    /* freshen (no new files): skip unless just renamed */
                    if (uO.fflag && !renamed)
    32bf:	85 ff                	test   %edi,%edi
    32c1:	0f 85 f9 e2 ff ff    	jne    15c0 <_extract_or_test_files+0xb50>
    32c7:	8b 75 1c             	mov    0x1c(%ebp),%esi
    32ca:	85 f6                	test   %esi,%esi
    32cc:	0f 85 df db ff ff    	jne    eb1 <_extract_or_test_files+0x441>
    32d2:	e9 e9 e2 ff ff       	jmp    15c0 <_extract_or_test_files+0xb50>
                    break;
                case EXISTS_AND_NEWER:             /* (or equal) */
#ifdef UNIXBACKUP
                    if ((!uO.B_flag && IS_OVERWRT_NONE) ||
#else
                    if (IS_OVERWRT_NONE ||
    32d7:	8b 45 78             	mov    0x78(%ebp),%eax
    32da:	83 f8 02             	cmp    $0x2,%eax
    32dd:	74 45                	je     3324 <_extract_or_test_files+0x28b4>
#endif
                        (uO.uflag && !renamed)) {
    32df:	85 ff                	test   %edi,%edi
    32e1:	75 0b                	jne    32ee <_extract_or_test_files+0x287e>
    32e3:	8b 4d 4c             	mov    0x4c(%ebp),%ecx
    32e6:	85 c9                	test   %ecx,%ecx
    32e8:	0f 85 c0 04 00 00    	jne    37ae <_extract_or_test_files+0x2d3e>
                        skip_entry = SKIP_Y_EXISTING;
                    } else {
#ifdef UNIXBACKUP
                        if (!IS_OVERWRT_ALL && !uO.B_flag)
#else
                        if (!IS_OVERWRT_ALL)
    32ee:	48                   	dec    %eax
    32ef:	0f 84 cb e2 ff ff    	je     15c0 <_extract_or_test_files+0xb50>
                    }
                    break;
                }
            if (query) {
#ifdef WINDLL
                switch (G.lpUserFunctions->replace != NULL ?
    32f5:	8b 85 58 0b 01 00    	mov    0x10b58(%ebp),%eax
    32fb:	8b 40 08             	mov    0x8(%eax),%eax
                        (*G.lpUserFunctions->replace)(G.filename) :
    32fe:	85 c0                	test   %eax,%eax
    3300:	0f 84 93 02 00 00    	je     3599 <_extract_or_test_files+0x2b29>
    3306:	89 34 24             	mov    %esi,(%esp)
    3309:	ff d0                	call   *%eax
                    }
                    break;
                }
            if (query) {
#ifdef WINDLL
                switch (G.lpUserFunctions->replace != NULL ?
    330b:	83 f8 67             	cmp    $0x67,%eax
                        (*G.lpUserFunctions->replace)(G.filename) :
    330e:	52                   	push   %edx
                    }
                    break;
                }
            if (query) {
#ifdef WINDLL
                switch (G.lpUserFunctions->replace != NULL ?
    330f:	0f 84 74 02 00 00    	je     3589 <_extract_or_test_files+0x2b19>
    3315:	0f 8f 8f 00 00 00    	jg     33aa <_extract_or_test_files+0x293a>
    331b:	83 f8 64             	cmp    $0x64,%eax
    331e:	0f 85 9c e2 ff ff    	jne    15c0 <_extract_or_test_files+0xb50>
            } /* end if (query) */
            if (skip_entry != SKIP_NO) {
#ifdef WINDLL
                if (skip_entry == SKIP_Y_EXISTING) {
                    /* report skipping of an existing entry */
                    Info(slide, 0, ((char *)slide,
    3324:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    332a:	89 34 24             	mov    %esi,(%esp)
    332d:	89 44 24 48          	mov    %eax,0x48(%esp)
    3331:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3337:	89 44 24 04          	mov    %eax,0x4(%esp)
    333b:	e8 30 d2 ff ff       	call   570 <_fnfilter>
    3340:	83 7d 78 02          	cmpl   $0x2,0x78(%ebp)
    3344:	0f 84 5a 04 00 00    	je     37a4 <_extract_or_test_files+0x2d34>
    334a:	85 ff                	test   %edi,%edi
    334c:	0f 85 52 04 00 00    	jne    37a4 <_extract_or_test_files+0x2d34>
    3352:	8b 75 4c             	mov    0x4c(%ebp),%esi
    3355:	85 f6                	test   %esi,%esi
    3357:	0f 84 47 04 00 00    	je     37a4 <_extract_or_test_files+0x2d34>
    335d:	ba 38 00 00 00       	mov    $0x38,%edx
    3362:	8b 7c 24 40          	mov    0x40(%esp),%edi
    3366:	89 44 24 08          	mov    %eax,0x8(%esp)
    336a:	89 54 24 04          	mov    %edx,0x4(%esp)
    336e:	89 3c 24             	mov    %edi,(%esp)
    3371:	e8 00 00 00 00       	call   3376 <_extract_or_test_files+0x2906>
    3376:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    337d:	00 
    337e:	89 44 24 08          	mov    %eax,0x8(%esp)
    3382:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3386:	89 2c 24             	mov    %ebp,(%esp)
    3389:	ff 54 24 48          	call   *0x48(%esp)
    338d:	83 ec 10             	sub    $0x10,%esp
    3390:	89 5c 24 48          	mov    %ebx,0x48(%esp)
    3394:	e9 18 db ff ff       	jmp    eb1 <_extract_or_test_files+0x441>
                case EXISTS_AND_OLDER:
#ifdef UNIXBACKUP
                    if (!uO.B_flag)
#endif
                    {
                        if (IS_OVERWRT_NONE)
    3399:	8b 45 78             	mov    0x78(%ebp),%eax
    339c:	83 f8 02             	cmp    $0x2,%eax
    339f:	0f 85 49 ff ff ff    	jne    32ee <_extract_or_test_files+0x287e>
    33a5:	e9 7a ff ff ff       	jmp    3324 <_extract_or_test_files+0x28b4>
                    }
                    break;
                }
            if (query) {
#ifdef WINDLL
                switch (G.lpUserFunctions->replace != NULL ?
    33aa:	83 f8 68             	cmp    $0x68,%eax
    33ad:	0f 84 e6 01 00 00    	je     3599 <_extract_or_test_files+0x2b29>
    33b3:	83 f8 69             	cmp    $0x69,%eax
    33b6:	0f 85 04 e2 ff ff    	jne    15c0 <_extract_or_test_files+0xb50>
                        (*G.lpUserFunctions->replace)(G.filename) :
                        IDM_REPLACE_NONE) {
                    case IDM_REPLACE_RENAME:
                        _ISO_INTERN(G.filename);
                        renamed = TRUE;
    33bc:	bf 01 00 00 00       	mov    $0x1,%edi
                    }
                    break;
                }
            if (query) {
#ifdef WINDLL
                switch (G.lpUserFunctions->replace != NULL ?
    33c1:	89 5c 24 48          	mov    %ebx,0x48(%esp)
    33c5:	e9 52 e1 ff ff       	jmp    151c <_extract_or_test_files+0xaac>
                  case EF_ACL:
                    eb_cmpr_offs = EB_OS2_HLEN;
                    break;
                  case EF_MAC3:
                    if (ebLen >= EB_MAC3_HLEN &&
                        (makeword(ef+(EB_HEADSIZE+EB_FLGS_OFFS))
    33ca:	8d 43 08             	lea    0x8(%ebx),%eax
    33cd:	89 04 24             	mov    %eax,(%esp)
    33d0:	e8 00 00 00 00       	call   33d5 <_extract_or_test_files+0x2965>
                  case EF_OS2:
                  case EF_ACL:
                    eb_cmpr_offs = EB_OS2_HLEN;
                    break;
                  case EF_MAC3:
                    if (ebLen >= EB_MAC3_HLEN &&
    33d5:	a8 04                	test   $0x4,%al
    33d7:	0f 84 08 f7 ff ff    	je     2ae5 <_extract_or_test_files+0x2075>
                        (makeword(ef+(EB_HEADSIZE+EB_FLGS_OFFS))
                         & EB_M3_FL_UNCMPR) &&
                        (makelong(ef+EB_HEADSIZE) == ebLen - EB_MAC3_HLEN))
    33dd:	8d 43 04             	lea    0x4(%ebx),%eax
    33e0:	89 04 24             	mov    %eax,(%esp)
    33e3:	e8 00 00 00 00       	call   33e8 <_extract_or_test_files+0x2978>
    33e8:	8d 55 f2             	lea    -0xe(%ebp),%edx
                    eb_cmpr_offs = EB_OS2_HLEN;
                    break;
                  case EF_MAC3:
                    if (ebLen >= EB_MAC3_HLEN &&
                        (makeword(ef+(EB_HEADSIZE+EB_FLGS_OFFS))
                         & EB_M3_FL_UNCMPR) &&
    33eb:	39 d0                	cmp    %edx,%eax
    33ed:	0f 85 f2 f6 ff ff    	jne    2ae5 <_extract_or_test_files+0x2075>
    33f3:	e9 c5 ed ff ff       	jmp    21bd <_extract_or_test_files+0x174d>

#ifndef SFX
#ifndef LZW_CLEAN
        case SHRUNK:
            if (!uO.tflag && QCOND2) {
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    33f8:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    33fe:	bf 6d 00 00 00       	mov    $0x6d,%edi
    3403:	f6 40 18 04          	testb  $0x4,0x18(%eax)
    3407:	b8 5b 00 00 00       	mov    $0x5b,%eax
    340c:	0f 44 f8             	cmove  %eax,%edi
    340f:	e9 b4 e8 ff ff       	jmp    1cc8 <_extract_or_test_files+0x1258>
                if (G.symlnk)   /* can also be deflated, but rarer... */
                    Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
                      "link", FnFilter1(G.filename), "", ""));
                else
#endif /* SYMLINKS */
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    3414:	8b 85 24 09 01 00    	mov    0x10924(%ebp),%eax
    341a:	bb 64 00 00 00       	mov    $0x64,%ebx
    341f:	85 c0                	test   %eax,%eax
    3421:	0f 84 67 e7 ff ff    	je     1b8e <_extract_or_test_files+0x111e>
    3427:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    342d:	bb 6d 00 00 00       	mov    $0x6d,%ebx
    3432:	f6 40 18 04          	testb  $0x4,0x18(%eax)
    3436:	b8 5b 00 00 00       	mov    $0x5b,%eax
    343b:	0f 44 d8             	cmove  %eax,%ebx
    343e:	e9 4b e7 ff ff       	jmp    1b8e <_extract_or_test_files+0x111e>
            break;
#endif /* !COPYRIGHT_CLEAN */

        case IMPLODED:
            if (!uO.tflag && QCOND2) {
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    3443:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    3449:	bf 6d 00 00 00       	mov    $0x6d,%edi
    344e:	f6 40 18 04          	testb  $0x4,0x18(%eax)
    3452:	b8 5b 00 00 00       	mov    $0x5b,%eax
    3457:	0f 44 f8             	cmove  %eax,%edi
    345a:	e9 4b e6 ff ff       	jmp    1aaa <_extract_or_test_files+0x103a>
            if ((r = UZinflate(__G__
                               (G.lrec.compression_method == ENHDEFLATED)))
                != 0) {
                if (r < PK_DISK) {
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
                        Info(slide, 0x401, ((char *)slide,
    345f:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3465:	89 44 24 04          	mov    %eax,0x4(%esp)
    3469:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    346f:	89 04 24             	mov    %eax,(%esp)
    3472:	e8 f9 d0 ff ff       	call   570 <_fnfilter>
    3477:	b9 40 05 00 00       	mov    $0x540,%ecx
    347c:	ba 5c 05 00 00       	mov    $0x55c,%edx
    3481:	89 44 24 10          	mov    %eax,0x10(%esp)
    3485:	83 7c 24 5c 03       	cmpl   $0x3,0x5c(%esp)
    348a:	c7 44 24 0c 38 05 00 	movl   $0x538,0xc(%esp)
    3491:	00 
    3492:	0f 45 d1             	cmovne %ecx,%edx
    3495:	8b 7c 24 40          	mov    0x40(%esp),%edi
    3499:	89 54 24 08          	mov    %edx,0x8(%esp)
    349d:	c7 44 24 04 88 05 00 	movl   $0x588,0x4(%esp)
    34a4:	00 
    34a5:	89 3c 24             	mov    %edi,(%esp)
    34a8:	e8 00 00 00 00       	call   34ad <_extract_or_test_files+0x2a3d>
    34ad:	e9 ca e2 ff ff       	jmp    177c <_extract_or_test_files+0xd0c>
        case DEFLATED:
#ifdef USE_DEFLATE64
        case ENHDEFLATED:
#endif
            if (!uO.tflag && QCOND2) {
                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),
    34b2:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    34b8:	bf 6d 00 00 00       	mov    $0x6d,%edi
    34bd:	f6 40 18 04          	testb  $0x4,0x18(%eax)
    34c1:	b8 5b 00 00 00       	mov    $0x5b,%eax
    34c6:	0f 44 f8             	cmove  %eax,%edi
    34c9:	e9 e4 e1 ff ff       	jmp    16b2 <_extract_or_test_files+0xc42>
#endif /* !SFX */

            if (!renamed) {
               /* remove absolute path specs */
               if (G.filename[0] == '/') {
                   Info(slide, 0x401, ((char *)slide,
    34ce:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    34d4:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    34da:	89 44 24 04          	mov    %eax,0x4(%esp)
    34de:	89 34 24             	mov    %esi,(%esp)
    34e1:	e8 8a d0 ff ff       	call   570 <_fnfilter>
    34e6:	c7 44 24 04 c0 08 00 	movl   $0x8c0,0x4(%esp)
    34ed:	00 
    34ee:	89 44 24 08          	mov    %eax,0x8(%esp)
    34f2:	8b 44 24 40          	mov    0x40(%esp),%eax
    34f6:	89 04 24             	mov    %eax,(%esp)
    34f9:	e8 00 00 00 00       	call   34fe <_extract_or_test_files+0x2a8e>
    34fe:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    3505:	00 
    3506:	89 44 24 08          	mov    %eax,0x8(%esp)
    350a:	8b 44 24 40          	mov    0x40(%esp),%eax
    350e:	89 44 24 04          	mov    %eax,0x4(%esp)
    3512:	89 2c 24             	mov    %ebp,(%esp)
    3515:	ff d3                	call   *%ebx
                        LoadFarString(AbsolutePathWarning),
                        FnFilter1(G.filename)));
                   if (!error_in_archive)
                       error_in_archive = PK_WARN;
    3517:	b8 01 00 00 00       	mov    $0x1,%eax
#endif /* !SFX */

            if (!renamed) {
               /* remove absolute path specs */
               if (G.filename[0] == '/') {
                   Info(slide, 0x401, ((char *)slide,
    351c:	83 ec 10             	sub    $0x10,%esp
                        LoadFarString(AbsolutePathWarning),
                        FnFilter1(G.filename)));
                   if (!error_in_archive)
                       error_in_archive = PK_WARN;
    351f:	89 c1                	mov    %eax,%ecx
    3521:	8b 54 24 48          	mov    0x48(%esp),%edx
    3525:	85 d2                	test   %edx,%edx
    3527:	0f 45 ca             	cmovne %edx,%ecx
    352a:	89 4c 24 48          	mov    %ecx,0x48(%esp)
    352e:	8d 8d e1 09 01 00    	lea    0x109e1(%ebp),%ecx
                   do {
                       char *p = G.filename + 1;
    3534:	89 c8                	mov    %ecx,%eax
                       do {
                           *(p-1) = *p;
    3536:	8a 10                	mov    (%eax),%dl
                       } while (*p++ != '\0');
    3538:	40                   	inc    %eax
                   if (!error_in_archive)
                       error_in_archive = PK_WARN;
                   do {
                       char *p = G.filename + 1;
                       do {
                           *(p-1) = *p;
    3539:	88 50 fe             	mov    %dl,-0x2(%eax)
                       } while (*p++ != '\0');
    353c:	84 d2                	test   %dl,%dl
    353e:	75 f6                	jne    3536 <_extract_or_test_files+0x2ac6>
                   } while (G.filename[0] == '/');
    3540:	80 bd e0 09 01 00 2f 	cmpb   $0x2f,0x109e0(%ebp)
    3547:	74 eb                	je     3534 <_extract_or_test_files+0x2ac4>
    3549:	e9 ef df ff ff       	jmp    153d <_extract_or_test_files+0xacd>
                  "" : (G.pInfo->textfile? txt : bin), uO.cflag? NEWLINE : ""));
            }
            if (((r = explode(__G)) != 0) && (r != 5)) { /* treat 5 specially */
                if (r < PK_DISK) {
                    if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
                        Info(slide, 0x401, ((char *)slide,
    354e:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3554:	89 44 24 04          	mov    %eax,0x4(%esp)
    3558:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    355e:	89 04 24             	mov    %eax,(%esp)
    3561:	e8 0a d0 ff ff       	call   570 <_fnfilter>
    3566:	b9 40 05 00 00       	mov    $0x540,%ecx
    356b:	ba 5c 05 00 00       	mov    $0x55c,%edx
    3570:	89 44 24 10          	mov    %eax,0x10(%esp)
    3574:	83 7c 24 5c 03       	cmpl   $0x3,0x5c(%esp)
    3579:	c7 44 24 0c 30 05 00 	movl   $0x530,0xc(%esp)
    3580:	00 
    3581:	0f 45 d1             	cmovne %ecx,%edx
    3584:	e9 0c ff ff ff       	jmp    3495 <_extract_or_test_files+0x2a25>
                    case IDM_REPLACE_RENAME:
                        _ISO_INTERN(G.filename);
                        renamed = TRUE;
                        goto startover;
                    case IDM_REPLACE_ALL:
                        G.overwrite_mode = OVERWRT_ALWAYS;
    3589:	c7 45 78 01 00 00 00 	movl   $0x1,0x78(%ebp)
    3590:	89 5c 24 48          	mov    %ebx,0x48(%esp)
    3594:	e9 2b e0 ff ff       	jmp    15c4 <_extract_or_test_files+0xb54>
                        /* FALL THROUGH, extract */
                    case IDM_REPLACE_YES:
                        break;
                    case IDM_REPLACE_NONE:
                        G.overwrite_mode = OVERWRT_NEVER;
    3599:	c7 45 78 02 00 00 00 	movl   $0x2,0x78(%ebp)
    35a0:	e9 7f fd ff ff       	jmp    3324 <_extract_or_test_files+0x28b4>
                break;
            case EF_PKVMS:
                if (makelong(ef+EB_HEADSIZE) !=
                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),
                          (extent)(ebLen-4)))
                    Info(slide, 1, ((char *)slide,
    35a5:	66 8b 0e             	mov    (%esi),%cx
    35a8:	83 c7 02             	add    $0x2,%edi
    35ab:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    35af:	83 c6 02             	add    $0x2,%esi
    35b2:	83 e8 02             	sub    $0x2,%eax
    35b5:	e9 18 ee ff ff       	jmp    23d2 <_extract_or_test_files+0x1962>
    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.filespecs;  ++i)
            fn_matched[i] = FALSE;
    if (G.xfilespecs > 0  &&
        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != (int *)NULL)
    35ba:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */
    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.filespecs;  ++i)
            fn_matched[i] = FALSE;
    if (G.xfilespecs > 0  &&
    35c1:	89 1c 24             	mov    %ebx,(%esp)
    35c4:	e8 00 00 00 00       	call   35c9 <_extract_or_test_files+0x2b59>
    35c9:	89 c2                	mov    %eax,%edx
    35cb:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
    35d2:	85 c0                	test   %eax,%eax
    35d4:	0f 84 e9 d4 ff ff    	je     ac3 <_extract_or_test_files+0x53>
    35da:	01 da                	add    %ebx,%edx
        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.xfilespecs;  ++i)
            xn_matched[i] = FALSE;
    35dc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    35e2:	83 c0 04             	add    $0x4,%eax
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.filespecs;  ++i)
            fn_matched[i] = FALSE;
    if (G.xfilespecs > 0  &&
        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.xfilespecs;  ++i)
    35e5:	39 d0                	cmp    %edx,%eax
    35e7:	75 f3                	jne    35dc <_extract_or_test_files+0x2b6c>
    35e9:	e9 e0 d4 ff ff       	jmp    ace <_extract_or_test_files+0x5e>
    G.reported_backslash = FALSE;
#endif

    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */
    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)
    35ee:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
#ifndef SFX
    G.reported_backslash = FALSE;
#endif

    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */
    if (G.filespecs > 0  &&
    35f5:	89 1c 24             	mov    %ebx,(%esp)
    35f8:	e8 00 00 00 00       	call   35fd <_extract_or_test_files+0x2b8d>
    35fd:	89 c2                	mov    %eax,%edx
    35ff:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    3603:	85 c0                	test   %eax,%eax
    3605:	0f 84 a5 d4 ff ff    	je     ab0 <_extract_or_test_files+0x40>
    360b:	01 da                	add    %ebx,%edx
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.filespecs;  ++i)
            fn_matched[i] = FALSE;
    360d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    3613:	83 c0 04             	add    $0x4,%eax
#endif

    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */
    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)
        for (i = 0;  i < G.filespecs;  ++i)
    3616:	39 d0                	cmp    %edx,%eax
    3618:	75 f3                	jne    360d <_extract_or_test_files+0x2b9d>
    361a:	e9 99 d4 ff ff       	jmp    ab8 <_extract_or_test_files+0x48>
                break;
            case EF_PKVMS:
                if (makelong(ef+EB_HEADSIZE) !=
                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),
                          (extent)(ebLen-4)))
                    Info(slide, 1, ((char *)slide,
    361f:	a0 fc 00 00 00       	mov    0xfc,%al
    3624:	be fd 00 00 00       	mov    $0xfd,%esi
    3629:	88 07                	mov    %al,(%edi)
    362b:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
    3632:	8d b8 dd 08 00 00    	lea    0x8dd(%eax),%edi
    3638:	b8 21 00 00 00       	mov    $0x21,%eax
    363d:	e9 84 ed ff ff       	jmp    23c6 <_extract_or_test_files+0x1956>
              FnFilter1(G.filename)));
        Info(slide, 0x401, ((char *)slide, LoadFarString(BadCRC), G.crc32val,
          G.lrec.crc32));
#if CRYPT
        if (G.pInfo->encrypted)
            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybeBadPasswd)));
    3642:	a0 44 01 00 00       	mov    0x144,%al
    3647:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    364d:	88 01                	mov    %al,(%ecx)
    364f:	be 45 01 00 00       	mov    $0x145,%esi
    3654:	b8 28 00 00 00       	mov    $0x28,%eax
    3659:	f7 c7 02 00 00 00    	test   $0x2,%edi
    365f:	0f 84 da ee ff ff    	je     253f <_extract_or_test_files+0x1acf>
    3665:	66 8b 0e             	mov    (%esi),%cx
    3668:	83 c7 02             	add    $0x2,%edi
    366b:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    366f:	83 c6 02             	add    $0x2,%esi
    3672:	83 e8 02             	sub    $0x2,%eax
    3675:	e9 c5 ee ff ff       	jmp    253f <_extract_or_test_files+0x1acf>
            }
            if (r == 5) {
                int warning = ((ulg)G.used_csize <= G.lrec.csize);

                if ((uO.tflag && uO.qflag) || (!uO.tflag && !QCOND2))
                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),
    367a:	8b b5 24 09 01 00    	mov    0x10924(%ebp),%esi
    3680:	8b 8d 94 00 00 00    	mov    0x94(%ebp),%ecx
    3686:	ba 12 00 00 00       	mov    $0x12,%edx
    368b:	bf 81 00 00 00       	mov    $0x81,%edi
    3690:	e9 ed fb ff ff       	jmp    3282 <_extract_or_test_files+0x2812>
                    if (!error_in_archive)
                        error_in_archive = error;
                }
                free(d);
            }
            free(sorted_dirlist);
    3695:	89 3c 24             	mov    %edi,(%esp)
    3698:	e8 00 00 00 00       	call   369d <_extract_or_test_files+0x2c2d>
            if (!uO.tflag && QCOND2) {
    369d:	8b 45 44             	mov    0x44(%ebp),%eax
    36a0:	85 c0                	test   %eax,%eax
    36a2:	0f 85 cc f5 ff ff    	jne    2c74 <_extract_or_test_files+0x2204>
                if (ndirs_fail > 0)
    36a8:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    36ac:	85 c0                	test   %eax,%eax
    36ae:	0f 84 c0 f5 ff ff    	je     2c74 <_extract_or_test_files+0x2204>
    36b4:	8b 7d 38             	mov    0x38(%ebp),%edi
    36b7:	85 ff                	test   %edi,%edi
    36b9:	0f 85 b5 f5 ff ff    	jne    2c74 <_extract_or_test_files+0x2204>
                    Info(slide, 0, ((char *)slide,
    36bf:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    36c3:	8d b5 dc 08 00 00    	lea    0x8dc(%ebp),%esi
    36c9:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    36cf:	89 44 24 08          	mov    %eax,0x8(%esp)
    36d3:	c7 44 24 04 00 08 00 	movl   $0x800,0x4(%esp)
    36da:	00 
    36db:	89 34 24             	mov    %esi,(%esp)
    36de:	e8 00 00 00 00       	call   36e3 <_extract_or_test_files+0x2c73>
    36e3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    36ea:	00 
    36eb:	89 44 24 08          	mov    %eax,0x8(%esp)
    36ef:	89 74 24 04          	mov    %esi,0x4(%esp)
    36f3:	89 2c 24             	mov    %ebp,(%esp)
    36f6:	ff d3                	call   *%ebx
    36f8:	83 ec 10             	sub    $0x10,%esp
    36fb:	e9 74 f5 ff ff       	jmp    2c74 <_extract_or_test_files+0x2204>
                    break;
                  case EF_BEOS:
                  case EF_ATHEOS:
                    if (ebLen >= EB_BEOS_HLEN &&
                        (*(ef+(EB_HEADSIZE+EB_FLGS_OFFS)) & EB_BE_FL_UNCMPR) &&
                        (makelong(ef+EB_HEADSIZE) == ebLen - EB_BEOS_HLEN))
    3700:	8d 43 04             	lea    0x4(%ebx),%eax
    3703:	89 04 24             	mov    %eax,(%esp)
    3706:	e8 00 00 00 00       	call   370b <_extract_or_test_files+0x2c9b>
    370b:	8d 55 fb             	lea    -0x5(%ebp),%edx
                        eb_cmpr_offs = EB_MAC3_HLEN;
                    break;
                  case EF_BEOS:
                  case EF_ATHEOS:
                    if (ebLen >= EB_BEOS_HLEN &&
                        (*(ef+(EB_HEADSIZE+EB_FLGS_OFFS)) & EB_BE_FL_UNCMPR) &&
    370e:	39 d0                	cmp    %edx,%eax
    3710:	0f 85 14 f1 ff ff    	jne    282a <_extract_or_test_files+0x1dba>
    3716:	e9 a2 ea ff ff       	jmp    21bd <_extract_or_test_files+0x174d>
        error_in_archive = IZ_BADPWD;    /* bad passwd => all files skipped */
#endif
    else if ((num_skipped > 0L) && error_in_archive <= PK_WARN)
        error_in_archive = IZ_UNSUP;     /* was PK_WARN; Jean-loup complained */
#if CRYPT
    else if ((num_bad_pwd > 0L) && !error_in_archive)
    371b:	8b 54 24 50          	mov    0x50(%esp),%edx
    371f:	89 d0                	mov    %edx,%eax
    3721:	85 d2                	test   %edx,%edx
    3723:	0f 85 41 f7 ff ff    	jne    2e6a <_extract_or_test_files+0x23fa>
        error_in_archive = PK_WARN;
    3729:	b0 01                	mov    $0x1,%al
    372b:	8b 9c 24 94 00 00 00 	mov    0x94(%esp),%ebx
    3732:	89 c1                	mov    %eax,%ecx
    3734:	85 db                	test   %ebx,%ebx
    3736:	0f 44 ca             	cmove  %edx,%ecx
    3739:	89 4c 24 50          	mov    %ecx,0x50(%esp)
#endif

    return error_in_archive;

} /* end function extract_or_test_files() */
    373d:	8b 44 24 50          	mov    0x50(%esp),%eax
    3741:	81 c4 bc 00 00 00    	add    $0xbc,%esp
    3747:	5b                   	pop    %ebx
    3748:	5e                   	pop    %esi
    3749:	5f                   	pop    %edi
    374a:	5d                   	pop    %ebp
    374b:	c3                   	ret    
            if (num_bad_pwd > 0L)
                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipBadPasswd)
                  , num_bad_pwd, (num_bad_pwd==1L)? "":"s"));
#endif /* CRYPT */
        } else if ((uO.qflag == 0) && !error_in_archive && (num == 0))
            Info(slide, 0, ((char *)slide, LoadFarString(ZeroFilesTested),
    374c:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
    3752:	8d bd dc 08 00 00    	lea    0x8dc(%ebp),%edi
    3758:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    375e:	89 44 24 08          	mov    %eax,0x8(%esp)
    3762:	c7 44 24 04 80 07 00 	movl   $0x780,0x4(%esp)
    3769:	00 
    376a:	89 3c 24             	mov    %edi,(%esp)
    376d:	e8 00 00 00 00       	call   3772 <_extract_or_test_files+0x2d02>
    3772:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3779:	00 
    377a:	89 44 24 08          	mov    %eax,0x8(%esp)
    377e:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3782:	89 2c 24             	mov    %ebp,(%esp)
    3785:	ff d3                	call   *%ebx
    }

    /* give warning if files not tested or extracted (first condition can still
     * happen if zipfile is empty and no files specified on command line) */

    if ((filnum == 0) && error_in_archive <= PK_WARN) {
    3787:	89 f0                	mov    %esi,%eax
            if (num_bad_pwd > 0L)
                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipBadPasswd)
                  , num_bad_pwd, (num_bad_pwd==1L)? "":"s"));
#endif /* CRYPT */
        } else if ((uO.qflag == 0) && !error_in_archive && (num == 0))
            Info(slide, 0, ((char *)slide, LoadFarString(ZeroFilesTested),
    3789:	83 ec 10             	sub    $0x10,%esp
    }

    /* give warning if files not tested or extracted (first condition can still
     * happen if zipfile is empty and no files specified on command line) */

    if ((filnum == 0) && error_in_archive <= PK_WARN) {
    378c:	84 c0                	test   %al,%al
    378e:	0f 85 a5 f6 ff ff    	jne    2e39 <_extract_or_test_files+0x23c9>
    3794:	eb 85                	jmp    371b <_extract_or_test_files+0x2cab>
            }
        } else {
            ulg ndirs_fail = 0;

            if (num_dirs == 1)
                sorted_dirlist[0] = dirlist;
    3796:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
    379d:	89 07                	mov    %eax,(%edi)
    379f:	e9 2b e2 ff ff       	jmp    19cf <_extract_or_test_files+0xf5f>
            } /* end if (query) */
            if (skip_entry != SKIP_NO) {
#ifdef WINDLL
                if (skip_entry == SKIP_Y_EXISTING) {
                    /* report skipping of an existing entry */
                    Info(slide, 0, ((char *)slide,
    37a4:	ba 14 00 00 00       	mov    $0x14,%edx
    37a9:	e9 b4 fb ff ff       	jmp    3362 <_extract_or_test_files+0x28f2>
#ifdef UNIXBACKUP
                    if ((!uO.B_flag && IS_OVERWRT_NONE) ||
#else
                    if (IS_OVERWRT_NONE ||
#endif
                        (uO.uflag && !renamed)) {
    37ae:	31 ff                	xor    %edi,%edi
    37b0:	e9 6f fb ff ff       	jmp    3324 <_extract_or_test_files+0x28b4>
#endif /* !SFX */
    if (uO.tflag) {
        ulg num = filnum - num_bad_pwd;

        if (uO.qflag < 2) {        /* GRR 930710:  was (uO.qflag == 1) */
            if (error_in_archive)
    37b5:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    37b9:	85 c9                	test   %ecx,%ecx
    37bb:	0f 84 11 01 00 00    	je     38d2 <_extract_or_test_files+0x2e62>
                Info(slide, 0, ((char *)slide, LoadFarString(ErrorInArchive),
    37c1:	b9 12 00 00 00       	mov    $0x12,%ecx
    37c6:	b8 87 00 00 00       	mov    $0x87,%eax
    37cb:	8b 95 04 09 01 00    	mov    0x10904(%ebp),%edx
    37d1:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    37d7:	83 7c 24 50 01       	cmpl   $0x1,0x50(%esp)
    37dc:	0f 45 c1             	cmovne %ecx,%eax
    37df:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    37e5:	89 54 24 0c          	mov    %edx,0xc(%esp)
    37e9:	89 44 24 08          	mov    %eax,0x8(%esp)
    37ed:	c7 44 24 04 c0 07 00 	movl   $0x7c0,0x4(%esp)
    37f4:	00 
    37f5:	89 1c 24             	mov    %ebx,(%esp)
    37f8:	e8 00 00 00 00       	call   37fd <_extract_or_test_files+0x2d8d>
                  G.zipfn));
            else if (G.process_all_files && (num_skipped+num_bad_pwd == 0L))
                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInCompData),
                  G.zipfn));
            else
                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInTestedFiles)
    37fd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3804:	00 
    3805:	89 44 24 08          	mov    %eax,0x8(%esp)
    3809:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    380d:	89 2c 24             	mov    %ebp,(%esp)
    3810:	ff d7                	call   *%edi
    3812:	83 ec 10             	sub    $0x10,%esp
                  , G.zipfn, num, (num==1L)? "":"s"));
            if (num_skipped > 0L)
    3815:	8b 44 24 68          	mov    0x68(%esp),%eax
    3819:	85 c0                	test   %eax,%eax
    381b:	74 4a                	je     3867 <_extract_or_test_files+0x2df7>
                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipped),
    381d:	8b 4c 24 68          	mov    0x68(%esp),%ecx
    3821:	ba 90 00 00 00       	mov    $0x90,%edx
    3826:	89 c8                	mov    %ecx,%eax
    3828:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    382e:	48                   	dec    %eax
    382f:	b8 12 00 00 00       	mov    $0x12,%eax
    3834:	0f 45 c2             	cmovne %edx,%eax
    3837:	89 44 24 0c          	mov    %eax,0xc(%esp)
    383b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    383f:	c7 44 24 04 a0 05 00 	movl   $0x5a0,0x4(%esp)
    3846:	00 
    3847:	89 1c 24             	mov    %ebx,(%esp)
    384a:	e8 00 00 00 00       	call   384f <_extract_or_test_files+0x2ddf>
    384f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3856:	00 
    3857:	89 44 24 08          	mov    %eax,0x8(%esp)
    385b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    385f:	89 2c 24             	mov    %ebp,(%esp)
    3862:	ff d7                	call   *%edi
    3864:	83 ec 10             	sub    $0x10,%esp
                  num_skipped, (num_skipped==1L)? "":"s"));
#if CRYPT
            if (num_bad_pwd > 0L)
    3867:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
    386e:	85 c0                	test   %eax,%eax
    3870:	0f 84 b9 f5 ff ff    	je     2e2f <_extract_or_test_files+0x23bf>
                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipBadPasswd)
    3876:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
    387d:	ba 90 00 00 00       	mov    $0x90,%edx
    3882:	89 c8                	mov    %ecx,%eax
    3884:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    388a:	48                   	dec    %eax
    388b:	b8 12 00 00 00       	mov    $0x12,%eax
    3890:	0f 45 c2             	cmovne %edx,%eax
    3893:	89 44 24 0c          	mov    %eax,0xc(%esp)
    3897:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    389b:	c7 44 24 04 80 06 00 	movl   $0x680,0x4(%esp)
    38a2:	00 
    38a3:	89 1c 24             	mov    %ebx,(%esp)
    38a6:	e8 00 00 00 00       	call   38ab <_extract_or_test_files+0x2e3b>
    38ab:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    38b2:	00 
    38b3:	89 44 24 08          	mov    %eax,0x8(%esp)
    38b7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    38bb:	89 2c 24             	mov    %ebp,(%esp)
    38be:	ff d7                	call   *%edi
    }

    /* give warning if files not tested or extracted (first condition can still
     * happen if zipfile is empty and no files specified on command line) */

    if ((filnum == 0) && error_in_archive <= PK_WARN) {
    38c0:	89 f0                	mov    %esi,%eax
            if (num_skipped > 0L)
                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipped),
                  num_skipped, (num_skipped==1L)? "":"s"));
#if CRYPT
            if (num_bad_pwd > 0L)
                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipBadPasswd)
    38c2:	83 ec 10             	sub    $0x10,%esp
    }

    /* give warning if files not tested or extracted (first condition can still
     * happen if zipfile is empty and no files specified on command line) */

    if ((filnum == 0) && error_in_archive <= PK_WARN) {
    38c5:	84 c0                	test   %al,%al
    38c7:	0f 85 6c f5 ff ff    	jne    2e39 <_extract_or_test_files+0x23c9>
    38cd:	e9 49 fe ff ff       	jmp    371b <_extract_or_test_files+0x2cab>

        if (uO.qflag < 2) {        /* GRR 930710:  was (uO.qflag == 1) */
            if (error_in_archive)
                Info(slide, 0, ((char *)slide, LoadFarString(ErrorInArchive),
                  (error_in_archive == PK_WARN)? "warning-" : "", G.zipfn));
            else if (num == 0L)
    38d2:	85 c0                	test   %eax,%eax
    38d4:	0f 84 76 04 00 00    	je     3d50 <_extract_or_test_files+0x32e0>
                Info(slide, 0, ((char *)slide, LoadFarString(ZeroFilesTested),
                  G.zipfn));
            else if (G.process_all_files && (num_skipped+num_bad_pwd == 0L))
    38da:	8b 55 74             	mov    0x74(%ebp),%edx
                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInCompData),
    38dd:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
                Info(slide, 0, ((char *)slide, LoadFarString(ErrorInArchive),
                  (error_in_archive == PK_WARN)? "warning-" : "", G.zipfn));
            else if (num == 0L)
                Info(slide, 0, ((char *)slide, LoadFarString(ZeroFilesTested),
                  G.zipfn));
            else if (G.process_all_files && (num_skipped+num_bad_pwd == 0L))
    38e3:	85 d2                	test   %edx,%edx
    38e5:	74 11                	je     38f8 <_extract_or_test_files+0x2e88>
    38e7:	8b 54 24 68          	mov    0x68(%esp),%edx
    38eb:	03 94 24 94 00 00 00 	add    0x94(%esp),%edx
    38f2:	0f 84 83 04 00 00    	je     3d7b <_extract_or_test_files+0x330b>
                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInCompData),
                  G.zipfn));
            else
                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInTestedFiles)
    38f8:	b9 90 00 00 00       	mov    $0x90,%ecx
    38fd:	ba 12 00 00 00       	mov    $0x12,%edx
    3902:	83 f8 01             	cmp    $0x1,%eax
    3905:	89 44 24 0c          	mov    %eax,0xc(%esp)
    3909:	0f 45 d1             	cmovne %ecx,%edx
    390c:	89 54 24 10          	mov    %edx,0x10(%esp)
    3910:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    3916:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
    391c:	c7 44 24 04 00 06 00 	movl   $0x600,0x4(%esp)
    3923:	00 
    3924:	89 44 24 08          	mov    %eax,0x8(%esp)
    3928:	89 1c 24             	mov    %ebx,(%esp)
    392b:	e8 00 00 00 00       	call   3930 <_extract_or_test_files+0x2ec0>
    3930:	e9 c8 fe ff ff       	jmp    37fd <_extract_or_test_files+0x2d8d>
        else
            error_in_archive = PK_FIND;  /* no files found at all */
    }
#if CRYPT
    else if ((filnum == num_bad_pwd) && error_in_archive <= PK_WARN)
        error_in_archive = IZ_BADPWD;    /* bad passwd => all files skipped */
    3935:	c7 44 24 50 52 00 00 	movl   $0x52,0x50(%esp)
    393c:	00 
        error_in_archive = PK_WARN;
#endif

    return error_in_archive;

} /* end function extract_or_test_files() */
    393d:	8b 44 24 50          	mov    0x50(%esp),%eax
    3941:	81 c4 bc 00 00 00    	add    $0xbc,%esp
    3947:	5b                   	pop    %ebx
    3948:	5e                   	pop    %esi
    3949:	5f                   	pop    %edi
    394a:	5d                   	pop    %ebp
    394b:	c3                   	ret    
                        /* There may be no dir_attribs info available, or
                         * we have encountered a mem allocation error.
                         * In case of an error, report it and set program
                         * error state to warning level.
                         */
                        if (error) {
    394c:	85 c0                	test   %eax,%eax
    394e:	0f 84 3f dc ff ff    	je     1593 <_extract_or_test_files+0xb23>
                            Info(slide, 0x401, ((char *)slide,
    3954:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    395a:	8b 54 24 60          	mov    0x60(%esp),%edx
    395e:	89 44 24 48          	mov    %eax,0x48(%esp)
    3962:	8b 7c 24 40          	mov    0x40(%esp),%edi
    3966:	be 98 01 00 00       	mov    $0x198,%esi
    396b:	b8 41 00 00 00       	mov    $0x41,%eax
    3970:	85 d2                	test   %edx,%edx
    3972:	74 17                	je     398b <_extract_or_test_files+0x2f1b>
    3974:	a0 98 01 00 00       	mov    0x198,%al
    3979:	be 99 01 00 00       	mov    $0x199,%esi
    397e:	88 07                	mov    %al,(%edi)
    3980:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3986:	b8 40 00 00 00       	mov    $0x40,%eax
    398b:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3991:	74 10                	je     39a3 <_extract_or_test_files+0x2f33>
    3993:	66 8b 16             	mov    (%esi),%dx
    3996:	83 c7 02             	add    $0x2,%edi
    3999:	66 89 57 fe          	mov    %dx,-0x2(%edi)
    399d:	83 c6 02             	add    $0x2,%esi
    39a0:	83 e8 02             	sub    $0x2,%eax
    39a3:	89 c1                	mov    %eax,%ecx
    39a5:	31 d2                	xor    %edx,%edx
    39a7:	c1 e9 02             	shr    $0x2,%ecx
    39aa:	a8 02                	test   $0x2,%al
    39ac:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    39ae:	74 0b                	je     39bb <_extract_or_test_files+0x2f4b>
    39b0:	66 8b 16             	mov    (%esi),%dx
    39b3:	66 89 17             	mov    %dx,(%edi)
    39b6:	ba 02 00 00 00       	mov    $0x2,%edx
    39bb:	a8 01                	test   $0x1,%al
    39bd:	74 06                	je     39c5 <_extract_or_test_files+0x2f55>
    39bf:	8a 04 16             	mov    (%esi,%edx,1),%al
    39c2:	88 04 17             	mov    %al,(%edi,%edx,1)
    39c5:	8b 44 24 40          	mov    0x40(%esp),%eax
    39c9:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    39d0:	00 
    39d1:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
    39d8:	00 
    39d9:	89 44 24 04          	mov    %eax,0x4(%esp)
    39dd:	89 2c 24             	mov    %ebp,(%esp)
    39e0:	ff 54 24 48          	call   *0x48(%esp)
                                 LoadFarString(DirlistEntryNoMem)));
                            if (!error_in_archive)
                                error_in_archive = PK_WARN;
    39e4:	b8 01 00 00 00       	mov    $0x1,%eax
                         * we have encountered a mem allocation error.
                         * In case of an error, report it and set program
                         * error state to warning level.
                         */
                        if (error) {
                            Info(slide, 0x401, ((char *)slide,
    39e9:	83 ec 10             	sub    $0x10,%esp
                                 LoadFarString(DirlistEntryNoMem)));
                            if (!error_in_archive)
                                error_in_archive = PK_WARN;
    39ec:	85 db                	test   %ebx,%ebx
    39ee:	0f 44 d8             	cmove  %eax,%ebx
    39f1:	e9 9d db ff ff       	jmp    1593 <_extract_or_test_files+0xb23>

    if ((filnum == 0) && error_in_archive <= PK_WARN) {
        if (num_skipped > 0L)
            error_in_archive = IZ_UNSUP; /* unsupport. compression/encryption */
        else
            error_in_archive = PK_FIND;  /* no files found at all */
    39f6:	83 7c 24 68 01       	cmpl   $0x1,0x68(%esp)
    39fb:	19 c0                	sbb    %eax,%eax
    39fd:	83 e0 ba             	and    $0xffffffba,%eax
    3a00:	83 c0 51             	add    $0x51,%eax
    3a03:	89 44 24 50          	mov    %eax,0x50(%esp)
        error_in_archive = PK_WARN;
#endif

    return error_in_archive;

} /* end function extract_or_test_files() */
    3a07:	8b 44 24 50          	mov    0x50(%esp),%eax
    3a0b:	81 c4 bc 00 00 00    	add    $0xbc,%esp
    3a11:	5b                   	pop    %ebx
    3a12:	5e                   	pop    %esi
    3a13:	5f                   	pop    %edi
    3a14:	5d                   	pop    %ebp
    3a15:	c3                   	ret    
                        default:
                            if ((r & 0xff) != PK_ERR)
                                Info(slide, 1, ((char *)slide,
                                  LoadFarString(UnknErrorEAs)));
                            else {
                                ush m = (ush)(r >> 8);
    3a16:	8b 44 24 64          	mov    0x64(%esp),%eax
    3a1a:	c1 f8 08             	sar    $0x8,%eax
                                if (m == DEFLATED)            /* GRR KLUDGE! */
    3a1d:	66 83 f8 08          	cmp    $0x8,%ax
                        default:
                            if ((r & 0xff) != PK_ERR)
                                Info(slide, 1, ((char *)slide,
                                  LoadFarString(UnknErrorEAs)));
                            else {
                                ush m = (ush)(r >> 8);
    3a21:	89 c2                	mov    %eax,%edx
                                if (m == DEFLATED)            /* GRR KLUDGE! */
    3a23:	0f 84 f0 00 00 00    	je     3b19 <_extract_or_test_files+0x30a9>
                                    Info(slide, 1, ((char *)slide,
                                      LoadFarString(BadCRC_EAs)));
                                else
                                    Info(slide, 1, ((char *)slide,
    3a29:	31 c0                	xor    %eax,%eax
    3a2b:	8b 7c 24 40          	mov    0x40(%esp),%edi
    3a2f:	66 89 d0             	mov    %dx,%ax
    3a32:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    3a38:	89 44 24 08          	mov    %eax,0x8(%esp)
    3a3c:	c7 44 24 04 20 03 00 	movl   $0x320,0x4(%esp)
    3a43:	00 
    3a44:	89 3c 24             	mov    %edi,(%esp)
    3a47:	e8 00 00 00 00       	call   3a4c <_extract_or_test_files+0x2fdc>
    3a4c:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3a53:	00 
    3a54:	89 44 24 08          	mov    %eax,0x8(%esp)
    3a58:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3a5c:	89 2c 24             	mov    %ebp,(%esp)
    3a5f:	ff d3                	call   *%ebx
    3a61:	83 ec 10             	sub    $0x10,%esp
    3a64:	e9 b8 ee ff ff       	jmp    2921 <_extract_or_test_files+0x1eb1>

#ifdef SET_DIR_ATTRIB
    if (num_dirs > 0) {
        sorted_dirlist = (direntry **)malloc(num_dirs*sizeof(direntry *));
        if (sorted_dirlist == (direntry **)NULL) {
            Info(slide, 0x401, ((char *)slide,
    3a69:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    3a6f:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    3a75:	89 df                	mov    %ebx,%edi
    3a77:	be dc 01 00 00       	mov    $0x1dc,%esi
    3a7c:	b8 3c 00 00 00       	mov    $0x3c,%eax
    3a81:	f6 c3 01             	test   $0x1,%bl
    3a84:	74 1b                	je     3aa1 <_extract_or_test_files+0x3031>
    3a86:	a0 dc 01 00 00       	mov    0x1dc,%al
    3a8b:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3a91:	88 85 dc 08 00 00    	mov    %al,0x8dc(%ebp)
    3a97:	be dd 01 00 00       	mov    $0x1dd,%esi
    3a9c:	b8 3b 00 00 00       	mov    $0x3b,%eax
    3aa1:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3aa7:	74 10                	je     3ab9 <_extract_or_test_files+0x3049>
    3aa9:	66 8b 0e             	mov    (%esi),%cx
    3aac:	83 c7 02             	add    $0x2,%edi
    3aaf:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    3ab3:	83 c6 02             	add    $0x2,%esi
    3ab6:	83 e8 02             	sub    $0x2,%eax
    3ab9:	89 c1                	mov    %eax,%ecx
    3abb:	c1 e9 02             	shr    $0x2,%ecx
    3abe:	a8 02                	test   $0x2,%al
    3ac0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3ac2:	74 0b                	je     3acf <_extract_or_test_files+0x305f>
    3ac4:	66 8b 0e             	mov    (%esi),%cx
    3ac7:	66 89 0f             	mov    %cx,(%edi)
    3aca:	b9 02 00 00 00       	mov    $0x2,%ecx
    3acf:	a8 01                	test   $0x1,%al
    3ad1:	74 06                	je     3ad9 <_extract_or_test_files+0x3069>
    3ad3:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    3ad6:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    3ad9:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    3ae0:	00 
    3ae1:	c7 44 24 08 3b 00 00 	movl   $0x3b,0x8(%esp)
    3ae8:	00 
    3ae9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3aed:	89 2c 24             	mov    %ebp,(%esp)
    3af0:	ff d2                	call   *%edx
    3af2:	83 ec 10             	sub    $0x10,%esp
              LoadFarString(DirlistSortNoMem)));
            while (dirlist != (direntry *)NULL) {
    3af5:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
    3afc:	85 c0                	test   %eax,%eax
    3afe:	0f 84 70 f1 ff ff    	je     2c74 <_extract_or_test_files+0x2204>
                direntry *d = dirlist;

                dirlist = dirlist->next;
    3b04:	8b 18                	mov    (%eax),%ebx
                free(d);
    3b06:	89 04 24             	mov    %eax,(%esp)
    3b09:	e8 00 00 00 00       	call   3b0e <_extract_or_test_files+0x309e>
    3b0e:	89 d8                	mov    %ebx,%eax
    if (num_dirs > 0) {
        sorted_dirlist = (direntry **)malloc(num_dirs*sizeof(direntry *));
        if (sorted_dirlist == (direntry **)NULL) {
            Info(slide, 0x401, ((char *)slide,
              LoadFarString(DirlistSortNoMem)));
            while (dirlist != (direntry *)NULL) {
    3b10:	85 db                	test   %ebx,%ebx
    3b12:	75 f0                	jne    3b04 <_extract_or_test_files+0x3094>
    3b14:	e9 5b f1 ff ff       	jmp    2c74 <_extract_or_test_files+0x2204>
                                Info(slide, 1, ((char *)slide,
                                  LoadFarString(UnknErrorEAs)));
                            else {
                                ush m = (ush)(r >> 8);
                                if (m == DEFLATED)            /* GRR KLUDGE! */
                                    Info(slide, 1, ((char *)slide,
    3b19:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    3b1d:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    3b23:	89 cf                	mov    %ecx,%edi
    3b25:	be fc 00 00 00       	mov    $0xfc,%esi
    3b2a:	b8 22 00 00 00       	mov    $0x22,%eax
    3b2f:	f6 c1 01             	test   $0x1,%cl
    3b32:	0f 84 91 ed ff ff    	je     28c9 <_extract_or_test_files+0x1e59>
    3b38:	a0 fc 00 00 00       	mov    0xfc,%al
    3b3d:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3b43:	88 01                	mov    %al,(%ecx)
    3b45:	be fd 00 00 00       	mov    $0xfd,%esi
    3b4a:	b8 21 00 00 00       	mov    $0x21,%eax
    3b4f:	e9 75 ed ff ff       	jmp    28c9 <_extract_or_test_files+0x1e59>
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(InvalidComprDataEAs)));
                            break;
                        case PK_MEM3:
                        case PK_MEM4:
                            Info(slide, 1, ((char *)slide,
    3b54:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    3b58:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    3b5e:	89 cf                	mov    %ecx,%edi
    3b60:	be 18 02 00 00       	mov    $0x218,%esi
    3b65:	b8 24 00 00 00       	mov    $0x24,%eax
    3b6a:	f6 c1 01             	test   $0x1,%cl
    3b6d:	74 17                	je     3b86 <_extract_or_test_files+0x3116>
    3b6f:	a0 18 02 00 00       	mov    0x218,%al
    3b74:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3b7a:	88 01                	mov    %al,(%ecx)
    3b7c:	be 19 02 00 00       	mov    $0x219,%esi
    3b81:	b8 23 00 00 00       	mov    $0x23,%eax
    3b86:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3b8c:	74 10                	je     3b9e <_extract_or_test_files+0x312e>
    3b8e:	66 8b 0e             	mov    (%esi),%cx
    3b91:	83 c7 02             	add    $0x2,%edi
    3b94:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    3b98:	83 c6 02             	add    $0x2,%esi
    3b9b:	83 e8 02             	sub    $0x2,%eax
    3b9e:	89 c1                	mov    %eax,%ecx
    3ba0:	c1 e9 02             	shr    $0x2,%ecx
    3ba3:	a8 02                	test   $0x2,%al
    3ba5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3ba7:	74 0b                	je     3bb4 <_extract_or_test_files+0x3144>
    3ba9:	66 8b 0e             	mov    (%esi),%cx
    3bac:	66 89 0f             	mov    %cx,(%edi)
    3baf:	b9 02 00 00 00       	mov    $0x2,%ecx
    3bb4:	a8 01                	test   $0x1,%al
    3bb6:	74 06                	je     3bbe <_extract_or_test_files+0x314e>
    3bb8:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    3bbb:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    3bbe:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3bc5:	00 
    3bc6:	c7 44 24 08 23 00 00 	movl   $0x23,0x8(%esp)
    3bcd:	00 
    3bce:	e9 3e ed ff ff       	jmp    2911 <_extract_or_test_files+0x1ea1>
                    if (uO.qflag)
                        Info(slide, 1, ((char *)slide, "%-22s ",
                          FnFilter1(G.filename)));
                    switch (r) {
                        case IZ_EF_TRUNC:
                            Info(slide, 1, ((char *)slide,
    3bd3:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
    3bda:	8b 7c 24 40          	mov    0x40(%esp),%edi
    3bde:	83 e8 0b             	sub    $0xb,%eax
    3be1:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    3be7:	c7 44 24 0c c5 00 00 	movl   $0xc5,0xc(%esp)
    3bee:	00 
    3bef:	89 44 24 08          	mov    %eax,0x8(%esp)
    3bf3:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
    3bfa:	00 
    3bfb:	89 3c 24             	mov    %edi,(%esp)
    3bfe:	e8 00 00 00 00       	call   3c03 <_extract_or_test_files+0x3193>
    3c03:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3c0a:	00 
    3c0b:	89 44 24 08          	mov    %eax,0x8(%esp)
    3c0f:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3c13:	89 2c 24             	mov    %ebp,(%esp)
    3c16:	ff d3                	call   *%ebx
    3c18:	83 ec 10             	sub    $0x10,%esp
    3c1b:	e9 ff f4 ff ff       	jmp    311f <_extract_or_test_files+0x26af>
                              LoadFarString(UnsuppNTSDVersEAs),
                              (int)ef[EB_HEADSIZE+EB_NTSD_VERSION]));
                            r = PK_WARN;
                            break;
                        default:
                            if ((r & 0xff) != PK_ERR)
    3c20:	80 7c 24 64 02       	cmpb   $0x2,0x64(%esp)
    3c25:	0f 84 93 00 00 00    	je     3cbe <_extract_or_test_files+0x324e>
                                Info(slide, 1, ((char *)slide,
    3c2b:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    3c2f:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    3c35:	89 cf                	mov    %ecx,%edi
    3c37:	be 70 01 00 00       	mov    $0x170,%esi
    3c3c:	b8 27 00 00 00       	mov    $0x27,%eax
    3c41:	f6 c1 01             	test   $0x1,%cl
    3c44:	74 17                	je     3c5d <_extract_or_test_files+0x31ed>
    3c46:	a0 70 01 00 00       	mov    0x170,%al
    3c4b:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3c51:	88 01                	mov    %al,(%ecx)
    3c53:	be 71 01 00 00       	mov    $0x171,%esi
    3c58:	b8 26 00 00 00       	mov    $0x26,%eax
    3c5d:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3c63:	74 10                	je     3c75 <_extract_or_test_files+0x3205>
    3c65:	66 8b 0e             	mov    (%esi),%cx
    3c68:	83 c7 02             	add    $0x2,%edi
    3c6b:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    3c6f:	83 c6 02             	add    $0x2,%esi
    3c72:	83 e8 02             	sub    $0x2,%eax
    3c75:	89 c1                	mov    %eax,%ecx
    3c77:	c1 e9 02             	shr    $0x2,%ecx
    3c7a:	a8 02                	test   $0x2,%al
    3c7c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3c7e:	74 0b                	je     3c8b <_extract_or_test_files+0x321b>
    3c80:	66 8b 0e             	mov    (%esi),%cx
    3c83:	66 89 0f             	mov    %cx,(%edi)
    3c86:	b9 02 00 00 00       	mov    $0x2,%ecx
    3c8b:	a8 01                	test   $0x1,%al
    3c8d:	74 06                	je     3c95 <_extract_or_test_files+0x3225>
    3c8f:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    3c92:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    3c95:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3c9c:	00 
    3c9d:	c7 44 24 08 26 00 00 	movl   $0x26,0x8(%esp)
    3ca4:	00 
                                  LoadFarString(UnknErrorEAs)));
                            else {
                                ush m = (ush)(r >> 8);
                                if (m == DEFLATED)            /* GRR KLUDGE! */
                                    Info(slide, 1, ((char *)slide,
    3ca5:	8b 44 24 40          	mov    0x40(%esp),%eax
    3ca9:	89 2c 24             	mov    %ebp,(%esp)
    3cac:	89 44 24 04          	mov    %eax,0x4(%esp)
    3cb0:	ff d2                	call   *%edx
    3cb2:	83 ec 10             	sub    $0x10,%esp
    3cb5:	8b 5c 24 64          	mov    0x64(%esp),%ebx
    3cb9:	e9 b9 f3 ff ff       	jmp    3077 <_extract_or_test_files+0x2607>
                        default:
                            if ((r & 0xff) != PK_ERR)
                                Info(slide, 1, ((char *)slide,
                                  LoadFarString(UnknErrorEAs)));
                            else {
                                ush m = (ush)(r >> 8);
    3cbe:	8b 44 24 64          	mov    0x64(%esp),%eax
    3cc2:	c1 f8 08             	sar    $0x8,%eax
                                if (m == DEFLATED)            /* GRR KLUDGE! */
    3cc5:	66 83 f8 08          	cmp    $0x8,%ax
                        default:
                            if ((r & 0xff) != PK_ERR)
                                Info(slide, 1, ((char *)slide,
                                  LoadFarString(UnknErrorEAs)));
                            else {
                                ush m = (ush)(r >> 8);
    3cc9:	89 c2                	mov    %eax,%edx
                                if (m == DEFLATED)            /* GRR KLUDGE! */
    3ccb:	0f 85 58 fd ff ff    	jne    3a29 <_extract_or_test_files+0x2fb9>
                                    Info(slide, 1, ((char *)slide,
    3cd1:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    3cd5:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    3cdb:	89 cf                	mov    %ecx,%edi
    3cdd:	be fc 00 00 00       	mov    $0xfc,%esi
    3ce2:	b8 22 00 00 00       	mov    $0x22,%eax
    3ce7:	f6 c1 01             	test   $0x1,%cl
    3cea:	74 17                	je     3d03 <_extract_or_test_files+0x3293>
    3cec:	a0 fc 00 00 00       	mov    0xfc,%al
    3cf1:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3cf7:	88 01                	mov    %al,(%ecx)
    3cf9:	be fd 00 00 00       	mov    $0xfd,%esi
    3cfe:	b8 21 00 00 00       	mov    $0x21,%eax
    3d03:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3d09:	74 10                	je     3d1b <_extract_or_test_files+0x32ab>
    3d0b:	66 8b 0e             	mov    (%esi),%cx
    3d0e:	83 c7 02             	add    $0x2,%edi
    3d11:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    3d15:	83 c6 02             	add    $0x2,%esi
    3d18:	83 e8 02             	sub    $0x2,%eax
    3d1b:	89 c1                	mov    %eax,%ecx
    3d1d:	c1 e9 02             	shr    $0x2,%ecx
    3d20:	a8 02                	test   $0x2,%al
    3d22:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3d24:	74 0b                	je     3d31 <_extract_or_test_files+0x32c1>
    3d26:	66 8b 0e             	mov    (%esi),%cx
    3d29:	66 89 0f             	mov    %cx,(%edi)
    3d2c:	b9 02 00 00 00       	mov    $0x2,%ecx
    3d31:	a8 01                	test   $0x1,%al
    3d33:	74 06                	je     3d3b <_extract_or_test_files+0x32cb>
    3d35:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    3d38:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    3d3b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3d42:	00 
    3d43:	c7 44 24 08 21 00 00 	movl   $0x21,0x8(%esp)
    3d4a:	00 
    3d4b:	e9 55 ff ff ff       	jmp    3ca5 <_extract_or_test_files+0x3235>
        if (uO.qflag < 2) {        /* GRR 930710:  was (uO.qflag == 1) */
            if (error_in_archive)
                Info(slide, 0, ((char *)slide, LoadFarString(ErrorInArchive),
                  (error_in_archive == PK_WARN)? "warning-" : "", G.zipfn));
            else if (num == 0L)
                Info(slide, 0, ((char *)slide, LoadFarString(ZeroFilesTested),
    3d50:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
    3d56:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    3d5c:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    3d62:	89 44 24 08          	mov    %eax,0x8(%esp)
    3d66:	c7 44 24 04 80 07 00 	movl   $0x780,0x4(%esp)
    3d6d:	00 
    3d6e:	89 1c 24             	mov    %ebx,(%esp)
    3d71:	e8 00 00 00 00       	call   3d76 <_extract_or_test_files+0x3306>
    3d76:	e9 82 fa ff ff       	jmp    37fd <_extract_or_test_files+0x2d8d>
                  G.zipfn));
            else if (G.process_all_files && (num_skipped+num_bad_pwd == 0L))
                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInCompData),
    3d7b:	8b 85 04 09 01 00    	mov    0x10904(%ebp),%eax
    3d81:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    3d87:	89 44 24 08          	mov    %eax,0x8(%esp)
    3d8b:	c7 44 24 04 40 06 00 	movl   $0x640,0x4(%esp)
    3d92:	00 
    3d93:	89 1c 24             	mov    %ebx,(%esp)
    3d96:	e8 00 00 00 00       	call   3d9b <_extract_or_test_files+0x332b>
    3d9b:	e9 5d fa ff ff       	jmp    37fd <_extract_or_test_files+0x2d8d>
                              LoadFarString(TruncNTSD),
                              ebLen-(EB_NTSD_L_LEN+EB_CMPRHEADLEN), "\n"));
                            break;
#if (defined(WIN32) && defined(NTSD_EAS))
                        case PK_WARN:
                            Info(slide, 1, ((char *)slide,
    3da0:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    3da4:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    3daa:	89 cf                	mov    %ecx,%edi
    3dac:	be 3c 02 00 00       	mov    $0x23c,%esi
    3db1:	b8 1a 00 00 00       	mov    $0x1a,%eax
    3db6:	f6 c1 01             	test   $0x1,%cl
    3db9:	74 17                	je     3dd2 <_extract_or_test_files+0x3362>
    3dbb:	a0 3c 02 00 00       	mov    0x23c,%al
    3dc0:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3dc6:	88 01                	mov    %al,(%ecx)
    3dc8:	be 3d 02 00 00       	mov    $0x23d,%esi
    3dcd:	b8 19 00 00 00       	mov    $0x19,%eax
    3dd2:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3dd8:	74 10                	je     3dea <_extract_or_test_files+0x337a>
    3dda:	66 8b 0e             	mov    (%esi),%cx
    3ddd:	83 c7 02             	add    $0x2,%edi
    3de0:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    3de4:	83 c6 02             	add    $0x2,%esi
    3de7:	83 e8 02             	sub    $0x2,%eax
    3dea:	89 c1                	mov    %eax,%ecx
    3dec:	c1 e9 02             	shr    $0x2,%ecx
    3def:	a8 02                	test   $0x2,%al
    3df1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3df3:	74 0b                	je     3e00 <_extract_or_test_files+0x3390>
    3df5:	66 8b 0e             	mov    (%esi),%cx
    3df8:	66 89 0f             	mov    %cx,(%edi)
    3dfb:	b9 02 00 00 00       	mov    $0x2,%ecx
    3e00:	a8 01                	test   $0x1,%al
    3e02:	74 06                	je     3e0a <_extract_or_test_files+0x339a>
    3e04:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    3e07:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    3e0a:	8b 44 24 40          	mov    0x40(%esp),%eax
    3e0e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3e15:	00 
    3e16:	c7 44 24 08 19 00 00 	movl   $0x19,0x8(%esp)
    3e1d:	00 
    3e1e:	89 44 24 04          	mov    %eax,0x4(%esp)
    3e22:	89 2c 24             	mov    %ebp,(%esp)
    3e25:	bb 01 00 00 00       	mov    $0x1,%ebx
    3e2a:	ff d2                	call   *%edx
    3e2c:	83 ec 10             	sub    $0x10,%esp
    3e2f:	e9 43 f2 ff ff       	jmp    3077 <_extract_or_test_files+0x2607>
                            Info(slide, 1, ((char *)slide,
                              LoadFarString(InvalidComprDataEAs)));
                            break;
                        case PK_MEM3:
                        case PK_MEM4:
                            Info(slide, 1, ((char *)slide,
    3e34:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    3e38:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    3e3e:	89 cf                	mov    %ecx,%edi
    3e40:	be 18 02 00 00       	mov    $0x218,%esi
    3e45:	b8 24 00 00 00       	mov    $0x24,%eax
    3e4a:	f6 c1 01             	test   $0x1,%cl
    3e4d:	74 17                	je     3e66 <_extract_or_test_files+0x33f6>
    3e4f:	a0 18 02 00 00       	mov    0x218,%al
    3e54:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    3e5a:	88 01                	mov    %al,(%ecx)
    3e5c:	be 19 02 00 00       	mov    $0x219,%esi
    3e61:	b8 23 00 00 00       	mov    $0x23,%eax
    3e66:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3e6c:	74 10                	je     3e7e <_extract_or_test_files+0x340e>
    3e6e:	66 8b 0e             	mov    (%esi),%cx
    3e71:	83 c7 02             	add    $0x2,%edi
    3e74:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    3e78:	83 c6 02             	add    $0x2,%esi
    3e7b:	83 e8 02             	sub    $0x2,%eax
    3e7e:	89 c1                	mov    %eax,%ecx
    3e80:	c1 e9 02             	shr    $0x2,%ecx
    3e83:	a8 02                	test   $0x2,%al
    3e85:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3e87:	74 0b                	je     3e94 <_extract_or_test_files+0x3424>
    3e89:	66 8b 0e             	mov    (%esi),%cx
    3e8c:	66 89 0f             	mov    %cx,(%edi)
    3e8f:	b9 02 00 00 00       	mov    $0x2,%ecx
    3e94:	a8 01                	test   $0x1,%al
    3e96:	74 06                	je     3e9e <_extract_or_test_files+0x342e>
    3e98:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    3e9b:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    3e9e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3ea5:	00 
    3ea6:	c7 44 24 08 23 00 00 	movl   $0x23,0x8(%esp)
    3ead:	00 
    3eae:	e9 37 e6 ff ff       	jmp    24ea <_extract_or_test_files+0x1a7a>
    3eb3:	90                   	nop
    3eb4:	90                   	nop
    3eb5:	90                   	nop
    3eb6:	90                   	nop
    3eb7:	90                   	nop
    3eb8:	90                   	nop
    3eb9:	90                   	nop
    3eba:	90                   	nop
    3ebb:	90                   	nop
    3ebc:	90                   	nop
    3ebd:	90                   	nop
    3ebe:	90                   	nop
    3ebf:	90                   	nop

fileio.o:     file format pe-i386


Disassembly of section .text:

00000000 <_disk_error>:
/* Function disk_error() */
/*************************/

static int disk_error(__G)
    __GDEF
{
       0:	57                   	push   %edi
       1:	56                   	push   %esi
       2:	53                   	push   %ebx
       3:	89 c3                	mov    %eax,%ebx
       5:	83 ec 10             	sub    $0x10,%esp
    /* OK to use slide[] here because this file is finished regardless */
    Info(slide, 0x4a1, ((char *)slide, LoadFarString(DiskFullQuery),
       8:	8d 80 dc 88 00 00    	lea    0x88dc(%eax),%eax
       e:	8b b8 68 82 00 00    	mov    0x8268(%eax),%edi
      14:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
      1a:	89 44 24 04          	mov    %eax,0x4(%esp)
      1e:	8d 83 e0 09 01 00    	lea    0x109e0(%ebx),%eax
      24:	89 04 24             	mov    %eax,(%esp)
      27:	e8 00 00 00 00       	call   2c <_disk_error+0x2c>
      2c:	89 34 24             	mov    %esi,(%esp)
      2f:	89 44 24 08          	mov    %eax,0x8(%esp)
      33:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
      3a:	00 
      3b:	e8 00 00 00 00       	call   40 <_disk_error+0x40>
      40:	89 74 24 04          	mov    %esi,0x4(%esp)
      44:	89 1c 24             	mov    %ebx,(%esp)
      47:	c7 44 24 0c a1 04 00 	movl   $0x4a1,0xc(%esp)
      4e:	00 
      4f:	89 44 24 08          	mov    %eax,0x8(%esp)
      53:	ff d7                	call   *%edi
    fgets(G.answerbuf, 9, stdin);
    if (*G.answerbuf == 'y')   /* stop writing to this file */
        G.disk_full = 1;       /*  (outfile bad?), but new OK */
    else
#endif
        G.disk_full = 2;       /* no:  exit program */
      55:	c7 83 b0 09 01 00 02 	movl   $0x2,0x109b0(%ebx)
      5c:	00 00 00 

static int disk_error(__G)
    __GDEF
{
    /* OK to use slide[] here because this file is finished regardless */
    Info(slide, 0x4a1, ((char *)slide, LoadFarString(DiskFullQuery),
      5f:	83 ec 10             	sub    $0x10,%esp
#endif
        G.disk_full = 2;       /* no:  exit program */

    return PK_DISK;

} /* end function disk_error() */
      62:	b8 32 00 00 00       	mov    $0x32,%eax
      67:	83 c4 10             	add    $0x10,%esp
      6a:	5b                   	pop    %ebx
      6b:	5e                   	pop    %esi
      6c:	5f                   	pop    %edi
      6d:	c3                   	ret    
      6e:	66 90                	xchg   %ax,%ax

00000070 <_open_input_file>:
/* Function open_input_file() */
/******************************/

int open_input_file(__G)    /* return 1 if open failed */
    __GDEF
{
      70:	57                   	push   %edi
      71:	56                   	push   %esi
      72:	53                   	push   %ebx
      73:	83 ec 10             	sub    $0x10,%esp
      76:	8b 5c 24 20          	mov    0x20(%esp),%ebx
#else /* !CMS_MVS */
#ifdef USE_STRM_INPUT
    G.zipfd = fopen(G.zipfn, FOPR);
#else /* !USE_STRM_INPUT */
# ifdef O_BINARY
    G.zipfd = open(G.zipfn, O_RDONLY | O_BINARY);
      7a:	c7 44 24 04 00 80 00 	movl   $0x8000,0x4(%esp)
      81:	00 
      82:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
      88:	89 04 24             	mov    %eax,(%esp)
      8b:	e8 00 00 00 00       	call   90 <_open_input_file+0x20>
      90:	89 c2                	mov    %eax,%edx
      92:	89 83 08 09 01 00    	mov    %eax,0x10908(%ebx)
    {
        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotOpenZipfile),
          G.zipfn, strerror(errno)));
        return 1;
    }
    return 0;
      98:	31 c0                	xor    %eax,%eax

#ifdef USE_STRM_INPUT
    if (G.zipfd == NULL)
#else
    /* if (G.zipfd < 0) */  /* no good for Windows CE port */
    if (G.zipfd == -1)
      9a:	42                   	inc    %edx
      9b:	74 07                	je     a4 <_open_input_file+0x34>
          G.zipfn, strerror(errno)));
        return 1;
    }
    return 0;

} /* end function open_input_file() */
      9d:	83 c4 10             	add    $0x10,%esp
      a0:	5b                   	pop    %ebx
      a1:	5e                   	pop    %esi
      a2:	5f                   	pop    %edi
      a3:	c3                   	ret    
#else
    /* if (G.zipfd < 0) */  /* no good for Windows CE port */
    if (G.zipfd == -1)
#endif
    {
        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotOpenZipfile),
      a4:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
      aa:	e8 00 00 00 00       	call   af <_open_input_file+0x3f>
      af:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
      b5:	8b 00                	mov    (%eax),%eax
      b7:	89 04 24             	mov    %eax,(%esp)
      ba:	e8 00 00 00 00       	call   bf <_open_input_file+0x4f>
      bf:	89 44 24 0c          	mov    %eax,0xc(%esp)
      c3:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
      c9:	89 34 24             	mov    %esi,(%esp)
      cc:	89 44 24 08          	mov    %eax,0x8(%esp)
      d0:	c7 44 24 04 80 01 00 	movl   $0x180,0x4(%esp)
      d7:	00 
      d8:	e8 00 00 00 00       	call   dd <_open_input_file+0x6d>
      dd:	89 74 24 04          	mov    %esi,0x4(%esp)
      e1:	89 1c 24             	mov    %ebx,(%esp)
      e4:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
      eb:	00 
      ec:	89 44 24 08          	mov    %eax,0x8(%esp)
      f0:	ff d7                	call   *%edi
          G.zipfn, strerror(errno)));
        return 1;
      f2:	b8 01 00 00 00       	mov    $0x1,%eax
#else
    /* if (G.zipfd < 0) */  /* no good for Windows CE port */
    if (G.zipfd == -1)
#endif
    {
        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotOpenZipfile),
      f7:	83 ec 10             	sub    $0x10,%esp
          G.zipfn, strerror(errno)));
        return 1;
    }
    return 0;

} /* end function open_input_file() */
      fa:	83 c4 10             	add    $0x10,%esp
      fd:	5b                   	pop    %ebx
      fe:	5e                   	pop    %esi
      ff:	5f                   	pop    %edi
     100:	c3                   	ret    
     101:	eb 0d                	jmp    110 <_open_outfile>
     103:	90                   	nop
     104:	90                   	nop
     105:	90                   	nop
     106:	90                   	nop
     107:	90                   	nop
     108:	90                   	nop
     109:	90                   	nop
     10a:	90                   	nop
     10b:	90                   	nop
     10c:	90                   	nop
     10d:	90                   	nop
     10e:	90                   	nop
     10f:	90                   	nop

00000110 <_open_outfile>:
/* Function open_outfile() */
/***************************/

int open_outfile(__G)         /* return 1 if fail */
    __GDEF
{
     110:	55                   	push   %ebp
     111:	57                   	push   %edi
     112:	56                   	push   %esi
     113:	53                   	push   %ebx
     114:	83 ec 1c             	sub    $0x1c,%esp
     117:	8b 5c 24 30          	mov    0x30(%esp),%ebx
#ifdef DLL
    if (G.redirect_data)
     11b:	8b b3 a0 00 00 00    	mov    0xa0(%ebx),%esi
     121:	85 f6                	test   %esi,%esi
     123:	75 73                	jne    198 <_open_outfile+0x88>
    }
#endif /* BORLAND_STAT_BUG */
#ifdef SYMLINKS
    if (SSTAT(G.filename, &G.statbuf) == 0 || lstat(G.filename,&G.statbuf) == 0)
#else
    if (SSTAT(G.filename, &G.statbuf) == 0)
     125:	8d 83 7c 09 01 00    	lea    0x1097c(%ebx),%eax
     12b:	8d bb e0 09 01 00    	lea    0x109e0(%ebx),%edi
     131:	89 44 24 08          	mov    %eax,0x8(%esp)
     135:	89 7c 24 04          	mov    %edi,0x4(%esp)
     139:	89 1c 24             	mov    %ebx,(%esp)
     13c:	e8 00 00 00 00       	call   141 <_open_outfile+0x31>
     141:	85 c0                	test   %eax,%eax
     143:	75 19                	jne    15e <_open_outfile+0x4e>
            free(tname);
        } else
#endif /* UNIXBACKUP */
        {
#ifdef DOS_FLX_OS2_W32
            if (!(G.statbuf.st_mode & S_IWRITE)) {
     145:	f6 83 82 09 01 00 80 	testb  $0x80,0x10982(%ebx)
     14c:	0f 84 ee 00 00 00    	je     240 <_open_outfile+0x130>
#endif /* DOS_FLX_OS2_W32 */
#ifdef NLM
            /* Give the file read/write permission (non-POSIX shortcut) */
            chmod(G.filename, 0);
#endif /* NLM */
            if (unlink(G.filename) != 0) {
     152:	89 3c 24             	mov    %edi,(%esp)
     155:	e8 00 00 00 00       	call   15a <_open_outfile+0x4a>
     15a:	85 c0                	test   %eax,%eax
     15c:	75 58                	jne    1b6 <_open_outfile+0xa6>
        return 1;   /* with "./" fix in checkdir(), should never reach here */
    }
#endif /* NOVELL_BUG_FAILSAFE */
    Trace((stderr, "open_outfile:  doing fopen(%s) for writing\n",
      FnFilter1(G.filename)));
    if ((G.outfile = fopen(G.filename, FOPW)) == (FILE *)NULL) {
     15e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     165:	00 
     166:	89 3c 24             	mov    %edi,(%esp)
     169:	e8 00 00 00 00       	call   16e <_open_outfile+0x5e>
     16e:	89 83 c8 09 01 00    	mov    %eax,0x109c8(%ebx)
     174:	85 c0                	test   %eax,%eax
     176:	0f 84 94 00 00 00    	je     210 <_open_outfile+0x100>
#endif /* !RISCOS */
#endif /* ?DOS_NLM_OS2_W32 */
#endif /* USE_FWRITE */
#ifdef OS2_W32
    /* preallocate the final file size to prevent file fragmentation */
    SetFileSize(G.outfile, G.lrec.ucsize);
     17c:	8b 93 24 09 01 00    	mov    0x10924(%ebx),%edx
     182:	89 04 24             	mov    %eax,(%esp)
     185:	89 54 24 04          	mov    %edx,0x4(%esp)
     189:	e8 00 00 00 00       	call   18e <_open_outfile+0x7e>
#endif
    return 0;

} /* end function open_outfile() */
     18e:	83 c4 1c             	add    $0x1c,%esp
     191:	89 f0                	mov    %esi,%eax
     193:	5b                   	pop    %ebx
     194:	5e                   	pop    %esi
     195:	5f                   	pop    %edi
     196:	5d                   	pop    %ebp
     197:	c3                   	ret    
int open_outfile(__G)         /* return 1 if fail */
    __GDEF
{
#ifdef DLL
    if (G.redirect_data)
        return (redirect_outfile(__G) == FALSE);
     198:	89 1c 24             	mov    %ebx,(%esp)
     19b:	e8 00 00 00 00       	call   1a0 <_open_outfile+0x90>
     1a0:	85 c0                	test   %eax,%eax
     1a2:	0f 94 c0             	sete   %al
     1a5:	25 ff 00 00 00       	and    $0xff,%eax
    /* preallocate the final file size to prevent file fragmentation */
    SetFileSize(G.outfile, G.lrec.ucsize);
#endif
    return 0;

} /* end function open_outfile() */
     1aa:	83 c4 1c             	add    $0x1c,%esp
int open_outfile(__G)         /* return 1 if fail */
    __GDEF
{
#ifdef DLL
    if (G.redirect_data)
        return (redirect_outfile(__G) == FALSE);
     1ad:	89 c6                	mov    %eax,%esi
    /* preallocate the final file size to prevent file fragmentation */
    SetFileSize(G.outfile, G.lrec.ucsize);
#endif
    return 0;

} /* end function open_outfile() */
     1af:	5b                   	pop    %ebx
     1b0:	89 f0                	mov    %esi,%eax
     1b2:	5e                   	pop    %esi
     1b3:	5f                   	pop    %edi
     1b4:	5d                   	pop    %ebp
     1b5:	c3                   	ret    
#ifdef NLM
            /* Give the file read/write permission (non-POSIX shortcut) */
            chmod(G.filename, 0);
#endif /* NLM */
            if (unlink(G.filename) != 0) {
                Info(slide, 0x401, ((char *)slide,
     1b6:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     1bc:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
     1c2:	89 44 24 04          	mov    %eax,0x4(%esp)
     1c6:	89 3c 24             	mov    %edi,(%esp)
     1c9:	e8 00 00 00 00       	call   1ce <_open_outfile+0xbe>
     1ce:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     1d4:	89 44 24 08          	mov    %eax,0x8(%esp)
     1d8:	c7 44 24 04 4c 01 00 	movl   $0x14c,0x4(%esp)
     1df:	00 
    }
#endif /* NOVELL_BUG_FAILSAFE */
    Trace((stderr, "open_outfile:  doing fopen(%s) for writing\n",
      FnFilter1(G.filename)));
    if ((G.outfile = fopen(G.filename, FOPW)) == (FILE *)NULL) {
        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotCreateFile),
     1e0:	89 34 24             	mov    %esi,(%esp)
     1e3:	e8 00 00 00 00       	call   1e8 <_open_outfile+0xd8>
     1e8:	89 74 24 04          	mov    %esi,0x4(%esp)
     1ec:	89 1c 24             	mov    %ebx,(%esp)
     1ef:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     1f6:	00 
     1f7:	89 44 24 08          	mov    %eax,0x8(%esp)
          FnFilter1(G.filename)));
        return 1;
     1fb:	be 01 00 00 00       	mov    $0x1,%esi
    }
#endif /* NOVELL_BUG_FAILSAFE */
    Trace((stderr, "open_outfile:  doing fopen(%s) for writing\n",
      FnFilter1(G.filename)));
    if ((G.outfile = fopen(G.filename, FOPW)) == (FILE *)NULL) {
        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotCreateFile),
     200:	ff d5                	call   *%ebp
    /* preallocate the final file size to prevent file fragmentation */
    SetFileSize(G.outfile, G.lrec.ucsize);
#endif
    return 0;

} /* end function open_outfile() */
     202:	89 f0                	mov    %esi,%eax
    }
#endif /* NOVELL_BUG_FAILSAFE */
    Trace((stderr, "open_outfile:  doing fopen(%s) for writing\n",
      FnFilter1(G.filename)));
    if ((G.outfile = fopen(G.filename, FOPW)) == (FILE *)NULL) {
        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotCreateFile),
     204:	83 ec 10             	sub    $0x10,%esp
    /* preallocate the final file size to prevent file fragmentation */
    SetFileSize(G.outfile, G.lrec.ucsize);
#endif
    return 0;

} /* end function open_outfile() */
     207:	83 c4 1c             	add    $0x1c,%esp
     20a:	5b                   	pop    %ebx
     20b:	5e                   	pop    %esi
     20c:	5f                   	pop    %edi
     20d:	5d                   	pop    %ebp
     20e:	c3                   	ret    
     20f:	90                   	nop
    }
#endif /* NOVELL_BUG_FAILSAFE */
    Trace((stderr, "open_outfile:  doing fopen(%s) for writing\n",
      FnFilter1(G.filename)));
    if ((G.outfile = fopen(G.filename, FOPW)) == (FILE *)NULL) {
        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotCreateFile),
     210:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     216:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
     21c:	89 44 24 04          	mov    %eax,0x4(%esp)
     220:	89 3c 24             	mov    %edi,(%esp)
     223:	e8 00 00 00 00       	call   228 <_open_outfile+0x118>
     228:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     22e:	89 44 24 08          	mov    %eax,0x8(%esp)
     232:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
     239:	00 
     23a:	eb a4                	jmp    1e0 <_open_outfile+0xd0>
     23c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#ifdef DOS_FLX_OS2_W32
            if (!(G.statbuf.st_mode & S_IWRITE)) {
                Trace((stderr,
                  "open_outfile:  existing file %s is read-only\n",
                  FnFilter1(G.filename)));
                chmod(G.filename, S_IREAD | S_IWRITE);
     240:	c7 44 24 04 80 01 00 	movl   $0x180,0x4(%esp)
     247:	00 
     248:	89 3c 24             	mov    %edi,(%esp)
     24b:	e8 00 00 00 00       	call   250 <_open_outfile+0x140>
     250:	e9 fd fe ff ff       	jmp    152 <_open_outfile+0x42>
     255:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000260 <_undefer_input>:
/* function undefer_input() */
/****************************/

void undefer_input(__G)
    __GDEF
{
     260:	8b 44 24 04          	mov    0x4(%esp),%eax
    if (G.incnt > 0)
     264:	8b 88 ec 08 01 00    	mov    0x108ec(%eax),%ecx
     26a:	85 c9                	test   %ecx,%ecx
     26c:	7e 0e                	jle    27c <_undefer_input+0x1c>
        G.csize += G.incnt;
     26e:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
     274:	01 ca                	add    %ecx,%edx
     276:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
    if (G.incnt_leftover > 0) {
     27c:	8b 90 5c 0b 01 00    	mov    0x10b5c(%eax),%edx
     282:	85 d2                	test   %edx,%edx
     284:	7e 2a                	jle    2b0 <_undefer_input+0x50>
         * This condition was checked when G.incnt_leftover was set > 0 in
         * defer_leftover_input(), and it is NOT allowed to touch G.csize
         * before calling undefer_input() when (G.incnt_leftover > 0)
         * (single exception: see read_byte()'s  "G.csize <= 0" handling) !!
         */
        G.incnt = G.incnt_leftover + (int)G.csize;
     286:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
        G.inptr = G.inptr_leftover - (int)G.csize;
        G.incnt_leftover = 0;
     28c:	c7 80 5c 0b 01 00 00 	movl   $0x0,0x10b5c(%eax)
     293:	00 00 00 
         * This condition was checked when G.incnt_leftover was set > 0 in
         * defer_leftover_input(), and it is NOT allowed to touch G.csize
         * before calling undefer_input() when (G.incnt_leftover > 0)
         * (single exception: see read_byte()'s  "G.csize <= 0" handling) !!
         */
        G.incnt = G.incnt_leftover + (int)G.csize;
     296:	01 ca                	add    %ecx,%edx
     298:	89 90 ec 08 01 00    	mov    %edx,0x108ec(%eax)
        G.inptr = G.inptr_leftover - (int)G.csize;
     29e:	8b 90 60 0b 01 00    	mov    0x10b60(%eax),%edx
     2a4:	29 ca                	sub    %ecx,%edx
     2a6:	89 90 e8 08 01 00    	mov    %edx,0x108e8(%eax)
     2ac:	c3                   	ret    
     2ad:	8d 76 00             	lea    0x0(%esi),%esi
        G.incnt_leftover = 0;
    } else if (G.incnt < 0)
     2b0:	85 c9                	test   %ecx,%ecx
     2b2:	78 01                	js     2b5 <_undefer_input+0x55>
     2b4:	c3                   	ret    
        G.incnt = 0;
     2b5:	c7 80 ec 08 01 00 00 	movl   $0x0,0x108ec(%eax)
     2bc:	00 00 00 
     2bf:	c3                   	ret    

000002c0 <_defer_leftover_input>:
/* function defer_leftover_input() */
/***********************************/

void defer_leftover_input(__G)
    __GDEF
{
     2c0:	53                   	push   %ebx
     2c1:	8b 44 24 08          	mov    0x8(%esp),%eax
    if ((long)G.incnt > G.csize) {
     2c5:	8b 88 ec 08 01 00    	mov    0x108ec(%eax),%ecx
     2cb:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
     2d1:	39 d1                	cmp    %edx,%ecx
     2d3:	7e 2b                	jle    300 <_defer_leftover_input+0x40>
        /* (G.csize < MAXINT), we can safely cast it to int !! */
        if (G.csize < 0L)
     2d5:	85 d2                	test   %edx,%edx
     2d7:	78 3b                	js     314 <_defer_leftover_input+0x54>
     2d9:	89 d3                	mov    %edx,%ebx
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
     2db:	03 98 e8 08 01 00    	add    0x108e8(%eax),%ebx
        G.incnt_leftover = G.incnt - (int)G.csize;
     2e1:	29 d1                	sub    %edx,%ecx
        G.incnt = (int)G.csize;
     2e3:	89 90 ec 08 01 00    	mov    %edx,0x108ec(%eax)
     2e9:	31 d2                	xor    %edx,%edx
{
    if ((long)G.incnt > G.csize) {
        /* (G.csize < MAXINT), we can safely cast it to int !! */
        if (G.csize < 0L)
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
     2eb:	89 98 60 0b 01 00    	mov    %ebx,0x10b60(%eax)
        G.incnt_leftover = G.incnt - (int)G.csize;
     2f1:	89 88 5c 0b 01 00    	mov    %ecx,0x10b5c(%eax)
        G.incnt = (int)G.csize;
    } else
        G.incnt_leftover = 0;
    G.csize -= G.incnt;
     2f7:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
} /* end function defer_leftover_input() */
     2fd:	5b                   	pop    %ebx
     2fe:	c3                   	ret    
     2ff:	90                   	nop
     300:	29 ca                	sub    %ecx,%edx
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
        G.incnt_leftover = G.incnt - (int)G.csize;
        G.incnt = (int)G.csize;
    } else
        G.incnt_leftover = 0;
     302:	c7 80 5c 0b 01 00 00 	movl   $0x0,0x10b5c(%eax)
     309:	00 00 00 
    G.csize -= G.incnt;
     30c:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
} /* end function defer_leftover_input() */
     312:	5b                   	pop    %ebx
     313:	c3                   	ret    
     314:	31 db                	xor    %ebx,%ebx
     316:	31 d2                	xor    %edx,%edx
     318:	eb c1                	jmp    2db <_defer_leftover_input+0x1b>
     31a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00000320 <_readbuf>:

unsigned readbuf(__G__ buf, size)   /* return number of bytes read into buf */
    __GDEF
    char *buf;
    register unsigned size;
{
     320:	55                   	push   %ebp
     321:	57                   	push   %edi
     322:	56                   	push   %esi
     323:	53                   	push   %ebx
     324:	83 ec 1c             	sub    $0x1c,%esp
    register unsigned count;
    unsigned n;

    n = size;
    while (size) {
     327:	8b 4c 24 38          	mov    0x38(%esp),%ecx

unsigned readbuf(__G__ buf, size)   /* return number of bytes read into buf */
    __GDEF
    char *buf;
    register unsigned size;
{
     32b:	8b 7c 24 30          	mov    0x30(%esp),%edi
     32f:	8b 74 24 34          	mov    0x34(%esp),%esi
    register unsigned count;
    unsigned n;

    n = size;
    while (size) {
     333:	85 c9                	test   %ecx,%ecx
     335:	0f 84 ed 00 00 00    	je     428 <_readbuf+0x108>
     33b:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
     341:	8b 5c 24 38          	mov    0x38(%esp),%ebx
     345:	eb 3f                	jmp    386 <_readbuf+0x66>
     347:	8b 8f e8 08 01 00    	mov    0x108e8(%edi),%ecx
            }
            /* buffer ALWAYS starts on a block boundary:  */
            G.cur_zipfile_bufstart += INBUFSIZ;
            G.inptr = G.inbuf;
        }
        count = MIN(size, (unsigned)G.incnt);
     34d:	39 d8                	cmp    %ebx,%eax
        memcpy(buf, G.inptr, count);
     34f:	89 34 24             	mov    %esi,(%esp)
            }
            /* buffer ALWAYS starts on a block boundary:  */
            G.cur_zipfile_bufstart += INBUFSIZ;
            G.inptr = G.inbuf;
        }
        count = MIN(size, (unsigned)G.incnt);
     352:	0f 47 c3             	cmova  %ebx,%eax
        memcpy(buf, G.inptr, count);
     355:	89 44 24 08          	mov    %eax,0x8(%esp)
     359:	89 4c 24 04          	mov    %ecx,0x4(%esp)
            }
            /* buffer ALWAYS starts on a block boundary:  */
            G.cur_zipfile_bufstart += INBUFSIZ;
            G.inptr = G.inbuf;
        }
        count = MIN(size, (unsigned)G.incnt);
     35d:	89 c5                	mov    %eax,%ebp
        memcpy(buf, G.inptr, count);
     35f:	e8 00 00 00 00       	call   364 <_readbuf+0x44>
        buf += count;
        G.inptr += count;
     364:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
            G.cur_zipfile_bufstart += INBUFSIZ;
            G.inptr = G.inbuf;
        }
        count = MIN(size, (unsigned)G.incnt);
        memcpy(buf, G.inptr, count);
        buf += count;
     36a:	01 ee                	add    %ebp,%esi
        G.inptr += count;
     36c:	01 e8                	add    %ebp,%eax
     36e:	89 87 e8 08 01 00    	mov    %eax,0x108e8(%edi)
        G.incnt -= count;
     374:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
     37a:	29 e8                	sub    %ebp,%eax
{
    register unsigned count;
    unsigned n;

    n = size;
    while (size) {
     37c:	29 eb                	sub    %ebp,%ebx
        }
        count = MIN(size, (unsigned)G.incnt);
        memcpy(buf, G.inptr, count);
        buf += count;
        G.inptr += count;
        G.incnt -= count;
     37e:	89 87 ec 08 01 00    	mov    %eax,0x108ec(%edi)
{
    register unsigned count;
    unsigned n;

    n = size;
    while (size) {
     384:	74 5a                	je     3e0 <_readbuf+0xc0>
        if (G.incnt <= 0) {
     386:	85 c0                	test   %eax,%eax
     388:	7f bd                	jg     347 <_readbuf+0x27>
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0)
     38a:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
     391:	00 
     392:	8b 87 e4 08 01 00    	mov    0x108e4(%edi),%eax
     398:	89 44 24 04          	mov    %eax,0x4(%esp)
     39c:	8b 87 08 09 01 00    	mov    0x10908(%edi),%eax
     3a2:	89 04 24             	mov    %eax,(%esp)
     3a5:	e8 00 00 00 00       	call   3aa <_readbuf+0x8a>
     3aa:	89 87 ec 08 01 00    	mov    %eax,0x108ec(%edi)
     3b0:	85 c0                	test   %eax,%eax
     3b2:	74 38                	je     3ec <_readbuf+0xcc>
                return (n-size);
            else if (G.incnt < 0) {
     3b4:	78 44                	js     3fa <_readbuf+0xda>
                  (uch *)LoadFarString(ReadError),  /* CANNOT use slide */
                  (ulg)strlen(LoadFarString(ReadError)), 0x401);
                return 0;  /* discarding some data; better than lock-up */
            }
            /* buffer ALWAYS starts on a block boundary:  */
            G.cur_zipfile_bufstart += INBUFSIZ;
     3b6:	8b 97 10 09 01 00    	mov    0x10910(%edi),%edx
            G.inptr = G.inbuf;
     3bc:	8b 8f e4 08 01 00    	mov    0x108e4(%edi),%ecx
                  (uch *)LoadFarString(ReadError),  /* CANNOT use slide */
                  (ulg)strlen(LoadFarString(ReadError)), 0x401);
                return 0;  /* discarding some data; better than lock-up */
            }
            /* buffer ALWAYS starts on a block boundary:  */
            G.cur_zipfile_bufstart += INBUFSIZ;
     3c2:	81 c2 00 20 00 00    	add    $0x2000,%edx
            G.inptr = G.inbuf;
     3c8:	89 8f e8 08 01 00    	mov    %ecx,0x108e8(%edi)
                  (uch *)LoadFarString(ReadError),  /* CANNOT use slide */
                  (ulg)strlen(LoadFarString(ReadError)), 0x401);
                return 0;  /* discarding some data; better than lock-up */
            }
            /* buffer ALWAYS starts on a block boundary:  */
            G.cur_zipfile_bufstart += INBUFSIZ;
     3ce:	89 97 10 09 01 00    	mov    %edx,0x10910(%edi)
     3d4:	e9 74 ff ff ff       	jmp    34d <_readbuf+0x2d>
     3d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     3e0:	8b 44 24 38          	mov    0x38(%esp),%eax
        G.incnt -= count;
        size -= count;
    }
    return n;

} /* end function readbuf() */
     3e4:	83 c4 1c             	add    $0x1c,%esp
     3e7:	5b                   	pop    %ebx
     3e8:	5e                   	pop    %esi
     3e9:	5f                   	pop    %edi
     3ea:	5d                   	pop    %ebp
     3eb:	c3                   	ret    

    n = size;
    while (size) {
        if (G.incnt <= 0) {
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0)
                return (n-size);
     3ec:	8b 44 24 38          	mov    0x38(%esp),%eax
        G.incnt -= count;
        size -= count;
    }
    return n;

} /* end function readbuf() */
     3f0:	83 c4 1c             	add    $0x1c,%esp

    n = size;
    while (size) {
        if (G.incnt <= 0) {
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0)
                return (n-size);
     3f3:	29 d8                	sub    %ebx,%eax
        G.incnt -= count;
        size -= count;
    }
    return n;

} /* end function readbuf() */
     3f5:	5b                   	pop    %ebx
     3f6:	5e                   	pop    %esi
     3f7:	5f                   	pop    %edi
     3f8:	5d                   	pop    %ebp
     3f9:	c3                   	ret    
        if (G.incnt <= 0) {
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0)
                return (n-size);
            else if (G.incnt < 0) {
                /* another hack, but no real harm copying same thing twice */
                (*G.message)((zvoid *)&G,
     3fa:	89 3c 24             	mov    %edi,(%esp)
     3fd:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     404:	00 
     405:	c7 44 24 08 1b 00 00 	movl   $0x1b,0x8(%esp)
     40c:	00 
     40d:	c7 44 24 04 14 01 00 	movl   $0x114,0x4(%esp)
     414:	00 
     415:	ff 97 44 0b 01 00    	call   *0x10b44(%edi)
                  (uch *)LoadFarString(ReadError),  /* CANNOT use slide */
                  (ulg)strlen(LoadFarString(ReadError)), 0x401);
                return 0;  /* discarding some data; better than lock-up */
     41b:	31 c0                	xor    %eax,%eax
        if (G.incnt <= 0) {
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0)
                return (n-size);
            else if (G.incnt < 0) {
                /* another hack, but no real harm copying same thing twice */
                (*G.message)((zvoid *)&G,
     41d:	83 ec 10             	sub    $0x10,%esp
        G.incnt -= count;
        size -= count;
    }
    return n;

} /* end function readbuf() */
     420:	83 c4 1c             	add    $0x1c,%esp
     423:	5b                   	pop    %ebx
     424:	5e                   	pop    %esi
     425:	5f                   	pop    %edi
     426:	5d                   	pop    %ebp
     427:	c3                   	ret    
        buf += count;
        G.inptr += count;
        G.incnt -= count;
        size -= count;
    }
    return n;
     428:	31 c0                	xor    %eax,%eax
     42a:	eb b8                	jmp    3e4 <_readbuf+0xc4>
     42c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000430 <_readbyte>:
/* Function readbyte() */
/***********************/

int readbyte(__G)   /* refill inbuf and return a byte if available, else EOF */
    __GDEF
{
     430:	55                   	push   %ebp
     431:	57                   	push   %edi
     432:	56                   	push   %esi
     433:	53                   	push   %ebx
     434:	83 ec 1c             	sub    $0x1c,%esp
     437:	8b 74 24 30          	mov    0x30(%esp),%esi
    if (G.mem_mode)
     43b:	8b 8e a0 09 01 00    	mov    0x109a0(%esi),%ecx
     441:	85 c9                	test   %ecx,%ecx
     443:	0f 85 37 01 00 00    	jne    580 <_readbyte+0x150>
        return EOF;
    if (G.csize <= 0) {
     449:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
     44f:	85 c0                	test   %eax,%eax
     451:	0f 8e 18 01 00 00    	jle    56f <_readbyte+0x13f>
        G.csize--;             /* for tests done after exploding */
        G.incnt = 0;
        return EOF;
    }
    if (G.incnt <= 0) {
     457:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     45d:	85 c0                	test   %eax,%eax
     45f:	7e 32                	jle    493 <_readbyte+0x63>
        G.inptr = G.inbuf;
        defer_leftover_input(__G);           /* decrements G.csize */
    }

#if CRYPT
    if (G.pInfo->encrypted) {
     461:	8b 96 d8 08 00 00    	mov    0x8d8(%esi),%edx
     467:	f6 42 18 01          	testb  $0x1,0x18(%edx)
     46b:	0f 85 3f 01 00 00    	jne    5b0 <_readbyte+0x180>
     471:	48                   	dec    %eax
     472:	8b be e8 08 01 00    	mov    0x108e8(%esi),%edi
        for (n = G.incnt, p = G.inptr;  n--;  p++)
            zdecode(*p);
    }
#endif /* CRYPT */

    --G.incnt;
     478:	89 86 ec 08 01 00    	mov    %eax,0x108ec(%esi)
    return *G.inptr++;
     47e:	8d 47 01             	lea    0x1(%edi),%eax
     481:	89 86 e8 08 01 00    	mov    %eax,0x108e8(%esi)
     487:	31 c0                	xor    %eax,%eax
     489:	8a 07                	mov    (%edi),%al

} /* end function readbyte() */
     48b:	83 c4 1c             	add    $0x1c,%esp
     48e:	5b                   	pop    %ebx
     48f:	5e                   	pop    %esi
     490:	5f                   	pop    %edi
     491:	5d                   	pop    %ebp
     492:	c3                   	ret    
        G.csize--;             /* for tests done after exploding */
        G.incnt = 0;
        return EOF;
    }
    if (G.incnt <= 0) {
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0) {
     493:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
     49a:	00 
     49b:	8b 86 e4 08 01 00    	mov    0x108e4(%esi),%eax
     4a1:	89 44 24 04          	mov    %eax,0x4(%esp)
     4a5:	8b 86 08 09 01 00    	mov    0x10908(%esi),%eax
     4ab:	89 04 24             	mov    %eax,(%esp)
     4ae:	e8 00 00 00 00       	call   4b3 <_readbyte+0x83>
     4b3:	89 86 ec 08 01 00    	mov    %eax,0x108ec(%esi)
     4b9:	85 c0                	test   %eax,%eax
     4bb:	0f 84 bf 00 00 00    	je     580 <_readbyte+0x150>
            G.incnt = 0;       /* do not allow negative value to affect stuff */
            return EOF;
        } else if (G.incnt < 0) {  /* "fail" (abort, retry, ...) returns this */
     4c1:	0f 88 17 01 00 00    	js     5de <_readbyte+0x1ae>
#else
            DESTROYGLOBALS();
            EXIT(PK_BADERR);    /* totally bailing; better than lock-up */
#endif
        }
        G.cur_zipfile_bufstart += INBUFSIZ; /* always starts on block bndry */
     4c7:	8b 96 10 09 01 00    	mov    0x10910(%esi),%edx
        G.inptr = G.inbuf;
     4cd:	8b be e4 08 01 00    	mov    0x108e4(%esi),%edi
#else
            DESTROYGLOBALS();
            EXIT(PK_BADERR);    /* totally bailing; better than lock-up */
#endif
        }
        G.cur_zipfile_bufstart += INBUFSIZ; /* always starts on block bndry */
     4d3:	81 c2 00 20 00 00    	add    $0x2000,%edx
/***********************************/

void defer_leftover_input(__G)
    __GDEF
{
    if ((long)G.incnt > G.csize) {
     4d9:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
#else
            DESTROYGLOBALS();
            EXIT(PK_BADERR);    /* totally bailing; better than lock-up */
#endif
        }
        G.cur_zipfile_bufstart += INBUFSIZ; /* always starts on block bndry */
     4df:	89 96 10 09 01 00    	mov    %edx,0x10910(%esi)
        G.inptr = G.inbuf;
     4e5:	89 be e8 08 01 00    	mov    %edi,0x108e8(%esi)
/***********************************/

void defer_leftover_input(__G)
    __GDEF
{
    if ((long)G.incnt > G.csize) {
     4eb:	39 c8                	cmp    %ecx,%eax
     4ed:	0f 8e 95 00 00 00    	jle    588 <_readbyte+0x158>
        /* (G.csize < MAXINT), we can safely cast it to int !! */
        if (G.csize < 0L)
     4f3:	85 c9                	test   %ecx,%ecx
     4f5:	0f 88 c5 00 00 00    	js     5c0 <_readbyte+0x190>
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
        G.incnt_leftover = G.incnt - (int)G.csize;
     4fb:	29 c8                	sub    %ecx,%eax
{
    if ((long)G.incnt > G.csize) {
        /* (G.csize < MAXINT), we can safely cast it to int !! */
        if (G.csize < 0L)
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
     4fd:	8d 1c 0f             	lea    (%edi,%ecx,1),%ebx
        G.incnt_leftover = G.incnt - (int)G.csize;
     500:	89 86 5c 0b 01 00    	mov    %eax,0x10b5c(%esi)
        G.inptr = G.inbuf;
        defer_leftover_input(__G);           /* decrements G.csize */
    }

#if CRYPT
    if (G.pInfo->encrypted) {
     506:	8b 86 d8 08 00 00    	mov    0x8d8(%esi),%eax
{
    if ((long)G.incnt > G.csize) {
        /* (G.csize < MAXINT), we can safely cast it to int !! */
        if (G.csize < 0L)
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
     50c:	89 9e 60 0b 01 00    	mov    %ebx,0x10b60(%esi)
        G.incnt_leftover = G.incnt - (int)G.csize;
        G.incnt = (int)G.csize;
     512:	89 8e ec 08 01 00    	mov    %ecx,0x108ec(%esi)
    } else
        G.incnt_leftover = 0;
    G.csize -= G.incnt;
     518:	c7 86 90 00 00 00 00 	movl   $0x0,0x90(%esi)
     51f:	00 00 00 
     522:	8d 51 ff             	lea    -0x1(%ecx),%edx
        G.inptr = G.inbuf;
        defer_leftover_input(__G);           /* decrements G.csize */
    }

#if CRYPT
    if (G.pInfo->encrypted) {
     525:	f6 40 18 01          	testb  $0x1,0x18(%eax)
     529:	74 7e                	je     5a9 <_readbyte+0x179>

        /* This was previously set to decrypt one byte beyond G.csize, when
         * incnt reached that far.  GRR said, "but it's required:  why?"  This
         * was a bug in fillinbuf() -- was it also a bug here?
         */
        for (n = G.incnt, p = G.inptr;  n--;  p++)
     52b:	85 c9                	test   %ecx,%ecx
     52d:	74 7a                	je     5a9 <_readbyte+0x179>
/* Function readbyte() */
/***********************/

int readbyte(__G)   /* refill inbuf and return a byte if available, else EOF */
    __GDEF
{
     52f:	89 fb                	mov    %edi,%ebx
     531:	8d 6a 01             	lea    0x1(%edx),%ebp
        /* This was previously set to decrypt one byte beyond G.csize, when
         * incnt reached that far.  GRR said, "but it's required:  why?"  This
         * was a bug in fillinbuf() -- was it also a bug here?
         */
        for (n = G.incnt, p = G.inptr;  n--;  p++)
            zdecode(*p);
     534:	89 34 24             	mov    %esi,(%esp)

        /* This was previously set to decrypt one byte beyond G.csize, when
         * incnt reached that far.  GRR said, "but it's required:  why?"  This
         * was a bug in fillinbuf() -- was it also a bug here?
         */
        for (n = G.incnt, p = G.inptr;  n--;  p++)
     537:	43                   	inc    %ebx
            zdecode(*p);
     538:	e8 00 00 00 00       	call   53d <_readbyte+0x10d>
     53d:	88 c1                	mov    %al,%cl
     53f:	31 c0                	xor    %eax,%eax
     541:	32 4b ff             	xor    -0x1(%ebx),%cl
     544:	88 c8                	mov    %cl,%al
     546:	88 4b ff             	mov    %cl,-0x1(%ebx)
     549:	89 44 24 04          	mov    %eax,0x4(%esp)
     54d:	89 34 24             	mov    %esi,(%esp)
     550:	e8 00 00 00 00       	call   555 <_readbyte+0x125>
     555:	89 e8                	mov    %ebp,%eax
     557:	29 d8                	sub    %ebx,%eax

        /* This was previously set to decrypt one byte beyond G.csize, when
         * incnt reached that far.  GRR said, "but it's required:  why?"  This
         * was a bug in fillinbuf() -- was it also a bug here?
         */
        for (n = G.incnt, p = G.inptr;  n--;  p++)
     559:	01 f8                	add    %edi,%eax
     55b:	75 d7                	jne    534 <_readbyte+0x104>
     55d:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     563:	8b be e8 08 01 00    	mov    0x108e8(%esi),%edi
     569:	48                   	dec    %eax
     56a:	e9 09 ff ff ff       	jmp    478 <_readbyte+0x48>
    __GDEF
{
    if (G.mem_mode)
        return EOF;
    if (G.csize <= 0) {
        G.csize--;             /* for tests done after exploding */
     56f:	48                   	dec    %eax
        G.incnt = 0;
     570:	c7 86 ec 08 01 00 00 	movl   $0x0,0x108ec(%esi)
     577:	00 00 00 
    __GDEF
{
    if (G.mem_mode)
        return EOF;
    if (G.csize <= 0) {
        G.csize--;             /* for tests done after exploding */
     57a:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
        G.incnt = 0;
        return EOF;
     580:	83 c8 ff             	or     $0xffffffff,%eax
     583:	e9 03 ff ff ff       	jmp    48b <_readbyte+0x5b>
     588:	29 c1                	sub    %eax,%ecx
     58a:	8d 50 ff             	lea    -0x1(%eax),%edx
        G.inptr = G.inbuf;
        defer_leftover_input(__G);           /* decrements G.csize */
    }

#if CRYPT
    if (G.pInfo->encrypted) {
     58d:	8b 86 d8 08 00 00    	mov    0x8d8(%esi),%eax
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
        G.incnt_leftover = G.incnt - (int)G.csize;
        G.incnt = (int)G.csize;
    } else
        G.incnt_leftover = 0;
     593:	c7 86 5c 0b 01 00 00 	movl   $0x0,0x10b5c(%esi)
     59a:	00 00 00 
     59d:	89 8e 90 00 00 00    	mov    %ecx,0x90(%esi)
        G.inptr = G.inbuf;
        defer_leftover_input(__G);           /* decrements G.csize */
    }

#if CRYPT
    if (G.pInfo->encrypted) {
     5a3:	f6 40 18 01          	testb  $0x1,0x18(%eax)
     5a7:	75 86                	jne    52f <_readbyte+0xff>

        /* This was previously set to decrypt one byte beyond G.csize, when
         * incnt reached that far.  GRR said, "but it's required:  why?"  This
         * was a bug in fillinbuf() -- was it also a bug here?
         */
        for (n = G.incnt, p = G.inptr;  n--;  p++)
     5a9:	89 d0                	mov    %edx,%eax
     5ab:	e9 c8 fe ff ff       	jmp    478 <_readbyte+0x48>
     5b0:	8b be e8 08 01 00    	mov    0x108e8(%esi),%edi
     5b6:	8d 50 ff             	lea    -0x1(%eax),%edx
     5b9:	e9 71 ff ff ff       	jmp    52f <_readbyte+0xff>
     5be:	66 90                	xchg   %ax,%ax
    if ((long)G.incnt > G.csize) {
        /* (G.csize < MAXINT), we can safely cast it to int !! */
        if (G.csize < 0L)
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
        G.incnt_leftover = G.incnt - (int)G.csize;
     5c0:	89 86 5c 0b 01 00    	mov    %eax,0x10b5c(%esi)
{
    if ((long)G.incnt > G.csize) {
        /* (G.csize < MAXINT), we can safely cast it to int !! */
        if (G.csize < 0L)
            G.csize = 0L;
        G.inptr_leftover = G.inptr + (int)G.csize;
     5c6:	89 be 60 0b 01 00    	mov    %edi,0x10b60(%esi)
        G.incnt_leftover = G.incnt - (int)G.csize;
        G.incnt = (int)G.csize;
    } else
        G.incnt_leftover = 0;
    G.csize -= G.incnt;
     5cc:	c7 86 90 00 00 00 00 	movl   $0x0,0x90(%esi)
     5d3:	00 00 00 
     5d6:	83 c8 ff             	or     $0xffffffff,%eax
     5d9:	e9 9a fe ff ff       	jmp    478 <_readbyte+0x48>
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0) {
            G.incnt = 0;       /* do not allow negative value to affect stuff */
            return EOF;
        } else if (G.incnt < 0) {  /* "fail" (abort, retry, ...) returns this */
            /* another hack, but no real harm copying same thing twice */
            (*G.message)((zvoid *)&G,
     5de:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     5e5:	00 
     5e6:	c7 44 24 08 1b 00 00 	movl   $0x1b,0x8(%esp)
     5ed:	00 
     5ee:	c7 44 24 04 14 01 00 	movl   $0x114,0x4(%esp)
     5f5:	00 
     5f6:	89 34 24             	mov    %esi,(%esp)
     5f9:	ff 96 44 0b 01 00    	call   *0x10b44(%esi)
     5ff:	83 ec 10             	sub    $0x10,%esp
              (uch *)LoadFarString(ReadError),
              (ulg)strlen(LoadFarString(ReadError)), 0x401);
            echon();
#ifdef WINDLL
            longjmp(dll_error_return, 1);
     602:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
     609:	00 
     60a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     611:	e8 00 00 00 00       	call   616 <_readbyte+0x1e6>
     616:	8d 76 00             	lea    0x0(%esi),%esi
     619:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000620 <_seek_zipf>:
/************************/

int seek_zipf(__G__ abs_offset)
    __GDEF
    Z_OFF_T abs_offset;
{
     620:	57                   	push   %edi
     621:	56                   	push   %esi
     622:	53                   	push   %ebx
     623:	83 ec 10             	sub    $0x10,%esp
     626:	8b 74 24 20          	mov    0x20(%esp),%esi
 * returns PK error codes:
 *  PK_BADERR if effective offset in zipfile is negative
 *  PK_EOF if seeking past end of zipfile
 *  PK_OK when seek was successful
 */
    Z_OFF_T request = abs_offset + G.extra_bytes;
     62a:	8b 44 24 24          	mov    0x24(%esp),%eax
     62e:	8b 96 14 09 01 00    	mov    0x10914(%esi),%edx
     634:	01 c2                	add    %eax,%edx
    Z_OFF_T inbuf_offset = request % INBUFSIZ;
     636:	89 d0                	mov    %edx,%eax
     638:	c1 f8 1f             	sar    $0x1f,%eax
     63b:	c1 e8 13             	shr    $0x13,%eax
     63e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
     641:	81 e3 ff 1f 00 00    	and    $0x1fff,%ebx
     647:	29 c3                	sub    %eax,%ebx
    Z_OFF_T bufstart = request - inbuf_offset;
     649:	89 d0                	mov    %edx,%eax
     64b:	29 d8                	sub    %ebx,%eax

    if (request < 0) {
     64d:	85 d2                	test   %edx,%edx
     64f:	0f 88 9e 00 00 00    	js     6f3 <_seek_zipf+0xd3>
        Info(slide, 1, ((char *)slide, LoadFarStringSmall(SeekMsg),
             G.zipfn, LoadFarString(ReportMsg)));
        return(PK_BADERR);
    } else if (bufstart != G.cur_zipfile_bufstart) {
     655:	39 86 10 09 01 00    	cmp    %eax,0x10910(%esi)
     65b:	74 67                	je     6c4 <_seek_zipf+0xa4>
          abs_offset, G.extra_bytes));
#ifdef USE_STRM_INPUT
        fseek(G.zipfd, bufstart, SEEK_SET);
        G.cur_zipfile_bufstart = ftell(G.zipfd);
#else /* !USE_STRM_INPUT */
        G.cur_zipfile_bufstart = lseek(G.zipfd, bufstart, SEEK_SET);
     65d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     664:	00 
     665:	89 44 24 04          	mov    %eax,0x4(%esp)
     669:	8b 86 08 09 01 00    	mov    0x10908(%esi),%eax
     66f:	89 04 24             	mov    %eax,(%esp)
     672:	e8 00 00 00 00       	call   677 <_seek_zipf+0x57>
     677:	89 86 10 09 01 00    	mov    %eax,0x10910(%esi)
        Trace((stderr,
          "       request = %ld, (abs+extra) = %ld, inbuf_offset = %ld\n",
          request, (abs_offset+G.extra_bytes), inbuf_offset));
        Trace((stderr, "       bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          bufstart, G.cur_zipfile_bufstart));
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
     67d:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
     684:	00 
     685:	8b 86 e4 08 01 00    	mov    0x108e4(%esi),%eax
     68b:	89 44 24 04          	mov    %eax,0x4(%esp)
     68f:	8b 86 08 09 01 00    	mov    0x10908(%esi),%eax
     695:	89 04 24             	mov    %eax,(%esp)
     698:	e8 00 00 00 00       	call   69d <_seek_zipf+0x7d>
     69d:	85 c0                	test   %eax,%eax
     69f:	0f 8e a0 00 00 00    	jle    745 <_seek_zipf+0x125>
            return(PK_EOF);
        G.incnt -= (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
     6a5:	8b be e4 08 01 00    	mov    0x108e4(%esi),%edi
          request, (abs_offset+G.extra_bytes), inbuf_offset));
        Trace((stderr, "       bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          bufstart, G.cur_zipfile_bufstart));
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            return(PK_EOF);
        G.incnt -= (int)inbuf_offset;
     6ab:	29 d8                	sub    %ebx,%eax
        G.inptr = G.inbuf + (int)inbuf_offset;
     6ad:	01 fb                	add    %edi,%ebx
          request, (abs_offset+G.extra_bytes), inbuf_offset));
        Trace((stderr, "       bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          bufstart, G.cur_zipfile_bufstart));
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            return(PK_EOF);
        G.incnt -= (int)inbuf_offset;
     6af:	89 86 ec 08 01 00    	mov    %eax,0x108ec(%esi)
        G.inptr = G.inbuf + (int)inbuf_offset;
     6b5:	89 9e e8 08 01 00    	mov    %ebx,0x108e8(%esi)
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    }
    return(PK_OK);
} /* end function seek_zipf() */
     6bb:	83 c4 10             	add    $0x10,%esp
        G.inptr = G.inbuf + (int)inbuf_offset;
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    }
    return(PK_OK);
     6be:	31 c0                	xor    %eax,%eax
} /* end function seek_zipf() */
     6c0:	5b                   	pop    %ebx
     6c1:	5e                   	pop    %esi
     6c2:	5f                   	pop    %edi
     6c3:	c3                   	ret    
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            return(PK_EOF);
        G.incnt -= (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
     6c4:	8b 96 e4 08 01 00    	mov    0x108e4(%esi),%edx
     6ca:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     6d0:	29 d0                	sub    %edx,%eax
     6d2:	8b 8e ec 08 01 00    	mov    0x108ec(%esi),%ecx
     6d8:	29 d8                	sub    %ebx,%eax
        G.inptr = G.inbuf + (int)inbuf_offset;
     6da:	01 d3                	add    %edx,%ebx
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            return(PK_EOF);
        G.incnt -= (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
     6dc:	01 c1                	add    %eax,%ecx
        G.inptr = G.inbuf + (int)inbuf_offset;
     6de:	89 9e e8 08 01 00    	mov    %ebx,0x108e8(%esi)
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            return(PK_EOF);
        G.incnt -= (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
     6e4:	89 8e ec 08 01 00    	mov    %ecx,0x108ec(%esi)
        G.inptr = G.inbuf + (int)inbuf_offset;
    }
    return(PK_OK);
} /* end function seek_zipf() */
     6ea:	83 c4 10             	add    $0x10,%esp
        G.inptr = G.inbuf + (int)inbuf_offset;
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    }
    return(PK_OK);
     6ed:	31 c0                	xor    %eax,%eax
} /* end function seek_zipf() */
     6ef:	5b                   	pop    %ebx
     6f0:	5e                   	pop    %esi
     6f1:	5f                   	pop    %edi
     6f2:	c3                   	ret    
    Z_OFF_T request = abs_offset + G.extra_bytes;
    Z_OFF_T inbuf_offset = request % INBUFSIZ;
    Z_OFF_T bufstart = request - inbuf_offset;

    if (request < 0) {
        Info(slide, 1, ((char *)slide, LoadFarStringSmall(SeekMsg),
     6f3:	8b be 44 0b 01 00    	mov    0x10b44(%esi),%edi
     6f9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     700:	00 
     701:	8b 86 04 09 01 00    	mov    0x10904(%esi),%eax
     707:	8d 9e dc 08 00 00    	lea    0x8dc(%esi),%ebx
     70d:	89 1c 24             	mov    %ebx,(%esp)
     710:	89 44 24 08          	mov    %eax,0x8(%esp)
     714:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     71b:	00 
     71c:	e8 00 00 00 00       	call   721 <_seek_zipf+0x101>
     721:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     725:	89 34 24             	mov    %esi,(%esp)
     728:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
     72f:	00 
     730:	89 44 24 08          	mov    %eax,0x8(%esp)
     734:	ff d7                	call   *%edi
             G.zipfn, LoadFarString(ReportMsg)));
        return(PK_BADERR);
     736:	b8 03 00 00 00       	mov    $0x3,%eax
    Z_OFF_T request = abs_offset + G.extra_bytes;
    Z_OFF_T inbuf_offset = request % INBUFSIZ;
    Z_OFF_T bufstart = request - inbuf_offset;

    if (request < 0) {
        Info(slide, 1, ((char *)slide, LoadFarStringSmall(SeekMsg),
     73b:	83 ec 10             	sub    $0x10,%esp
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    }
    return(PK_OK);
} /* end function seek_zipf() */
     73e:	83 c4 10             	add    $0x10,%esp
     741:	5b                   	pop    %ebx
     742:	5e                   	pop    %esi
     743:	5f                   	pop    %edi
     744:	c3                   	ret    
        Trace((stderr,
          "       request = %ld, (abs+extra) = %ld, inbuf_offset = %ld\n",
          request, (abs_offset+G.extra_bytes), inbuf_offset));
        Trace((stderr, "       bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          bufstart, G.cur_zipfile_bufstart));
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
     745:	89 86 ec 08 01 00    	mov    %eax,0x108ec(%esi)
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    }
    return(PK_OK);
} /* end function seek_zipf() */
     74b:	83 c4 10             	add    $0x10,%esp
          "       request = %ld, (abs+extra) = %ld, inbuf_offset = %ld\n",
          request, (abs_offset+G.extra_bytes), inbuf_offset));
        Trace((stderr, "       bufstart = %ld, cur_zipfile_bufstart = %ld\n",
          bufstart, G.cur_zipfile_bufstart));
        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) <= 0)
            return(PK_EOF);
     74e:	b8 33 00 00 00       	mov    $0x33,%eax
    } else {
        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;
        G.inptr = G.inbuf + (int)inbuf_offset;
    }
    return(PK_OK);
} /* end function seek_zipf() */
     753:	5b                   	pop    %ebx
     754:	5e                   	pop    %esi
     755:	5f                   	pop    %edi
     756:	c3                   	ret    
     757:	89 f6                	mov    %esi,%esi
     759:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000760 <_flush>:
    __GDEF
    uch *rawbuf;        /* cannot be ZCONST, gets passed to (*G.message)() */
    ulg size;
    int unshrink;
#endif /* USE_DEFLATE64 && __16BIT__ */
{
     760:	55                   	push   %ebp
     761:	57                   	push   %edi
     762:	56                   	push   %esi
     763:	53                   	push   %ebx
     764:	83 ec 6c             	sub    $0x6c,%esp
     767:	8b ac 24 80 00 00 00 	mov    0x80(%esp),%ebp

/*---------------------------------------------------------------------------
    Compute the CRC first; if testing or if disk is full, that's it.
  ---------------------------------------------------------------------------*/

    G.crc32val = crc32(G.crc32val, rawbuf, (extent)size);
     76e:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
    __GDEF
    uch *rawbuf;        /* cannot be ZCONST, gets passed to (*G.message)() */
    ulg size;
    int unshrink;
#endif /* USE_DEFLATE64 && __16BIT__ */
{
     775:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx

/*---------------------------------------------------------------------------
    Compute the CRC first; if testing or if disk is full, that's it.
  ---------------------------------------------------------------------------*/

    G.crc32val = crc32(G.crc32val, rawbuf, (extent)size);
     77c:	89 44 24 08          	mov    %eax,0x8(%esp)
     780:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     784:	8b 85 e0 08 01 00    	mov    0x108e0(%ebp),%eax
     78a:	89 04 24             	mov    %eax,(%esp)
     78d:	e8 00 00 00 00       	call   792 <_flush+0x32>
     792:	89 85 e0 08 01 00    	mov    %eax,0x108e0(%ebp)

#ifdef DLL
    if ((G.statreportcb != NULL) &&
     798:	8b 85 54 0b 01 00    	mov    0x10b54(%ebp),%eax
     79e:	85 c0                	test   %eax,%eax
     7a0:	74 3f                	je     7e1 <_flush+0x81>
        (*G.statreportcb)(__G__ UZ_ST_IN_PROGRESS, G.zipfn, G.filename, NULL))
     7a2:	8d 95 e0 09 01 00    	lea    0x109e0(%ebp),%edx
     7a8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
     7af:	00 
     7b0:	89 54 24 0c          	mov    %edx,0xc(%esp)
     7b4:	8b 95 04 09 01 00    	mov    0x10904(%ebp),%edx
     7ba:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
     7c1:	00 
     7c2:	89 54 24 08          	mov    %edx,0x8(%esp)
     7c6:	89 2c 24             	mov    %ebp,(%esp)
     7c9:	ff d0                	call   *%eax
        return IZ_CTRLC;        /* cancel operation by user request */
     7cb:	ba 50 00 00 00       	mov    $0x50,%edx

    G.crc32val = crc32(G.crc32val, rawbuf, (extent)size);

#ifdef DLL
    if ((G.statreportcb != NULL) &&
        (*G.statreportcb)(__G__ UZ_ST_IN_PROGRESS, G.zipfn, G.filename, NULL))
     7d0:	83 ec 14             	sub    $0x14,%esp
  ---------------------------------------------------------------------------*/

    G.crc32val = crc32(G.crc32val, rawbuf, (extent)size);

#ifdef DLL
    if ((G.statreportcb != NULL) &&
     7d3:	85 c0                	test   %eax,%eax
     7d5:	74 0a                	je     7e1 <_flush+0x81>
        }
    }

    return PK_OK;

} /* end function flush() [resp. partflush() for 16-bit Deflate64 support] */
     7d7:	83 c4 6c             	add    $0x6c,%esp
     7da:	89 d0                	mov    %edx,%eax
     7dc:	5b                   	pop    %ebx
     7dd:	5e                   	pop    %esi
     7de:	5f                   	pop    %edi
     7df:	5d                   	pop    %ebp
     7e0:	c3                   	ret    
    if ((G.statreportcb != NULL) &&
        (*G.statreportcb)(__G__ UZ_ST_IN_PROGRESS, G.zipfn, G.filename, NULL))
        return IZ_CTRLC;        /* cancel operation by user request */
#endif

    if (uO.tflag || size == 0L)  /* testing or nothing to write:  all done */
     7e1:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
     7e8:	85 c0                	test   %eax,%eax
     7ea:	0f 84 f0 00 00 00    	je     8e0 <_flush+0x180>
     7f0:	8b 45 44             	mov    0x44(%ebp),%eax
     7f3:	85 c0                	test   %eax,%eax
     7f5:	0f 85 e5 00 00 00    	jne    8e0 <_flush+0x180>
        return PK_OK;

    if (G.disk_full)
     7fb:	8b 85 b0 09 01 00    	mov    0x109b0(%ebp),%eax
        return PK_DISK;         /* disk already full:  ignore rest of file */
     801:	ba 32 00 00 00       	mov    $0x32,%edx
#endif

    if (uO.tflag || size == 0L)  /* testing or nothing to write:  all done */
        return PK_OK;

    if (G.disk_full)
     806:	89 44 24 30          	mov    %eax,0x30(%esp)
     80a:	85 c0                	test   %eax,%eax
     80c:	75 c9                	jne    7d7 <_flush+0x77>
    end-of-lines and ASCII/EBCDIC as needed.  If SMALL_MEM or MED_MEM are NOT
    defined, outbuf is assumed to be at least as large as rawbuf and is not
    necessarily checked for overflow.
  ---------------------------------------------------------------------------*/

    if (!G.pInfo->textmode) {   /* write raw binary data */
     80e:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
     814:	f6 40 18 08          	testb  $0x8,0x18(%eax)
     818:	0f 84 b4 02 00 00    	je     ad2 <_flush+0x372>
        if (!uO.cflag && WriteError(rawbuf, size, G.outfile))
            return disk_error(__G);
        else if (uO.cflag && (*G.message)((zvoid *)&G, rawbuf, size, 0))
            return PK_OK;
    } else {   /* textmode:  aflag is true */
        if (unshrink) {
     81e:	8b b4 24 8c 00 00 00 	mov    0x8c(%esp),%esi
     825:	85 f6                	test   %esi,%esi
     827:	0f 84 4d 04 00 00    	je     c7a <_flush+0x51a>
            /* rawbuf = outbuf */
            transbuf = G.outbuf2;
     82d:	8b b5 d4 09 01 00    	mov    0x109d4(%ebp),%esi
#if (defined(SMALL_MEM) || defined(MED_MEM) || defined(VMS_TEXT_CONV))
            transbufsiz = TRANSBUFSIZ;
     833:	c7 44 24 38 00 00 04 	movl   $0x40000,0x38(%esp)
     83a:	00 
        else if (uO.cflag && (*G.message)((zvoid *)&G, rawbuf, size, 0))
            return PK_OK;
    } else {   /* textmode:  aflag is true */
        if (unshrink) {
            /* rawbuf = outbuf */
            transbuf = G.outbuf2;
     83b:	89 74 24 2c          	mov    %esi,0x2c(%esp)
            transbufsiz = OUTBUFSIZ;
            Trace((stderr, "\ntransbufsiz = OUTBUFSIZ = %u\n",
                   (unsigned)OUTBUFSIZ));
#endif
        }
        if (G.newfile) {
     83f:	8b 8d b4 09 01 00    	mov    0x109b4(%ebp),%ecx
     845:	85 c9                	test   %ecx,%ecx
     847:	0f 85 44 04 00 00    	jne    c91 <_flush+0x531>
     84d:	8b 85 68 0b 01 00    	mov    0x10b68(%ebp),%eax
     853:	89 44 24 30          	mov    %eax,0x30(%esp)
            G.didCRlast = FALSE;         /* no previous buffers written */
            G.newfile = FALSE;
        }

#ifdef VMS_TEXT_CONV
        if (G.VMS_line_state >= 0)
     857:	8b 74 24 30          	mov    0x30(%esp),%esi
     85b:	85 f6                	test   %esi,%esi
     85d:	0f 88 63 04 00 00    	js     cc6 <_flush+0x566>
     863:	8b 44 24 2c          	mov    0x2c(%esp),%eax
                        }
                        break;

                    /* 3: ready to PutNativeEOL */
                    case 3:
                        if (q > transbuf+(extent)transbufsiz-lenEOL) {
     867:	8b 4c 24 38          	mov    0x38(%esp),%ecx
            G.didCRlast = FALSE;         /* no previous buffers written */
            G.newfile = FALSE;
        }

#ifdef VMS_TEXT_CONV
        if (G.VMS_line_state >= 0)
     86b:	89 c7                	mov    %eax,%edi
     86d:	89 de                	mov    %ebx,%esi
                        }
                        break;

                    /* 3: ready to PutNativeEOL */
                    case 3:
                        if (q > transbuf+(extent)transbufsiz-lenEOL) {
     86f:	8d 44 08 fe          	lea    -0x2(%eax,%ecx,1),%eax
     873:	89 44 24 3c          	mov    %eax,0x3c(%esp)
     877:	89 d8                	mov    %ebx,%eax
     879:	29 f0                	sub    %esi,%eax
#ifdef VMS_TEXT_CONV
        if (G.VMS_line_state >= 0)
        {
            p = rawbuf;
            q = transbuf;
            while ((extent)(p-rawbuf) < (extent)size) {
     87b:	39 84 24 88 00 00 00 	cmp    %eax,0x88(%esp)
     882:	0f 86 b0 02 00 00    	jbe    b38 <_flush+0x3d8>
                switch (G.VMS_line_state) {
     888:	83 bd 68 0b 01 00 04 	cmpl   $0x4,0x10b68(%ebp)
     88f:	77 ea                	ja     87b <_flush+0x11b>
     891:	8b 95 68 0b 01 00    	mov    0x10b68(%ebp),%edx
     897:	ff 24 95 3c 00 00 00 	jmp    *0x3c(,%edx,4)
            if (G.redirect_data) {
                if (writeToMemory(__G__ transbuf, (extent)(q-transbuf)))
                    return PK_ERR;
            } else
#endif
            if (!uO.cflag && WriteError(transbuf, (extent)(q-transbuf),
     89e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     8a2:	89 fe                	mov    %edi,%esi
     8a4:	29 c6                	sub    %eax,%esi
     8a6:	89 44 24 0c          	mov    %eax,0xc(%esp)
     8aa:	89 74 24 08          	mov    %esi,0x8(%esp)
     8ae:	89 54 24 30          	mov    %edx,0x30(%esp)
     8b2:	8b 85 c8 09 01 00    	mov    0x109c8(%ebp),%eax
     8b8:	89 2c 24             	mov    %ebp,(%esp)
     8bb:	89 44 24 04          	mov    %eax,0x4(%esp)
     8bf:	e8 00 00 00 00       	call   8c4 <_flush+0x164>
     8c4:	8b 54 24 30          	mov    0x30(%esp),%edx
     8c8:	39 c6                	cmp    %eax,%esi
     8ca:	0f 85 24 05 00 00    	jne    df4 <_flush+0x694>
                G.outfile))
                return disk_error(__G);
            else if (uO.cflag && (*G.message)((zvoid *)&G, transbuf,
     8d0:	8b 45 14             	mov    0x14(%ebp),%eax
     8d3:	85 c0                	test   %eax,%eax
     8d5:	0f 85 80 02 00 00    	jne    b5b <_flush+0x3fb>
     8db:	90                   	nop
     8dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                (ulg)(q-transbuf), 0))
                return PK_OK;
        }
    }

    return PK_OK;
     8e0:	31 d2                	xor    %edx,%edx

} /* end function flush() [resp. partflush() for 16-bit Deflate64 support] */
     8e2:	83 c4 6c             	add    $0x6c,%esp
     8e5:	89 d0                	mov    %edx,%eax
     8e7:	5b                   	pop    %ebx
     8e8:	5e                   	pop    %esi
     8e9:	5f                   	pop    %edi
     8ea:	5d                   	pop    %ebp
     8eb:	c3                   	ret    
     8ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                        }
                        break;

                    /* 3: ready to PutNativeEOL */
                    case 3:
                        if (q > transbuf+(extent)transbufsiz-lenEOL) {
     8f0:	3b 7c 24 3c          	cmp    0x3c(%esp),%edi
     8f4:	76 41                	jbe    937 <_flush+0x1d7>
#ifdef DLL
                            if (G.redirect_data) {
     8f6:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
     8fc:	85 c0                	test   %eax,%eax
     8fe:	0f 85 bd 02 00 00    	jne    bc1 <_flush+0x461>
                                if (writeToMemory(__G__ transbuf,
                                      (extent)(q-transbuf))) return PK_ERR;
                            } else
#endif
                            if (!uO.cflag &&
     904:	8b 45 14             	mov    0x14(%ebp),%eax
     907:	85 c0                	test   %eax,%eax
     909:	0f 84 25 03 00 00    	je     c34 <_flush+0x4d4>
                                WriteError(transbuf, (extent)(q-transbuf),
                                  G.outfile))
                                return disk_error(__G);
                            else if (uO.cflag && (*G.message)((zvoid *)&G,
                                     transbuf, (ulg)(q-transbuf), 0))
     90f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
#endif
                            if (!uO.cflag &&
                                WriteError(transbuf, (extent)(q-transbuf),
                                  G.outfile))
                                return disk_error(__G);
                            else if (uO.cflag && (*G.message)((zvoid *)&G,
     913:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     91a:	00 
                                     transbuf, (ulg)(q-transbuf), 0))
     91b:	29 c7                	sub    %eax,%edi
#endif
                            if (!uO.cflag &&
                                WriteError(transbuf, (extent)(q-transbuf),
                                  G.outfile))
                                return disk_error(__G);
                            else if (uO.cflag && (*G.message)((zvoid *)&G,
     91d:	89 44 24 04          	mov    %eax,0x4(%esp)
     921:	89 7c 24 08          	mov    %edi,0x8(%esp)
     925:	89 2c 24             	mov    %ebp,(%esp)
     928:	89 c7                	mov    %eax,%edi
     92a:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
     930:	83 ec 10             	sub    $0x10,%esp
     933:	85 c0                	test   %eax,%eax
     935:	75 a9                	jne    8e0 <_flush+0x180>
                                     transbuf, (ulg)(q-transbuf), 0))
                                return PK_OK;
                            q = transbuf;
                        }
                        PutNativeEOL
     937:	c6 07 0d             	movb   $0xd,(%edi)
     93a:	c6 47 01 0a          	movb   $0xa,0x1(%edi)
                        G.VMS_line_state = G.VMS_line_pad ? 4 : 0;
     93e:	8b 85 6c 0b 01 00    	mov    0x10b6c(%ebp),%eax
     944:	ba 04 00 00 00       	mov    $0x4,%edx
     949:	85 c0                	test   %eax,%eax
     94b:	0f 45 c2             	cmovne %edx,%eax
     94e:	89 85 68 0b 01 00    	mov    %eax,0x10b68(%ebp)
                            else if (uO.cflag && (*G.message)((zvoid *)&G,
                                     transbuf, (ulg)(q-transbuf), 0))
                                return PK_OK;
                            q = transbuf;
                        }
                        PutNativeEOL
     954:	83 c7 02             	add    $0x2,%edi
                        G.VMS_line_state = G.VMS_line_pad ? 4 : 0;
                        break;
     957:	e9 1b ff ff ff       	jmp    877 <_flush+0x117>
     95c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                        break;

                    /* 2: ready to read VMS_line_length chars */
                    case 2:
                        {
                            extent remaining = (extent)size+(rawbuf-p);
     960:	89 f0                	mov    %esi,%eax
     962:	8b 94 24 88 00 00 00 	mov    0x88(%esp),%edx
     969:	29 d8                	sub    %ebx,%eax
     96b:	01 d0                	add    %edx,%eax
     96d:	89 c1                	mov    %eax,%ecx
                            extent outroom;

                            if (G.VMS_line_length < remaining) {
     96f:	8b 85 64 0b 01 00    	mov    0x10b64(%ebp),%eax
     975:	39 c1                	cmp    %eax,%ecx
     977:	76 0c                	jbe    985 <_flush+0x225>
                                remaining = G.VMS_line_length;
                                G.VMS_line_state = 3;
     979:	c7 85 68 0b 01 00 03 	movl   $0x3,0x10b68(%ebp)
     980:	00 00 00 
     983:	89 c1                	mov    %eax,%ecx
                            }

                            outroom = transbuf+(extent)transbufsiz-q;
     985:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     989:	89 7c 24 30          	mov    %edi,0x30(%esp)
     98d:	03 54 24 38          	add    0x38(%esp),%edx
     991:	89 54 24 34          	mov    %edx,0x34(%esp)
     995:	29 fa                	sub    %edi,%edx
                            if (remaining >= outroom) {
     997:	39 d1                	cmp    %edx,%ecx
     999:	72 7e                	jb     a19 <_flush+0x2b9>
                                remaining -= outroom;
     99b:	29 d1                	sub    %edx,%ecx
                                for (;outroom > 0; p++, outroom--)
     99d:	85 d2                	test   %edx,%edx
     99f:	74 1f                	je     9c0 <_flush+0x260>
     9a1:	31 c0                	xor    %eax,%eax
     9a3:	89 4c 24 30          	mov    %ecx,0x30(%esp)
                                    *q++ = native(*p);
     9a7:	8a 0c 03             	mov    (%ebx,%eax,1),%cl
     9aa:	88 0c 07             	mov    %cl,(%edi,%eax,1)
     9ad:	40                   	inc    %eax
                            }

                            outroom = transbuf+(extent)transbufsiz-q;
                            if (remaining >= outroom) {
                                remaining -= outroom;
                                for (;outroom > 0; p++, outroom--)
     9ae:	39 c2                	cmp    %eax,%edx
     9b0:	75 f5                	jne    9a7 <_flush+0x247>
     9b2:	8b 44 24 34          	mov    0x34(%esp),%eax
     9b6:	8b 4c 24 30          	mov    0x30(%esp),%ecx
     9ba:	01 d3                	add    %edx,%ebx
     9bc:	89 44 24 30          	mov    %eax,0x30(%esp)
                                    *q++ = native(*p);
#ifdef DLL
                                if (G.redirect_data) {
     9c0:	8b 85 a0 00 00 00    	mov    0xa0(%ebp),%eax
     9c6:	85 c0                	test   %eax,%eax
     9c8:	0f 85 c2 01 00 00    	jne    b90 <_flush+0x430>
                                    if (writeToMemory(__G__ transbuf,
                                          (extent)(q-transbuf))) return PK_ERR;
                                } else
#endif
                                if (!uO.cflag && WriteError(transbuf,
     9ce:	8b 45 14             	mov    0x14(%ebp),%eax
     9d1:	85 c0                	test   %eax,%eax
     9d3:	0f 84 17 02 00 00    	je     bf0 <_flush+0x490>
                                    (extent)(q-transbuf), G.outfile))
                                    return disk_error(__G);
                                else if (uO.cflag && (*G.message)((zvoid *)&G,
                                         transbuf, (ulg)(q-transbuf), 0))
     9d9:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
     9dd:	8b 44 24 30          	mov    0x30(%esp),%eax
     9e1:	29 f8                	sub    %edi,%eax
                                } else
#endif
                                if (!uO.cflag && WriteError(transbuf,
                                    (extent)(q-transbuf), G.outfile))
                                    return disk_error(__G);
                                else if (uO.cflag && (*G.message)((zvoid *)&G,
     9e3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     9ea:	00 
     9eb:	89 44 24 08          	mov    %eax,0x8(%esp)
     9ef:	89 7c 24 04          	mov    %edi,0x4(%esp)
     9f3:	89 2c 24             	mov    %ebp,(%esp)
     9f6:	89 4c 24 34          	mov    %ecx,0x34(%esp)
     9fa:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
     a00:	83 ec 10             	sub    $0x10,%esp
     a03:	85 c0                	test   %eax,%eax
     a05:	8b 4c 24 34          	mov    0x34(%esp),%ecx
     a09:	0f 85 d1 fe ff ff    	jne    8e0 <_flush+0x180>
     a0f:	8b 85 64 0b 01 00    	mov    0x10b64(%ebp),%eax
     a15:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
                                         transbuf, (ulg)(q-transbuf), 0))
                                    return PK_OK;
                                q = transbuf;
                                /* fall through to normal case */
                            }
                            G.VMS_line_length -= remaining;
     a19:	29 c8                	sub    %ecx,%eax
                            for (;remaining > 0; p++, remaining--)
     a1b:	85 c9                	test   %ecx,%ecx
                                         transbuf, (ulg)(q-transbuf), 0))
                                    return PK_OK;
                                q = transbuf;
                                /* fall through to normal case */
                            }
                            G.VMS_line_length -= remaining;
     a1d:	89 85 64 0b 01 00    	mov    %eax,0x10b64(%ebp)
                            for (;remaining > 0; p++, remaining--)
     a23:	0f 84 4e fe ff ff    	je     877 <_flush+0x117>
     a29:	8d 14 0b             	lea    (%ebx,%ecx,1),%edx
     a2c:	89 f8                	mov    %edi,%eax
     a2e:	89 4c 24 30          	mov    %ecx,0x30(%esp)
                                *q++ = native(*p);
     a32:	40                   	inc    %eax
     a33:	8a 0b                	mov    (%ebx),%cl
                                    return PK_OK;
                                q = transbuf;
                                /* fall through to normal case */
                            }
                            G.VMS_line_length -= remaining;
                            for (;remaining > 0; p++, remaining--)
     a35:	43                   	inc    %ebx
                                *q++ = native(*p);
     a36:	88 48 ff             	mov    %cl,-0x1(%eax)
                                    return PK_OK;
                                q = transbuf;
                                /* fall through to normal case */
                            }
                            G.VMS_line_length -= remaining;
                            for (;remaining > 0; p++, remaining--)
     a39:	39 d3                	cmp    %edx,%ebx
     a3b:	75 f5                	jne    a32 <_flush+0x2d2>
     a3d:	8b 4c 24 30          	mov    0x30(%esp),%ecx
     a41:	01 cf                	add    %ecx,%edi
     a43:	e9 2f fe ff ff       	jmp    877 <_flush+0x117>
                               ((G.VMS_line_length & 1) != 0); /* odd */
                        break;

                    /* 1: read one byte of length, need second */
                    case 1:
                        G.VMS_line_length += ((unsigned)(*p++) << 8);
     a48:	31 c0                	xor    %eax,%eax
     a4a:	8b 8d 64 0b 01 00    	mov    0x10b64(%ebp),%ecx
     a50:	8a 03                	mov    (%ebx),%al
                        G.VMS_line_state = 2;
     a52:	c7 85 68 0b 01 00 02 	movl   $0x2,0x10b68(%ebp)
     a59:	00 00 00 
                               ((G.VMS_line_length & 1) != 0); /* odd */
                        break;

                    /* 1: read one byte of length, need second */
                    case 1:
                        G.VMS_line_length += ((unsigned)(*p++) << 8);
     a5c:	c1 e0 08             	shl    $0x8,%eax
     a5f:	43                   	inc    %ebx
     a60:	01 c1                	add    %eax,%ecx
     a62:	89 8d 64 0b 01 00    	mov    %ecx,0x10b64(%ebp)
                        G.VMS_line_state = 2;
                        break;
     a68:	e9 0a fe ff ff       	jmp    877 <_flush+0x117>
     a6d:	8d 76 00             	lea    0x0(%esi),%esi
                        G.VMS_line_state = G.VMS_line_pad ? 4 : 0;
                        break;

                    /* 4: ready to read pad byte */
                    case 4:
                        ++p;
     a70:	43                   	inc    %ebx
                        G.VMS_line_state = 0;
     a71:	c7 85 68 0b 01 00 00 	movl   $0x0,0x10b68(%ebp)
     a78:	00 00 00 
                        break;
     a7b:	e9 f7 fd ff ff       	jmp    877 <_flush+0x117>
                switch (G.VMS_line_state) {

                    /* 0: ready to read line length */
                    case 0:
                        G.VMS_line_length = 0;
                        if ((extent)(p-rawbuf) == (extent)size-1) {
     a80:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
            while ((extent)(p-rawbuf) < (extent)size) {
                switch (G.VMS_line_state) {

                    /* 0: ready to read line length */
                    case 0:
                        G.VMS_line_length = 0;
     a87:	c7 85 64 0b 01 00 00 	movl   $0x0,0x10b64(%ebp)
     a8e:	00 00 00 
                        if ((extent)(p-rawbuf) == (extent)size-1) {
     a91:	8d 51 ff             	lea    -0x1(%ecx),%edx
     a94:	39 c2                	cmp    %eax,%edx
     a96:	0f 84 84 00 00 00    	je     b20 <_flush+0x3c0>
{
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
     a9c:	31 c0                	xor    %eax,%eax
     a9e:	31 d2                	xor    %edx,%edx
     aa0:	8a 43 01             	mov    0x1(%ebx),%al
     aa3:	8a 13                	mov    (%ebx),%dl
     aa5:	c1 e0 08             	shl    $0x8,%eax
                        if ((extent)(p-rawbuf) == (extent)size-1) {
                            /* last char */
                            G.VMS_line_length = (unsigned)(*p++);
                            G.VMS_line_state = 1;
                        } else {
                            G.VMS_line_length = makeword(p);
     aa8:	31 c9                	xor    %ecx,%ecx
{
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
     aaa:	09 d0                	or     %edx,%eax
                            /* last char */
                            G.VMS_line_length = (unsigned)(*p++);
                            G.VMS_line_state = 1;
                        } else {
                            G.VMS_line_length = makeword(p);
                            p += 2;
     aac:	83 c3 02             	add    $0x2,%ebx
                        if ((extent)(p-rawbuf) == (extent)size-1) {
                            /* last char */
                            G.VMS_line_length = (unsigned)(*p++);
                            G.VMS_line_state = 1;
                        } else {
                            G.VMS_line_length = makeword(p);
     aaf:	66 89 c1             	mov    %ax,%cx
                            p += 2;
                            G.VMS_line_state = 2;
     ab2:	c7 85 68 0b 01 00 02 	movl   $0x2,0x10b68(%ebp)
     ab9:	00 00 00 
                        if ((extent)(p-rawbuf) == (extent)size-1) {
                            /* last char */
                            G.VMS_line_length = (unsigned)(*p++);
                            G.VMS_line_state = 1;
                        } else {
                            G.VMS_line_length = makeword(p);
     abc:	89 8d 64 0b 01 00    	mov    %ecx,0x10b64(%ebp)
                            p += 2;
                            G.VMS_line_state = 2;
                        }
                        G.VMS_line_pad =
                               ((G.VMS_line_length & 1) != 0); /* odd */
     ac2:	89 c8                	mov    %ecx,%eax
     ac4:	83 e0 01             	and    $0x1,%eax
     ac7:	89 85 6c 0b 01 00    	mov    %eax,0x10b6c(%ebp)
                        break;
     acd:	e9 a5 fd ff ff       	jmp    877 <_flush+0x117>
         * on 16-bit systems but does make it more of a pain; however, because
         * at least MSC 5.1 has a lousy implementation of fwrite() (as does
         * DEC Ultrix cc), write() is used anyway.
         */
#ifdef DLL
        if (G.redirect_data) {
     ad2:	8b 95 a0 00 00 00    	mov    0xa0(%ebp),%edx
     ad8:	85 d2                	test   %edx,%edx
     ada:	0f 85 d1 02 00 00    	jne    db1 <_flush+0x651>
#else
            writeToMemory(__G__ rawbuf, (extent)size);
#endif
        } else
#endif
        if (!uO.cflag && WriteError(rawbuf, size, G.outfile))
     ae0:	8b 45 14             	mov    0x14(%ebp),%eax
     ae3:	85 c0                	test   %eax,%eax
     ae5:	0f 84 71 02 00 00    	je     d5c <_flush+0x5fc>
            return disk_error(__G);
        else if (uO.cflag && (*G.message)((zvoid *)&G, rawbuf, size, 0))
     aeb:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
     af2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     af9:	00 
     afa:	89 44 24 08          	mov    %eax,0x8(%esp)
     afe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     b02:	89 2c 24             	mov    %ebp,(%esp)
     b05:	89 54 24 2c          	mov    %edx,0x2c(%esp)
     b09:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
     b0f:	83 ec 10             	sub    $0x10,%esp
     b12:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     b16:	e9 bc fc ff ff       	jmp    7d7 <_flush+0x77>
     b1b:	90                   	nop
     b1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                    /* 0: ready to read line length */
                    case 0:
                        G.VMS_line_length = 0;
                        if ((extent)(p-rawbuf) == (extent)size-1) {
                            /* last char */
                            G.VMS_line_length = (unsigned)(*p++);
     b20:	31 c9                	xor    %ecx,%ecx
     b22:	43                   	inc    %ebx
     b23:	8a 4b ff             	mov    -0x1(%ebx),%cl
                            G.VMS_line_state = 1;
     b26:	c7 85 68 0b 01 00 01 	movl   $0x1,0x10b68(%ebp)
     b2d:	00 00 00 
                    /* 0: ready to read line length */
                    case 0:
                        G.VMS_line_length = 0;
                        if ((extent)(p-rawbuf) == (extent)size-1) {
                            /* last char */
                            G.VMS_line_length = (unsigned)(*p++);
     b30:	89 8d 64 0b 01 00    	mov    %ecx,0x10b64(%ebp)
     b36:	eb 8a                	jmp    ac2 <_flush+0x362>
        Done translating:  write whatever we've got to file (or screen).
      -----------------------------------------------------------------------*/

        Trace((stderr, "p - rawbuf = %u   q-transbuf = %u   size = %lu\n",
          (unsigned)(p-rawbuf), (unsigned)(q-transbuf), size));
        if (q > transbuf) {
     b38:	3b 7c 24 2c          	cmp    0x2c(%esp),%edi
     b3c:	0f 86 9e fd ff ff    	jbe    8e0 <_flush+0x180>
#ifdef DLL
            if (G.redirect_data) {
     b42:	8b 95 a0 00 00 00    	mov    0xa0(%ebp),%edx
     b48:	85 d2                	test   %edx,%edx
     b4a:	0f 85 7f 02 00 00    	jne    dcf <_flush+0x66f>
                if (writeToMemory(__G__ transbuf, (extent)(q-transbuf)))
                    return PK_ERR;
            } else
#endif
            if (!uO.cflag && WriteError(transbuf, (extent)(q-transbuf),
     b50:	8b 4d 14             	mov    0x14(%ebp),%ecx
     b53:	85 c9                	test   %ecx,%ecx
     b55:	0f 84 43 fd ff ff    	je     89e <_flush+0x13e>
                G.outfile))
                return disk_error(__G);
            else if (uO.cflag && (*G.message)((zvoid *)&G, transbuf,
                (ulg)(q-transbuf), 0))
     b5b:	8b 44 24 2c          	mov    0x2c(%esp),%eax
            } else
#endif
            if (!uO.cflag && WriteError(transbuf, (extent)(q-transbuf),
                G.outfile))
                return disk_error(__G);
            else if (uO.cflag && (*G.message)((zvoid *)&G, transbuf,
     b5f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     b66:	00 
                (ulg)(q-transbuf), 0))
     b67:	29 c7                	sub    %eax,%edi
            } else
#endif
            if (!uO.cflag && WriteError(transbuf, (extent)(q-transbuf),
                G.outfile))
                return disk_error(__G);
            else if (uO.cflag && (*G.message)((zvoid *)&G, transbuf,
     b69:	89 44 24 04          	mov    %eax,0x4(%esp)
     b6d:	89 7c 24 08          	mov    %edi,0x8(%esp)
     b71:	89 2c 24             	mov    %ebp,(%esp)
     b74:	89 54 24 30          	mov    %edx,0x30(%esp)
     b78:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
     b7e:	83 ec 10             	sub    $0x10,%esp
     b81:	8b 54 24 30          	mov    0x30(%esp),%edx
     b85:	e9 4d fc ff ff       	jmp    7d7 <_flush+0x77>
     b8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                                for (;outroom > 0; p++, outroom--)
                                    *q++ = native(*p);
#ifdef DLL
                                if (G.redirect_data) {
                                    if (writeToMemory(__G__ transbuf,
                                          (extent)(q-transbuf))) return PK_ERR;
     b90:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
     b94:	8b 44 24 30          	mov    0x30(%esp),%eax
     b98:	29 f8                	sub    %edi,%eax
                                remaining -= outroom;
                                for (;outroom > 0; p++, outroom--)
                                    *q++ = native(*p);
#ifdef DLL
                                if (G.redirect_data) {
                                    if (writeToMemory(__G__ transbuf,
     b9a:	89 7c 24 04          	mov    %edi,0x4(%esp)
     b9e:	89 44 24 08          	mov    %eax,0x8(%esp)
     ba2:	89 2c 24             	mov    %ebp,(%esp)
     ba5:	89 4c 24 34          	mov    %ecx,0x34(%esp)
     ba9:	e8 00 00 00 00       	call   bae <_flush+0x44e>
     bae:	85 c0                	test   %eax,%eax
     bb0:	75 2f                	jne    be1 <_flush+0x481>
     bb2:	8b 85 64 0b 01 00    	mov    0x10b64(%ebp),%eax
     bb8:	8b 4c 24 34          	mov    0x34(%esp),%ecx
     bbc:	e9 58 fe ff ff       	jmp    a19 <_flush+0x2b9>
                    case 3:
                        if (q > transbuf+(extent)transbufsiz-lenEOL) {
#ifdef DLL
                            if (G.redirect_data) {
                                if (writeToMemory(__G__ transbuf,
                                      (extent)(q-transbuf))) return PK_ERR;
     bc1:	8b 44 24 2c          	mov    0x2c(%esp),%eax
                    /* 3: ready to PutNativeEOL */
                    case 3:
                        if (q > transbuf+(extent)transbufsiz-lenEOL) {
#ifdef DLL
                            if (G.redirect_data) {
                                if (writeToMemory(__G__ transbuf,
     bc5:	89 2c 24             	mov    %ebp,(%esp)
                                      (extent)(q-transbuf))) return PK_ERR;
     bc8:	29 c7                	sub    %eax,%edi
                    /* 3: ready to PutNativeEOL */
                    case 3:
                        if (q > transbuf+(extent)transbufsiz-lenEOL) {
#ifdef DLL
                            if (G.redirect_data) {
                                if (writeToMemory(__G__ transbuf,
     bca:	89 44 24 04          	mov    %eax,0x4(%esp)
     bce:	89 7c 24 08          	mov    %edi,0x8(%esp)
     bd2:	89 c7                	mov    %eax,%edi
     bd4:	e8 00 00 00 00       	call   bd9 <_flush+0x479>
     bd9:	85 c0                	test   %eax,%eax
     bdb:	0f 84 56 fd ff ff    	je     937 <_flush+0x1d7>
                                for (;outroom > 0; p++, outroom--)
                                    *q++ = native(*p);
#ifdef DLL
                                if (G.redirect_data) {
                                    if (writeToMemory(__G__ transbuf,
                                          (extent)(q-transbuf))) return PK_ERR;
     be1:	ba 02 00 00 00       	mov    $0x2,%edx
     be6:	e9 ec fb ff ff       	jmp    7d7 <_flush+0x77>
     beb:	90                   	nop
     bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                                } else
#endif
                                if (!uO.cflag && WriteError(transbuf,
     bf0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     bf4:	8b 7c 24 30          	mov    0x30(%esp),%edi
     bf8:	29 c7                	sub    %eax,%edi
     bfa:	89 44 24 0c          	mov    %eax,0xc(%esp)
     bfe:	89 7c 24 08          	mov    %edi,0x8(%esp)
     c02:	89 4c 24 34          	mov    %ecx,0x34(%esp)
     c06:	8b 85 c8 09 01 00    	mov    0x109c8(%ebp),%eax
     c0c:	89 2c 24             	mov    %ebp,(%esp)
     c0f:	89 44 24 04          	mov    %eax,0x4(%esp)
     c13:	e8 00 00 00 00       	call   c18 <_flush+0x4b8>
     c18:	8b 4c 24 34          	mov    0x34(%esp),%ecx
     c1c:	39 c7                	cmp    %eax,%edi
     c1e:	0f 85 d0 01 00 00    	jne    df4 <_flush+0x694>
                                    (extent)(q-transbuf), G.outfile))
                                    return disk_error(__G);
                                else if (uO.cflag && (*G.message)((zvoid *)&G,
     c24:	8b 45 14             	mov    0x14(%ebp),%eax
     c27:	85 c0                	test   %eax,%eax
     c29:	0f 84 e0 fd ff ff    	je     a0f <_flush+0x2af>
     c2f:	e9 a5 fd ff ff       	jmp    9d9 <_flush+0x279>
                                if (writeToMemory(__G__ transbuf,
                                      (extent)(q-transbuf))) return PK_ERR;
                            } else
#endif
                            if (!uO.cflag &&
                                WriteError(transbuf, (extent)(q-transbuf),
     c34:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     c38:	89 fa                	mov    %edi,%edx
     c3a:	29 c2                	sub    %eax,%edx
     c3c:	89 44 24 0c          	mov    %eax,0xc(%esp)
     c40:	89 54 24 08          	mov    %edx,0x8(%esp)
     c44:	89 54 24 30          	mov    %edx,0x30(%esp)
     c48:	8b 85 c8 09 01 00    	mov    0x109c8(%ebp),%eax
     c4e:	89 2c 24             	mov    %ebp,(%esp)
     c51:	89 44 24 04          	mov    %eax,0x4(%esp)
     c55:	e8 00 00 00 00       	call   c5a <_flush+0x4fa>
                            if (G.redirect_data) {
                                if (writeToMemory(__G__ transbuf,
                                      (extent)(q-transbuf))) return PK_ERR;
                            } else
#endif
                            if (!uO.cflag &&
     c5a:	8b 54 24 30          	mov    0x30(%esp),%edx
     c5e:	39 c2                	cmp    %eax,%edx
     c60:	0f 85 8e 01 00 00    	jne    df4 <_flush+0x694>
                                WriteError(transbuf, (extent)(q-transbuf),
                                  G.outfile))
                                return disk_error(__G);
                            else if (uO.cflag && (*G.message)((zvoid *)&G,
     c66:	8b 45 14             	mov    0x14(%ebp),%eax
     c69:	85 c0                	test   %eax,%eax
     c6b:	0f 85 9e fc ff ff    	jne    90f <_flush+0x1af>
     c71:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
     c75:	e9 bd fc ff ff       	jmp    937 <_flush+0x1d7>
#if (defined(SMALL_MEM) || defined(MED_MEM) || defined(VMS_TEXT_CONV))
            transbufsiz = TRANSBUFSIZ;
#endif
        } else {
            /* rawbuf = slide */
            transbuf = G.outbuf;
     c7a:	8b b5 cc 09 01 00    	mov    0x109cc(%ebp),%esi
#if (defined(SMALL_MEM) || defined(MED_MEM) || defined(VMS_TEXT_CONV))
            transbufsiz = OUTBUFSIZ;
     c80:	c7 44 24 38 00 00 02 	movl   $0x20000,0x38(%esp)
     c87:	00 
#if (defined(SMALL_MEM) || defined(MED_MEM) || defined(VMS_TEXT_CONV))
            transbufsiz = TRANSBUFSIZ;
#endif
        } else {
            /* rawbuf = slide */
            transbuf = G.outbuf;
     c88:	89 74 24 2c          	mov    %esi,0x2c(%esp)
     c8c:	e9 ae fb ff ff       	jmp    83f <_flush+0xdf>
                   (unsigned)OUTBUFSIZ));
#endif
        }
        if (G.newfile) {
#ifdef VMS_TEXT_CONV
            if (G.pInfo->hostnum == VMS_ && G.extra_field &&
     c91:	80 78 13 02          	cmpb   $0x2,0x13(%eax)
     c95:	0f 84 67 01 00 00    	je     e02 <_flush+0x6a2>
                is_vms_varlen_txt(__G__ G.extra_field,
                                  G.lrec.extra_field_length))
                G.VMS_line_state = 0;    /* 0: ready to read line length */
            else
                G.VMS_line_state = -1;   /* -1: don't treat as VMS text */
     c9b:	c7 85 68 0b 01 00 ff 	movl   $0xffffffff,0x10b68(%ebp)
     ca2:	ff ff ff 
     ca5:	c7 44 24 30 ff ff ff 	movl   $0xffffffff,0x30(%esp)
     cac:	ff 
#endif
            G.didCRlast = FALSE;         /* no previous buffers written */
     cad:	c7 85 b8 09 01 00 00 	movl   $0x0,0x109b8(%ebp)
     cb4:	00 00 00 
            G.newfile = FALSE;
     cb7:	c7 85 b4 09 01 00 00 	movl   $0x0,0x109b4(%ebp)
     cbe:	00 00 00 
     cc1:	e9 91 fb ff ff       	jmp    857 <_flush+0xf7>
     cc6:	89 d9                	mov    %ebx,%ecx
        stream-oriented files, not record-oriented).
      -----------------------------------------------------------------------*/

        /* else not VMS text */ {
            p = rawbuf;
            if (*p == LF && G.didCRlast)
     cc8:	80 3b 0a             	cmpb   $0xa,(%ebx)
     ccb:	74 6e                	je     d3b <_flush+0x5db>
            G.didCRlast = FALSE;         /* no previous buffers written */
            G.newfile = FALSE;
        }

#ifdef VMS_TEXT_CONV
        if (G.VMS_line_state >= 0)
     ccd:	31 d2                	xor    %edx,%edx

        /* else not VMS text */ {
            p = rawbuf;
            if (*p == LF && G.didCRlast)
                ++p;
            G.didCRlast = FALSE;
     ccf:	c7 85 b8 09 01 00 00 	movl   $0x0,0x109b8(%ebp)
     cd6:	00 00 00 
            for (q = transbuf;  (extent)(p-rawbuf) < (extent)size;  ++p) {
     cd9:	39 94 24 88 00 00 00 	cmp    %edx,0x88(%esp)
     ce0:	0f 86 fa fb ff ff    	jbe    8e0 <_flush+0x180>
                if (*p == CR) {           /* lone CR or CR/LF: treat as EOL  */
                    PutNativeEOL
                    if ((extent)(p-rawbuf) == (extent)size-1)
     ce6:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
        /* else not VMS text */ {
            p = rawbuf;
            if (*p == LF && G.didCRlast)
                ++p;
            G.didCRlast = FALSE;
            for (q = transbuf;  (extent)(p-rawbuf) < (extent)size;  ++p) {
     ced:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
                if (*p == CR) {           /* lone CR or CR/LF: treat as EOL  */
                    PutNativeEOL
                    if ((extent)(p-rawbuf) == (extent)size-1)
     cf1:	8d 70 ff             	lea    -0x1(%eax),%esi
     cf4:	89 74 24 30          	mov    %esi,0x30(%esp)
     cf8:	89 c6                	mov    %eax,%esi
     cfa:	eb 18                	jmp    d14 <_flush+0x5b4>
     cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                        /* last char in buffer */
                        G.didCRlast = TRUE;
                    else if (p[1] == LF)  /* get rid of accompanying LF */
                        ++p;
                } else if (*p == LF)      /* lone LF */
     d00:	3c 0a                	cmp    $0xa,%al
     d02:	74 4c                	je     d50 <_flush+0x5f0>
                    PutNativeEOL
                else
#ifndef DOS_FLX_OS2_W32
                if (*p != CTRLZ)          /* lose all ^Z's */
#endif
                    *q++ = native(*p);
     d04:	88 07                	mov    %al,(%edi)
     d06:	47                   	inc    %edi
        /* else not VMS text */ {
            p = rawbuf;
            if (*p == LF && G.didCRlast)
                ++p;
            G.didCRlast = FALSE;
            for (q = transbuf;  (extent)(p-rawbuf) < (extent)size;  ++p) {
     d07:	43                   	inc    %ebx
     d08:	89 da                	mov    %ebx,%edx
     d0a:	29 ca                	sub    %ecx,%edx
     d0c:	39 d6                	cmp    %edx,%esi
     d0e:	0f 86 24 fe ff ff    	jbe    b38 <_flush+0x3d8>
                if (*p == CR) {           /* lone CR or CR/LF: treat as EOL  */
     d14:	8a 03                	mov    (%ebx),%al
     d16:	3c 0d                	cmp    $0xd,%al
     d18:	75 e6                	jne    d00 <_flush+0x5a0>
                    PutNativeEOL
     d1a:	c6 07 0d             	movb   $0xd,(%edi)
     d1d:	8d 47 02             	lea    0x2(%edi),%eax
     d20:	c6 47 01 0a          	movb   $0xa,0x1(%edi)
                    if ((extent)(p-rawbuf) == (extent)size-1)
     d24:	3b 54 24 30          	cmp    0x30(%esp),%edx
     d28:	74 76                	je     da0 <_flush+0x640>
                        /* last char in buffer */
                        G.didCRlast = TRUE;
                    else if (p[1] == LF)  /* get rid of accompanying LF */
     d2a:	80 7b 01 0a          	cmpb   $0xa,0x1(%ebx)
            if (*p == LF && G.didCRlast)
                ++p;
            G.didCRlast = FALSE;
            for (q = transbuf;  (extent)(p-rawbuf) < (extent)size;  ++p) {
                if (*p == CR) {           /* lone CR or CR/LF: treat as EOL  */
                    PutNativeEOL
     d2e:	89 c7                	mov    %eax,%edi
                    if ((extent)(p-rawbuf) == (extent)size-1)
                        /* last char in buffer */
                        G.didCRlast = TRUE;
                    else if (p[1] == LF)  /* get rid of accompanying LF */
                        ++p;
     d30:	0f 94 c0             	sete   %al
     d33:	31 d2                	xor    %edx,%edx
     d35:	88 c2                	mov    %al,%dl
     d37:	01 d3                	add    %edx,%ebx
     d39:	eb cc                	jmp    d07 <_flush+0x5a7>
        stream-oriented files, not record-oriented).
      -----------------------------------------------------------------------*/

        /* else not VMS text */ {
            p = rawbuf;
            if (*p == LF && G.didCRlast)
     d3b:	8b b5 b8 09 01 00    	mov    0x109b8(%ebp),%esi
     d41:	85 f6                	test   %esi,%esi
     d43:	74 88                	je     ccd <_flush+0x56d>
     d45:	ba 01 00 00 00       	mov    $0x1,%edx
                ++p;
     d4a:	43                   	inc    %ebx
     d4b:	eb 82                	jmp    ccf <_flush+0x56f>
     d4d:	8d 76 00             	lea    0x0(%esi),%esi
                        /* last char in buffer */
                        G.didCRlast = TRUE;
                    else if (p[1] == LF)  /* get rid of accompanying LF */
                        ++p;
                } else if (*p == LF)      /* lone LF */
                    PutNativeEOL
     d50:	c6 07 0d             	movb   $0xd,(%edi)
     d53:	c6 47 01 0a          	movb   $0xa,0x1(%edi)
     d57:	83 c7 02             	add    $0x2,%edi
     d5a:	eb ab                	jmp    d07 <_flush+0x5a7>
#else
            writeToMemory(__G__ rawbuf, (extent)size);
#endif
        } else
#endif
        if (!uO.cflag && WriteError(rawbuf, size, G.outfile))
     d5c:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
     d63:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
     d67:	89 44 24 08          	mov    %eax,0x8(%esp)
     d6b:	89 54 24 2c          	mov    %edx,0x2c(%esp)
     d6f:	8b 85 c8 09 01 00    	mov    0x109c8(%ebp),%eax
     d75:	89 2c 24             	mov    %ebp,(%esp)
     d78:	89 44 24 04          	mov    %eax,0x4(%esp)
     d7c:	e8 00 00 00 00       	call   d81 <_flush+0x621>
     d81:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     d85:	3b 84 24 88 00 00 00 	cmp    0x88(%esp),%eax
     d8c:	75 66                	jne    df4 <_flush+0x694>
            return disk_error(__G);
        else if (uO.cflag && (*G.message)((zvoid *)&G, rawbuf, size, 0))
     d8e:	8b 7d 14             	mov    0x14(%ebp),%edi
     d91:	85 ff                	test   %edi,%edi
     d93:	0f 85 52 fd ff ff    	jne    aeb <_flush+0x38b>
                (ulg)(q-transbuf), 0))
                return PK_OK;
        }
    }

    return PK_OK;
     d99:	31 d2                	xor    %edx,%edx
     d9b:	e9 42 fb ff ff       	jmp    8e2 <_flush+0x182>
            for (q = transbuf;  (extent)(p-rawbuf) < (extent)size;  ++p) {
                if (*p == CR) {           /* lone CR or CR/LF: treat as EOL  */
                    PutNativeEOL
                    if ((extent)(p-rawbuf) == (extent)size-1)
                        /* last char in buffer */
                        G.didCRlast = TRUE;
     da0:	c7 85 b8 09 01 00 01 	movl   $0x1,0x109b8(%ebp)
     da7:	00 00 00 
            if (*p == LF && G.didCRlast)
                ++p;
            G.didCRlast = FALSE;
            for (q = transbuf;  (extent)(p-rawbuf) < (extent)size;  ++p) {
                if (*p == CR) {           /* lone CR or CR/LF: treat as EOL  */
                    PutNativeEOL
     daa:	89 c7                	mov    %eax,%edi
     dac:	e9 56 ff ff ff       	jmp    d07 <_flush+0x5a7>
#ifdef DLL
        if (G.redirect_data) {
#ifdef NO_SLIDE_REDIR
            if (writeToMemory(__G__ rawbuf, (extent)size)) return PK_ERR;
#else
            writeToMemory(__G__ rawbuf, (extent)size);
     db1:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
     db8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     dbc:	89 44 24 08          	mov    %eax,0x8(%esp)
     dc0:	89 2c 24             	mov    %ebp,(%esp)
     dc3:	e8 00 00 00 00       	call   dc8 <_flush+0x668>
                (ulg)(q-transbuf), 0))
                return PK_OK;
        }
    }

    return PK_OK;
     dc8:	31 d2                	xor    %edx,%edx
     dca:	e9 13 fb ff ff       	jmp    8e2 <_flush+0x182>
        Trace((stderr, "p - rawbuf = %u   q-transbuf = %u   size = %lu\n",
          (unsigned)(p-rawbuf), (unsigned)(q-transbuf), size));
        if (q > transbuf) {
#ifdef DLL
            if (G.redirect_data) {
                if (writeToMemory(__G__ transbuf, (extent)(q-transbuf)))
     dcf:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     dd3:	89 2c 24             	mov    %ebp,(%esp)
     dd6:	29 c7                	sub    %eax,%edi
     dd8:	89 44 24 04          	mov    %eax,0x4(%esp)
     ddc:	89 7c 24 08          	mov    %edi,0x8(%esp)
     de0:	e8 00 00 00 00       	call   de5 <_flush+0x685>
     de5:	89 c2                	mov    %eax,%edx
     de7:	85 c0                	test   %eax,%eax
     de9:	0f 85 f2 fd ff ff    	jne    be1 <_flush+0x481>
     def:	e9 e3 f9 ff ff       	jmp    7d7 <_flush+0x77>
                    return PK_ERR;
            } else
#endif
            if (!uO.cflag && WriteError(transbuf, (extent)(q-transbuf),
                G.outfile))
                return disk_error(__G);
     df4:	89 e8                	mov    %ebp,%eax
     df6:	e8 05 f2 ff ff       	call   0 <_disk_error>
     dfb:	89 c2                	mov    %eax,%edx
     dfd:	e9 d5 f9 ff ff       	jmp    7d7 <_flush+0x77>
                   (unsigned)OUTBUFSIZ));
#endif
        }
        if (G.newfile) {
#ifdef VMS_TEXT_CONV
            if (G.pInfo->hostnum == VMS_ && G.extra_field &&
     e02:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
     e08:	89 c6                	mov    %eax,%esi
     e0a:	89 44 24 48          	mov    %eax,0x48(%esp)
     e0e:	85 c0                	test   %eax,%eax
     e10:	0f 84 85 fe ff ff    	je     c9b <_flush+0x53b>
                is_vms_varlen_txt(__G__ G.extra_field,
     e16:	31 c0                	xor    %eax,%eax
     e18:	66 8b 85 38 09 01 00 	mov    0x10938(%ebp),%ax
     e1f:	89 c7                	mov    %eax,%edi
#define VMS_FABSIG              0x42414656      /* "VFAB" */
/* offsets of interesting fields in VMS fabdef structure */
#define VMSFAB_B_RFM            31      /* record format byte */
#define VMSFAB_B_ORG            29      /* file organization byte */

    if (ef_len == 0 || ef_buf == NULL)
     e21:	85 c0                	test   %eax,%eax
#endif
        }
        if (G.newfile) {
#ifdef VMS_TEXT_CONV
            if (G.pInfo->hostnum == VMS_ && G.extra_field &&
                is_vms_varlen_txt(__G__ G.extra_field,
     e23:	89 7c 24 34          	mov    %edi,0x34(%esp)
#define VMS_FABSIG              0x42414656      /* "VFAB" */
/* offsets of interesting fields in VMS fabdef structure */
#define VMSFAB_B_RFM            31      /* record format byte */
#define VMSFAB_B_ORG            29      /* file organization byte */

    if (ef_len == 0 || ef_buf == NULL)
     e27:	0f 84 6e fe ff ff    	je     c9b <_flush+0x53b>
        return FALSE;

    while (ef_len >= EB_HEADSIZE) {
     e2d:	83 f8 03             	cmp    $0x3,%eax
     e30:	0f 86 65 fe ff ff    	jbe    c9b <_flush+0x53b>
{
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
     e36:	31 c0                	xor    %eax,%eax
     e38:	31 d2                	xor    %edx,%edx
     e3a:	8a 46 01             	mov    0x1(%esi),%al
     e3d:	8a 16                	mov    (%esi),%dl
     e3f:	c1 e0 08             	shl    $0x8,%eax
     e42:	31 c9                	xor    %ecx,%ecx
     e44:	09 d0                	or     %edx,%eax
     e46:	31 d2                	xor    %edx,%edx
     e48:	8a 56 03             	mov    0x3(%esi),%dl
     e4b:	8a 4e 02             	mov    0x2(%esi),%cl
     e4e:	c1 e2 08             	shl    $0x8,%edx
     e51:	09 ca                	or     %ecx,%edx
    if (ef_len == 0 || ef_buf == NULL)
        return FALSE;

    while (ef_len >= EB_HEADSIZE) {
        eb_id = makeword(EB_ID + ef_buf);
        eb_len = makeword(EB_LEN + ef_buf);
     e53:	89 d6                	mov    %edx,%esi

        if (eb_len > (ef_len - EB_HEADSIZE)) {
     e55:	8d 57 fc             	lea    -0x4(%edi),%edx
    if (ef_len == 0 || ef_buf == NULL)
        return FALSE;

    while (ef_len >= EB_HEADSIZE) {
        eb_id = makeword(EB_ID + ef_buf);
        eb_len = makeword(EB_LEN + ef_buf);
     e58:	81 e6 ff ff 00 00    	and    $0xffff,%esi
     e5e:	89 f1                	mov    %esi,%ecx
     e60:	89 74 24 3c          	mov    %esi,0x3c(%esp)

        if (eb_len > (ef_len - EB_HEADSIZE)) {
     e64:	39 d1                	cmp    %edx,%ecx
     e66:	0f 87 2f fe ff ff    	ja     c9b <_flush+0x53b>

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
            {
                Info(slide, 1, ((char *)slide,
     e6c:	8d b5 dc 08 00 00    	lea    0x8dc(%ebp),%esi
     e72:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
     e79:	89 74 24 44          	mov    %esi,0x44(%esp)
     e7d:	83 e6 01             	and    $0x1,%esi

    while (ef_len >= EB_HEADSIZE) {
        eb_id = makeword(EB_ID + ef_buf);
        eb_len = makeword(EB_LEN + ef_buf);

        if (eb_len > (ef_len - EB_HEADSIZE)) {
     e80:	c6 44 24 43 00       	movb   $0x0,0x43(%esp)

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
            {
                Info(slide, 1, ((char *)slide,
     e85:	89 74 24 4c          	mov    %esi,0x4c(%esp)
     e89:	89 ac 24 80 00 00 00 	mov    %ebp,0x80(%esp)
     e90:	8b 5c 24 48          	mov    0x48(%esp),%ebx
     e94:	e9 8c 00 00 00       	jmp    f25 <_flush+0x7c5>
              "is_vms_varlen_txt: block length %u > rest ef_size %u\n", eb_len,
              ef_len - EB_HEADSIZE));
            break;
        }

        switch (eb_id) {
     e99:	66 3d 49 4d          	cmp    $0x4d49,%ax
     e9d:	75 30                	jne    ecf <_flush+0x76f>
{
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
     e9f:	31 c0                	xor    %eax,%eax
     ea1:	8a 43 07             	mov    0x7(%ebx),%al
     ea4:	c1 e0 18             	shl    $0x18,%eax
     ea7:	89 c2                	mov    %eax,%edx
        + (((ulg)sig[2]) << 16)
     ea9:	31 c0                	xor    %eax,%eax
     eab:	8a 43 06             	mov    0x6(%ebx),%al
     eae:	c1 e0 10             	shl    $0x10,%eax
     eb1:	01 d0                	add    %edx,%eax
        + (((ulg)sig[1]) << 8)
        + ((ulg)sig[0]);
     eb3:	31 d2                	xor    %edx,%edx
     eb5:	8a 53 04             	mov    0x4(%ebx),%dl
     eb8:	01 c2                	add    %eax,%edx
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
        + (((ulg)sig[2]) << 16)
        + (((ulg)sig[1]) << 8)
     eba:	31 c0                	xor    %eax,%eax
     ebc:	8a 43 05             	mov    0x5(%ebx),%al
     ebf:	c1 e0 08             	shl    $0x8,%eax
{
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
     ec2:	01 d0                	add    %edx,%eax
                eb_data += fldsize + VMSPK_ITEMHEADSZ;
            }
            break;

          case EF_IZVMS:
            if (makelong(ef_buf+EB_HEADSIZE) == VMS_FABSIG) {
     ec4:	3d 56 46 41 42       	cmp    $0x42414656,%eax
     ec9:	0f 84 c5 01 00 00    	je     1094 <_flush+0x934>
          default:
            break;
        }

        /* Skip this extra field block */
        ef_buf += (eb_len + EB_HEADSIZE);
     ecf:	8b 74 24 3c          	mov    0x3c(%esp),%esi
     ed3:	8b 44 24 34          	mov    0x34(%esp),%eax
     ed7:	29 f0                	sub    %esi,%eax
        ef_len -= (eb_len + EB_HEADSIZE);
     ed9:	83 e8 04             	sub    $0x4,%eax
          default:
            break;
        }

        /* Skip this extra field block */
        ef_buf += (eb_len + EB_HEADSIZE);
     edc:	8d 5c 33 04          	lea    0x4(%ebx,%esi,1),%ebx
        ef_len -= (eb_len + EB_HEADSIZE);
     ee0:	89 44 24 34          	mov    %eax,0x34(%esp)
#define VMSFAB_B_ORG            29      /* file organization byte */

    if (ef_len == 0 || ef_buf == NULL)
        return FALSE;

    while (ef_len >= EB_HEADSIZE) {
     ee4:	83 f8 03             	cmp    $0x3,%eax
     ee7:	0f 86 7f 01 00 00    	jbe    106c <_flush+0x90c>
{
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
     eed:	31 c0                	xor    %eax,%eax
     eef:	31 d2                	xor    %edx,%edx
     ef1:	8a 43 01             	mov    0x1(%ebx),%al
     ef4:	8a 13                	mov    (%ebx),%dl
     ef6:	c1 e0 08             	shl    $0x8,%eax
     ef9:	31 c9                	xor    %ecx,%ecx
     efb:	09 d0                	or     %edx,%eax
     efd:	31 d2                	xor    %edx,%edx
     eff:	8a 53 03             	mov    0x3(%ebx),%dl
     f02:	8a 4b 02             	mov    0x2(%ebx),%cl
     f05:	c1 e2 08             	shl    $0x8,%edx
     f08:	09 ca                	or     %ecx,%edx

    while (ef_len >= EB_HEADSIZE) {
        eb_id = makeword(EB_ID + ef_buf);
        eb_len = makeword(EB_LEN + ef_buf);

        if (eb_len > (ef_len - EB_HEADSIZE)) {
     f0a:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    if (ef_len == 0 || ef_buf == NULL)
        return FALSE;

    while (ef_len >= EB_HEADSIZE) {
        eb_id = makeword(EB_ID + ef_buf);
        eb_len = makeword(EB_LEN + ef_buf);
     f0e:	89 d6                	mov    %edx,%esi
     f10:	81 e6 ff ff 00 00    	and    $0xffff,%esi

        if (eb_len > (ef_len - EB_HEADSIZE)) {
     f16:	8d 51 fc             	lea    -0x4(%ecx),%edx
    if (ef_len == 0 || ef_buf == NULL)
        return FALSE;

    while (ef_len >= EB_HEADSIZE) {
        eb_id = makeword(EB_ID + ef_buf);
        eb_len = makeword(EB_LEN + ef_buf);
     f19:	89 74 24 3c          	mov    %esi,0x3c(%esp)

        if (eb_len > (ef_len - EB_HEADSIZE)) {
     f1d:	39 d6                	cmp    %edx,%esi
     f1f:	0f 87 47 01 00 00    	ja     106c <_flush+0x90c>
              "is_vms_varlen_txt: block length %u > rest ef_size %u\n", eb_len,
              ef_len - EB_HEADSIZE));
            break;
        }

        switch (eb_id) {
     f25:	66 83 f8 0c          	cmp    $0xc,%ax
     f29:	0f 85 6a ff ff ff    	jne    e99 <_flush+0x739>
             *  - <size> bytes of actual attribute data
             */

            /* get pointer to start of data and its total length */
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;
     f2f:	8b 44 24 3c          	mov    0x3c(%esp),%eax
             *  - 2 bytes <size> of data
             *  - <size> bytes of actual attribute data
             */

            /* get pointer to start of data and its total length */
            eb_data = ef_buf+(EB_HEADSIZE+4);
     f33:	8d 73 08             	lea    0x8(%ebx),%esi
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
        + (((ulg)sig[2]) << 16)
        + (((ulg)sig[1]) << 8)
        + ((ulg)sig[0]);
     f36:	0f b6 7b 04          	movzbl 0x4(%ebx),%edi
             *  - <size> bytes of actual attribute data
             */

            /* get pointer to start of data and its total length */
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;
     f3a:	8d 50 fc             	lea    -0x4(%eax),%edx
{
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
     f3d:	31 c0                	xor    %eax,%eax
     f3f:	8a 43 07             	mov    0x7(%ebx),%al
        + (((ulg)sig[2]) << 16)
        + (((ulg)sig[1]) << 8)
        + ((ulg)sig[0]);
     f42:	81 e7 ff 00 00 00    	and    $0xff,%edi
{
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
     f48:	c1 e0 18             	shl    $0x18,%eax
             *  - <size> bytes of actual attribute data
             */

            /* get pointer to start of data and its total length */
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;
     f4b:	89 54 24 5c          	mov    %edx,0x5c(%esp)
{
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
     f4f:	89 c1                	mov    %eax,%ecx
        + (((ulg)sig[2]) << 16)
     f51:	31 c0                	xor    %eax,%eax
     f53:	8a 43 06             	mov    0x6(%ebx),%al
     f56:	c1 e0 10             	shl    $0x10,%eax
     f59:	01 c8                	add    %ecx,%eax
     f5b:	01 f8                	add    %edi,%eax
        + (((ulg)sig[1]) << 8)
     f5d:	0f b6 7b 05          	movzbl 0x5(%ebx),%edi
     f61:	81 e7 ff 00 00 00    	and    $0xff,%edi
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
     f67:	89 54 24 08          	mov    %edx,0x8(%esp)
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
        + (((ulg)sig[2]) << 16)
        + (((ulg)sig[1]) << 8)
     f6b:	89 f9                	mov    %edi,%ecx
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
     f6d:	89 74 24 04          	mov    %esi,0x4(%esp)
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
        + (((ulg)sig[2]) << 16)
        + (((ulg)sig[1]) << 8)
     f71:	c1 e1 08             	shl    $0x8,%ecx
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
     f74:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
{
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
     f7b:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
     f7e:	e8 00 00 00 00       	call   f83 <_flush+0x823>
            /* get pointer to start of data and its total length */
            eb_data = ef_buf+(EB_HEADSIZE+4);
            eb_datlen = eb_len-4;

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
     f83:	39 c7                	cmp    %eax,%edi
     f85:	75 64                	jne    feb <_flush+0x88b>
                /* skip over the data analysis code */
                break;
            }

            /* scan through the attribute data items */
            while (eb_datlen > 4)
     f87:	8b 7c 24 5c          	mov    0x5c(%esp),%edi
     f8b:	83 ff 04             	cmp    $0x4,%edi
     f8e:	0f 86 3b ff ff ff    	jbe    ecf <_flush+0x76f>
{
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
     f94:	31 c0                	xor    %eax,%eax
     f96:	31 d2                	xor    %edx,%edx
     f98:	8a 46 03             	mov    0x3(%esi),%al
     f9b:	8a 56 02             	mov    0x2(%esi),%dl
     f9e:	c1 e0 08             	shl    $0x8,%eax
            }

            /* scan through the attribute data items */
            while (eb_datlen > 4)
            {
                unsigned fldsize = makeword(&eb_data[VMSPK_ITEMLEN]);
     fa1:	31 c9                	xor    %ecx,%ecx
{
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
     fa3:	09 d0                	or     %edx,%eax
     fa5:	31 d2                	xor    %edx,%edx
     fa7:	0f b6 2e             	movzbl (%esi),%ebp
     faa:	8a 56 01             	mov    0x1(%esi),%dl
     fad:	81 e5 ff 00 00 00    	and    $0xff,%ebp
     fb3:	c1 e2 08             	shl    $0x8,%edx
            }

            /* scan through the attribute data items */
            while (eb_datlen > 4)
            {
                unsigned fldsize = makeword(&eb_data[VMSPK_ITEMLEN]);
     fb6:	66 89 c1             	mov    %ax,%cx
{
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
     fb9:	09 ea                	or     %ebp,%edx
            while (eb_datlen > 4)
            {
                unsigned fldsize = makeword(&eb_data[VMSPK_ITEMLEN]);

                /* check the item type word */
                switch (makeword(&eb_data[VMSPK_ITEMID])) {
     fbb:	66 83 fa 04          	cmp    $0x4,%dx
     fbf:	75 0f                	jne    fd0 <_flush+0x870>
                  case VMSATR_C_RECATTR:
                    /* we have found the (currently only) interesting
                     * data item */
                    if (fldsize >= 1) {
     fc1:	66 85 c0             	test   %ax,%ax
     fc4:	74 0a                	je     fd0 <_flush+0x870>
                        vms_rectype = eb_data[VMSPK_ITEMHEADSZ] & 15;
     fc6:	8a 46 04             	mov    0x4(%esi),%al
     fc9:	83 e0 0f             	and    $0xf,%eax
     fcc:	88 44 24 43          	mov    %al,0x43(%esp)
     fd0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
                  default:
                    break;
                }
                /* skip to next data item */
                eb_datlen -= fldsize + VMSPK_ITEMHEADSZ;
                eb_data += fldsize + VMSPK_ITEMHEADSZ;
     fd5:	8d 74 0e 04          	lea    0x4(%esi,%ecx,1),%esi
     fd9:	29 c8                	sub    %ecx,%eax
                    break;
                  default:
                    break;
                }
                /* skip to next data item */
                eb_datlen -= fldsize + VMSPK_ITEMHEADSZ;
     fdb:	01 c7                	add    %eax,%edi
     fdd:	89 7c 24 5c          	mov    %edi,0x5c(%esp)
                /* skip over the data analysis code */
                break;
            }

            /* scan through the attribute data items */
            while (eb_datlen > 4)
     fe1:	83 ff 04             	cmp    $0x4,%edi
     fe4:	77 ae                	ja     f94 <_flush+0x834>
     fe6:	e9 e4 fe ff ff       	jmp    ecf <_flush+0x76f>

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
            {
                Info(slide, 1, ((char *)slide,
     feb:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
     ff2:	8b 54 24 4c          	mov    0x4c(%esp),%edx
     ff6:	8b 7c 24 44          	mov    0x44(%esp),%edi
     ffa:	be 04 00 00 00       	mov    $0x4,%esi
     fff:	8b a8 44 0b 01 00    	mov    0x10b44(%eax),%ebp
    1005:	85 d2                	test   %edx,%edx
    1007:	b8 35 00 00 00       	mov    $0x35,%eax
    100c:	0f 85 f3 00 00 00    	jne    1105 <_flush+0x9a5>
    1012:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1018:	0f 85 d2 00 00 00    	jne    10f0 <_flush+0x990>
    101e:	89 c1                	mov    %eax,%ecx
    1020:	31 d2                	xor    %edx,%edx
    1022:	c1 e9 02             	shr    $0x2,%ecx
    1025:	a8 02                	test   $0x2,%al
    1027:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    1029:	74 0b                	je     1036 <_flush+0x8d6>
    102b:	66 8b 16             	mov    (%esi),%dx
    102e:	66 89 17             	mov    %dx,(%edi)
    1031:	ba 02 00 00 00       	mov    $0x2,%edx
    1036:	a8 01                	test   $0x1,%al
    1038:	74 06                	je     1040 <_flush+0x8e0>
    103a:	8a 04 16             	mov    (%esi,%edx,1),%al
    103d:	88 04 17             	mov    %al,(%edi,%edx,1)
    1040:	8b 44 24 44          	mov    0x44(%esp),%eax
    1044:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    104b:	00 
    104c:	89 44 24 04          	mov    %eax,0x4(%esp)
    1050:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    1057:	c7 44 24 08 34 00 00 	movl   $0x34,0x8(%esp)
    105e:	00 
    105f:	89 04 24             	mov    %eax,(%esp)
    1062:	ff d5                	call   *%ebp
    1064:	83 ec 10             	sub    $0x10,%esp
    1067:	e9 63 fe ff ff       	jmp    ecf <_flush+0x76f>
    106c:	8b ac 24 80 00 00 00 	mov    0x80(%esp),%ebp
    1073:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
                   (unsigned)OUTBUFSIZ));
#endif
        }
        if (G.newfile) {
#ifdef VMS_TEXT_CONV
            if (G.pInfo->hostnum == VMS_ && G.extra_field &&
    107a:	80 7c 24 43 02       	cmpb   $0x2,0x43(%esp)
    107f:	0f 85 16 fc ff ff    	jne    c9b <_flush+0x53b>
                is_vms_varlen_txt(__G__ G.extra_field,
                                  G.lrec.extra_field_length))
                G.VMS_line_state = 0;    /* 0: ready to read line length */
    1085:	c7 85 68 0b 01 00 00 	movl   $0x0,0x10b68(%ebp)
    108c:	00 00 00 
    108f:	e9 19 fc ff ff       	jmp    cad <_flush+0x54d>
            }
            break;

          case EF_IZVMS:
            if (makelong(ef_buf+EB_HEADSIZE) == VMS_FABSIG) {
                if ((eb_data = extract_izvms_block(__G__
    1094:	8d 44 24 5c          	lea    0x5c(%esp),%eax
    1098:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    109f:	00 
    10a0:	89 44 24 0c          	mov    %eax,0xc(%esp)
    10a4:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    10a8:	89 44 24 08          	mov    %eax,0x8(%esp)
    10ac:	8d 43 04             	lea    0x4(%ebx),%eax
    10af:	89 44 24 04          	mov    %eax,0x4(%esp)
    10b3:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    10ba:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    10c1:	00 
    10c2:	89 04 24             	mov    %eax,(%esp)
    10c5:	e8 00 00 00 00       	call   10ca <_flush+0x96a>
    10ca:	85 c0                	test   %eax,%eax
    10cc:	0f 84 fd fd ff ff    	je     ecf <_flush+0x76f>
                                                   ef_buf+EB_HEADSIZE, eb_len,
                                                   &eb_datlen, NULL, 0))
                    != NULL)
                {
                    if (eb_datlen >= VMSFAB_B_RFM+1) {
    10d2:	83 7c 24 5c 1f       	cmpl   $0x1f,0x5c(%esp)
    10d7:	76 0a                	jbe    10e3 <_flush+0x983>
                        vms_rectype = eb_data[VMSFAB_B_RFM] & 15;
    10d9:	8a 48 1f             	mov    0x1f(%eax),%cl
    10dc:	83 e1 0f             	and    $0xf,%ecx
    10df:	88 4c 24 43          	mov    %cl,0x43(%esp)
                        vms_fileorg = eb_data[VMSFAB_B_ORG] >> 4;
                    }
                    free(eb_data);
    10e3:	89 04 24             	mov    %eax,(%esp)
    10e6:	e8 00 00 00 00       	call   10eb <_flush+0x98b>
    10eb:	e9 df fd ff ff       	jmp    ecf <_flush+0x76f>

            /* test the CRC checksum */
            if (makelong(ef_buf+EB_HEADSIZE) !=
                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))
            {
                Info(slide, 1, ((char *)slide,
    10f0:	66 8b 16             	mov    (%esi),%dx
    10f3:	83 c7 02             	add    $0x2,%edi
    10f6:	66 89 57 fe          	mov    %dx,-0x2(%edi)
    10fa:	83 c6 02             	add    $0x2,%esi
    10fd:	83 e8 02             	sub    $0x2,%eax
    1100:	e9 19 ff ff ff       	jmp    101e <_flush+0x8be>
    1105:	a0 04 00 00 00       	mov    0x4,%al
    110a:	be 05 00 00 00       	mov    $0x5,%esi
    110f:	88 07                	mov    %al,(%edi)
    1111:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    1118:	8d b8 dd 08 00 00    	lea    0x8dd(%eax),%edi
    111e:	b8 34 00 00 00       	mov    $0x34,%eax
    1123:	e9 ea fe ff ff       	jmp    1012 <_flush+0x8b2>
    1128:	90                   	nop
    1129:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001130 <_UzpMessagePrnt@16>:
int UZ_EXP UzpMessagePrnt(pG, buf, size, flag)
    zvoid *pG;   /* globals struct:  always passed */
    uch *buf;    /* preformatted string to be printed */
    ulg size;    /* length of string (may include nulls) */
    int flag;    /* flag bits */
{
    1130:	55                   	push   %ebp
    1131:	57                   	push   %edi
    1132:	56                   	push   %esi
    1133:	53                   	push   %ebx
    1134:	83 ec 1c             	sub    $0x1c,%esp
#ifdef WINDLL
    if (MSG_NO_WDLL(flag))
        return 0;
#endif
#ifdef WINDLL
    if (MSG_NO_WGUI(flag))
    1137:	f7 44 24 3c 00 11 00 	testl  $0x1100,0x3c(%esp)
    113e:	00 
    113f:	0f 85 6c 01 00 00    	jne    12b1 <_UzpMessagePrnt@16+0x181>
    if (MSG_NO_AGUI(flag))
        return 0;
#endif
 */
#ifdef DLL                 /* don't display message if data is redirected */
    if (((Uz_Globs *)pG)->redirect_data &&
    1145:	8b 44 24 30          	mov    0x30(%esp),%eax
    1149:	8b 98 a0 00 00 00    	mov    0xa0(%eax),%ebx
    114f:	85 db                	test   %ebx,%ebx
    1151:	74 0e                	je     1161 <_UzpMessagePrnt@16+0x31>
    1153:	8b 88 a4 00 00 00    	mov    0xa4(%eax),%ecx
    1159:	85 c9                	test   %ecx,%ecx
    115b:	0f 84 50 01 00 00    	je     12b1 <_UzpMessagePrnt@16+0x181>
        !((Uz_Globs *)pG)->redirect_text)
        return 0;
#endif

    if (MSG_STDERR(flag) && !((Uz_Globs *)pG)->UzO.tflag)
    1161:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
    1165:	83 e5 01             	and    $0x1,%ebp
    1168:	0f 85 52 01 00 00    	jne    12c0 <_UzpMessagePrnt@16+0x190>
        outfp = (FILE *)stderr;
    else
        outfp = (FILE *)stdout;
    116e:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    1174:	8d 73 20             	lea    0x20(%ebx),%esi
     *    expansion of the __G__ macro in the REENTRANT case (see globals.h).
     *    This name identity is mandatory for the LoadFarString() macro
     *    (in the SMALL_MEM case) !!!
     */
    int error;
    uch *q=buf, *endbuf=buf+(unsigned)size;
    1177:	8b 7c 24 34          	mov    0x34(%esp),%edi
    117b:	8b 44 24 38          	mov    0x38(%esp),%eax
    117f:	01 c7                	add    %eax,%edi
        *endbuf++ = '\n';     /*  with room for one more char at end of buf */
        ++size;               /*  (safe assumption:  only used for four */
    }                         /*  short queries in extract.c and fileio.c) */
#endif

    if (MSG_TNEWLN(flag)) {   /* again assumes writable buffer:  fragile... */
    1181:	f6 44 24 3c 40       	testb  $0x40,0x3c(%esp)
    1186:	74 23                	je     11ab <_UzpMessagePrnt@16+0x7b>
        if ((!size && !((Uz_Globs *)pG)->sol) ||
    1188:	8b 44 24 38          	mov    0x38(%esp),%eax
    118c:	85 c0                	test   %eax,%eax
    118e:	0f 84 4c 01 00 00    	je     12e0 <_UzpMessagePrnt@16+0x1b0>
            (size && (endbuf[-1] != '\n')))
    1194:	80 7f ff 0a          	cmpb   $0xa,-0x1(%edi)
    1198:	0f 84 56 01 00 00    	je     12f4 <_UzpMessagePrnt@16+0x1c4>
        {
            *endbuf++ = '\n';
            ++size;
    119e:	8b 44 24 38          	mov    0x38(%esp),%eax

    if (MSG_TNEWLN(flag)) {   /* again assumes writable buffer:  fragile... */
        if ((!size && !((Uz_Globs *)pG)->sol) ||
            (size && (endbuf[-1] != '\n')))
        {
            *endbuf++ = '\n';
    11a2:	c6 07 0a             	movb   $0xa,(%edi)
            ++size;
    11a5:	40                   	inc    %eax

    if (MSG_TNEWLN(flag)) {   /* again assumes writable buffer:  fragile... */
        if ((!size && !((Uz_Globs *)pG)->sol) ||
            (size && (endbuf[-1] != '\n')))
        {
            *endbuf++ = '\n';
    11a6:	47                   	inc    %edi
            ++size;
    11a7:	89 44 24 38          	mov    %eax,0x38(%esp)
    ((Uz_Globs *)pG)->width = SCREENWIDTH;
#  endif
# endif
#endif /* MORE */

    if (MSG_LNEWLN(flag) && !((Uz_Globs *)pG)->sol) {
    11ab:	f6 44 24 3c 20       	testb  $0x20,0x3c(%esp)
    11b0:	0f 84 98 00 00 00    	je     124e <_UzpMessagePrnt@16+0x11e>
    11b6:	8b 44 24 30          	mov    0x30(%esp),%eax
    11ba:	8b 80 c0 09 01 00    	mov    0x109c0(%eax),%eax
    11c0:	85 c0                	test   %eax,%eax
    11c2:	0f 85 86 00 00 00    	jne    124e <_UzpMessagePrnt@16+0x11e>
    : _filbuf (__F);
}

__CRT_INLINE int __cdecl __MINGW_NOTHROW putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    11c8:	8b 46 04             	mov    0x4(%esi),%eax
    11cb:	48                   	dec    %eax
    ?  (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    :  _flsbuf (__c, __F);
    11cc:	89 46 04             	mov    %eax,0x4(%esi)
    11cf:	85 c0                	test   %eax,%eax
    11d1:	0f 88 3f 01 00 00    	js     1316 <_UzpMessagePrnt@16+0x1e6>
}

__CRT_INLINE int __cdecl __MINGW_NOTHROW putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    ?  (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    11d7:	8b 06                	mov    (%esi),%eax
    11d9:	8d 48 01             	lea    0x1(%eax),%ecx
    11dc:	89 0e                	mov    %ecx,(%esi)
    11de:	c6 00 0a             	movb   $0xa,(%eax)
        /* not at start of line:  want newline */
#ifdef OS2DLL
        if (!((Uz_Globs *)pG)->redirect_text) {
#endif
            putc('\n', outfp);
            fflush(outfp);
    11e1:	89 34 24             	mov    %esi,(%esp)
    11e4:	e8 00 00 00 00       	call   11e9 <_UzpMessagePrnt@16+0xb9>
                if (((Uz_Globs *)pG)->lines >= ((Uz_Globs *)pG)->height)
                    (*((Uz_Globs *)pG)->mpause)((zvoid *)pG,
                      LoadFarString(MorePrompt), 1);
            }
#endif /* MORE */
            if (MSG_STDERR(flag) && ((Uz_Globs *)pG)->UzO.tflag &&
    11e9:	85 ed                	test   %ebp,%ebp
    11eb:	74 53                	je     1240 <_UzpMessagePrnt@16+0x110>
    11ed:	8b 44 24 30          	mov    0x30(%esp),%eax
    11f1:	8b 40 44             	mov    0x44(%eax),%eax
    11f4:	85 c0                	test   %eax,%eax
    11f6:	74 48                	je     1240 <_UzpMessagePrnt@16+0x110>
                !isatty(1) && isatty(2))
    11f8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    11ff:	e8 00 00 00 00       	call   1204 <_UzpMessagePrnt@16+0xd4>
                if (((Uz_Globs *)pG)->lines >= ((Uz_Globs *)pG)->height)
                    (*((Uz_Globs *)pG)->mpause)((zvoid *)pG,
                      LoadFarString(MorePrompt), 1);
            }
#endif /* MORE */
            if (MSG_STDERR(flag) && ((Uz_Globs *)pG)->UzO.tflag &&
    1204:	85 c0                	test   %eax,%eax
    1206:	75 38                	jne    1240 <_UzpMessagePrnt@16+0x110>
                !isatty(1) && isatty(2))
    1208:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    120f:	e8 00 00 00 00       	call   1214 <_UzpMessagePrnt@16+0xe4>
    1214:	85 c0                	test   %eax,%eax
    1216:	74 28                	je     1240 <_UzpMessagePrnt@16+0x110>
    : _filbuf (__F);
}

__CRT_INLINE int __cdecl __MINGW_NOTHROW putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    1218:	8b 43 44             	mov    0x44(%ebx),%eax
    121b:	48                   	dec    %eax
    ?  (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    :  _flsbuf (__c, __F);
    121c:	89 43 44             	mov    %eax,0x44(%ebx)
    121f:	85 c0                	test   %eax,%eax
    1221:	0f 88 66 01 00 00    	js     138d <_UzpMessagePrnt@16+0x25d>
}

__CRT_INLINE int __cdecl __MINGW_NOTHROW putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    ?  (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    1227:	8b 43 40             	mov    0x40(%ebx),%eax
    122a:	8d 48 01             	lea    0x1(%eax),%ecx
    122d:	89 4b 40             	mov    %ecx,0x40(%ebx)
    1230:	c6 00 0a             	movb   $0xa,(%eax)
            {
                /* error output from testing redirected:  also send to stderr */
                putc('\n', stderr);
                fflush(stderr);
    1233:	8d 43 40             	lea    0x40(%ebx),%eax
    1236:	89 04 24             	mov    %eax,(%esp)
    1239:	e8 00 00 00 00       	call   123e <_UzpMessagePrnt@16+0x10e>
    123e:	66 90                	xchg   %ax,%ax
            }
#ifdef OS2DLL
        } else
           REDIRECTC('\n');
#endif
        ((Uz_Globs *)pG)->sol = TRUE;
    1240:	8b 44 24 30          	mov    0x30(%esp),%eax
    1244:	c7 80 c0 09 01 00 01 	movl   $0x1,0x109c0(%eax)
    124b:	00 00 00 
        } /* end while */
        size = (ulg)(p - q);   /* remaining text */
    }
#endif /* MORE */

    if (size) {
    124e:	8b 4c 24 38          	mov    0x38(%esp),%ecx
    1252:	85 c9                	test   %ecx,%ecx
    1254:	74 5b                	je     12b1 <_UzpMessagePrnt@16+0x181>
#ifdef OS2DLL
        if (!((Uz_Globs *)pG)->redirect_text) {
#endif
            if ((error = WriteError(q, size, outfp)) != 0)
    1256:	8b 44 24 34          	mov    0x34(%esp),%eax
    125a:	89 74 24 04          	mov    %esi,0x4(%esp)
    125e:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1262:	8b 44 24 38          	mov    0x38(%esp),%eax
    1266:	89 44 24 08          	mov    %eax,0x8(%esp)
    126a:	8b 44 24 30          	mov    0x30(%esp),%eax
    126e:	89 04 24             	mov    %eax,(%esp)
    1271:	e8 00 00 00 00       	call   1276 <_UzpMessagePrnt@16+0x146>
    1276:	3b 44 24 38          	cmp    0x38(%esp),%eax
    127a:	74 07                	je     1283 <_UzpMessagePrnt@16+0x153>

    if (MSG_TNEWLN(flag)) {   /* again assumes writable buffer:  fragile... */
        if ((!size && !((Uz_Globs *)pG)->sol) ||
            (size && (endbuf[-1] != '\n')))
        {
            *endbuf++ = '\n';
    127c:	b8 01 00 00 00       	mov    $0x1,%eax
    1281:	eb 30                	jmp    12b3 <_UzpMessagePrnt@16+0x183>
#ifdef OS2DLL
        if (!((Uz_Globs *)pG)->redirect_text) {
#endif
            if ((error = WriteError(q, size, outfp)) != 0)
                return error;
            fflush(outfp);
    1283:	89 34 24             	mov    %esi,(%esp)
    1286:	e8 00 00 00 00       	call   128b <_UzpMessagePrnt@16+0x15b>
            if (MSG_STDERR(flag) && ((Uz_Globs *)pG)->UzO.tflag &&
    128b:	85 ed                	test   %ebp,%ebp
    128d:	74 0f                	je     129e <_UzpMessagePrnt@16+0x16e>
    128f:	8b 44 24 30          	mov    0x30(%esp),%eax
    1293:	8b 50 44             	mov    0x44(%eax),%edx
    1296:	85 d2                	test   %edx,%edx
    1298:	0f 85 8d 00 00 00    	jne    132b <_UzpMessagePrnt@16+0x1fb>
        } else {                /* GRR:  this is ugly:  hide with macro */
            if ((error = REDIRECTPRINT(q, size)) != 0)
                return error;
        }
#endif /* OS2DLL */
        ((Uz_Globs *)pG)->sol = (endbuf[-1] == '\n');
    129e:	31 c0                	xor    %eax,%eax
    12a0:	8b 54 24 30          	mov    0x30(%esp),%edx
    12a4:	80 7f ff 0a          	cmpb   $0xa,-0x1(%edi)
    12a8:	0f 94 c0             	sete   %al
    12ab:	89 82 c0 09 01 00    	mov    %eax,0x109c0(%edx)
    }
    return 0;
    12b1:	31 c0                	xor    %eax,%eax

} /* end function UzpMessagePrnt() */
    12b3:	83 c4 1c             	add    $0x1c,%esp
    12b6:	5b                   	pop    %ebx
    12b7:	5e                   	pop    %esi
    12b8:	5f                   	pop    %edi
    12b9:	5d                   	pop    %ebp
    12ba:	c2 10 00             	ret    $0x10
    12bd:	8d 76 00             	lea    0x0(%esi),%esi
    if (((Uz_Globs *)pG)->redirect_data &&
        !((Uz_Globs *)pG)->redirect_text)
        return 0;
#endif

    if (MSG_STDERR(flag) && !((Uz_Globs *)pG)->UzO.tflag)
    12c0:	8b 44 24 30          	mov    0x30(%esp),%eax
        outfp = (FILE *)stderr;
    12c4:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    if (((Uz_Globs *)pG)->redirect_data &&
        !((Uz_Globs *)pG)->redirect_text)
        return 0;
#endif

    if (MSG_STDERR(flag) && !((Uz_Globs *)pG)->UzO.tflag)
    12ca:	8b 50 44             	mov    0x44(%eax),%edx
        outfp = (FILE *)stderr;
    12cd:	8d 73 40             	lea    0x40(%ebx),%esi
    if (((Uz_Globs *)pG)->redirect_data &&
        !((Uz_Globs *)pG)->redirect_text)
        return 0;
#endif

    if (MSG_STDERR(flag) && !((Uz_Globs *)pG)->UzO.tflag)
    12d0:	85 d2                	test   %edx,%edx
    12d2:	0f 84 9f fe ff ff    	je     1177 <_UzpMessagePrnt@16+0x47>
        outfp = (FILE *)stderr;
    else
        outfp = (FILE *)stdout;
    12d8:	8d 73 20             	lea    0x20(%ebx),%esi
    12db:	e9 97 fe ff ff       	jmp    1177 <_UzpMessagePrnt@16+0x47>
        ++size;               /*  (safe assumption:  only used for four */
    }                         /*  short queries in extract.c and fileio.c) */
#endif

    if (MSG_TNEWLN(flag)) {   /* again assumes writable buffer:  fragile... */
        if ((!size && !((Uz_Globs *)pG)->sol) ||
    12e0:	8b 44 24 30          	mov    0x30(%esp),%eax
    12e4:	8b 80 c0 09 01 00    	mov    0x109c0(%eax),%eax
    12ea:	85 c0                	test   %eax,%eax
    12ec:	0f 84 ac fe ff ff    	je     119e <_UzpMessagePrnt@16+0x6e>
    12f2:	eb bd                	jmp    12b1 <_UzpMessagePrnt@16+0x181>
    ((Uz_Globs *)pG)->width = SCREENWIDTH;
#  endif
# endif
#endif /* MORE */

    if (MSG_LNEWLN(flag) && !((Uz_Globs *)pG)->sol) {
    12f4:	f6 44 24 3c 20       	testb  $0x20,0x3c(%esp)
    12f9:	0f 84 57 ff ff ff    	je     1256 <_UzpMessagePrnt@16+0x126>
    12ff:	8b 44 24 30          	mov    0x30(%esp),%eax
    1303:	8b 80 c0 09 01 00    	mov    0x109c0(%eax),%eax
    1309:	85 c0                	test   %eax,%eax
    130b:	0f 84 b7 fe ff ff    	je     11c8 <_UzpMessagePrnt@16+0x98>
    1311:	e9 40 ff ff ff       	jmp    1256 <_UzpMessagePrnt@16+0x126>
    :  _flsbuf (__c, __F);
    1316:	89 74 24 04          	mov    %esi,0x4(%esp)
    131a:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
    1321:	e8 00 00 00 00       	call   1326 <_UzpMessagePrnt@16+0x1f6>
    1326:	e9 b6 fe ff ff       	jmp    11e1 <_UzpMessagePrnt@16+0xb1>
#endif
            if ((error = WriteError(q, size, outfp)) != 0)
                return error;
            fflush(outfp);
            if (MSG_STDERR(flag) && ((Uz_Globs *)pG)->UzO.tflag &&
                !isatty(1) && isatty(2))
    132b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    1332:	e8 00 00 00 00       	call   1337 <_UzpMessagePrnt@16+0x207>
        if (!((Uz_Globs *)pG)->redirect_text) {
#endif
            if ((error = WriteError(q, size, outfp)) != 0)
                return error;
            fflush(outfp);
            if (MSG_STDERR(flag) && ((Uz_Globs *)pG)->UzO.tflag &&
    1337:	85 c0                	test   %eax,%eax
    1339:	0f 85 5f ff ff ff    	jne    129e <_UzpMessagePrnt@16+0x16e>
                !isatty(1) && isatty(2))
    133f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    1346:	e8 00 00 00 00       	call   134b <_UzpMessagePrnt@16+0x21b>
    134b:	85 c0                	test   %eax,%eax
    134d:	0f 84 4b ff ff ff    	je     129e <_UzpMessagePrnt@16+0x16e>
            {
                /* error output from testing redirected:  also send to stderr */
                if ((error = WriteError(q, size, stderr)) != 0)
    1353:	8b 44 24 34          	mov    0x34(%esp),%eax
    1357:	8d 73 40             	lea    0x40(%ebx),%esi
    135a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    135e:	8b 44 24 38          	mov    0x38(%esp),%eax
    1362:	89 44 24 08          	mov    %eax,0x8(%esp)
    1366:	8b 44 24 30          	mov    0x30(%esp),%eax
    136a:	89 74 24 04          	mov    %esi,0x4(%esp)
    136e:	89 04 24             	mov    %eax,(%esp)
    1371:	e8 00 00 00 00       	call   1376 <_UzpMessagePrnt@16+0x246>
    1376:	39 44 24 38          	cmp    %eax,0x38(%esp)
    137a:	0f 85 fc fe ff ff    	jne    127c <_UzpMessagePrnt@16+0x14c>
                    return error;
                fflush(stderr);
    1380:	89 34 24             	mov    %esi,(%esp)
    1383:	e8 00 00 00 00       	call   1388 <_UzpMessagePrnt@16+0x258>
    1388:	e9 11 ff ff ff       	jmp    129e <_UzpMessagePrnt@16+0x16e>
    138d:	8d 43 40             	lea    0x40(%ebx),%eax
    1390:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
    1397:	89 44 24 04          	mov    %eax,0x4(%esp)
    139b:	e8 00 00 00 00       	call   13a0 <_UzpMessagePrnt@16+0x270>
    13a0:	e9 8e fe ff ff       	jmp    1233 <_UzpMessagePrnt@16+0x103>
    13a5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    13a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000013b0 <_UzpMessageNull@16>:
    ulg size;     /* length of string (may include nulls) */
    int flag;     /* flag bits */
{
    return 0;

} /* end function UzpMessageNull() */
    13b0:	31 c0                	xor    %eax,%eax
    13b2:	c2 10 00             	ret    $0x10
    13b5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    13b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000013c0 <_UzpInput@16>:
    int flag;     /* flag bits (bit 0: no echo) */
{
    /* tell picky compilers to shut up about "unused variable" warnings */
    pG = pG; buf = buf; flag = flag;

    *size = 0;
    13c0:	8b 44 24 0c          	mov    0xc(%esp),%eax
    13c4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    return 0;

} /* end function UzpInput() */
    13ca:	31 c0                	xor    %eax,%eax
    13cc:	c2 10 00             	ret    $0x10
    13cf:	90                   	nop

000013d0 <_dos_to_unix_time>:
/* Function dos_to_unix_time() */ /* used for freshening/updating/timestamps */
/*******************************/

time_t dos_to_unix_time(dosdatetime)
    ulg dosdatetime;
{
    13d0:	55                   	push   %ebp
    13d1:	57                   	push   %edi
    13d2:	56                   	push   %esi
    13d3:	53                   	push   %ebx
    13d4:	81 ec dc 00 00 00    	sub    $0xdc,%esp
    13da:	8b 9c 24 f0 00 00 00 	mov    0xf0(%esp),%ebx


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;
    13e1:	89 d9                	mov    %ebx,%ecx
#endif /* !MACOS && !RISCOS && !QDOS && !TANDEM */
#endif /* ?TOPS20 */


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    13e3:	89 df                	mov    %ebx,%edi
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;
    13e5:	c1 e9 10             	shr    $0x10,%ecx
#endif /* ?TOPS20 */


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    13e8:	89 da                	mov    %ebx,%edx
#endif /* !MACOS && !RISCOS && !QDOS && !TANDEM */
#endif /* ?TOPS20 */


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    13ea:	c1 ef 19             	shr    $0x19,%edi
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;
    13ed:	83 e1 1f             	and    $0x1f,%ecx
#endif /* ?TOPS20 */


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    13f0:	c1 ea 15             	shr    $0x15,%edx
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;
    13f3:	8d 41 ff             	lea    -0x1(%ecx),%eax

    /* dissect time */
    hh = (int)((unsigned)dosdatetime >> 11) & 0x1f;
    mm = (int)((unsigned)dosdatetime >> 5) & 0x3f;
    ss = (int)((unsigned)dosdatetime & 0x1f) * 2;
    13f6:	89 d9                	mov    %ebx,%ecx
#endif /* !MACOS && !RISCOS && !QDOS && !TANDEM */
#endif /* ?TOPS20 */


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    13f8:	8d 77 0a             	lea    0xa(%edi),%esi
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;

    /* dissect time */
    hh = (int)((unsigned)dosdatetime >> 11) & 0x1f;
    mm = (int)((unsigned)dosdatetime >> 5) & 0x3f;
    ss = (int)((unsigned)dosdatetime & 0x1f) * 2;
    13fb:	83 e1 1f             	and    $0x1f,%ecx
    13fe:	01 c9                	add    %ecx,%ecx


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;
    1400:	89 44 24 14          	mov    %eax,0x14(%esp)

    /* dissect time */
    hh = (int)((unsigned)dosdatetime >> 11) & 0x1f;
    mm = (int)((unsigned)dosdatetime >> 5) & 0x3f;
    ss = (int)((unsigned)dosdatetime & 0x1f) * 2;
    1404:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)

    /* leap = # of leap yrs from YRBASE up to but not including current year */
    leap = ((yr + YRBASE - 1) / 4);   /* leap year base factor */

    /* calculate days from BASE to this year and add expired days this year */
    days = (yr * 365) + (leap - 492) + ydays[mo];
    1408:	8d 0c f6             	lea    (%esi,%esi,8),%ecx
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;

    /* dissect time */
    hh = (int)((unsigned)dosdatetime >> 11) & 0x1f;
    140b:	89 d8                	mov    %ebx,%eax
#endif /* ?TOPS20 */


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    140d:	83 e2 0f             	and    $0xf,%edx

    /* leap = # of leap yrs from YRBASE up to but not including current year */
    leap = ((yr + YRBASE - 1) / 4);   /* leap year base factor */

    /* calculate days from BASE to this year and add expired days this year */
    days = (yr * 365) + (leap - 492) + ydays[mo];
    1410:	8d 0c ce             	lea    (%esi,%ecx,8),%ecx
#endif /* ?TOPS20 */


    /* dissect date */
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    1413:	4a                   	dec    %edx
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;

    /* dissect time */
    hh = (int)((unsigned)dosdatetime >> 11) & 0x1f;
    1414:	c1 e8 0b             	shr    $0xb,%eax

    /* leap = # of leap yrs from YRBASE up to but not including current year */
    leap = ((yr + YRBASE - 1) / 4);   /* leap year base factor */

    /* calculate days from BASE to this year and add expired days this year */
    days = (yr * 365) + (leap - 492) + ydays[mo];
    1417:	8d 2c 89             	lea    (%ecx,%ecx,4),%ebp
/*---------------------------------------------------------------------------
    Calculate the number of seconds since the epoch, usually 1 January 1970.
  ---------------------------------------------------------------------------*/

    /* leap = # of leap yrs from YRBASE up to but not including current year */
    leap = ((yr + YRBASE - 1) / 4);   /* leap year base factor */
    141a:	8d 8f bb 07 00 00    	lea    0x7bb(%edi),%ecx
    1420:	c1 f9 02             	sar    $0x2,%ecx
    yr = ((int)(dosdatetime >> 25) & 0x7f) + (1980 - YRBASE);
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;

    /* dissect time */
    hh = (int)((unsigned)dosdatetime >> 11) & 0x1f;
    1423:	83 e0 1f             	and    $0x1f,%eax
    1426:	89 44 24 18          	mov    %eax,0x18(%esp)
    mm = (int)((unsigned)dosdatetime >> 5) & 0x3f;
    142a:	89 d8                	mov    %ebx,%eax
    142c:	c1 e8 05             	shr    $0x5,%eax

    /* leap = # of leap yrs from YRBASE up to but not including current year */
    leap = ((yr + YRBASE - 1) / 4);   /* leap year base factor */

    /* calculate days from BASE to this year and add expired days this year */
    days = (yr * 365) + (leap - 492) + ydays[mo];
    142f:	8d ac 0d 14 fe ff ff 	lea    -0x1ec(%ebp,%ecx,1),%ebp
    1436:	31 c9                	xor    %ecx,%ecx
    mo = ((int)(dosdatetime >> 21) & 0x0f) - 1;
    dy = ((int)(dosdatetime >> 16) & 0x1f) - 1;

    /* dissect time */
    hh = (int)((unsigned)dosdatetime >> 11) & 0x1f;
    mm = (int)((unsigned)dosdatetime >> 5) & 0x3f;
    1438:	83 e0 3f             	and    $0x3f,%eax

    /* leap = # of leap yrs from YRBASE up to but not including current year */
    leap = ((yr + YRBASE - 1) / 4);   /* leap year base factor */

    /* calculate days from BASE to this year and add expired days this year */
    days = (yr * 365) + (leap - 492) + ydays[mo];
    143b:	66 8b 8c 12 a4 00 00 	mov    0xa4(%edx,%edx,1),%cx
    1442:	00 
    1443:	01 e9                	add    %ebp,%ecx

    /* if year is a leap year and month is after February, add another day */
    if ((mo > 1) && ((yr+YRBASE)%4 == 0) && ((yr+YRBASE) != 2100))
    1445:	4a                   	dec    %edx
    1446:	7e 14                	jle    145c <_dos_to_unix_time+0x8c>
    1448:	83 e7 03             	and    $0x3,%edi
    144b:	75 0f                	jne    145c <_dos_to_unix_time+0x8c>
    144d:	81 fe 82 00 00 00    	cmp    $0x82,%esi
    1453:	0f 95 c2             	setne  %dl
        ++days;                 /* OK through 2199 */
    1456:	80 fa 01             	cmp    $0x1,%dl
    1459:	83 d9 ff             	sbb    $0xffffffff,%ecx

    /* convert date & time to seconds relative to 00:00:00, 01/01/YRBASE */
    m_time = (time_t)((unsigned long)(days + dy) * 86400L +
                      (unsigned long)hh * 3600L +
                      (unsigned long)(mm * 60 + ss));
    145c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    1463:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
    1467:	c1 e0 06             	shl    $0x6,%eax
    146a:	29 d0                	sub    %edx,%eax
    if ((mo > 1) && ((yr+YRBASE)%4 == 0) && ((yr+YRBASE) != 2100))
        ++days;                 /* OK through 2199 */

    /* convert date & time to seconds relative to 00:00:00, 01/01/YRBASE */
    m_time = (time_t)((unsigned long)(days + dy) * 86400L +
                      (unsigned long)hh * 3600L +
    146c:	8b 54 24 18          	mov    0x18(%esp),%edx
    1470:	89 d6                	mov    %edx,%esi
                      (unsigned long)(mm * 60 + ss));
    1472:	01 e8                	add    %ebp,%eax
    if ((mo > 1) && ((yr+YRBASE)%4 == 0) && ((yr+YRBASE) != 2100))
        ++days;                 /* OK through 2199 */

    /* convert date & time to seconds relative to 00:00:00, 01/01/YRBASE */
    m_time = (time_t)((unsigned long)(days + dy) * 86400L +
                      (unsigned long)hh * 3600L +
    1474:	c1 e6 04             	shl    $0x4,%esi
    1477:	c1 e2 08             	shl    $0x8,%edx
    147a:	29 f2                	sub    %esi,%edx
    147c:	89 d6                	mov    %edx,%esi
    147e:	c1 e6 04             	shl    $0x4,%esi
    1481:	29 d6                	sub    %edx,%esi
    1483:	01 c6                	add    %eax,%esi
    /* if year is a leap year and month is after February, add another day */
    if ((mo > 1) && ((yr+YRBASE)%4 == 0) && ((yr+YRBASE) != 2100))
        ++days;                 /* OK through 2199 */

    /* convert date & time to seconds relative to 00:00:00, 01/01/YRBASE */
    m_time = (time_t)((unsigned long)(days + dy) * 86400L +
    1485:	8b 44 24 14          	mov    0x14(%esp),%eax
    1489:	01 c1                	add    %eax,%ecx
    148b:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
    148e:	89 c2                	mov    %eax,%edx
    1490:	c1 e2 04             	shl    $0x4,%edx
    1493:	29 c2                	sub    %eax,%edx
    1495:	89 d0                	mov    %edx,%eax
    1497:	c1 e0 04             	shl    $0x4,%eax
    149a:	29 d0                	sub    %edx,%eax
    149c:	c1 e0 07             	shl    $0x7,%eax
                      (unsigned long)hh * 3600L +
    149f:	8d 04 06             	lea    (%esi,%eax,1),%eax
    14a2:	89 44 24 20          	mov    %eax,0x20(%esp)
  ---------------------------------------------------------------------------*/

#if (!defined(MACOS) && !defined(RISCOS) && !defined(QDOS) && !defined(TANDEM))
#ifdef WIN32
    /* account for timezone differences */
    res = GetTimeZoneInformation(&tzinfo);
    14a6:	8d 44 24 24          	lea    0x24(%esp),%eax
    14aa:	89 04 24             	mov    %eax,(%esp)
    14ad:	e8 00 00 00 00       	call   14b2 <_dos_to_unix_time+0xe2>
    if (res != TIME_ZONE_ID_INVALID)
    14b2:	40                   	inc    %eax
  ---------------------------------------------------------------------------*/

#if (!defined(MACOS) && !defined(RISCOS) && !defined(QDOS) && !defined(TANDEM))
#ifdef WIN32
    /* account for timezone differences */
    res = GetTimeZoneInformation(&tzinfo);
    14b3:	52                   	push   %edx
    if (res != TIME_ZONE_ID_INVALID)
    14b4:	0f 84 cd 00 00 00    	je     1587 <_dos_to_unix_time+0x1b7>
    {
    m_time += 60*(tzinfo.Bias);
    14ba:	8b 44 24 24          	mov    0x24(%esp),%eax
    14be:	8b 7c 24 20          	mov    0x20(%esp),%edi
    14c2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    14c9:	c1 e0 06             	shl    $0x6,%eax
    14cc:	29 d0                	sub    %edx,%eax
    14ce:	01 f8                	add    %edi,%eax
/*---------------------------------------------------------------------------
    Adjust for local daylight savings (summer) time.
  ---------------------------------------------------------------------------*/

#ifndef BSD4_4  /* (DST already added to tm_gmtoff, so skip tm_isdst) */
    if ( (dosdatetime >= DOSTIME_2038_01_18) &&
    14d0:	81 fb ff ff 31 74    	cmp    $0x7431ffff,%ebx
#ifdef WIN32
    /* account for timezone differences */
    res = GetTimeZoneInformation(&tzinfo);
    if (res != TIME_ZONE_ID_INVALID)
    {
    m_time += 60*(tzinfo.Bias);
    14d6:	89 44 24 20          	mov    %eax,0x20(%esp)
/*---------------------------------------------------------------------------
    Adjust for local daylight savings (summer) time.
  ---------------------------------------------------------------------------*/

#ifndef BSD4_4  /* (DST already added to tm_gmtoff, so skip tm_isdst) */
    if ( (dosdatetime >= DOSTIME_2038_01_18) &&
    14da:	76 57                	jbe    1533 <_dos_to_unix_time+0x163>
    14dc:	3d ff ff ff 6f       	cmp    $0x6fffffff,%eax
    14e1:	7f 50                	jg     1533 <_dos_to_unix_time+0x163>
         (m_time < (time_t)0x70000000L) )
        m_time = U_TIME_T_MAX;  /* saturate in case of (unsigned) overflow */
    if (m_time < (time_t)0L)    /* a converted DOS time cannot be negative */
        m_time = S_TIME_T_MAX;  /*  -> saturate at max signed time_t value */
    TIMET_TO_NATIVE(m_time)     /* NOP unless MSC 7.0 or Macintosh */
    if (((tm = localtime((time_t *)&m_time)) != NULL) && tm->tm_isdst)
    14e3:	8d 44 24 20          	lea    0x20(%esp),%eax
#ifndef BSD4_4  /* (DST already added to tm_gmtoff, so skip tm_isdst) */
    if ( (dosdatetime >= DOSTIME_2038_01_18) &&
         (m_time < (time_t)0x70000000L) )
        m_time = U_TIME_T_MAX;  /* saturate in case of (unsigned) overflow */
    if (m_time < (time_t)0L)    /* a converted DOS time cannot be negative */
        m_time = S_TIME_T_MAX;  /*  -> saturate at max signed time_t value */
    14e7:	c7 44 24 20 ff ff ff 	movl   $0x7fffffff,0x20(%esp)
    14ee:	7f 
    TIMET_TO_NATIVE(m_time)     /* NOP unless MSC 7.0 or Macintosh */
    if (((tm = localtime((time_t *)&m_time)) != NULL) && tm->tm_isdst)
    14ef:	89 04 24             	mov    %eax,(%esp)
    14f2:	e8 00 00 00 00       	call   14f7 <_dos_to_unix_time+0x127>
    14f7:	85 c0                	test   %eax,%eax
    14f9:	75 4c                	jne    1547 <_dos_to_unix_time+0x177>
    14fb:	90                   	nop
    14fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#ifdef WIN32
        m_time += 60L * tzinfo.DaylightBias;    /* adjust with DST bias */
    else
        m_time += 60L * tzinfo.StandardBias;    /* add StdBias (normally 0) */
    1500:	8b 44 24 78          	mov    0x78(%esp),%eax
    1504:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    150b:	c1 e0 06             	shl    $0x6,%eax
    150e:	29 d0                	sub    %edx,%eax
    1510:	8b 54 24 20          	mov    0x20(%esp),%edx
    1514:	01 d0                	add    %edx,%eax
#endif /* !MACOS && !RISCOS && !QDOS && !TANDEM */
#endif /* ?TOPS20 */

#endif /* ?HAVE_MKTIME */

    if ( (dosdatetime >= DOSTIME_2038_01_18) &&
    1516:	81 fb ff ff 31 74    	cmp    $0x7431ffff,%ebx
    151c:	77 51                	ja     156f <_dos_to_unix_time+0x19f>
    151e:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
    1523:	85 c0                	test   %eax,%eax
    1525:	0f 48 c2             	cmovs  %edx,%eax
    if (m_time < (time_t)0L)    /* a converted DOS time cannot be negative */
        m_time = S_TIME_T_MAX;  /*  -> saturate at max signed time_t value */

    return m_time;

} /* end function dos_to_unix_time() */
    1528:	81 c4 dc 00 00 00    	add    $0xdc,%esp
    152e:	5b                   	pop    %ebx
    152f:	5e                   	pop    %esi
    1530:	5f                   	pop    %edi
    1531:	5d                   	pop    %ebp
    1532:	c3                   	ret    

#ifndef BSD4_4  /* (DST already added to tm_gmtoff, so skip tm_isdst) */
    if ( (dosdatetime >= DOSTIME_2038_01_18) &&
         (m_time < (time_t)0x70000000L) )
        m_time = U_TIME_T_MAX;  /* saturate in case of (unsigned) overflow */
    if (m_time < (time_t)0L)    /* a converted DOS time cannot be negative */
    1533:	85 c0                	test   %eax,%eax
    1535:	78 ac                	js     14e3 <_dos_to_unix_time+0x113>
        m_time = S_TIME_T_MAX;  /*  -> saturate at max signed time_t value */
    TIMET_TO_NATIVE(m_time)     /* NOP unless MSC 7.0 or Macintosh */
    if (((tm = localtime((time_t *)&m_time)) != NULL) && tm->tm_isdst)
    1537:	8d 44 24 20          	lea    0x20(%esp),%eax
    153b:	89 04 24             	mov    %eax,(%esp)
    153e:	e8 00 00 00 00       	call   1543 <_dos_to_unix_time+0x173>
    1543:	85 c0                	test   %eax,%eax
    1545:	74 b9                	je     1500 <_dos_to_unix_time+0x130>
    1547:	8b 70 20             	mov    0x20(%eax),%esi
    154a:	85 f6                	test   %esi,%esi
    154c:	74 b2                	je     1500 <_dos_to_unix_time+0x130>
#ifdef WIN32
        m_time += 60L * tzinfo.DaylightBias;    /* adjust with DST bias */
    154e:	8b 84 24 cc 00 00 00 	mov    0xcc(%esp),%eax
    1555:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    1559:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    1560:	c1 e0 06             	shl    $0x6,%eax
    1563:	29 d0                	sub    %edx,%eax
    1565:	01 c8                	add    %ecx,%eax
#endif /* !MACOS && !RISCOS && !QDOS && !TANDEM */
#endif /* ?TOPS20 */

#endif /* ?HAVE_MKTIME */

    if ( (dosdatetime >= DOSTIME_2038_01_18) &&
    1567:	81 fb ff ff 31 74    	cmp    $0x7431ffff,%ebx
    156d:	76 af                	jbe    151e <_dos_to_unix_time+0x14e>
    156f:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
    1574:	3d ff ff ff 6f       	cmp    $0x6fffffff,%eax
    1579:	0f 4e c2             	cmovle %edx,%eax
    if (m_time < (time_t)0L)    /* a converted DOS time cannot be negative */
        m_time = S_TIME_T_MAX;  /*  -> saturate at max signed time_t value */

    return m_time;

} /* end function dos_to_unix_time() */
    157c:	81 c4 dc 00 00 00    	add    $0xdc,%esp
    1582:	5b                   	pop    %ebx
    1583:	5e                   	pop    %esi
    1584:	5f                   	pop    %edi
    1585:	5d                   	pop    %ebp
    1586:	c3                   	ret    
    1587:	8b 44 24 20          	mov    0x20(%esp),%eax
    158b:	eb da                	jmp    1567 <_dos_to_unix_time+0x197>
    158d:	8d 76 00             	lea    0x0(%esi),%esi

00001590 <_check_for_newer>:
/******************************/

int check_for_newer(__G__ filename)  /* return 1 if existing file is newer */
    __GDEF                           /*  or equal; 0 if older; -1 if doesn't */
    char *filename;                  /*  exist yet */
{
    1590:	56                   	push   %esi
    1591:	53                   	push   %ebx
    1592:	83 ec 34             	sub    $0x34,%esp
    1595:	8b 5c 24 40          	mov    0x40(%esp),%ebx
        (dhh*1800L + dmin*30L + dss/2L), -1L, -1L, (char *) -1, -1, -1, -1))
        return DOES_NOT_EXIST;
#endif /* AOS_VS */

    Trace((stderr, "check_for_newer:  doing stat(%s)\n", FnFilter1(filename)));
    if (SSTAT(filename, &G.statbuf)) {
    1599:	89 1c 24             	mov    %ebx,(%esp)
    159c:	8d 83 7c 09 01 00    	lea    0x1097c(%ebx),%eax
    15a2:	89 44 24 08          	mov    %eax,0x8(%esp)
    15a6:	8b 44 24 44          	mov    0x44(%esp),%eax
    15aa:	89 44 24 04          	mov    %eax,0x4(%esp)
    15ae:	e8 00 00 00 00       	call   15b3 <_check_for_newer+0x23>
    15b3:	85 c0                	test   %eax,%eax
    15b5:	0f 85 85 00 00 00    	jne    1640 <_check_for_newer+0xb0>
#ifdef USE_EF_UT_TIME
    /* The `Unix extra field mtime' should be used for comparison with the
     * time stamp of the existing file >>>ONLY<<< when the EF info is also
     * used to set the modification time of the extracted file.
     */
    if (G.extra_field &&
    15bb:	8b 83 18 09 01 00    	mov    0x10918(%ebx),%eax
    15c1:	85 c0                	test   %eax,%eax
    15c3:	74 3b                	je     1600 <_check_for_newer+0x70>
#ifdef IZ_CHECK_TZ
        G.tz_is_valid &&
#endif
        (ef_scan_for_izux(G.extra_field, G.lrec.extra_field_length, 0,
    15c5:	8d 54 24 24          	lea    0x24(%esp),%edx
    15c9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    15d0:	00 
    15d1:	89 54 24 10          	mov    %edx,0x10(%esp)
    15d5:	8b 93 28 09 01 00    	mov    0x10928(%ebx),%edx
    15db:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    15e2:	00 
    15e3:	89 54 24 0c          	mov    %edx,0xc(%esp)
    15e7:	31 d2                	xor    %edx,%edx
    15e9:	66 8b 93 38 09 01 00 	mov    0x10938(%ebx),%dx
    15f0:	89 04 24             	mov    %eax,(%esp)
    15f3:	89 54 24 04          	mov    %edx,0x4(%esp)
    15f7:	e8 00 00 00 00       	call   15fc <_check_for_newer+0x6c>
#ifdef USE_EF_UT_TIME
    /* The `Unix extra field mtime' should be used for comparison with the
     * time stamp of the existing file >>>ONLY<<< when the EF info is also
     * used to set the modification time of the extracted file.
     */
    if (G.extra_field &&
    15fc:	a8 01                	test   $0x1,%al
    15fe:	75 30                	jne    1630 <_check_for_newer+0xa0>
        archive  = z_utime.mtime;
    } else {
        /* round up existing filetime to nearest 2 seconds for comparison,
         * but saturate in case of arithmetic overflow
         */
        existing = ((G.statbuf.st_mtime & 1) &&
    1600:	8b b3 98 09 01 00    	mov    0x10998(%ebx),%esi
    1606:	89 f0                	mov    %esi,%eax
    1608:	83 e0 01             	and    $0x1,%eax
                    (G.statbuf.st_mtime + 1 > G.statbuf.st_mtime)) ?
                   G.statbuf.st_mtime + 1 : G.statbuf.st_mtime;
    160b:	83 f8 01             	cmp    $0x1,%eax
        archive  = dos_to_unix_time(G.lrec.last_mod_dos_datetime);
    160e:	8b 83 28 09 01 00    	mov    0x10928(%ebx),%eax
        /* round up existing filetime to nearest 2 seconds for comparison,
         * but saturate in case of arithmetic overflow
         */
        existing = ((G.statbuf.st_mtime & 1) &&
                    (G.statbuf.st_mtime + 1 > G.statbuf.st_mtime)) ?
                   G.statbuf.st_mtime + 1 : G.statbuf.st_mtime;
    1614:	83 de ff             	sbb    $0xffffffff,%esi
        archive  = dos_to_unix_time(G.lrec.last_mod_dos_datetime);
    1617:	89 04 24             	mov    %eax,(%esp)
    161a:	e8 b1 fd ff ff       	call   13d0 <_dos_to_unix_time>
#endif /* ?USE_EF_UT_TIME */

    TTrace((stderr, "check_for_newer:  existing %lu, archive %lu, e-a %ld\n",
      (ulg)existing, (ulg)archive, (long)(existing-archive)));

    return (existing >= archive);
    161f:	39 c6                	cmp    %eax,%esi
    1621:	0f 9d c0             	setge  %al
    1624:	25 ff 00 00 00       	and    $0xff,%eax

} /* end function check_for_newer() */
    1629:	83 c4 34             	add    $0x34,%esp
    162c:	5b                   	pop    %ebx
    162d:	5e                   	pop    %esi
    162e:	c3                   	ret    
    162f:	90                   	nop
        (ef_scan_for_izux(G.extra_field, G.lrec.extra_field_length, 0,
                          G.lrec.last_mod_dos_datetime, &z_utime, NULL)
         & EB_UT_FL_MTIME))
    {
        TTrace((stderr, "check_for_newer:  using Unix extra field mtime\n"));
        existing = G.statbuf.st_mtime;
    1630:	8b b3 98 09 01 00    	mov    0x10998(%ebx),%esi
        archive  = z_utime.mtime;
    1636:	8b 44 24 28          	mov    0x28(%esp),%eax
    163a:	eb e3                	jmp    161f <_check_for_newer+0x8f>
    163c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                Info(slide, 0, ((char *)slide, LoadFarString(FileIsSymLink),
                  FnFilter1(filename), " with no real file"));
            return EXISTS_AND_OLDER;   /* symlink dates are meaningless */
        }
#endif /* SYMLINKS */
        return DOES_NOT_EXIST;
    1640:	83 c8 ff             	or     $0xffffffff,%eax
    1643:	eb e4                	jmp    1629 <_check_for_newer+0x99>
    1645:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1649:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001650 <_do_string>:

int do_string(__G__ length, option)   /* return PK-type error code */
    __GDEF
    unsigned int length;        /* without prototype, ush converted to this */
    int option;
{
    1650:	55                   	push   %ebp
    1651:	57                   	push   %edi
    1652:	56                   	push   %esi
    1653:	53                   	push   %ebx
    1654:	83 ec 3c             	sub    $0x3c,%esp
    position; its length is given by 'length'.  So start off by checking the
    length of the string:  if zero, we're already done.
  ---------------------------------------------------------------------------*/

    if (!length)
        return PK_COOL;
    1657:	31 c0                	xor    %eax,%eax

int do_string(__G__ length, option)   /* return PK-type error code */
    __GDEF
    unsigned int length;        /* without prototype, ush converted to this */
    int option;
{
    1659:	8b 5c 24 54          	mov    0x54(%esp),%ebx
    165d:	8b 6c 24 50          	mov    0x50(%esp),%ebp
    The string, by the way, is assumed to start at the current file-pointer
    position; its length is given by 'length'.  So start off by checking the
    length of the string:  if zero, we're already done.
  ---------------------------------------------------------------------------*/

    if (!length)
    1661:	85 db                	test   %ebx,%ebx
    1663:	74 55                	je     16ba <_do_string+0x6a>
        return PK_COOL;

    switch (option) {
    1665:	83 7c 24 58 06       	cmpl   $0x6,0x58(%esp)
    166a:	0f 87 d4 00 00 00    	ja     1744 <_do_string+0xf4>
    1670:	8b 44 24 58          	mov    0x58(%esp),%eax
    1674:	ff 24 85 88 00 00 00 	jmp    *0x88(,%eax,4)
     * just to be sure.
     */

    case DS_FN:
    case DS_FN_L:
        if (length >= FILNAMSIZ) {
    167b:	81 fb 03 01 00 00    	cmp    $0x103,%ebx
    1681:	0f 87 9a 03 00 00    	ja     1a21 <_do_string+0x3d1>
    unsigned int length;        /* without prototype, ush converted to this */
    int option;
{
    unsigned comment_bytes_left;
    unsigned int block_len;
    int error=PK_OK;
    1687:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    168e:	00 
            /* remember excess length in block_len */
            block_len = length - (FILNAMSIZ - 1);
            length = FILNAMSIZ - 1;
        } else
            /* no excess size */
            block_len = 0;
    168f:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    1696:	00 
        if (readbuf(__G__ G.filename, length) == 0)
    1697:	8d b5 e0 09 01 00    	lea    0x109e0(%ebp),%esi
    169d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    16a1:	89 74 24 04          	mov    %esi,0x4(%esp)
    16a5:	89 2c 24             	mov    %ebp,(%esp)
    16a8:	e8 73 ec ff ff       	call   320 <_readbuf>
    16ad:	85 c0                	test   %eax,%eax
    16af:	0f 85 ce 01 00 00    	jne    1883 <_do_string+0x233>
            register uch *p = G.outbuf;
            register uch *q = G.outbuf;

            if ((block_len = readbuf(__G__ (char *)G.outbuf,
                   MIN((unsigned)OUTBUFSIZ, comment_bytes_left))) == 0)
                return PK_EOF;
    16b5:	b8 33 00 00 00       	mov    $0x33,%eax

    } /* end switch (option) */

    return error;

} /* end function do_string() */
    16ba:	83 c4 3c             	add    $0x3c,%esp
    16bd:	5b                   	pop    %ebx
    16be:	5e                   	pop    %esi
    16bf:	5f                   	pop    %edi
    16c0:	5d                   	pop    %ebp
    16c1:	c3                   	ret    
    unsigned int length;        /* without prototype, ush converted to this */
    int option;
{
    unsigned comment_bytes_left;
    unsigned int block_len;
    int error=PK_OK;
    16c2:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    16c9:	00 
     */

    case SKIP:
        /* cur_zipfile_bufstart already takes account of extra_bytes, so don't
         * correct for it twice: */
        seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    16ca:	8b b5 14 09 01 00    	mov    0x10914(%ebp),%esi
    16d0:	8b 85 10 09 01 00    	mov    0x10910(%ebp),%eax
    16d6:	29 f0                	sub    %esi,%eax
                  (G.inptr-G.inbuf) + length);
    16d8:	8b bd e4 08 01 00    	mov    0x108e4(%ebp),%edi
     */

    case SKIP:
        /* cur_zipfile_bufstart already takes account of extra_bytes, so don't
         * correct for it twice: */
        seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    16de:	89 c2                	mov    %eax,%edx
                  (G.inptr-G.inbuf) + length);
    16e0:	8b 85 e8 08 01 00    	mov    0x108e8(%ebp),%eax
    16e6:	29 f8                	sub    %edi,%eax
     */

    case SKIP:
        /* cur_zipfile_bufstart already takes account of extra_bytes, so don't
         * correct for it twice: */
        seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    16e8:	89 2c 24             	mov    %ebp,(%esp)
    16eb:	01 d0                	add    %edx,%eax
                  (G.inptr-G.inbuf) + length);
    16ed:	01 c3                	add    %eax,%ebx
     */

    case SKIP:
        /* cur_zipfile_bufstart already takes account of extra_bytes, so don't
         * correct for it twice: */
        seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    16ef:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    16f3:	e8 28 ef ff ff       	call   620 <_seek_zipf>
                  (G.inptr-G.inbuf) + length);
        break;
    16f8:	8b 44 24 18          	mov    0x18(%esp),%eax

    } /* end switch (option) */

    return error;

} /* end function do_string() */
    16fc:	83 c4 3c             	add    $0x3c,%esp
    16ff:	5b                   	pop    %ebx
    1700:	5e                   	pop    %esi
    1701:	5f                   	pop    %edi
    1702:	5d                   	pop    %ebp
    1703:	c3                   	ret    
     * Fourth case:  assume we're at the start of an "extra field"; malloc
     * storage for it and read data into the allocated space.
     */

    case EXTRA_FIELD:
        if (G.extra_field != (uch *)NULL)
    1704:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
    170a:	85 c0                	test   %eax,%eax
    170c:	74 08                	je     1716 <_do_string+0xc6>
            free(G.extra_field);
    170e:	89 04 24             	mov    %eax,(%esp)
    1711:	e8 00 00 00 00       	call   1716 <_do_string+0xc6>
        if ((G.extra_field = (uch *)malloc(length)) == (uch *)NULL) {
    1716:	89 1c 24             	mov    %ebx,(%esp)
    1719:	e8 00 00 00 00       	call   171e <_do_string+0xce>
    171e:	89 85 18 09 01 00    	mov    %eax,0x10918(%ebp)
    1724:	85 c0                	test   %eax,%eax
    1726:	0f 84 80 03 00 00    	je     1aac <_do_string+0x45c>
            /* cur_zipfile_bufstart already takes account of extra_bytes,
             * so don't correct for it twice: */
            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
                      (G.inptr-G.inbuf) + length);
        } else
            if (readbuf(__G__ (char *)G.extra_field, length) == 0)
    172c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    1730:	89 44 24 04          	mov    %eax,0x4(%esp)
    1734:	89 2c 24             	mov    %ebp,(%esp)
    1737:	e8 e4 eb ff ff       	call   320 <_readbuf>
    173c:	85 c0                	test   %eax,%eax
    173e:	0f 84 71 ff ff ff    	je     16b5 <_do_string+0x65>

    } /* end switch (option) */

    return error;

} /* end function do_string() */
    1744:	83 c4 3c             	add    $0x3c,%esp
    unsigned int length;        /* without prototype, ush converted to this */
    int option;
{
    unsigned comment_bytes_left;
    unsigned int block_len;
    int error=PK_OK;
    1747:	31 c0                	xor    %eax,%eax

    } /* end switch (option) */

    return error;

} /* end function do_string() */
    1749:	5b                   	pop    %ebx
    174a:	5e                   	pop    %esi
    174b:	5f                   	pop    %edi
    174c:	5d                   	pop    %ebp
    174d:	c3                   	ret    
                A_TO_N(G.outbuf);   /* translate string to native */
            }

#ifdef WINDLL
            /* ran out of local mem -- had to cheat */
            win_fprintf((zvoid *)&G, stdout, length, (char *)G.outbuf);
    174e:	a1 00 00 00 00       	mov    0x0,%eax
  ---------------------------------------------------------------------------*/

    if (!length)
        return PK_COOL;

    switch (option) {
    1753:	89 de                	mov    %ebx,%esi
                A_TO_N(G.outbuf);   /* translate string to native */
            }

#ifdef WINDLL
            /* ran out of local mem -- had to cheat */
            win_fprintf((zvoid *)&G, stdout, length, (char *)G.outbuf);
    1755:	83 c0 20             	add    $0x20,%eax
    1758:	89 5c 24 54          	mov    %ebx,0x54(%esp)
    175c:	89 c3                	mov    %eax,%ebx
    175e:	66 90                	xchg   %ax,%ax
        block_len = OUTBUFSIZ;       /* for the while statement, first time */
        while (comment_bytes_left > 0 && block_len > 0) {
            register uch *p = G.outbuf;
            register uch *q = G.outbuf;

            if ((block_len = readbuf(__G__ (char *)G.outbuf,
    1760:	b8 00 00 02 00       	mov    $0x20000,%eax
    case DISPLAY:
    case DISPL_8:
        comment_bytes_left = length;
        block_len = OUTBUFSIZ;       /* for the while statement, first time */
        while (comment_bytes_left > 0 && block_len > 0) {
            register uch *p = G.outbuf;
    1765:	8b bd cc 09 01 00    	mov    0x109cc(%ebp),%edi
            register uch *q = G.outbuf;

            if ((block_len = readbuf(__G__ (char *)G.outbuf,
    176b:	81 fe 00 00 02 00    	cmp    $0x20000,%esi
    1771:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1775:	0f 46 c6             	cmovbe %esi,%eax
    1778:	89 44 24 08          	mov    %eax,0x8(%esp)
    177c:	89 2c 24             	mov    %ebp,(%esp)
    177f:	e8 9c eb ff ff       	call   320 <_readbuf>
    1784:	85 c0                	test   %eax,%eax
    1786:	0f 84 29 ff ff ff    	je     16b5 <_do_string+0x65>
                return PK_EOF;
            comment_bytes_left -= block_len;

            /* this is why we allocated an extra byte for outbuf:  terminate
             *  with zero (ASCIIZ) */
            G.outbuf[block_len] = '\0';
    178c:	8b 95 cc 09 01 00    	mov    0x109cc(%ebp),%edx
            register uch *q = G.outbuf;

            if ((block_len = readbuf(__G__ (char *)G.outbuf,
                   MIN((unsigned)OUTBUFSIZ, comment_bytes_left))) == 0)
                return PK_EOF;
            comment_bytes_left -= block_len;
    1792:	29 c6                	sub    %eax,%esi
            G.outbuf[block_len] = '\0';

            /* remove all ASCII carriage returns from comment before printing
             * (since used before A_TO_N(), check for CR instead of '\r')
             */
            while (*p) {
    1794:	89 f9                	mov    %edi,%ecx
                return PK_EOF;
            comment_bytes_left -= block_len;

            /* this is why we allocated an extra byte for outbuf:  terminate
             *  with zero (ASCIIZ) */
            G.outbuf[block_len] = '\0';
    1796:	c6 04 02 00          	movb   $0x0,(%edx,%eax,1)

            /* remove all ASCII carriage returns from comment before printing
             * (since used before A_TO_N(), check for CR instead of '\r')
             */
            while (*p) {
    179a:	8a 17                	mov    (%edi),%dl
    179c:	84 d2                	test   %dl,%dl
    179e:	74 1d                	je     17bd <_do_string+0x16d>
                while (*p == CR)
    17a0:	89 f8                	mov    %edi,%eax
    17a2:	80 fa 0d             	cmp    $0xd,%dl
    17a5:	75 08                	jne    17af <_do_string+0x15f>
                    ++p;
    17a7:	40                   	inc    %eax

            /* remove all ASCII carriage returns from comment before printing
             * (since used before A_TO_N(), check for CR instead of '\r')
             */
            while (*p) {
                while (*p == CR)
    17a8:	8a 10                	mov    (%eax),%dl
    17aa:	80 fa 0d             	cmp    $0xd,%dl
    17ad:	74 f8                	je     17a7 <_do_string+0x157>
                    ++p;
                *q++ = *p++;
    17af:	41                   	inc    %ecx
    17b0:	88 51 ff             	mov    %dl,-0x1(%ecx)
            G.outbuf[block_len] = '\0';

            /* remove all ASCII carriage returns from comment before printing
             * (since used before A_TO_N(), check for CR instead of '\r')
             */
            while (*p) {
    17b3:	8a 50 01             	mov    0x1(%eax),%dl
                while (*p == CR)
                    ++p;
                *q++ = *p++;
    17b6:	8d 78 01             	lea    0x1(%eax),%edi
            G.outbuf[block_len] = '\0';

            /* remove all ASCII carriage returns from comment before printing
             * (since used before A_TO_N(), check for CR instead of '\r')
             */
            while (*p) {
    17b9:	84 d2                	test   %dl,%dl
    17bb:	75 e3                	jne    17a0 <_do_string+0x150>
                while (*p == CR)
                    ++p;
                *q++ = *p++;
            }
            /* could check whether (p - outbuf) == block_len here */
            *q = '\0';
    17bd:	c6 01 00             	movb   $0x0,(%ecx)

            if (option == DISPL_8) {
    17c0:	83 7c 24 58 05       	cmpl   $0x5,0x58(%esp)
    17c5:	74 6f                	je     1836 <_do_string+0x1e6>
                A_TO_N(G.outbuf);   /* translate string to native */
            }

#ifdef WINDLL
            /* ran out of local mem -- had to cheat */
            win_fprintf((zvoid *)&G, stdout, length, (char *)G.outbuf);
    17c7:	8b 85 cc 09 01 00    	mov    0x109cc(%ebp),%eax
    17cd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    17d1:	89 44 24 0c          	mov    %eax,0xc(%esp)
    17d5:	8b 44 24 54          	mov    0x54(%esp),%eax
    17d9:	89 44 24 08          	mov    %eax,0x8(%esp)
    17dd:	89 2c 24             	mov    %ebp,(%esp)
    17e0:	e8 00 00 00 00       	call   17e5 <_do_string+0x195>
            win_fprintf((zvoid *)&G, stdout, 2, (char *)"\n\n");
    17e5:	c7 44 24 0c 50 00 00 	movl   $0x50,0xc(%esp)
    17ec:	00 
    17ed:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
    17f4:	00 
    17f5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    17f9:	89 2c 24             	mov    %ebp,(%esp)
    17fc:	e8 00 00 00 00       	call   1801 <_do_string+0x1b1>

    case DISPLAY:
    case DISPL_8:
        comment_bytes_left = length;
        block_len = OUTBUFSIZ;       /* for the while statement, first time */
        while (comment_bytes_left > 0 && block_len > 0) {
    1801:	85 f6                	test   %esi,%esi
    1803:	0f 85 57 ff ff ff    	jne    1760 <_do_string+0x110>
            (*G.message)((zvoid *)&G, slide, (ulg)(q-slide), 0);
#endif /* ?NOANSIFILT */
#endif /* ?WINDLL */
        }
        /* add '\n' if not at start of line */
        (*G.message)((zvoid *)&G, slide, 0L, 0x40);
    1809:	8d 85 dc 08 00 00    	lea    0x8dc(%ebp),%eax
    180f:	c7 44 24 0c 40 00 00 	movl   $0x40,0xc(%esp)
    1816:	00 
    1817:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    181e:	00 
    181f:	89 44 24 04          	mov    %eax,0x4(%esp)
    1823:	89 2c 24             	mov    %ebp,(%esp)
    1826:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
    unsigned int length;        /* without prototype, ush converted to this */
    int option;
{
    unsigned comment_bytes_left;
    unsigned int block_len;
    int error=PK_OK;
    182c:	31 c0                	xor    %eax,%eax
            (*G.message)((zvoid *)&G, slide, (ulg)(q-slide), 0);
#endif /* ?NOANSIFILT */
#endif /* ?WINDLL */
        }
        /* add '\n' if not at start of line */
        (*G.message)((zvoid *)&G, slide, 0L, 0x40);
    182e:	83 ec 10             	sub    $0x10,%esp
        break;
    1831:	e9 84 fe ff ff       	jmp    16ba <_do_string+0x6a>

            if (option == DISPL_8) {
                /* translate the text coded in the entry's host-dependent
                   "extended ASCII" charset into the compiler's (system's)
                   internal text code page */
                Ext_ASCII_TO_Native((char *)G.outbuf, G.pInfo->hostnum,
    1836:	8b 95 d8 08 00 00    	mov    0x8d8(%ebp),%edx
    183c:	8a 42 13             	mov    0x13(%edx),%al
    183f:	84 c0                	test   %al,%al
    1841:	75 2e                	jne    1871 <_do_string+0x221>
    1843:	f6 42 18 40          	testb  $0x40,0x18(%edx)
    1847:	74 0f                	je     1858 <_do_string+0x208>
    1849:	8a 42 12             	mov    0x12(%edx),%al
    184c:	8d 48 e7             	lea    -0x19(%eax),%ecx
    184f:	80 f9 01             	cmp    $0x1,%cl
    1852:	76 21                	jbe    1875 <_do_string+0x225>
    1854:	3c 28                	cmp    $0x28,%al
    1856:	74 1d                	je     1875 <_do_string+0x225>
    1858:	8b 85 cc 09 01 00    	mov    0x109cc(%ebp),%eax
    185e:	89 44 24 04          	mov    %eax,0x4(%esp)
    1862:	89 04 24             	mov    %eax,(%esp)
    1865:	e8 00 00 00 00       	call   186a <_do_string+0x21a>
    186a:	57                   	push   %edi
    186b:	57                   	push   %edi
    186c:	e9 56 ff ff ff       	jmp    17c7 <_do_string+0x177>
    1871:	3c 06                	cmp    $0x6,%al
    1873:	74 e3                	je     1858 <_do_string+0x208>
    1875:	66 81 7a 12 32 0b    	cmpw   $0xb32,0x12(%edx)
    187b:	0f 85 46 ff ff ff    	jne    17c7 <_do_string+0x177>
    1881:	eb d5                	jmp    1858 <_do_string+0x208>
            return PK_EOF;
        G.filename[length] = '\0';      /* terminate w/zero:  ASCIIZ */

        /* translate the Zip entry filename coded in host-dependent "extended
           ASCII" into the compiler's (system's) internal text code page */
        Ext_ASCII_TO_Native(G.filename, G.pInfo->hostnum, G.pInfo->hostver,
    1883:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
        } else
            /* no excess size */
            block_len = 0;
        if (readbuf(__G__ G.filename, length) == 0)
            return PK_EOF;
        G.filename[length] = '\0';      /* terminate w/zero:  ASCIIZ */
    1889:	c6 84 1d e0 09 01 00 	movb   $0x0,0x109e0(%ebp,%ebx,1)
    1890:	00 

        /* translate the Zip entry filename coded in host-dependent "extended
           ASCII" into the compiler's (system's) internal text code page */
        Ext_ASCII_TO_Native(G.filename, G.pInfo->hostnum, G.pInfo->hostver,
    1891:	8a 50 13             	mov    0x13(%eax),%dl
    1894:	84 d2                	test   %dl,%dl
    1896:	74 6b                	je     1903 <_do_string+0x2b3>
    1898:	80 fa 06             	cmp    $0x6,%dl
    189b:	0f 85 83 00 00 00    	jne    1924 <_do_string+0x2d4>
    18a1:	89 74 24 04          	mov    %esi,0x4(%esp)
    18a5:	89 34 24             	mov    %esi,(%esp)
    18a8:	e8 00 00 00 00       	call   18ad <_do_string+0x25d>
    18ad:	51                   	push   %ecx
    18ae:	51                   	push   %ecx
    18af:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
                            G.pInfo->HasUxAtt, (option == DS_FN_L));

        if (G.pInfo->lcflag)      /* replace with lowercase filename */
    18b5:	8a 40 18             	mov    0x18(%eax),%al
    18b8:	a8 10                	test   $0x10,%al
    18ba:	0f 84 cb 00 00 00    	je     198b <_do_string+0x33b>
    18c0:	89 f2                	mov    %esi,%edx
    18c2:	89 df                	mov    %ebx,%edi
    18c4:	89 74 24 28          	mov    %esi,0x28(%esp)
    18c8:	89 d3                	mov    %edx,%ebx
            STRLOWER(G.filename, G.filename);
    18ca:	8a 03                	mov    (%ebx),%al
    18cc:	88 44 24 23          	mov    %al,0x23(%esp)
    18d0:	84 c0                	test   %al,%al
    18d2:	0f 84 9f 00 00 00    	je     1977 <_do_string+0x327>
    18d8:	a1 00 00 00 00       	mov    0x0,%eax
    18dd:	8b 00                	mov    (%eax),%eax
    18df:	89 1c 24             	mov    %ebx,(%esp)
    18e2:	89 44 24 04          	mov    %eax,0x4(%esp)
    18e6:	e8 00 00 00 00       	call   18eb <_do_string+0x29b>
    18eb:	83 f8 01             	cmp    $0x1,%eax
    18ee:	76 41                	jbe    1931 <_do_string+0x2e1>
    18f0:	31 c9                	xor    %ecx,%ecx
    18f2:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
    18f5:	88 14 0e             	mov    %dl,(%esi,%ecx,1)
    18f8:	41                   	inc    %ecx
    18f9:	39 c8                	cmp    %ecx,%eax
    18fb:	75 f5                	jne    18f2 <_do_string+0x2a2>
    18fd:	01 c6                	add    %eax,%esi
    18ff:	01 c3                	add    %eax,%ebx
    1901:	eb c7                	jmp    18ca <_do_string+0x27a>
            return PK_EOF;
        G.filename[length] = '\0';      /* terminate w/zero:  ASCIIZ */

        /* translate the Zip entry filename coded in host-dependent "extended
           ASCII" into the compiler's (system's) internal text code page */
        Ext_ASCII_TO_Native(G.filename, G.pInfo->hostnum, G.pInfo->hostver,
    1903:	83 7c 24 58 06       	cmpl   $0x6,0x58(%esp)
    1908:	74 06                	je     1910 <_do_string+0x2c0>
    190a:	f6 40 18 40          	testb  $0x40,0x18(%eax)
    190e:	74 91                	je     18a1 <_do_string+0x251>
    1910:	8a 50 12             	mov    0x12(%eax),%dl
    1913:	8d 4a e7             	lea    -0x19(%edx),%ecx
    1916:	80 f9 01             	cmp    $0x1,%cl
    1919:	76 09                	jbe    1924 <_do_string+0x2d4>
    191b:	80 fa 28             	cmp    $0x28,%dl
    191e:	0f 85 7d ff ff ff    	jne    18a1 <_do_string+0x251>
    1924:	66 81 78 12 32 0b    	cmpw   $0xb32,0x12(%eax)
    192a:	75 89                	jne    18b5 <_do_string+0x265>
    192c:	e9 70 ff ff ff       	jmp    18a1 <_do_string+0x251>
                            G.pInfo->HasUxAtt, (option == DS_FN_L));

        if (G.pInfo->lcflag)      /* replace with lowercase filename */
            STRLOWER(G.filename, G.filename);
    1931:	8d 46 01             	lea    0x1(%esi),%eax
    1934:	89 44 24 24          	mov    %eax,0x24(%esp)
__CRT_INLINE int __cdecl __MINGW_NOTHROW isgraph(int c) {return __ISCTYPE(c, (_PUNCT|_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW islower(int c) {return __ISCTYPE(c, _LOWER);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isprint(int c) {return __ISCTYPE(c, (_BLANK|_PUNCT|_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW ispunct(int c) {return __ISCTYPE(c, _PUNCT);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isspace(int c) {return __ISCTYPE(c, _SPACE);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isupper(int c) {return __ISCTYPE(c, _UPPER);}
    1938:	a1 00 00 00 00       	mov    0x0,%eax
    193d:	0f be 4c 24 23       	movsbl 0x23(%esp),%ecx
    1942:	83 38 01             	cmpl   $0x1,(%eax)
    1945:	0f 85 b9 00 00 00    	jne    1a04 <_do_string+0x3b4>
    194b:	a1 00 00 00 00       	mov    0x0,%eax
    1950:	8b 00                	mov    (%eax),%eax
    1952:	66 8b 04 48          	mov    (%eax,%ecx,2),%ax
    1956:	83 e0 01             	and    $0x1,%eax
    1959:	8a 54 24 23          	mov    0x23(%esp),%dl
    195d:	85 c0                	test   %eax,%eax
    195f:	74 0a                	je     196b <_do_string+0x31b>
    1961:	89 0c 24             	mov    %ecx,(%esp)
    1964:	e8 00 00 00 00       	call   1969 <_do_string+0x319>
    1969:	88 c2                	mov    %al,%dl
    196b:	88 16                	mov    %dl,(%esi)
    196d:	43                   	inc    %ebx
    196e:	8b 74 24 24          	mov    0x24(%esp),%esi
    1972:	e9 53 ff ff ff       	jmp    18ca <_do_string+0x27a>
    1977:	89 fb                	mov    %edi,%ebx
    1979:	89 f7                	mov    %esi,%edi
    197b:	8b 74 24 28          	mov    0x28(%esp),%esi
    197f:	c6 07 00             	movb   $0x0,(%edi)
    1982:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    1988:	8a 40 18             	mov    0x18(%eax),%al

        if (G.pInfo->vollabel && length > 8 && G.filename[8] == '.') {
    198b:	a8 20                	test   $0x20,%al
    198d:	74 12                	je     19a1 <_do_string+0x351>
    198f:	83 fb 08             	cmp    $0x8,%ebx
    1992:	76 0d                	jbe    19a1 <_do_string+0x351>
    1994:	80 bd e8 09 01 00 2e 	cmpb   $0x2e,0x109e8(%ebp)
    199b:	0f 84 78 01 00 00    	je     1b19 <_do_string+0x4c9>
            char *p = G.filename+8;
            while (*p++)
                p[-1] = *p;  /* disk label, and 8th char is dot:  remove dot */
        }

        if (!block_len)         /* no overflow, we're done here */
    19a1:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    19a5:	8b 44 24 18          	mov    0x18(%esp),%eax
    19a9:	85 d2                	test   %edx,%edx
    19ab:	0f 84 09 fd ff ff    	je     16ba <_do_string+0x6a>

        /*
         * We truncated the filename, so print what's left and then fall
         * through to the SKIP routine.
         */
        Info(slide, 0x401, ((char *)slide, "[ %s ]\n", FnFilter1(G.filename)));
    19b1:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    19b7:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    19bd:	89 34 24             	mov    %esi,(%esp)
    19c0:	89 44 24 04          	mov    %eax,0x4(%esp)
    19c4:	e8 00 00 00 00       	call   19c9 <_do_string+0x379>
    19c9:	8d b5 dc 08 00 00    	lea    0x8dc(%ebp),%esi
    19cf:	89 44 24 08          	mov    %eax,0x8(%esp)
    19d3:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
    19da:	00 
    19db:	89 34 24             	mov    %esi,(%esp)
    19de:	e8 00 00 00 00       	call   19e3 <_do_string+0x393>
    19e3:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    19ea:	00 
    19eb:	89 44 24 08          	mov    %eax,0x8(%esp)
    19ef:	89 74 24 04          	mov    %esi,0x4(%esp)
    19f3:	89 2c 24             	mov    %ebp,(%esp)
    19f6:	ff d3                	call   *%ebx
    19f8:	83 ec 10             	sub    $0x10,%esp
    19fb:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    19ff:	e9 c6 fc ff ff       	jmp    16ca <_do_string+0x7a>
    1a04:	89 0c 24             	mov    %ecx,(%esp)
    1a07:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    1a0e:	00 
    1a0f:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
    1a13:	e8 00 00 00 00       	call   1a18 <_do_string+0x3c8>
    1a18:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    1a1c:	e9 38 ff ff ff       	jmp    1959 <_do_string+0x309>
     */

    case DS_FN:
    case DS_FN_L:
        if (length >= FILNAMSIZ) {
            Info(slide, 0x401, ((char *)slide,
    1a21:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    1a27:	8d 95 dc 08 00 00    	lea    0x8dc(%ebp),%edx
    1a2d:	89 44 24 18          	mov    %eax,0x18(%esp)
    1a31:	89 d7                	mov    %edx,%edi
    1a33:	be 5c 00 00 00       	mov    $0x5c,%esi
    1a38:	b8 2a 00 00 00       	mov    $0x2a,%eax
    1a3d:	f6 c2 01             	test   $0x1,%dl
    1a40:	0f 85 0a 01 00 00    	jne    1b50 <_do_string+0x500>
    1a46:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1a4c:	0f 85 e9 00 00 00    	jne    1b3b <_do_string+0x4eb>
    1a52:	89 c1                	mov    %eax,%ecx
    1a54:	c1 e9 02             	shr    $0x2,%ecx
    1a57:	a8 02                	test   $0x2,%al
    1a59:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    1a5b:	74 0b                	je     1a68 <_do_string+0x418>
    1a5d:	66 8b 0e             	mov    (%esi),%cx
    1a60:	66 89 0f             	mov    %cx,(%edi)
    1a63:	b9 02 00 00 00       	mov    $0x2,%ecx
    1a68:	a8 01                	test   $0x1,%al
    1a6a:	74 06                	je     1a72 <_do_string+0x422>
    1a6c:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    1a6f:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    1a72:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1a79:	00 
    1a7a:	c7 44 24 08 29 00 00 	movl   $0x29,0x8(%esp)
    1a81:	00 
    1a82:	89 54 24 04          	mov    %edx,0x4(%esp)
    1a86:	89 2c 24             	mov    %ebp,(%esp)
    1a89:	ff 54 24 18          	call   *0x18(%esp)
              LoadFarString(FilenameTooLongTrunc)));
            error = PK_WARN;
            /* remember excess length in block_len */
            block_len = length - (FILNAMSIZ - 1);
    1a8d:	8d 83 fd fe ff ff    	lea    -0x103(%ebx),%eax
     */

    case DS_FN:
    case DS_FN_L:
        if (length >= FILNAMSIZ) {
            Info(slide, 0x401, ((char *)slide,
    1a93:	83 ec 10             	sub    $0x10,%esp
              LoadFarString(FilenameTooLongTrunc)));
            error = PK_WARN;
            /* remember excess length in block_len */
            block_len = length - (FILNAMSIZ - 1);
            length = FILNAMSIZ - 1;
    1a96:	bb 03 01 00 00       	mov    $0x103,%ebx
        if (length >= FILNAMSIZ) {
            Info(slide, 0x401, ((char *)slide,
              LoadFarString(FilenameTooLongTrunc)));
            error = PK_WARN;
            /* remember excess length in block_len */
            block_len = length - (FILNAMSIZ - 1);
    1a9b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    case DS_FN:
    case DS_FN_L:
        if (length >= FILNAMSIZ) {
            Info(slide, 0x401, ((char *)slide,
              LoadFarString(FilenameTooLongTrunc)));
            error = PK_WARN;
    1a9f:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    1aa6:	00 
    1aa7:	e9 eb fb ff ff       	jmp    1697 <_do_string+0x47>

    case EXTRA_FIELD:
        if (G.extra_field != (uch *)NULL)
            free(G.extra_field);
        if ((G.extra_field = (uch *)malloc(length)) == (uch *)NULL) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(ExtraFieldTooLong),
    1aac:	8d b5 dc 08 00 00    	lea    0x8dc(%ebp),%esi
    1ab2:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    1ab8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    1abc:	c7 44 24 04 e0 00 00 	movl   $0xe0,0x4(%esp)
    1ac3:	00 
    1ac4:	89 34 24             	mov    %esi,(%esp)
    1ac7:	e8 00 00 00 00       	call   1acc <_do_string+0x47c>
    1acc:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1ad3:	00 
    1ad4:	89 44 24 08          	mov    %eax,0x8(%esp)
    1ad8:	89 74 24 04          	mov    %esi,0x4(%esp)
    1adc:	89 2c 24             	mov    %ebp,(%esp)
    1adf:	ff d7                	call   *%edi
              length));
            /* cur_zipfile_bufstart already takes account of extra_bytes,
             * so don't correct for it twice: */
            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    1ae1:	8b 95 14 09 01 00    	mov    0x10914(%ebp),%edx
    1ae7:	8b 85 10 09 01 00    	mov    0x10910(%ebp),%eax
                      (G.inptr-G.inbuf) + length);
    1aed:	8b 8d e4 08 01 00    	mov    0x108e4(%ebp),%ecx
        if ((G.extra_field = (uch *)malloc(length)) == (uch *)NULL) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(ExtraFieldTooLong),
              length));
            /* cur_zipfile_bufstart already takes account of extra_bytes,
             * so don't correct for it twice: */
            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    1af3:	29 d0                	sub    %edx,%eax

    case EXTRA_FIELD:
        if (G.extra_field != (uch *)NULL)
            free(G.extra_field);
        if ((G.extra_field = (uch *)malloc(length)) == (uch *)NULL) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(ExtraFieldTooLong),
    1af5:	83 ec 10             	sub    $0x10,%esp
              length));
            /* cur_zipfile_bufstart already takes account of extra_bytes,
             * so don't correct for it twice: */
            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    1af8:	89 c2                	mov    %eax,%edx
                      (G.inptr-G.inbuf) + length);
    1afa:	8b 85 e8 08 01 00    	mov    0x108e8(%ebp),%eax
    1b00:	29 c8                	sub    %ecx,%eax
        if ((G.extra_field = (uch *)malloc(length)) == (uch *)NULL) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(ExtraFieldTooLong),
              length));
            /* cur_zipfile_bufstart already takes account of extra_bytes,
             * so don't correct for it twice: */
            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    1b02:	89 2c 24             	mov    %ebp,(%esp)
    1b05:	01 d0                	add    %edx,%eax
                      (G.inptr-G.inbuf) + length);
    1b07:	01 c3                	add    %eax,%ebx
        if ((G.extra_field = (uch *)malloc(length)) == (uch *)NULL) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(ExtraFieldTooLong),
              length));
            /* cur_zipfile_bufstart already takes account of extra_bytes,
             * so don't correct for it twice: */
            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +
    1b09:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1b0d:	e8 0e eb ff ff       	call   620 <_seek_zipf>
    unsigned int length;        /* without prototype, ush converted to this */
    int option;
{
    unsigned comment_bytes_left;
    unsigned int block_len;
    int error=PK_OK;
    1b12:	31 c0                	xor    %eax,%eax
    1b14:	e9 a1 fb ff ff       	jmp    16ba <_do_string+0x6a>

        if (G.pInfo->lcflag)      /* replace with lowercase filename */
            STRLOWER(G.filename, G.filename);

        if (G.pInfo->vollabel && length > 8 && G.filename[8] == '.') {
            char *p = G.filename+8;
    1b19:	8d 95 e8 09 01 00    	lea    0x109e8(%ebp),%edx
            while (*p++)
    1b1f:	8d 8d e9 09 01 00    	lea    0x109e9(%ebp),%ecx
    1b25:	31 c0                	xor    %eax,%eax
                p[-1] = *p;  /* disk label, and 8th char is dot:  remove dot */
    1b27:	8a 5c 02 01          	mov    0x1(%edx,%eax,1),%bl
    1b2b:	88 1c 02             	mov    %bl,(%edx,%eax,1)
    1b2e:	40                   	inc    %eax
        if (G.pInfo->lcflag)      /* replace with lowercase filename */
            STRLOWER(G.filename, G.filename);

        if (G.pInfo->vollabel && length > 8 && G.filename[8] == '.') {
            char *p = G.filename+8;
            while (*p++)
    1b2f:	80 7c 01 ff 00       	cmpb   $0x0,-0x1(%ecx,%eax,1)
    1b34:	75 f1                	jne    1b27 <_do_string+0x4d7>
    1b36:	e9 66 fe ff ff       	jmp    19a1 <_do_string+0x351>
     */

    case DS_FN:
    case DS_FN_L:
        if (length >= FILNAMSIZ) {
            Info(slide, 0x401, ((char *)slide,
    1b3b:	66 8b 0e             	mov    (%esi),%cx
    1b3e:	83 c7 02             	add    $0x2,%edi
    1b41:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    1b45:	83 c6 02             	add    $0x2,%esi
    1b48:	83 e8 02             	sub    $0x2,%eax
    1b4b:	e9 02 ff ff ff       	jmp    1a52 <_do_string+0x402>
    1b50:	a0 5c 00 00 00       	mov    0x5c,%al
    1b55:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    1b5b:	88 85 dc 08 00 00    	mov    %al,0x8dc(%ebp)
    1b61:	be 5d 00 00 00       	mov    $0x5d,%esi
    1b66:	b8 29 00 00 00       	mov    $0x29,%eax
    1b6b:	e9 d6 fe ff ff       	jmp    1a46 <_do_string+0x3f6>

00001b70 <_makeword>:
/* Function makeword() */
/***********************/

ush makeword(b)
    ZCONST uch *b;
{
    1b70:	8b 54 24 04          	mov    0x4(%esp),%edx
    /*
     * Convert Intel style 'short' integer to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (ush)((b[1] << 8) | b[0]);
    1b74:	31 c0                	xor    %eax,%eax
    1b76:	8a 0a                	mov    (%edx),%cl
    1b78:	8a 42 01             	mov    0x1(%edx),%al
    1b7b:	c1 e0 08             	shl    $0x8,%eax
    1b7e:	81 e1 ff 00 00 00    	and    $0xff,%ecx
    1b84:	89 ca                	mov    %ecx,%edx
    1b86:	09 d0                	or     %edx,%eax
}
    1b88:	c3                   	ret    
    1b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001b90 <_makelong>:
/* Function makelong() */
/***********************/

ulg makelong(sig)
    ZCONST uch *sig;
{
    1b90:	8b 54 24 04          	mov    0x4(%esp),%edx
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
    1b94:	31 c0                	xor    %eax,%eax
    1b96:	8a 42 03             	mov    0x3(%edx),%al
    1b99:	c1 e0 18             	shl    $0x18,%eax
    1b9c:	89 c1                	mov    %eax,%ecx
        + (((ulg)sig[2]) << 16)
    1b9e:	31 c0                	xor    %eax,%eax
    1ba0:	8a 42 02             	mov    0x2(%edx),%al
    1ba3:	c1 e0 10             	shl    $0x10,%eax
    1ba6:	01 c8                	add    %ecx,%eax
        + (((ulg)sig[1]) << 8)
        + ((ulg)sig[0]);
    1ba8:	31 c9                	xor    %ecx,%ecx
    1baa:	8a 0a                	mov    (%edx),%cl
    1bac:	01 c1                	add    %eax,%ecx
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
        + (((ulg)sig[2]) << 16)
        + (((ulg)sig[1]) << 8)
    1bae:	31 c0                	xor    %eax,%eax
    1bb0:	8a 42 01             	mov    0x1(%edx),%al
    1bb3:	c1 e0 08             	shl    $0x8,%eax
{
    /*
     * Convert intel style 'long' variable to non-Intel non-16-bit
     * host format.  This routine also takes care of byte-ordering.
     */
    return (((ulg)sig[3]) << 24)
    1bb6:	01 c8                	add    %ecx,%eax
        + (((ulg)sig[2]) << 16)
        + (((ulg)sig[1]) << 8)
        + ((ulg)sig[0]);
}
    1bb8:	c3                   	ret    
    1bb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001bc0 <_plastchar>:
/************************/

char *plastchar(ptr, len)
    ZCONST char *ptr;
    extent len;
{
    1bc0:	57                   	push   %edi
    1bc1:	56                   	push   %esi
    1bc2:	53                   	push   %ebx
    1bc3:	83 ec 20             	sub    $0x20,%esp
    1bc6:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    1bca:	8b 74 24 34          	mov    0x34(%esp),%esi
    unsigned clen;
    ZCONST char *oldptr = ptr;
    while(*ptr != '\0' && len > 0){
    1bce:	80 3b 00             	cmpb   $0x0,(%ebx)
    1bd1:	74 33                	je     1c06 <_plastchar+0x46>
    1bd3:	85 f6                	test   %esi,%esi
    1bd5:	74 2f                	je     1c06 <_plastchar+0x46>
    1bd7:	8b 3d 00 00 00 00    	mov    0x0,%edi
    1bdd:	eb 03                	jmp    1be2 <_plastchar+0x22>
    1bdf:	90                   	nop
    1be0:	89 cb                	mov    %ecx,%ebx
        oldptr = ptr;
        clen = CLEN(ptr);
    1be2:	8b 07                	mov    (%edi),%eax
    1be4:	89 1c 24             	mov    %ebx,(%esp)
    1be7:	89 44 24 04          	mov    %eax,0x4(%esp)
    1beb:	e8 00 00 00 00       	call   1bf0 <_plastchar+0x30>
        ptr += clen;
    1bf0:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
    ZCONST char *ptr;
    extent len;
{
    unsigned clen;
    ZCONST char *oldptr = ptr;
    while(*ptr != '\0' && len > 0){
    1bf3:	80 39 00             	cmpb   $0x0,(%ecx)
    1bf6:	0f 95 44 24 1f       	setne  0x1f(%esp)
    1bfb:	29 c6                	sub    %eax,%esi
    1bfd:	0f 95 c2             	setne  %dl
    1c00:	84 54 24 1f          	test   %dl,0x1f(%esp)
    1c04:	75 da                	jne    1be0 <_plastchar+0x20>
        clen = CLEN(ptr);
        ptr += clen;
        len -= clen;
    }
    return (char *)oldptr;
}
    1c06:	83 c4 20             	add    $0x20,%esp
    1c09:	89 d8                	mov    %ebx,%eax
    1c0b:	5b                   	pop    %ebx
    1c0c:	5e                   	pop    %esi
    1c0d:	5f                   	pop    %edi
    1c0e:	c3                   	ret    
    1c0f:	90                   	nop

00001c10 <_uzmbschr>:
/***********************/

unsigned char *uzmbschr(str, c)
    ZCONST unsigned char *str;
    unsigned int c;
{
    1c10:	57                   	push   %edi
    1c11:	56                   	push   %esi
    1c12:	53                   	push   %ebx
    1c13:	83 ec 10             	sub    $0x10,%esp
    1c16:	8b 7c 24 20          	mov    0x20(%esp),%edi
    1c1a:	8b 5c 24 24          	mov    0x24(%esp),%ebx
    while(*str != '\0'){
    1c1e:	8a 07                	mov    (%edi),%al
    1c20:	84 c0                	test   %al,%al
    1c22:	74 31                	je     1c55 <_uzmbschr+0x45>
        if (*str == c) {return (unsigned char *)str;}
    1c24:	25 ff 00 00 00       	and    $0xff,%eax
    1c29:	8b 35 00 00 00 00    	mov    0x0,%esi
    1c2f:	39 d8                	cmp    %ebx,%eax
    1c31:	75 0c                	jne    1c3f <_uzmbschr+0x2f>
    1c33:	eb 2b                	jmp    1c60 <_uzmbschr+0x50>
    1c35:	81 e2 ff 00 00 00    	and    $0xff,%edx
    1c3b:	39 da                	cmp    %ebx,%edx
    1c3d:	74 21                	je     1c60 <_uzmbschr+0x50>
        INCSTR(str);
    1c3f:	8b 06                	mov    (%esi),%eax
    1c41:	89 3c 24             	mov    %edi,(%esp)
    1c44:	89 44 24 04          	mov    %eax,0x4(%esp)
    1c48:	e8 00 00 00 00       	call   1c4d <_uzmbschr+0x3d>
    1c4d:	01 c7                	add    %eax,%edi

unsigned char *uzmbschr(str, c)
    ZCONST unsigned char *str;
    unsigned int c;
{
    while(*str != '\0'){
    1c4f:	8a 17                	mov    (%edi),%dl
    1c51:	84 d2                	test   %dl,%dl
    1c53:	75 e0                	jne    1c35 <_uzmbschr+0x25>
        if (*str == c) {return (unsigned char *)str;}
        INCSTR(str);
    }
    return NULL;
}
    1c55:	83 c4 10             	add    $0x10,%esp
{
    while(*str != '\0'){
        if (*str == c) {return (unsigned char *)str;}
        INCSTR(str);
    }
    return NULL;
    1c58:	31 c0                	xor    %eax,%eax
}
    1c5a:	5b                   	pop    %ebx
    1c5b:	5e                   	pop    %esi
    1c5c:	5f                   	pop    %edi
    1c5d:	c3                   	ret    
    1c5e:	66 90                	xchg   %ax,%ax
    1c60:	83 c4 10             	add    $0x10,%esp
unsigned char *uzmbschr(str, c)
    ZCONST unsigned char *str;
    unsigned int c;
{
    while(*str != '\0'){
        if (*str == c) {return (unsigned char *)str;}
    1c63:	89 f8                	mov    %edi,%eax
        INCSTR(str);
    }
    return NULL;
}
    1c65:	5b                   	pop    %ebx
    1c66:	5e                   	pop    %esi
    1c67:	5f                   	pop    %edi
    1c68:	c3                   	ret    
    1c69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001c70 <_uzmbsrchr>:
/************************/

unsigned char *uzmbsrchr(str, c)
    ZCONST unsigned char *str;
    unsigned int c;
{
    1c70:	55                   	push   %ebp
    1c71:	57                   	push   %edi
    1c72:	56                   	push   %esi
    1c73:	53                   	push   %ebx
    1c74:	83 ec 1c             	sub    $0x1c,%esp
    unsigned char *match = NULL;
    while(*str != '\0'){
    1c77:	31 ed                	xor    %ebp,%ebp
/************************/

unsigned char *uzmbsrchr(str, c)
    ZCONST unsigned char *str;
    unsigned int c;
{
    1c79:	8b 7c 24 30          	mov    0x30(%esp),%edi
    1c7d:	8b 5c 24 34          	mov    0x34(%esp),%ebx
    unsigned char *match = NULL;
    while(*str != '\0'){
    1c81:	8a 17                	mov    (%edi),%dl
    1c83:	84 d2                	test   %dl,%dl
    1c85:	74 2a                	je     1cb1 <_uzmbsrchr+0x41>
    1c87:	8b 35 00 00 00 00    	mov    0x0,%esi
    1c8d:	8d 76 00             	lea    0x0(%esi),%esi
        if (*str == c) {match = (unsigned char *)str;}
        INCSTR(str);
    1c90:	8b 06                	mov    (%esi),%eax
    ZCONST unsigned char *str;
    unsigned int c;
{
    unsigned char *match = NULL;
    while(*str != '\0'){
        if (*str == c) {match = (unsigned char *)str;}
    1c92:	81 e2 ff 00 00 00    	and    $0xff,%edx
        INCSTR(str);
    1c98:	89 3c 24             	mov    %edi,(%esp)
    1c9b:	89 44 24 04          	mov    %eax,0x4(%esp)
    ZCONST unsigned char *str;
    unsigned int c;
{
    unsigned char *match = NULL;
    while(*str != '\0'){
        if (*str == c) {match = (unsigned char *)str;}
    1c9f:	39 da                	cmp    %ebx,%edx
    1ca1:	0f 44 ef             	cmove  %edi,%ebp
        INCSTR(str);
    1ca4:	e8 00 00 00 00       	call   1ca9 <_uzmbsrchr+0x39>
    1ca9:	01 c7                	add    %eax,%edi
unsigned char *uzmbsrchr(str, c)
    ZCONST unsigned char *str;
    unsigned int c;
{
    unsigned char *match = NULL;
    while(*str != '\0'){
    1cab:	8a 17                	mov    (%edi),%dl
    1cad:	84 d2                	test   %dl,%dl
    1caf:	75 df                	jne    1c90 <_uzmbsrchr+0x20>
        if (*str == c) {match = (unsigned char *)str;}
        INCSTR(str);
    }
    return match;
}
    1cb1:	83 c4 1c             	add    $0x1c,%esp
    1cb4:	89 e8                	mov    %ebp,%eax
    1cb6:	5b                   	pop    %ebx
    1cb7:	5e                   	pop    %esi
    1cb8:	5f                   	pop    %edi
    1cb9:	5d                   	pop    %ebp
    1cba:	c3                   	ret    
    1cbb:	90                   	nop
    1cbc:	90                   	nop
    1cbd:	90                   	nop
    1cbe:	90                   	nop
    1cbf:	90                   	nop

globals.o:     file format pe-i386


Disassembly of section .text:

00000000 <_globalsCtor>:
#endif /* ?REENTRANT */



Uz_Globs *globalsCtor()
{
   0:	57                   	push   %edi
   1:	83 ec 18             	sub    $0x18,%esp
#ifdef REENTRANT
    Uz_Globs *pG = (Uz_Globs *)malloc(sizeof(Uz_Globs));
   4:	c7 04 24 c0 0c 01 00 	movl   $0x10cc0,(%esp)
   b:	e8 00 00 00 00       	call   10 <_globalsCtor+0x10>
  10:	89 c2                	mov    %eax,%edx

    if (!pG)
  12:	85 c0                	test   %eax,%eax
  14:	74 74                	je     8a <_globalsCtor+0x8a>
        return (Uz_Globs *)NULL;
#endif /* REENTRANT */

    /* for REENTRANT version, G is defined as (*pG) */

    memzero(&G, sizeof(Uz_Globs));
  16:	31 c0                	xor    %eax,%eax
  18:	b9 30 43 00 00       	mov    $0x4330,%ecx
  1d:	89 d7                	mov    %edx,%edi

#ifdef REENTRANT
#ifdef USETHREADID
    registerGlobalPointer(__G);
#else
    GG = &G;
  1f:	89 15 00 00 00 00    	mov    %edx,0x0
        return (Uz_Globs *)NULL;
#endif /* REENTRANT */

    /* for REENTRANT version, G is defined as (*pG) */

    memzero(&G, sizeof(Uz_Globs));
  25:	f3 ab                	rep stos %eax,%es:(%edi)

    uO.lflag=(-1);
    G.wildzipfn = "";
    G.pfnames = (char **)fnames;
    G.pxnames = (char **)&fnames[1];
    G.pInfo = G.info;
  27:	8d 82 d8 00 00 00    	lea    0xd8(%edx),%eax
#endif
#ifdef TANDEM
    uO.aflag=1;     /* default to '-a' auto create Text Files as type 101 */
#endif

    uO.lflag=(-1);
  2d:	c7 42 28 ff ff ff ff 	movl   $0xffffffff,0x28(%edx)
    G.wildzipfn = "";
  34:	c7 82 00 09 01 00 00 	movl   $0x0,0x10900(%edx)
  3b:	00 00 00 
    G.pfnames = (char **)fnames;
  3e:	c7 82 c0 00 00 00 00 	movl   $0x0,0xc0(%edx)
  45:	00 00 00 
    G.pxnames = (char **)&fnames[1];
  48:	c7 82 c4 00 00 00 04 	movl   $0x4,0xc4(%edx)
  4f:	00 00 00 
    G.pInfo = G.info;
  52:	89 82 d8 08 00 00    	mov    %eax,0x8d8(%edx)
    G.sol = TRUE;          /* at start of line */
  58:	c7 82 c0 09 01 00 01 	movl   $0x1,0x109c0(%edx)
  5f:	00 00 00 

    G.message = UzpMessagePrnt;
  62:	c7 82 44 0b 01 00 00 	movl   $0x0,0x10b44(%edx)
  69:	00 00 00 
    G.input = UzpInput;           /* not used by anyone at the moment... */
  6c:	c7 82 48 0b 01 00 00 	movl   $0x0,0x10b48(%edx)
  73:	00 00 00 
#if defined(WINDLL) || defined(MACOS)
    G.mpause = NULL;              /* has scrollbars:  no need for pausing */
  76:	c7 82 4c 0b 01 00 00 	movl   $0x0,0x10b4c(%edx)
  7d:	00 00 00 
#else
    G.mpause = UzpMorePause;
#endif
    G.decr_passwd = UzpPassword;
  80:	c7 82 50 0b 01 00 00 	movl   $0x0,0x10b50(%edx)
  87:	00 00 00 
    GG = &G;
#endif /* ?USETHREADID */
#endif /* REENTRANT */

    return &G;
}
  8a:	83 c4 18             	add    $0x18,%esp
  8d:	89 d0                	mov    %edx,%eax
  8f:	5f                   	pop    %edi
  90:	c3                   	ret    
  91:	90                   	nop
  92:	90                   	nop
  93:	90                   	nop
  94:	90                   	nop
  95:	90                   	nop
  96:	90                   	nop
  97:	90                   	nop
  98:	90                   	nop
  99:	90                   	nop
  9a:	90                   	nop
  9b:	90                   	nop
  9c:	90                   	nop
  9d:	90                   	nop
  9e:	90                   	nop
  9f:	90                   	nop

inflate.o:     file format pe-i386


Disassembly of section .text:

00000000 <_inflate_codes>:
     __GDEF
struct huft *tl, *td;   /* literal/length and distance decoder tables */
unsigned bl, bd;        /* number of bits decoded by tl[] and td[] */
/* inflate (decompress) the codes in a deflated (compressed) block.
   Return an error code or zero if it all goes ok. */
{
       0:	55                   	push   %ebp
       1:	57                   	push   %edi
       2:	56                   	push   %esi
       3:	53                   	push   %ebx
       4:	83 ec 4c             	sub    $0x4c,%esp
       7:	8b 7c 24 60          	mov    0x60(%esp),%edi


  /* make local copies of globals */
  b = G.bb;                       /* initialize bit buffer */
  k = G.bk;
  w = G.wp;                       /* initialize window position */
       b:	8b 87 38 0b 01 00    	mov    0x10b38(%edi),%eax
  register unsigned k;  /* number of bits in bit buffer */
  int retval = 0;       /* error code returned: initialized to "no error" */


  /* make local copies of globals */
  b = G.bb;                       /* initialize bit buffer */
      11:	8b 97 3c 0b 01 00    	mov    0x10b3c(%edi),%edx
  k = G.bk;
  w = G.wp;                       /* initialize window position */
      17:	89 44 24 20          	mov    %eax,0x20(%esp)


  /* inflate the coded data */
  ml = mask_bits[bl];           /* precompute masks for speed */
      1b:	8b 44 24 6c          	mov    0x6c(%esp),%eax
  int retval = 0;       /* error code returned: initialized to "no error" */


  /* make local copies of globals */
  b = G.bb;                       /* initialize bit buffer */
  k = G.bk;
      1f:	8b 9f 40 0b 01 00    	mov    0x10b40(%edi),%ebx
      25:	89 d6                	mov    %edx,%esi
  w = G.wp;                       /* initialize window position */


  /* inflate the coded data */
  ml = mask_bits[bl];           /* precompute masks for speed */
      27:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
      2e:	89 44 24 24          	mov    %eax,0x24(%esp)
  md = mask_bits[bd];
      32:	8b 44 24 70          	mov    0x70(%esp),%eax
      36:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
      3d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  while (1)                     /* do until end of block */
  {
    NEEDBITS(bl)
      41:	3b 5c 24 6c          	cmp    0x6c(%esp),%ebx
      45:	7d 3f                	jge    86 <_inflate_codes+0x86>
      47:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
      4d:	85 c0                	test   %eax,%eax
      4f:	8d 50 ff             	lea    -0x1(%eax),%edx
      52:	89 97 ec 08 01 00    	mov    %edx,0x108ec(%edi)
      58:	0f 8e 93 03 00 00    	jle    3f1 <_inflate_codes+0x3f1>
      5e:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
      64:	8d 50 01             	lea    0x1(%eax),%edx
      67:	89 97 e8 08 01 00    	mov    %edx,0x108e8(%edi)
      6d:	8a 08                	mov    (%eax),%cl
      6f:	81 e1 ff 00 00 00    	and    $0xff,%ecx
      75:	89 c8                	mov    %ecx,%eax
      77:	88 d9                	mov    %bl,%cl
      79:	83 c3 08             	add    $0x8,%ebx
      7c:	d3 e0                	shl    %cl,%eax
      7e:	09 c6                	or     %eax,%esi
      80:	3b 5c 24 6c          	cmp    0x6c(%esp),%ebx
      84:	7c c1                	jl     47 <_inflate_codes+0x47>
    t = tl + ((unsigned)b & ml);
      86:	8b 44 24 24          	mov    0x24(%esp),%eax
      8a:	8b 4c 24 64          	mov    0x64(%esp),%ecx
      8e:	21 f0                	and    %esi,%eax
      90:	8d 14 c1             	lea    (%ecx,%eax,8),%edx
    while (1) {
      DUMPBITS(t->b)
      93:	31 c0                	xor    %eax,%eax
      95:	8a 4a 01             	mov    0x1(%edx),%cl
      98:	8a 42 01             	mov    0x1(%edx),%al
      9b:	29 c3                	sub    %eax,%ebx

      if ((e = t->e) == 32)     /* then it's a literal */
      9d:	8a 02                	mov    (%edx),%al
      9f:	89 c5                	mov    %eax,%ebp
      a1:	81 e5 ff 00 00 00    	and    $0xff,%ebp
  while (1)                     /* do until end of block */
  {
    NEEDBITS(bl)
    t = tl + ((unsigned)b & ml);
    while (1) {
      DUMPBITS(t->b)
      a7:	d3 ee                	shr    %cl,%esi

      if ((e = t->e) == 32)     /* then it's a literal */
      a9:	83 fd 20             	cmp    $0x20,%ebp
      ac:	0f 84 b0 01 00 00    	je     262 <_inflate_codes+0x262>
          w = 0;
        }
        break;
      }

      if (e < 31)               /* then it's a length */
      b2:	83 fd 1e             	cmp    $0x1e,%ebp
      b5:	0f 86 1f 02 00 00    	jbe    2da <_inflate_codes+0x2da>
          }
        } while (n);
        break;
      }

      if (e == 31)              /* it's the EOB signal */
      bb:	83 fd 1f             	cmp    $0x1f,%ebp
      be:	0f 84 f6 01 00 00    	je     2ba <_inflate_codes+0x2ba>
      {
        /* sorry for this goto, but we have to exit two loops at once */
        goto cleanup_decode;
      }

      if (IS_INVALID_CODE(e))
      c4:	83 fd 63             	cmp    $0x63,%ebp
      c7:	0f 84 88 01 00 00    	je     255 <_inflate_codes+0x255>
        return 1;

      e &= 31;
      cd:	89 c5                	mov    %eax,%ebp
      cf:	83 e5 1f             	and    $0x1f,%ebp
      NEEDBITS(e)
      d2:	39 dd                	cmp    %ebx,%ebp
      d4:	7e 64                	jle    13a <_inflate_codes+0x13a>
      d6:	89 d9                	mov    %ebx,%ecx
      d8:	89 54 24 1c          	mov    %edx,0x1c(%esp)
      dc:	eb 26                	jmp    104 <_inflate_codes+0x104>
      de:	66 90                	xchg   %ax,%ax
      e0:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
      e6:	8d 58 01             	lea    0x1(%eax),%ebx
      e9:	89 9f e8 08 01 00    	mov    %ebx,0x108e8(%edi)
      ef:	8a 10                	mov    (%eax),%dl
      f1:	81 e2 ff 00 00 00    	and    $0xff,%edx
      f7:	89 d0                	mov    %edx,%eax
      f9:	d3 e0                	shl    %cl,%eax
      fb:	83 c1 08             	add    $0x8,%ecx
      fe:	09 c6                	or     %eax,%esi
     100:	39 e9                	cmp    %ebp,%ecx
     102:	7d 4c                	jge    150 <_inflate_codes+0x150>
     104:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
     10a:	85 c0                	test   %eax,%eax
     10c:	8d 58 ff             	lea    -0x1(%eax),%ebx
     10f:	89 9f ec 08 01 00    	mov    %ebx,0x108ec(%edi)
     115:	7f c9                	jg     e0 <_inflate_codes+0xe0>
     117:	89 3c 24             	mov    %edi,(%esp)
     11a:	89 4c 24 18          	mov    %ecx,0x18(%esp)
     11e:	e8 00 00 00 00       	call   123 <_inflate_codes+0x123>
     123:	8b 4c 24 18          	mov    0x18(%esp),%ecx
     127:	83 f8 ff             	cmp    $0xffffffff,%eax
     12a:	75 cd                	jne    f9 <_inflate_codes+0xf9>
     12c:	89 cb                	mov    %ecx,%ebx
     12e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
     132:	85 c9                	test   %ecx,%ecx
     134:	0f 88 1b 01 00 00    	js     255 <_inflate_codes+0x255>
      t = t->v.t + ((unsigned)b & mask_bits[e]);
     13a:	8b 04 ad 00 00 00 00 	mov    0x0(,%ebp,4),%eax
     141:	8b 4a 04             	mov    0x4(%edx),%ecx
     144:	21 f0                	and    %esi,%eax
     146:	8d 04 c1             	lea    (%ecx,%eax,8),%eax
     149:	89 c2                	mov    %eax,%edx
     14b:	e9 43 ff ff ff       	jmp    93 <_inflate_codes+0x93>
     150:	89 cb                	mov    %ecx,%ebx
     152:	8b 54 24 1c          	mov    0x1c(%esp),%edx
     156:	eb e2                	jmp    13a <_inflate_codes+0x13a>
     158:	89 ea                	mov    %ebp,%edx
     15a:	89 cb                	mov    %ecx,%ebx
        n = t->v.n + ((unsigned)b & mask_bits[e]);
        DUMPBITS(e)

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
     15c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     160:	8b 4c 24 68          	mov    0x68(%esp),%ecx
     164:	21 d0                	and    %edx,%eax
     166:	8d 04 c1             	lea    (%ecx,%eax,8),%eax
        while (1) {
          DUMPBITS(t->b)
     169:	89 44 24 18          	mov    %eax,0x18(%esp)
     16d:	8a 40 01             	mov    0x1(%eax),%al
     170:	88 44 24 1c          	mov    %al,0x1c(%esp)
     174:	31 c0                	xor    %eax,%eax
     176:	8a 44 24 1c          	mov    0x1c(%esp),%al
     17a:	8a 4c 24 1c          	mov    0x1c(%esp),%cl
     17e:	29 c3                	sub    %eax,%ebx
          if ((e = t->e) < 32)
     180:	8b 44 24 18          	mov    0x18(%esp),%eax

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
        while (1) {
          DUMPBITS(t->b)
     184:	89 dd                	mov    %ebx,%ebp
          if ((e = t->e) < 32)
     186:	8a 18                	mov    (%eax),%bl
     188:	88 d8                	mov    %bl,%al

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
        while (1) {
          DUMPBITS(t->b)
     18a:	d3 ea                	shr    %cl,%edx
          if ((e = t->e) < 32)
     18c:	25 ff 00 00 00       	and    $0xff,%eax

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
        while (1) {
          DUMPBITS(t->b)
     191:	89 54 24 28          	mov    %edx,0x28(%esp)
          if ((e = t->e) < 32)
     195:	89 44 24 30          	mov    %eax,0x30(%esp)
     199:	83 f8 1f             	cmp    $0x1f,%eax
     19c:	0f 86 89 02 00 00    	jbe    42b <_inflate_codes+0x42b>
            break;
          if (IS_INVALID_CODE(e))
     1a2:	83 f8 63             	cmp    $0x63,%eax
     1a5:	0f 84 aa 00 00 00    	je     255 <_inflate_codes+0x255>
     1ab:	89 74 24 34          	mov    %esi,0x34(%esp)
     1af:	8b 54 24 18          	mov    0x18(%esp),%edx
     1b3:	8b 74 24 28          	mov    0x28(%esp),%esi
            return 1;
          e &= 31;
     1b7:	83 e3 1f             	and    $0x1f,%ebx
          NEEDBITS(e)
     1ba:	39 eb                	cmp    %ebp,%ebx
     1bc:	7e 62                	jle    220 <_inflate_codes+0x220>
     1be:	89 e9                	mov    %ebp,%ecx
     1c0:	89 54 24 1c          	mov    %edx,0x1c(%esp)
     1c4:	eb 28                	jmp    1ee <_inflate_codes+0x1ee>
     1c6:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
     1cc:	8d 68 01             	lea    0x1(%eax),%ebp
     1cf:	89 af e8 08 01 00    	mov    %ebp,0x108e8(%edi)
     1d5:	8a 10                	mov    (%eax),%dl
     1d7:	81 e2 ff 00 00 00    	and    $0xff,%edx
     1dd:	89 d0                	mov    %edx,%eax
     1df:	d3 e0                	shl    %cl,%eax
     1e1:	83 c1 08             	add    $0x8,%ecx
     1e4:	09 c6                	or     %eax,%esi
     1e6:	39 cb                	cmp    %ecx,%ebx
     1e8:	0f 8e f8 01 00 00    	jle    3e6 <_inflate_codes+0x3e6>
     1ee:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
     1f4:	85 c0                	test   %eax,%eax
     1f6:	8d 68 ff             	lea    -0x1(%eax),%ebp
     1f9:	89 af ec 08 01 00    	mov    %ebp,0x108ec(%edi)
     1ff:	7f c5                	jg     1c6 <_inflate_codes+0x1c6>
     201:	89 3c 24             	mov    %edi,(%esp)
     204:	89 4c 24 18          	mov    %ecx,0x18(%esp)
     208:	e8 00 00 00 00       	call   20d <_inflate_codes+0x20d>
     20d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
     211:	83 f8 ff             	cmp    $0xffffffff,%eax
     214:	75 c9                	jne    1df <_inflate_codes+0x1df>
     216:	89 cd                	mov    %ecx,%ebp
     218:	8b 54 24 1c          	mov    0x1c(%esp),%edx
     21c:	85 c9                	test   %ecx,%ecx
     21e:	78 35                	js     255 <_inflate_codes+0x255>
          t = t->v.t + ((unsigned)b & mask_bits[e]);
     220:	8b 04 9d 00 00 00 00 	mov    0x0(,%ebx,4),%eax
     227:	8b 5a 04             	mov    0x4(%edx),%ebx
     22a:	21 f0                	and    %esi,%eax
     22c:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
     22f:	89 c2                	mov    %eax,%edx

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
        while (1) {
          DUMPBITS(t->b)
     231:	31 c0                	xor    %eax,%eax
     233:	8a 42 01             	mov    0x1(%edx),%al
          if ((e = t->e) < 32)
     236:	8a 1a                	mov    (%edx),%bl

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
        while (1) {
          DUMPBITS(t->b)
     238:	29 c5                	sub    %eax,%ebp
          if ((e = t->e) < 32)
     23a:	31 c0                	xor    %eax,%eax

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
        while (1) {
          DUMPBITS(t->b)
     23c:	8a 4a 01             	mov    0x1(%edx),%cl
          if ((e = t->e) < 32)
     23f:	88 d8                	mov    %bl,%al

        /* decode distance of block to copy */
        NEEDBITS(bd)
        t = td + ((unsigned)b & md);
        while (1) {
          DUMPBITS(t->b)
     241:	d3 ee                	shr    %cl,%esi
          if ((e = t->e) < 32)
     243:	83 f8 1f             	cmp    $0x1f,%eax
     246:	0f 86 cf 01 00 00    	jbe    41b <_inflate_codes+0x41b>
            break;
          if (IS_INVALID_CODE(e))
     24c:	83 f8 63             	cmp    $0x63,%eax
     24f:	0f 85 62 ff ff ff    	jne    1b7 <_inflate_codes+0x1b7>
  /* inflate the coded data */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
  while (1)                     /* do until end of block */
  {
    NEEDBITS(bl)
     255:	b8 01 00 00 00       	mov    $0x1,%eax


cleanup_and_exit:
  /* done */
  return retval;
}
     25a:	83 c4 4c             	add    $0x4c,%esp
     25d:	5b                   	pop    %ebx
     25e:	5e                   	pop    %esi
     25f:	5f                   	pop    %edi
     260:	5d                   	pop    %ebp
     261:	c3                   	ret    
    while (1) {
      DUMPBITS(t->b)

      if ((e = t->e) == 32)     /* then it's a literal */
      {
        redirSlide[w++] = (uch)t->v.n;
     262:	8b 4c 24 20          	mov    0x20(%esp),%ecx
     266:	8b 87 bc 00 00 00    	mov    0xbc(%edi),%eax
     26c:	8b 52 04             	mov    0x4(%edx),%edx
     26f:	88 14 08             	mov    %dl,(%eax,%ecx,1)
     272:	8d 41 01             	lea    0x1(%ecx),%eax
     275:	89 44 24 20          	mov    %eax,0x20(%esp)
        if (w == wsize)
     279:	39 87 ac 00 00 00    	cmp    %eax,0xac(%edi)
     27f:	0f 85 bc fd ff ff    	jne    41 <_inflate_codes+0x41>
        {
          if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
     285:	8b af a0 09 01 00    	mov    0x109a0(%edi),%ebp
     28b:	85 ed                	test   %ebp,%ebp
     28d:	0f 84 99 03 00 00    	je     62c <_inflate_codes+0x62c>
     293:	89 44 24 08          	mov    %eax,0x8(%esp)
     297:	8b 87 bc 00 00 00    	mov    0xbc(%edi),%eax
     29d:	89 3c 24             	mov    %edi,(%esp)
     2a0:	89 44 24 04          	mov    %eax,0x4(%esp)
     2a4:	e8 00 00 00 00       	call   2a9 <_inflate_codes+0x2a9>
     2a9:	85 c0                	test   %eax,%eax
     2ab:	75 ad                	jne    25a <_inflate_codes+0x25a>
          w = 0;
     2ad:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
     2b4:	00 
     2b5:	e9 87 fd ff ff       	jmp    41 <_inflate_codes+0x41>
    }
  }
cleanup_decode:

  /* restore the globals from the locals */
  G.wp = (unsigned)w;             /* restore global window pointer */
     2ba:	8b 44 24 20          	mov    0x20(%esp),%eax
  G.bb = b;                       /* restore global bit buffer */
     2be:	89 b7 3c 0b 01 00    	mov    %esi,0x10b3c(%edi)
    }
  }
cleanup_decode:

  /* restore the globals from the locals */
  G.wp = (unsigned)w;             /* restore global window pointer */
     2c4:	89 87 38 0b 01 00    	mov    %eax,0x10b38(%edi)
  G.bb = b;                       /* restore global bit buffer */
  G.bk = k;
     2ca:	89 9f 40 0b 01 00    	mov    %ebx,0x10b40(%edi)


cleanup_and_exit:
  /* done */
  return retval;
}
     2d0:	83 c4 4c             	add    $0x4c,%esp
cleanup_decode:

  /* restore the globals from the locals */
  G.wp = (unsigned)w;             /* restore global window pointer */
  G.bb = b;                       /* restore global bit buffer */
  G.bk = k;
     2d3:	31 c0                	xor    %eax,%eax


cleanup_and_exit:
  /* done */
  return retval;
}
     2d5:	5b                   	pop    %ebx
     2d6:	5e                   	pop    %esi
     2d7:	5f                   	pop    %edi
     2d8:	5d                   	pop    %ebp
     2d9:	c3                   	ret    
      }

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
     2da:	88 c1                	mov    %al,%cl
     2dc:	81 e1 ff 00 00 00    	and    $0xff,%ecx
     2e2:	89 c8                	mov    %ecx,%eax
     2e4:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     2e8:	39 d9                	cmp    %ebx,%ecx
     2ea:	7e 68                	jle    354 <_inflate_codes+0x354>
     2ec:	89 d9                	mov    %ebx,%ecx
     2ee:	89 54 24 1c          	mov    %edx,0x1c(%esp)
     2f2:	89 c3                	mov    %eax,%ebx
     2f4:	eb 28                	jmp    31e <_inflate_codes+0x31e>
     2f6:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
     2fc:	8d 50 01             	lea    0x1(%eax),%edx
     2ff:	89 97 e8 08 01 00    	mov    %edx,0x108e8(%edi)
     305:	8a 10                	mov    (%eax),%dl
     307:	81 e2 ff 00 00 00    	and    $0xff,%edx
     30d:	89 d0                	mov    %edx,%eax
     30f:	d3 e0                	shl    %cl,%eax
     311:	83 c1 08             	add    $0x8,%ecx
     314:	09 c6                	or     %eax,%esi
     316:	39 cb                	cmp    %ecx,%ebx
     318:	0f 8e f2 00 00 00    	jle    410 <_inflate_codes+0x410>
     31e:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
     324:	85 c0                	test   %eax,%eax
     326:	8d 50 ff             	lea    -0x1(%eax),%edx
     329:	89 97 ec 08 01 00    	mov    %edx,0x108ec(%edi)
     32f:	7f c5                	jg     2f6 <_inflate_codes+0x2f6>
     331:	89 3c 24             	mov    %edi,(%esp)
     334:	89 4c 24 18          	mov    %ecx,0x18(%esp)
     338:	e8 00 00 00 00       	call   33d <_inflate_codes+0x33d>
     33d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
     341:	83 f8 ff             	cmp    $0xffffffff,%eax
     344:	75 c9                	jne    30f <_inflate_codes+0x30f>
     346:	89 cb                	mov    %ecx,%ebx
     348:	8b 54 24 1c          	mov    0x1c(%esp),%edx
     34c:	85 c9                	test   %ecx,%ecx
     34e:	0f 88 01 ff ff ff    	js     255 <_inflate_codes+0x255>
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     354:	8b 42 04             	mov    0x4(%edx),%eax
        DUMPBITS(e)
     357:	8a 4c 24 28          	mov    0x28(%esp),%cl

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     35b:	66 89 44 24 38       	mov    %ax,0x38(%esp)
        DUMPBITS(e)
     360:	89 f2                	mov    %esi,%edx

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     362:	8b 04 ad 00 00 00 00 	mov    0x0(,%ebp,4),%eax
        DUMPBITS(e)
     369:	29 eb                	sub    %ebp,%ebx
     36b:	d3 ea                	shr    %cl,%edx

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     36d:	89 44 24 3c          	mov    %eax,0x3c(%esp)
        DUMPBITS(e)

        /* decode distance of block to copy */
        NEEDBITS(bd)
     371:	3b 5c 24 70          	cmp    0x70(%esp),%ebx
     375:	0f 8d e1 fd ff ff    	jge    15c <_inflate_codes+0x15c>
     37b:	89 d9                	mov    %ebx,%ecx
     37d:	89 d5                	mov    %edx,%ebp
     37f:	8b 5c 24 70          	mov    0x70(%esp),%ebx
     383:	eb 28                	jmp    3ad <_inflate_codes+0x3ad>
     385:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
     38b:	8d 50 01             	lea    0x1(%eax),%edx
     38e:	89 97 e8 08 01 00    	mov    %edx,0x108e8(%edi)
     394:	8a 10                	mov    (%eax),%dl
     396:	81 e2 ff 00 00 00    	and    $0xff,%edx
     39c:	89 d0                	mov    %edx,%eax
     39e:	d3 e0                	shl    %cl,%eax
     3a0:	83 c1 08             	add    $0x8,%ecx
     3a3:	09 c5                	or     %eax,%ebp
     3a5:	39 d9                	cmp    %ebx,%ecx
     3a7:	0f 8d ab fd ff ff    	jge    158 <_inflate_codes+0x158>
     3ad:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
     3b3:	85 c0                	test   %eax,%eax
     3b5:	8d 50 ff             	lea    -0x1(%eax),%edx
     3b8:	89 97 ec 08 01 00    	mov    %edx,0x108ec(%edi)
     3be:	7f c5                	jg     385 <_inflate_codes+0x385>
     3c0:	89 3c 24             	mov    %edi,(%esp)
     3c3:	89 4c 24 18          	mov    %ecx,0x18(%esp)
     3c7:	e8 00 00 00 00       	call   3cc <_inflate_codes+0x3cc>
     3cc:	8b 4c 24 18          	mov    0x18(%esp),%ecx
     3d0:	83 f8 ff             	cmp    $0xffffffff,%eax
     3d3:	75 c9                	jne    39e <_inflate_codes+0x39e>
     3d5:	89 ea                	mov    %ebp,%edx
     3d7:	89 cb                	mov    %ecx,%ebx
     3d9:	85 c9                	test   %ecx,%ecx
     3db:	0f 89 7b fd ff ff    	jns    15c <_inflate_codes+0x15c>
     3e1:	e9 6f fe ff ff       	jmp    255 <_inflate_codes+0x255>
     3e6:	89 cd                	mov    %ecx,%ebp
     3e8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
     3ec:	e9 2f fe ff ff       	jmp    220 <_inflate_codes+0x220>
  /* inflate the coded data */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
  while (1)                     /* do until end of block */
  {
    NEEDBITS(bl)
     3f1:	89 3c 24             	mov    %edi,(%esp)
     3f4:	e8 00 00 00 00       	call   3f9 <_inflate_codes+0x3f9>
     3f9:	83 f8 ff             	cmp    $0xffffffff,%eax
     3fc:	0f 85 75 fc ff ff    	jne    77 <_inflate_codes+0x77>
     402:	85 db                	test   %ebx,%ebx
     404:	0f 89 7c fc ff ff    	jns    86 <_inflate_codes+0x86>
     40a:	e9 46 fe ff ff       	jmp    255 <_inflate_codes+0x255>
     40f:	90                   	nop
     410:	89 cb                	mov    %ecx,%ebx
     412:	8b 54 24 1c          	mov    0x1c(%esp),%edx
     416:	e9 39 ff ff ff       	jmp    354 <_inflate_codes+0x354>
     41b:	89 74 24 28          	mov    %esi,0x28(%esp)
     41f:	89 44 24 30          	mov    %eax,0x30(%esp)
     423:	8b 74 24 34          	mov    0x34(%esp),%esi
     427:	89 54 24 18          	mov    %edx,0x18(%esp)
            return 1;
          e &= 31;
          NEEDBITS(e)
          t = t->v.t + ((unsigned)b & mask_bits[e]);
        }
        NEEDBITS(e)
     42b:	88 d8                	mov    %bl,%al
     42d:	25 ff 00 00 00       	and    $0xff,%eax
     432:	89 44 24 34          	mov    %eax,0x34(%esp)
     436:	39 e8                	cmp    %ebp,%eax
     438:	7e 6a                	jle    4a4 <_inflate_codes+0x4a4>
     43a:	89 e9                	mov    %ebp,%ecx
     43c:	8b 5c 24 28          	mov    0x28(%esp),%ebx
     440:	8b 6c 24 34          	mov    0x34(%esp),%ebp
     444:	eb 28                	jmp    46e <_inflate_codes+0x46e>
     446:	8b 87 e8 08 01 00    	mov    0x108e8(%edi),%eax
     44c:	8d 50 01             	lea    0x1(%eax),%edx
     44f:	89 97 e8 08 01 00    	mov    %edx,0x108e8(%edi)
     455:	8a 10                	mov    (%eax),%dl
     457:	81 e2 ff 00 00 00    	and    $0xff,%edx
     45d:	89 d0                	mov    %edx,%eax
     45f:	d3 e0                	shl    %cl,%eax
     461:	83 c1 08             	add    $0x8,%ecx
     464:	09 c3                	or     %eax,%ebx
     466:	39 cd                	cmp    %ecx,%ebp
     468:	0f 8e b3 01 00 00    	jle    621 <_inflate_codes+0x621>
     46e:	8b 87 ec 08 01 00    	mov    0x108ec(%edi),%eax
     474:	85 c0                	test   %eax,%eax
     476:	8d 50 ff             	lea    -0x1(%eax),%edx
     479:	89 97 ec 08 01 00    	mov    %edx,0x108ec(%edi)
     47f:	7f c5                	jg     446 <_inflate_codes+0x446>
     481:	89 3c 24             	mov    %edi,(%esp)
     484:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
     488:	e8 00 00 00 00       	call   48d <_inflate_codes+0x48d>
     48d:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
     491:	83 f8 ff             	cmp    $0xffffffff,%eax
     494:	75 c9                	jne    45f <_inflate_codes+0x45f>
     496:	89 5c 24 28          	mov    %ebx,0x28(%esp)
     49a:	89 cd                	mov    %ecx,%ebp
     49c:	85 c9                	test   %ecx,%ecx
     49e:	0f 88 b1 fd ff ff    	js     255 <_inflate_codes+0x255>

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     4a4:	8b 44 24 3c          	mov    0x3c(%esp),%eax
          e &= 31;
          NEEDBITS(e)
          t = t->v.t + ((unsigned)b & mask_bits[e]);
        }
        NEEDBITS(e)
        d = (unsigned)w - t->v.n - ((unsigned)b & mask_bits[e]);
     4a8:	8b 54 24 28          	mov    0x28(%esp),%edx

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     4ac:	21 c6                	and    %eax,%esi
     4ae:	31 c0                	xor    %eax,%eax
     4b0:	66 8b 44 24 38       	mov    0x38(%esp),%ax
          e &= 31;
          NEEDBITS(e)
          t = t->v.t + ((unsigned)b & mask_bits[e]);
        }
        NEEDBITS(e)
        d = (unsigned)w - t->v.n - ((unsigned)b & mask_bits[e]);
     4b5:	89 6c 24 38          	mov    %ebp,0x38(%esp)

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     4b9:	01 f0                	add    %esi,%eax
          e &= 31;
          NEEDBITS(e)
          t = t->v.t + ((unsigned)b & mask_bits[e]);
        }
        NEEDBITS(e)
        d = (unsigned)w - t->v.n - ((unsigned)b & mask_bits[e]);
     4bb:	8b 74 24 18          	mov    0x18(%esp),%esi

      if (e < 31)               /* then it's a length */
      {
        /* get length of block to copy */
        NEEDBITS(e)
        n = t->v.n + ((unsigned)b & mask_bits[e]);
     4bf:	89 44 24 1c          	mov    %eax,0x1c(%esp)
          e &= 31;
          NEEDBITS(e)
          t = t->v.t + ((unsigned)b & mask_bits[e]);
        }
        NEEDBITS(e)
        d = (unsigned)w - t->v.n - ((unsigned)b & mask_bits[e]);
     4c3:	31 c0                	xor    %eax,%eax
     4c5:	66 8b 46 04          	mov    0x4(%esi),%ax
     4c9:	8b 74 24 20          	mov    0x20(%esp),%esi
     4cd:	89 f3                	mov    %esi,%ebx
     4cf:	29 c3                	sub    %eax,%ebx
     4d1:	89 d8                	mov    %ebx,%eax
     4d3:	8b 5c 24 30          	mov    0x30(%esp),%ebx
     4d7:	8b 0c 9d 00 00 00 00 	mov    0x0(,%ebx,4),%ecx
     4de:	21 ca                	and    %ecx,%edx
     4e0:	29 d0                	sub    %edx,%eax
     4e2:	89 44 24 18          	mov    %eax,0x18(%esp)
        DUMPBITS(e)

        /* do the copy */
        do {
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
          if (G.redirect_slide) {
     4e6:	8b 87 a8 00 00 00    	mov    0xa8(%edi),%eax
            /* &= w/ wsize unnecessary & wrong if redirect */
            if ((UINT_D64)d >= wsize)
     4ec:	8b 9f ac 00 00 00    	mov    0xac(%edi),%ebx
        DUMPBITS(e)

        /* do the copy */
        do {
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
          if (G.redirect_slide) {
     4f2:	85 c0                	test   %eax,%eax
     4f4:	0f 84 88 00 00 00    	je     582 <_inflate_codes+0x582>
            /* &= w/ wsize unnecessary & wrong if redirect */
            if ((UINT_D64)d >= wsize)
     4fa:	8b 44 24 18          	mov    0x18(%esp),%eax
     4fe:	39 d8                	cmp    %ebx,%eax
     500:	0f 83 4f fd ff ff    	jae    255 <_inflate_codes+0x255>
              return 1;         /* invalid compressed data */
            e = (unsigned)(wsize - (d > (unsigned)w ? (UINT_D64)d : w));
     506:	39 c6                	cmp    %eax,%esi
     508:	0f 43 c6             	cmovae %esi,%eax
     50b:	29 c3                	sub    %eax,%ebx
     50d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
                           ((d &= (unsigned)(wsize-1)) > (unsigned)w ?
                            (UINT_D64)d : w));
          if ((UINT_D64)e > n) e = (unsigned)n;
          n -= e;
#ifndef NOMEMCPY
          if ((unsigned)w - d >= e)
     511:	8b 4c 24 18          	mov    0x18(%esp),%ecx
     515:	39 c3                	cmp    %eax,%ebx
     517:	0f 47 d8             	cmova  %eax,%ebx
#endif
            e = (unsigned)(wsize -
                           ((d &= (unsigned)(wsize-1)) > (unsigned)w ?
                            (UINT_D64)d : w));
          if ((UINT_D64)e > n) e = (unsigned)n;
          n -= e;
     51a:	29 d8                	sub    %ebx,%eax
     51c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
#ifndef NOMEMCPY
          if ((unsigned)w - d >= e)
     520:	89 f0                	mov    %esi,%eax
     522:	29 c8                	sub    %ecx,%eax
     524:	39 c3                	cmp    %eax,%ebx
     526:	76 79                	jbe    5a1 <_inflate_codes+0x5a1>
     528:	89 f0                	mov    %esi,%eax
     52a:	8d 2c 33             	lea    (%ebx,%esi,1),%ebp
     52d:	8b 74 24 18          	mov    0x18(%esp),%esi
     531:	29 c6                	sub    %eax,%esi
            d += e;
          }
          else                  /* do it slowly to avoid memcpy() overlap */
#endif /* !NOMEMCPY */
            do {
              redirSlide[w++] = redirSlide[d++];
     533:	8b 97 bc 00 00 00    	mov    0xbc(%edi),%edx
     539:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
     53c:	8a 0c 31             	mov    (%ecx,%esi,1),%cl
     53f:	88 0c 02             	mov    %cl,(%edx,%eax,1)
     542:	40                   	inc    %eax
            } while (--e);
     543:	39 e8                	cmp    %ebp,%eax
     545:	75 ec                	jne    533 <_inflate_codes+0x533>
     547:	8b 54 24 18          	mov    0x18(%esp),%edx
     54b:	89 c6                	mov    %eax,%esi
     54d:	01 da                	add    %ebx,%edx
          if (w == wsize)
     54f:	39 b7 ac 00 00 00    	cmp    %esi,0xac(%edi)
     555:	89 54 24 18          	mov    %edx,0x18(%esp)
     559:	74 77                	je     5d2 <_inflate_codes+0x5d2>
          {
            if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
            w = 0;
          }
        } while (n);
     55b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
     55f:	85 c0                	test   %eax,%eax
     561:	75 83                	jne    4e6 <_inflate_codes+0x4e6>
     563:	8b 6c 24 38          	mov    0x38(%esp),%ebp
     567:	89 74 24 20          	mov    %esi,0x20(%esp)
          NEEDBITS(e)
          t = t->v.t + ((unsigned)b & mask_bits[e]);
        }
        NEEDBITS(e)
        d = (unsigned)w - t->v.n - ((unsigned)b & mask_bits[e]);
        DUMPBITS(e)
     56b:	89 eb                	mov    %ebp,%ebx
     56d:	8b 74 24 28          	mov    0x28(%esp),%esi
     571:	8a 4c 24 34          	mov    0x34(%esp),%cl
     575:	8b 6c 24 30          	mov    0x30(%esp),%ebp
     579:	d3 ee                	shr    %cl,%esi
     57b:	29 eb                	sub    %ebp,%ebx
     57d:	e9 bf fa ff ff       	jmp    41 <_inflate_codes+0x41>
            e = (unsigned)(wsize - (d > (unsigned)w ? (UINT_D64)d : w));
          }
          else
#endif
            e = (unsigned)(wsize -
                           ((d &= (unsigned)(wsize-1)) > (unsigned)w ?
     582:	8d 43 ff             	lea    -0x1(%ebx),%eax
     585:	8b 6c 24 18          	mov    0x18(%esp),%ebp
     589:	21 c5                	and    %eax,%ebp
     58b:	89 6c 24 18          	mov    %ebp,0x18(%esp)
     58f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
     593:	89 c8                	mov    %ecx,%eax
     595:	39 f1                	cmp    %esi,%ecx
     597:	0f 42 c6             	cmovb  %esi,%eax
              return 1;         /* invalid compressed data */
            e = (unsigned)(wsize - (d > (unsigned)w ? (UINT_D64)d : w));
          }
          else
#endif
            e = (unsigned)(wsize -
     59a:	29 c3                	sub    %eax,%ebx
     59c:	e9 6c ff ff ff       	jmp    50d <_inflate_codes+0x50d>
          n -= e;
#ifndef NOMEMCPY
          if ((unsigned)w - d >= e)
          /* (this test assumes unsigned comparison) */
          {
            memcpy(redirSlide + (unsigned)w, redirSlide + d, e);
     5a1:	8b 87 bc 00 00 00    	mov    0xbc(%edi),%eax
     5a7:	8b 6c 24 18          	mov    0x18(%esp),%ebp
     5ab:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     5af:	8d 14 30             	lea    (%eax,%esi,1),%edx
     5b2:	01 e8                	add    %ebp,%eax
     5b4:	89 44 24 04          	mov    %eax,0x4(%esp)
     5b8:	89 14 24             	mov    %edx,(%esp)
     5bb:	e8 00 00 00 00       	call   5c0 <_inflate_codes+0x5c0>
            w += e;
            d += e;
     5c0:	89 e9                	mov    %ebp,%ecx
     5c2:	01 d9                	add    %ebx,%ecx
#ifndef NOMEMCPY
          if ((unsigned)w - d >= e)
          /* (this test assumes unsigned comparison) */
          {
            memcpy(redirSlide + (unsigned)w, redirSlide + d, e);
            w += e;
     5c4:	01 de                	add    %ebx,%esi
            d += e;
     5c6:	89 4c 24 18          	mov    %ecx,0x18(%esp)
          else                  /* do it slowly to avoid memcpy() overlap */
#endif /* !NOMEMCPY */
            do {
              redirSlide[w++] = redirSlide[d++];
            } while (--e);
          if (w == wsize)
     5ca:	39 b7 ac 00 00 00    	cmp    %esi,0xac(%edi)
     5d0:	75 89                	jne    55b <_inflate_codes+0x55b>
          {
            if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
     5d2:	8b 87 a0 09 01 00    	mov    0x109a0(%edi),%eax
     5d8:	85 c0                	test   %eax,%eax
     5da:	74 25                	je     601 <_inflate_codes+0x601>
     5dc:	89 74 24 08          	mov    %esi,0x8(%esp)
     5e0:	8b 87 bc 00 00 00    	mov    0xbc(%edi),%eax
     5e6:	89 3c 24             	mov    %edi,(%esp)
     5e9:	89 44 24 04          	mov    %eax,0x4(%esp)
     5ed:	e8 00 00 00 00       	call   5f2 <_inflate_codes+0x5f2>
     5f2:	85 c0                	test   %eax,%eax
     5f4:	0f 85 60 fc ff ff    	jne    25a <_inflate_codes+0x25a>
            w = 0;
     5fa:	31 f6                	xor    %esi,%esi
     5fc:	e9 5a ff ff ff       	jmp    55b <_inflate_codes+0x55b>
            do {
              redirSlide[w++] = redirSlide[d++];
            } while (--e);
          if (w == wsize)
          {
            if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
     601:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     608:	00 
     609:	89 74 24 08          	mov    %esi,0x8(%esp)
     60d:	8b 87 bc 00 00 00    	mov    0xbc(%edi),%eax
     613:	89 3c 24             	mov    %edi,(%esp)
     616:	89 44 24 04          	mov    %eax,0x4(%esp)
     61a:	e8 00 00 00 00       	call   61f <_inflate_codes+0x61f>
     61f:	eb d1                	jmp    5f2 <_inflate_codes+0x5f2>
     621:	89 5c 24 28          	mov    %ebx,0x28(%esp)
     625:	89 cd                	mov    %ecx,%ebp
     627:	e9 78 fe ff ff       	jmp    4a4 <_inflate_codes+0x4a4>
      if ((e = t->e) == 32)     /* then it's a literal */
      {
        redirSlide[w++] = (uch)t->v.n;
        if (w == wsize)
        {
          if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
     62c:	8b 44 24 20          	mov    0x20(%esp),%eax
     630:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     637:	00 
     638:	89 44 24 08          	mov    %eax,0x8(%esp)
     63c:	8b 87 bc 00 00 00    	mov    0xbc(%edi),%eax
     642:	89 3c 24             	mov    %edi,(%esp)
     645:	89 44 24 04          	mov    %eax,0x4(%esp)
     649:	e8 00 00 00 00       	call   64e <_inflate_codes+0x64e>
     64e:	e9 56 fc ff ff       	jmp    2a9 <_inflate_codes+0x2a9>
     653:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     659:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000660 <_inflate_free>:



int inflate_free(__G)
    __GDEF
{
     660:	57                   	push   %edi
     661:	56                   	push   %esi
     662:	53                   	push   %ebx
     663:	83 ec 10             	sub    $0x10,%esp
     666:	8b 7c 24 20          	mov    0x20(%esp),%edi
  if (G.fixed_tl != (struct huft *)NULL)
     66a:	8b 9f fc 0a 01 00    	mov    0x10afc(%edi),%ebx
     670:	85 db                	test   %ebx,%ebx
     672:	74 52                	je     6c6 <_inflate_free+0x66>
  {
    huft_free(G.fixed_td);
     674:	8b b7 00 0b 01 00    	mov    0x10b00(%edi),%esi
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
     67a:	85 f6                	test   %esi,%esi
     67c:	74 22                	je     6a0 <_inflate_free+0x40>
     67e:	66 90                	xchg   %ax,%ax
  {
    q = (--p)->v.t;
     680:	8d 46 f8             	lea    -0x8(%esi),%eax
     683:	8b 76 fc             	mov    -0x4(%esi),%esi
    free((zvoid *)p);
     686:	89 04 24             	mov    %eax,(%esp)
     689:	e8 00 00 00 00       	call   68e <_inflate_free+0x2e>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
     68e:	85 f6                	test   %esi,%esi
     690:	75 ee                	jne    680 <_inflate_free+0x20>
    __GDEF
{
  if (G.fixed_tl != (struct huft *)NULL)
  {
    huft_free(G.fixed_td);
    huft_free(G.fixed_tl);
     692:	8b 9f fc 0a 01 00    	mov    0x10afc(%edi),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
     698:	85 db                	test   %ebx,%ebx
     69a:	74 16                	je     6b2 <_inflate_free+0x52>
     69c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  {
    q = (--p)->v.t;
     6a0:	8d 43 f8             	lea    -0x8(%ebx),%eax
     6a3:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
     6a6:	89 04 24             	mov    %eax,(%esp)
     6a9:	e8 00 00 00 00       	call   6ae <_inflate_free+0x4e>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
     6ae:	85 db                	test   %ebx,%ebx
     6b0:	75 ee                	jne    6a0 <_inflate_free+0x40>
{
  if (G.fixed_tl != (struct huft *)NULL)
  {
    huft_free(G.fixed_td);
    huft_free(G.fixed_tl);
    G.fixed_td = G.fixed_tl = (struct huft *)NULL;
     6b2:	c7 87 fc 0a 01 00 00 	movl   $0x0,0x10afc(%edi)
     6b9:	00 00 00 
     6bc:	c7 87 00 0b 01 00 00 	movl   $0x0,0x10b00(%edi)
     6c3:	00 00 00 
  }
  return 0;
}
     6c6:	83 c4 10             	add    $0x10,%esp
     6c9:	31 c0                	xor    %eax,%eax
     6cb:	5b                   	pop    %ebx
     6cc:	5e                   	pop    %esi
     6cd:	5f                   	pop    %edi
     6ce:	c3                   	ret    
     6cf:	90                   	nop

000006d0 <_huft_build>:
   case), two if the input is invalid (all zero length codes or an
   oversubscribed set of lengths), and three if not enough memory.
   The code with value 256 is special, and the tables are constructed
   so that no bits beyond that code are fetched when that code is
   decoded. */
{
     6d0:	55                   	push   %ebp
     6d1:	57                   	push   %edi
     6d2:	56                   	push   %esi
     6d3:	53                   	push   %ebx
     6d4:	81 ec fc 05 00 00    	sub    $0x5fc,%esp
     6da:	8b ac 24 14 06 00 00 	mov    0x614(%esp),%ebp
  int y;                        /* number of dummy codes added */
  unsigned z;                   /* number of entries in current table */


  /* Generate counts for each bit length */
  el = n > 256 ? b[256] : BMAX; /* set length of EOB code, if any */
     6e1:	c7 44 24 38 10 00 00 	movl   $0x10,0x38(%esp)
     6e8:	00 
     6e9:	81 bc 24 18 06 00 00 	cmpl   $0x100,0x618(%esp)
     6f0:	00 01 00 00 
     6f4:	76 0a                	jbe    700 <_huft_build+0x30>
     6f6:	8b 85 00 04 00 00    	mov    0x400(%ebp),%eax
     6fc:	89 44 24 38          	mov    %eax,0x38(%esp)
  memzero((char *)c, sizeof(c));
     700:	8d 94 24 a4 00 00 00 	lea    0xa4(%esp),%edx
     707:	31 c0                	xor    %eax,%eax
     709:	b9 11 00 00 00       	mov    $0x11,%ecx
     70e:	89 d7                	mov    %edx,%edi
     710:	f3 ab                	rep stos %eax,%es:(%edi)
     712:	89 e9                	mov    %ebp,%ecx
     714:	8b 84 24 18 06 00 00 	mov    0x618(%esp),%eax
     71b:	90                   	nop
     71c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  p = (unsigned *)b;  i = n;
  do {
    c[*p]++; p++;               /* assume all entries <= BMAX */
     720:	8b 19                	mov    (%ecx),%ebx
     722:	83 c1 04             	add    $0x4,%ecx
     725:	8b b4 9c a4 00 00 00 	mov    0xa4(%esp,%ebx,4),%esi
     72c:	46                   	inc    %esi
  } while (--i);
     72d:	48                   	dec    %eax
  /* Generate counts for each bit length */
  el = n > 256 ? b[256] : BMAX; /* set length of EOB code, if any */
  memzero((char *)c, sizeof(c));
  p = (unsigned *)b;  i = n;
  do {
    c[*p]++; p++;               /* assume all entries <= BMAX */
     72e:	89 b4 9c a4 00 00 00 	mov    %esi,0xa4(%esp,%ebx,4)
  } while (--i);
     735:	75 e9                	jne    720 <_huft_build+0x50>
  if (c[0] == n)                /* null input--all zero length codes */
     737:	8b 84 24 18 06 00 00 	mov    0x618(%esp),%eax
     73e:	b9 01 00 00 00       	mov    $0x1,%ecx
     743:	39 84 24 a4 00 00 00 	cmp    %eax,0xa4(%esp)
     74a:	0f 84 d7 04 00 00    	je     c27 <_huft_build+0x557>
  }


  /* Find minimum and maximum length, bound *m by those */
  for (j = 1; j <= BMAX; j++)
    if (c[j])
     750:	8b 04 8a             	mov    (%edx,%ecx,4),%eax
     753:	85 c0                	test   %eax,%eax
     755:	0f 85 9b 04 00 00    	jne    bf6 <_huft_build+0x526>
    return 0;
  }


  /* Find minimum and maximum length, bound *m by those */
  for (j = 1; j <= BMAX; j++)
     75b:	41                   	inc    %ecx
     75c:	83 f9 11             	cmp    $0x11,%ecx
     75f:	75 ef                	jne    750 <_huft_build+0x80>
     761:	be 00 00 02 00       	mov    $0x20000,%esi
     766:	c7 44 24 28 11 00 00 	movl   $0x11,0x28(%esp)
     76d:	00 
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if (*m < j)
     76e:	8b 84 24 2c 06 00 00 	mov    0x62c(%esp),%eax
     775:	8b 00                	mov    (%eax),%eax
     777:	39 c8                	cmp    %ecx,%eax
     779:	73 0b                	jae    786 <_huft_build+0xb6>
    *m = j;
     77b:	8b 84 24 2c 06 00 00 	mov    0x62c(%esp),%eax
     782:	89 08                	mov    %ecx,(%eax)
     784:	89 c8                	mov    %ecx,%eax
  for (i = BMAX; i; i--)
     786:	bb 10 00 00 00       	mov    $0x10,%ebx
     78b:	90                   	nop
     78c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (c[i])
     790:	8b 3c 9a             	mov    (%edx,%ebx,4),%edi
     793:	85 ff                	test   %edi,%edi
     795:	0f 85 4a 04 00 00    	jne    be5 <_huft_build+0x515>
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if (*m < j)
    *m = j;
  for (i = BMAX; i; i--)
     79b:	4b                   	dec    %ebx
     79c:	75 f2                	jne    790 <_huft_build+0xc0>
    if (c[i])
      break;
  g = i;                        /* maximum code length */
     79e:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
     7a5:	00 
  if (*m > i)
    *m = i;
     7a6:	8b 84 24 2c 06 00 00 	mov    0x62c(%esp),%eax
     7ad:	89 18                	mov    %ebx,(%eax)


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
     7af:	39 cb                	cmp    %ecx,%ebx
     7b1:	0f 86 2a 05 00 00    	jbe    ce1 <_huft_build+0x611>
    if ((y -= c[j]) < 0)
     7b7:	89 f0                	mov    %esi,%eax
     7b9:	2b 84 8c a4 00 00 00 	sub    0xa4(%esp,%ecx,4),%eax
     7c0:	0f 88 0f 04 00 00    	js     bd5 <_huft_build+0x505>
     7c6:	8d 4c 8a 04          	lea    0x4(%edx,%ecx,4),%ecx
     7ca:	8d 34 9a             	lea    (%edx,%ebx,4),%esi
     7cd:	eb 10                	jmp    7df <_huft_build+0x10f>
     7cf:	90                   	nop
     7d0:	8b 39                	mov    (%ecx),%edi
     7d2:	83 c1 04             	add    $0x4,%ecx
     7d5:	29 f8                	sub    %edi,%eax
     7d7:	85 c0                	test   %eax,%eax
     7d9:	0f 88 f6 03 00 00    	js     bd5 <_huft_build+0x505>
  if (*m > i)
    *m = i;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
     7df:	01 c0                	add    %eax,%eax
     7e1:	39 f1                	cmp    %esi,%ecx
     7e3:	75 eb                	jne    7d0 <_huft_build+0x100>
     7e5:	8b 8c 9c a4 00 00 00 	mov    0xa4(%esp,%ebx,4),%ecx
     7ec:	89 c6                	mov    %eax,%esi
    if ((y -= c[j]) < 0)
      return 2;                 /* bad input: more codes than bits */
  if ((y -= c[i]) < 0)
     7ee:	89 f7                	mov    %esi,%edi


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return 2;                 /* bad input: more codes than bits */
     7f0:	b8 02 00 00 00       	mov    $0x2,%eax
  if ((y -= c[i]) < 0)
     7f5:	29 cf                	sub    %ecx,%edi
     7f7:	89 7c 24 58          	mov    %edi,0x58(%esp)
     7fb:	0f 88 c9 03 00 00    	js     bca <_huft_build+0x4fa>
    return 2;
  c[i] += y;
     801:	89 b4 9c a4 00 00 00 	mov    %esi,0xa4(%esp,%ebx,4)


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
     808:	4b                   	dec    %ebx
    return 2;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
     809:	c7 84 24 30 01 00 00 	movl   $0x0,0x130(%esp)
     810:	00 00 00 00 
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
     814:	74 1a                	je     830 <_huft_build+0x160>
     816:	31 c0                	xor    %eax,%eax
     818:	31 c9                	xor    %ecx,%ecx
     81a:	8d b4 24 2c 01 00 00 	lea    0x12c(%esp),%esi
    *xp++ = (j += *p++);
     821:	8b 7c 82 04          	mov    0x4(%edx,%eax,4),%edi
     825:	01 f9                	add    %edi,%ecx
     827:	89 4c 86 08          	mov    %ecx,0x8(%esi,%eax,4)
     82b:	40                   	inc    %eax


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
     82c:	39 d8                	cmp    %ebx,%eax
     82e:	75 f1                	jne    821 <_huft_build+0x151>
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  memzero((char *)v, sizeof(v));
     830:	b9 20 01 00 00       	mov    $0x120,%ecx
     835:	31 c0                	xor    %eax,%eax
     837:	8d bc 24 70 01 00 00 	lea    0x170(%esp),%edi
     83e:	8b b4 24 18 06 00 00 	mov    0x618(%esp),%esi
     845:	f3 ab                	rep stos %eax,%es:(%edi)
  p = (unsigned *)b;  i = 0;
  do {
    if ((j = *p++) != 0)
     847:	8b 4c 85 00          	mov    0x0(%ebp,%eax,4),%ecx
     84b:	85 c9                	test   %ecx,%ecx
     84d:	74 18                	je     867 <_huft_build+0x197>
      v[x[j]++] = i;
     84f:	8b 9c 8c 2c 01 00 00 	mov    0x12c(%esp,%ecx,4),%ebx
     856:	8d 7b 01             	lea    0x1(%ebx),%edi
     859:	89 84 9c 70 01 00 00 	mov    %eax,0x170(%esp,%ebx,4)
     860:	89 bc 8c 2c 01 00 00 	mov    %edi,0x12c(%esp,%ecx,4)
  } while (++i < n);
     867:	40                   	inc    %eax
     868:	39 c6                	cmp    %eax,%esi
     86a:	77 db                	ja     847 <_huft_build+0x177>
  n = x[g];                     /* set n to length of v */
     86c:	8b 7c 24 44          	mov    0x44(%esp),%edi

  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = l[-1] = 0;                /* no bits decoded yet */
     870:	c7 84 24 e8 00 00 00 	movl   $0x0,0xe8(%esp)
     877:	00 00 00 00 
  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
     87b:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
     882:	00 
  q = (struct huft *)NULL;      /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
     883:	3b 7c 24 28          	cmp    0x28(%esp),%edi
  p = (unsigned *)b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);
  n = x[g];                     /* set n to length of v */
     887:	8b 84 bc 2c 01 00 00 	mov    0x12c(%esp,%edi,4),%eax


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
     88e:	c7 84 24 2c 01 00 00 	movl   $0x0,0x12c(%esp)
     895:	00 00 00 00 
  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
  q = (struct huft *)NULL;      /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
     899:	0f 8c 06 03 00 00    	jl     ba5 <_huft_build+0x4d5>
        }
      }

      /* set up table entry in r */
      r.b = (uch)(k - w);
      if (p >= v + n)
     89f:	8d 84 84 70 01 00 00 	lea    0x170(%esp,%eax,4),%eax
     8a6:	31 db                	xor    %ebx,%ebx
     8a8:	89 44 24 54          	mov    %eax,0x54(%esp)
     8ac:	8b 44 24 28          	mov    0x28(%esp),%eax
     8b0:	31 ed                	xor    %ebp,%ebp
     8b2:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
     8b9:	00 
     8ba:	8d 04 82             	lea    (%edx,%eax,4),%eax
     8bd:	83 cf ff             	or     $0xffffffff,%edi
     8c0:	89 44 24 48          	mov    %eax,0x48(%esp)
     8c4:	8d 84 24 70 01 00 00 	lea    0x170(%esp),%eax
     8cb:	31 d2                	xor    %edx,%edx
     8cd:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
     8d1:	8b 44 24 48          	mov    0x48(%esp),%eax
     8d5:	89 de                	mov    %ebx,%esi
     8d7:	8b 00                	mov    (%eax),%eax
     8d9:	89 44 24 2c          	mov    %eax,0x2c(%esp)
     8dd:	8b 44 24 28          	mov    0x28(%esp),%eax
     8e1:	8d 48 ff             	lea    -0x1(%eax),%ecx
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
     8e4:	b8 01 00 00 00       	mov    $0x1,%eax
     8e9:	d3 e0                	shl    %cl,%eax
     8eb:	89 44 24 50          	mov    %eax,0x50(%esp)

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
     8ef:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
     8f3:	85 db                	test   %ebx,%ebx
     8f5:	0f 84 86 02 00 00    	je     b81 <_huft_build+0x4b1>
     8fb:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
     902:	8d 9c 24 ec 00 00 00 	lea    0xec(%esp),%ebx
     909:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
     90d:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
     910:	89 4c 24 20          	mov    %ecx,0x20(%esp)
     914:	8b 19                	mov    (%ecx),%ebx
     916:	8d 4c 24 64          	lea    0x64(%esp),%ecx
     91a:	01 c8                	add    %ecx,%eax
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l[h])
     91c:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
     91f:	89 44 24 24          	mov    %eax,0x24(%esp)
     923:	3b 7c 24 28          	cmp    0x28(%esp),%edi
     927:	0f 8d 58 01 00 00    	jge    a85 <_huft_build+0x3b5>
     92d:	8d 76 00             	lea    0x0(%esi),%esi
      {
        w += l[h++];            /* add bits already decoded */
     930:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx

        /* compute minimum size table less than or equal to *m bits */
        z = (z = g - w) > *m ? *m : z;                  /* upper limit */
     934:	8b 84 24 2c 06 00 00 	mov    0x62c(%esp),%eax
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
     93b:	8b 5c 24 28          	mov    0x28(%esp),%ebx
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l[h])
      {
        w += l[h++];            /* add bits already decoded */
     93f:	41                   	inc    %ecx

        /* compute minimum size table less than or equal to *m bits */
        z = (z = g - w) > *m ? *m : z;                  /* upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
     940:	29 fb                	sub    %edi,%ebx
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l[h])
      {
        w += l[h++];            /* add bits already decoded */
     942:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)

        /* compute minimum size table less than or equal to *m bits */
        z = (z = g - w) > *m ? *m : z;                  /* upper limit */
     946:	8b 10                	mov    (%eax),%edx
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
     948:	88 d9                	mov    %bl,%cl
     94a:	b8 01 00 00 00       	mov    $0x1,%eax
     94f:	d3 e0                	shl    %cl,%eax
     951:	39 44 24 2c          	cmp    %eax,0x2c(%esp)
     955:	73 49                	jae    9a0 <_huft_build+0x2d0>
      while (k > w + l[h])
      {
        w += l[h++];            /* add bits already decoded */

        /* compute minimum size table less than or equal to *m bits */
        z = (z = g - w) > *m ? *m : z;                  /* upper limit */
     957:	8b 74 24 44          	mov    0x44(%esp),%esi
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          while (++j < z)       /* try smaller tables up to z bits */
     95b:	8d 6b 01             	lea    0x1(%ebx),%ebp
      while (k > w + l[h])
      {
        w += l[h++];            /* add bits already decoded */

        /* compute minimum size table less than or equal to *m bits */
        z = (z = g - w) > *m ? *m : z;                  /* upper limit */
     95e:	29 fe                	sub    %edi,%esi
     960:	39 d6                	cmp    %edx,%esi
     962:	0f 47 f2             	cmova  %edx,%esi
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
     965:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     969:	29 d0                	sub    %edx,%eax
          xp = c + k;
          while (++j < z)       /* try smaller tables up to z bits */
     96b:	39 ee                	cmp    %ebp,%esi
     96d:	0f 86 ad 02 00 00    	jbe    c20 <_huft_build+0x550>
          {
            if ((f <<= 1) <= *++xp)
     973:	8b 4c 24 48          	mov    0x48(%esp),%ecx
     977:	01 c0                	add    %eax,%eax
     979:	8b 51 04             	mov    0x4(%ecx),%edx
     97c:	39 c2                	cmp    %eax,%edx
     97e:	0f 83 9c 02 00 00    	jae    c20 <_huft_build+0x550>
     984:	f7 db                	neg    %ebx
     986:	8d 0c 99             	lea    (%ecx,%ebx,4),%ecx
     989:	89 eb                	mov    %ebp,%ebx
     98b:	eb 0c                	jmp    999 <_huft_build+0x2c9>
     98d:	8d 76 00             	lea    0x0(%esi),%esi
     990:	01 c0                	add    %eax,%eax
     992:	8b 14 99             	mov    (%ecx,%ebx,4),%edx
     995:	39 d0                	cmp    %edx,%eax
     997:	76 07                	jbe    9a0 <_huft_build+0x2d0>
        z = (z = g - w) > *m ? *m : z;                  /* upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          while (++j < z)       /* try smaller tables up to z bits */
     999:	43                   	inc    %ebx
          {
            if ((f <<= 1) <= *++xp)
              break;            /* enough codes to use up j bits */
            f -= *xp;           /* else deduct codes from patterns */
     99a:	29 d0                	sub    %edx,%eax
        z = (z = g - w) > *m ? *m : z;                  /* upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          while (++j < z)       /* try smaller tables up to z bits */
     99c:	39 de                	cmp    %ebx,%esi
     99e:	77 f0                	ja     990 <_huft_build+0x2c0>
            if ((f <<= 1) <= *++xp)
              break;            /* enough codes to use up j bits */
            f -= *xp;           /* else deduct codes from patterns */
          }
        }
        if ((unsigned)w + j > el && (unsigned)w < el)
     9a0:	8d 04 3b             	lea    (%ebx,%edi,1),%eax
     9a3:	8b 74 24 38          	mov    0x38(%esp),%esi
     9a7:	39 c6                	cmp    %eax,%esi
     9a9:	73 0e                	jae    9b9 <_huft_build+0x2e9>
          j = el - w;           /* make EOB code end at table */
     9ab:	89 f2                	mov    %esi,%edx
            if ((f <<= 1) <= *++xp)
              break;            /* enough codes to use up j bits */
            f -= *xp;           /* else deduct codes from patterns */
          }
        }
        if ((unsigned)w + j > el && (unsigned)w < el)
     9ad:	39 fe                	cmp    %edi,%esi
     9af:	0f 97 c0             	seta   %al
          j = el - w;           /* make EOB code end at table */
     9b2:	29 fa                	sub    %edi,%edx
     9b4:	84 c0                	test   %al,%al
     9b6:	0f 45 da             	cmovne %edx,%ebx
        z = 1 << j;             /* table entries for j-bit table */
     9b9:	88 d9                	mov    %bl,%cl
     9bb:	be 01 00 00 00       	mov    $0x1,%esi
     9c0:	d3 e6                	shl    %cl,%esi
        l[h] = j;               /* set table size in stack */
     9c2:	8b 44 24 20          	mov    0x20(%esp),%eax
     9c6:	89 58 04             	mov    %ebx,0x4(%eax)

        /* allocate and link in new table */
        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
     9c9:	8d 04 f5 08 00 00 00 	lea    0x8(,%esi,8),%eax
     9d0:	89 04 24             	mov    %eax,(%esp)
     9d3:	e8 00 00 00 00       	call   9d8 <_huft_build+0x308>
     9d8:	85 c0                	test   %eax,%eax
     9da:	0f 84 28 02 00 00    	je     c08 <_huft_build+0x538>
          return 3;             /* not enough memory */
        }
#ifdef DEBUG
        G.hufts += z + 1;         /* track memory usage */
#endif
        *t = q + 1;             /* link to list for huft_free() */
     9e0:	8b 94 24 28 06 00 00 	mov    0x628(%esp),%edx
     9e7:	8d 68 08             	lea    0x8(%eax),%ebp
        *(t = &(q->v.t)) = (struct huft *)NULL;
     9ea:	8d 48 04             	lea    0x4(%eax),%ecx
          return 3;             /* not enough memory */
        }
#ifdef DEBUG
        G.hufts += z + 1;         /* track memory usage */
#endif
        *t = q + 1;             /* link to list for huft_free() */
     9ed:	89 2a                	mov    %ebp,(%edx)
        *(t = &(q->v.t)) = (struct huft *)NULL;
     9ef:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        u[h] = ++q;             /* table starts after link */
     9f6:	8b 44 24 24          	mov    0x24(%esp),%eax
        }
#ifdef DEBUG
        G.hufts += z + 1;         /* track memory usage */
#endif
        *t = q + 1;             /* link to list for huft_free() */
        *(t = &(q->v.t)) = (struct huft *)NULL;
     9fa:	89 8c 24 28 06 00 00 	mov    %ecx,0x628(%esp)
        u[h] = ++q;             /* table starts after link */
     a01:	89 68 04             	mov    %ebp,0x4(%eax)

        /* connect to last table, if there is one */
        if (h)
     a04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
     a08:	85 c0                	test   %eax,%eax
     a0a:	74 54                	je     a60 <_huft_build+0x390>
        {
          x[h] = i;             /* save pattern for backing up */
     a0c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
     a10:	8b 44 24 34          	mov    0x34(%esp),%eax
          r.b = (uch)l[h-1];    /* bits to dump before this table */
          r.e = (uch)(32 + j);  /* bits in this table */
          r.v.t = q;            /* pointer to this table */
          j = (i & ((1 << w) - 1)) >> (w - l[h-1]);
     a14:	89 f9                	mov    %edi,%ecx
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.b = (uch)l[h-1];    /* bits to dump before this table */
          r.e = (uch)(32 + j);  /* bits in this table */
          r.v.t = q;            /* pointer to this table */
     a16:	89 6c 24 3c          	mov    %ebp,0x3c(%esp)
        u[h] = ++q;             /* table starts after link */

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
     a1a:	89 84 94 2c 01 00 00 	mov    %eax,0x12c(%esp,%edx,4)
          r.b = (uch)l[h-1];    /* bits to dump before this table */
          r.e = (uch)(32 + j);  /* bits in this table */
          r.v.t = q;            /* pointer to this table */
          j = (i & ((1 << w) - 1)) >> (w - l[h-1]);
     a21:	b8 01 00 00 00       	mov    $0x1,%eax
     a26:	d3 e0                	shl    %cl,%eax

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.b = (uch)l[h-1];    /* bits to dump before this table */
     a28:	8b 54 24 20          	mov    0x20(%esp),%edx
          r.e = (uch)(32 + j);  /* bits in this table */
          r.v.t = q;            /* pointer to this table */
          j = (i & ((1 << w) - 1)) >> (w - l[h-1]);
     a2c:	8b 4c 24 34          	mov    0x34(%esp),%ecx
     a30:	48                   	dec    %eax

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.b = (uch)l[h-1];    /* bits to dump before this table */
     a31:	8b 12                	mov    (%edx),%edx
          r.e = (uch)(32 + j);  /* bits in this table */
          r.v.t = q;            /* pointer to this table */
          j = (i & ((1 << w) - 1)) >> (w - l[h-1]);
     a33:	21 c8                	and    %ecx,%eax
     a35:	89 f9                	mov    %edi,%ecx
     a37:	89 54 24 40          	mov    %edx,0x40(%esp)
     a3b:	29 d1                	sub    %edx,%ecx
     a3d:	d3 e8                	shr    %cl,%eax
          u[h-1][j] = r;        /* connect to last table */
     a3f:	8b 4c 24 24          	mov    0x24(%esp),%ecx
     a43:	8b 11                	mov    (%ecx),%edx
     a45:	8d 04 c2             	lea    (%edx,%eax,8),%eax
        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.b = (uch)l[h-1];    /* bits to dump before this table */
          r.e = (uch)(32 + j);  /* bits in this table */
     a48:	8d 53 20             	lea    0x20(%ebx),%edx
          r.v.t = q;            /* pointer to this table */
          j = (i & ((1 << w) - 1)) >> (w - l[h-1]);
          u[h-1][j] = r;        /* connect to last table */
     a4b:	88 54 24 30          	mov    %dl,0x30(%esp)
     a4f:	8b 54 24 30          	mov    0x30(%esp),%edx
     a53:	89 68 04             	mov    %ebp,0x4(%eax)
     a56:	8a 74 24 40          	mov    0x40(%esp),%dh
     a5a:	89 54 24 30          	mov    %edx,0x30(%esp)
     a5e:	89 10                	mov    %edx,(%eax)
     a60:	8b 44 24 20          	mov    0x20(%esp),%eax
     a64:	89 fa                	mov    %edi,%edx
     a66:	83 c0 04             	add    $0x4,%eax
     a69:	89 44 24 20          	mov    %eax,0x20(%esp)
     a6d:	8b 44 24 24          	mov    0x24(%esp),%eax
     a71:	83 c0 04             	add    $0x4,%eax
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l[h])
     a74:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
     a77:	89 44 24 24          	mov    %eax,0x24(%esp)
     a7b:	3b 7c 24 28          	cmp    0x28(%esp),%edi
     a7f:	0f 8c ab fe ff ff    	jl     930 <_huft_build+0x260>
          u[h-1][j] = r;        /* connect to last table */
        }
      }

      /* set up table entry in r */
      r.b = (uch)(k - w);
     a85:	8a 44 24 28          	mov    0x28(%esp),%al
      if (p >= v + n)
     a89:	8b 4c 24 54          	mov    0x54(%esp),%ecx
          u[h-1][j] = r;        /* connect to last table */
        }
      }

      /* set up table entry in r */
      r.b = (uch)(k - w);
     a8d:	29 d0                	sub    %edx,%eax
     a8f:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
     a93:	88 44 24 24          	mov    %al,0x24(%esp)
      if (p >= v + n)
        r.e = INVALID_CODE;     /* out of values--invalid code */
     a97:	c6 44 24 20 63       	movb   $0x63,0x20(%esp)
        }
      }

      /* set up table entry in r */
      r.b = (uch)(k - w);
      if (p >= v + n)
     a9c:	39 4c 24 4c          	cmp    %ecx,0x4c(%esp)
     aa0:	0f 82 a8 01 00 00    	jb     c4e <_huft_build+0x57e>
        r.e = e[*p - s];        /* non-simple--look up in lists */
        r.v.n = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
     aa6:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     aaa:	b8 01 00 00 00       	mov    $0x1,%eax
     aaf:	29 d1                	sub    %edx,%ecx
     ab1:	d3 e0                	shl    %cl,%eax
     ab3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      for (j = i >> w; j < z; j += f)
     ab7:	88 d1                	mov    %dl,%cl
     ab9:	8b 44 24 34          	mov    0x34(%esp),%eax
     abd:	d3 e8                	shr    %cl,%eax
     abf:	89 c1                	mov    %eax,%ecx
     ac1:	39 f0                	cmp    %esi,%eax
     ac3:	73 3b                	jae    b00 <_huft_build+0x430>
     ac5:	89 7c 24 40          	mov    %edi,0x40(%esp)
     ac9:	89 54 24 5c          	mov    %edx,0x5c(%esp)
     acd:	8a 5c 24 20          	mov    0x20(%esp),%bl
     ad1:	8a 44 24 24          	mov    0x24(%esp),%al
     ad5:	8b 54 24 30          	mov    0x30(%esp),%edx
     ad9:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
     add:	8d 76 00             	lea    0x0(%esi),%esi
        q[j] = r;
     ae0:	88 da                	mov    %bl,%dl
     ae2:	89 7c cd 04          	mov    %edi,0x4(%ebp,%ecx,8)
     ae6:	88 c6                	mov    %al,%dh
     ae8:	89 54 cd 00          	mov    %edx,0x0(%ebp,%ecx,8)
        r.v.n = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
     aec:	03 4c 24 1c          	add    0x1c(%esp),%ecx
     af0:	39 f1                	cmp    %esi,%ecx
     af2:	72 ec                	jb     ae0 <_huft_build+0x410>
     af4:	89 54 24 30          	mov    %edx,0x30(%esp)
     af8:	8b 7c 24 40          	mov    0x40(%esp),%edi
     afc:	8b 54 24 5c          	mov    0x5c(%esp),%edx
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
     b00:	8b 5c 24 50          	mov    0x50(%esp),%ebx
     b04:	8b 4c 24 34          	mov    0x34(%esp),%ecx
     b08:	89 d8                	mov    %ebx,%eax
     b0a:	85 5c 24 34          	test   %ebx,0x34(%esp)
     b0e:	74 0c                	je     b1c <_huft_build+0x44c>
        i ^= j;
     b10:	31 c1                	xor    %eax,%ecx
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
     b12:	d1 e8                	shr    %eax
     b14:	85 c8                	test   %ecx,%eax
     b16:	75 f8                	jne    b10 <_huft_build+0x440>
     b18:	89 4c 24 34          	mov    %ecx,0x34(%esp)
        i ^= j;
      i ^= j;
     b1c:	8b 4c 24 34          	mov    0x34(%esp),%ecx
     b20:	31 c1                	xor    %eax,%ecx

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
     b22:	b8 01 00 00 00       	mov    $0x1,%eax
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;
     b27:	89 4c 24 34          	mov    %ecx,0x34(%esp)

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
     b2b:	88 d1                	mov    %dl,%cl
     b2d:	d3 e0                	shl    %cl,%eax
     b2f:	48                   	dec    %eax
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;
     b30:	8b 5c 24 34          	mov    0x34(%esp),%ebx

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
     b34:	21 d8                	and    %ebx,%eax
     b36:	3b 84 bc 2c 01 00 00 	cmp    0x12c(%esp,%edi,4),%eax
     b3d:	74 34                	je     b73 <_huft_build+0x4a3>
     b3f:	8d 9c 24 2c 01 00 00 	lea    0x12c(%esp),%ebx
     b46:	89 d1                	mov    %edx,%ecx
     b48:	b8 01 00 00 00       	mov    $0x1,%eax
     b4d:	89 da                	mov    %ebx,%edx
     b4f:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
     b53:	8b 5c 24 34          	mov    0x34(%esp),%ebx
        w -= l[--h];            /* don't need to update q */
     b57:	4f                   	dec    %edi
     b58:	8b ac bc ec 00 00 00 	mov    0xec(%esp,%edi,4),%ebp
     b5f:	29 e9                	sub    %ebp,%ecx
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
     b61:	89 c5                	mov    %eax,%ebp
     b63:	d3 e5                	shl    %cl,%ebp
     b65:	4d                   	dec    %ebp
     b66:	21 dd                	and    %ebx,%ebp
     b68:	3b 2c ba             	cmp    (%edx,%edi,4),%ebp
     b6b:	75 ea                	jne    b57 <_huft_build+0x487>
     b6d:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
     b71:	89 ca                	mov    %ecx,%edx

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
     b73:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     b77:	48                   	dec    %eax
     b78:	89 44 24 2c          	mov    %eax,0x2c(%esp)
     b7c:	e9 6e fd ff ff       	jmp    8ef <_huft_build+0x21f>
  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
  q = (struct huft *)NULL;      /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
     b81:	8b 44 24 28          	mov    0x28(%esp),%eax
     b85:	8b 4c 24 48          	mov    0x48(%esp),%ecx
     b89:	40                   	inc    %eax
     b8a:	83 c1 04             	add    $0x4,%ecx
     b8d:	89 44 24 28          	mov    %eax,0x28(%esp)
     b91:	89 f3                	mov    %esi,%ebx
     b93:	8b 44 24 28          	mov    0x28(%esp),%eax
     b97:	89 4c 24 48          	mov    %ecx,0x48(%esp)
     b9b:	39 44 24 44          	cmp    %eax,0x44(%esp)
     b9f:	0f 8d 2c fd ff ff    	jge    8d1 <_huft_build+0x201>
    }
  }


  /* return actual size of base table */
  *m = l[0];
     ba5:	8b bc 24 2c 06 00 00 	mov    0x62c(%esp),%edi
     bac:	8b 84 24 ec 00 00 00 	mov    0xec(%esp),%eax


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
     bb3:	8b 5c 24 58          	mov    0x58(%esp),%ebx
     bb7:	85 db                	test   %ebx,%ebx
    }
  }


  /* return actual size of base table */
  *m = l[0];
     bb9:	89 07                	mov    %eax,(%edi)


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
     bbb:	0f 95 c0             	setne  %al
     bbe:	31 d2                	xor    %edx,%edx
     bc0:	83 7c 24 44 01       	cmpl   $0x1,0x44(%esp)
     bc5:	0f 95 c2             	setne  %dl
     bc8:	21 d0                	and    %edx,%eax
}
     bca:	81 c4 fc 05 00 00    	add    $0x5fc,%esp
     bd0:	5b                   	pop    %ebx
     bd1:	5e                   	pop    %esi
     bd2:	5f                   	pop    %edi
     bd3:	5d                   	pop    %ebp
     bd4:	c3                   	ret    
     bd5:	81 c4 fc 05 00 00    	add    $0x5fc,%esp


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return 2;                 /* bad input: more codes than bits */
     bdb:	b8 02 00 00 00       	mov    $0x2,%eax
  *m = l[0];


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
}
     be0:	5b                   	pop    %ebx
     be1:	5e                   	pop    %esi
     be2:	5f                   	pop    %edi
     be3:	5d                   	pop    %ebp
     be4:	c3                   	ret    
  if (*m < j)
    *m = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
     be5:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  if (*m > i)
     be9:	39 c3                	cmp    %eax,%ebx
     beb:	0f 83 be fb ff ff    	jae    7af <_huft_build+0xdf>
     bf1:	e9 b0 fb ff ff       	jmp    7a6 <_huft_build+0xd6>
     bf6:	b8 01 00 00 00       	mov    $0x1,%eax
  }


  /* Find minimum and maximum length, bound *m by those */
  for (j = 1; j <= BMAX; j++)
    if (c[j])
     bfb:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     bff:	d3 e0                	shl    %cl,%eax
     c01:	89 c6                	mov    %eax,%esi
     c03:	e9 66 fb ff ff       	jmp    76e <_huft_build+0x9e>
     c08:	8b 7c 24 1c          	mov    0x1c(%esp),%edi

        /* allocate and link in new table */
        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
            (struct huft *)NULL)
        {
          if (h)
     c0c:	85 ff                	test   %edi,%edi
     c0e:	75 74                	jne    c84 <_huft_build+0x5b4>
  *m = l[0];


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
}
     c10:	81 c4 fc 05 00 00    	add    $0x5fc,%esp
        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
            (struct huft *)NULL)
        {
          if (h)
            huft_free(u[0]);
          return 3;             /* not enough memory */
     c16:	b8 03 00 00 00       	mov    $0x3,%eax
  *m = l[0];


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
}
     c1b:	5b                   	pop    %ebx
     c1c:	5e                   	pop    %esi
     c1d:	5f                   	pop    %edi
     c1e:	5d                   	pop    %ebp
     c1f:	c3                   	ret    
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          while (++j < z)       /* try smaller tables up to z bits */
          {
            if ((f <<= 1) <= *++xp)
     c20:	89 eb                	mov    %ebp,%ebx
     c22:	e9 79 fd ff ff       	jmp    9a0 <_huft_build+0x2d0>
  do {
    c[*p]++; p++;               /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (struct huft *)NULL;
     c27:	8b 84 24 28 06 00 00 	mov    0x628(%esp),%eax
     c2e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *m = 0;
     c34:	8b 84 24 2c 06 00 00 	mov    0x62c(%esp),%eax
     c3b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *m = l[0];


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
}
     c41:	81 c4 fc 05 00 00    	add    $0x5fc,%esp
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (struct huft *)NULL;
    *m = 0;
    return 0;
     c47:	31 c0                	xor    %eax,%eax
  *m = l[0];


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
}
     c49:	5b                   	pop    %ebx
     c4a:	5e                   	pop    %esi
     c4b:	5f                   	pop    %edi
     c4c:	5d                   	pop    %ebp
     c4d:	c3                   	ret    

      /* set up table entry in r */
      r.b = (uch)(k - w);
      if (p >= v + n)
        r.e = INVALID_CODE;     /* out of values--invalid code */
      else if (*p < s)
     c4e:	8b 44 24 4c          	mov    0x4c(%esp),%eax
     c52:	8b 08                	mov    (%eax),%ecx
     c54:	3b 8c 24 1c 06 00 00 	cmp    0x61c(%esp),%ecx
     c5b:	73 4a                	jae    ca7 <_huft_build+0x5d7>
      {
        r.e = (uch)(*p < 256 ? 32 : 31);  /* 256 is end-of-block code */
     c5d:	81 f9 00 01 00 00    	cmp    $0x100,%ecx
        r.v.n = (ush)*p++;                /* simple code is just the value */
     c63:	66 89 4c 24 3c       	mov    %cx,0x3c(%esp)
      r.b = (uch)(k - w);
      if (p >= v + n)
        r.e = INVALID_CODE;     /* out of values--invalid code */
      else if (*p < s)
      {
        r.e = (uch)(*p < 256 ? 32 : 31);  /* 256 is end-of-block code */
     c68:	19 c0                	sbb    %eax,%eax
     c6a:	83 f0 ff             	xor    $0xffffffff,%eax
     c6d:	83 c0 20             	add    $0x20,%eax
     c70:	88 44 24 20          	mov    %al,0x20(%esp)
        r.v.n = (ush)*p++;                /* simple code is just the value */
     c74:	8b 44 24 4c          	mov    0x4c(%esp),%eax
     c78:	83 c0 04             	add    $0x4,%eax
     c7b:	89 44 24 4c          	mov    %eax,0x4c(%esp)
     c7f:	e9 22 fe ff ff       	jmp    aa6 <_huft_build+0x3d6>
        /* allocate and link in new table */
        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==
            (struct huft *)NULL)
        {
          if (h)
            huft_free(u[0]);
     c84:	8b 5c 24 64          	mov    0x64(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
     c88:	85 db                	test   %ebx,%ebx
     c8a:	74 84                	je     c10 <_huft_build+0x540>
     c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  {
    q = (--p)->v.t;
     c90:	8d 43 f8             	lea    -0x8(%ebx),%eax
     c93:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
     c96:	89 04 24             	mov    %eax,(%esp)
     c99:	e8 00 00 00 00       	call   c9e <_huft_build+0x5ce>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
     c9e:	85 db                	test   %ebx,%ebx
     ca0:	75 ee                	jne    c90 <_huft_build+0x5c0>
     ca2:	e9 69 ff ff ff       	jmp    c10 <_huft_build+0x540>
        r.e = (uch)(*p < 256 ? 32 : 31);  /* 256 is end-of-block code */
        r.v.n = (ush)*p++;                /* simple code is just the value */
      }
      else
      {
        r.e = e[*p - s];        /* non-simple--look up in lists */
     ca7:	8b 84 24 1c 06 00 00 	mov    0x61c(%esp),%eax
        r.v.n = d[*p++ - s];
     cae:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
        r.e = (uch)(*p < 256 ? 32 : 31);  /* 256 is end-of-block code */
        r.v.n = (ush)*p++;                /* simple code is just the value */
      }
      else
      {
        r.e = e[*p - s];        /* non-simple--look up in lists */
     cb2:	29 c1                	sub    %eax,%ecx
     cb4:	8b 84 24 24 06 00 00 	mov    0x624(%esp),%eax
        r.v.n = d[*p++ - s];
     cbb:	83 c3 04             	add    $0x4,%ebx
        r.e = (uch)(*p < 256 ? 32 : 31);  /* 256 is end-of-block code */
        r.v.n = (ush)*p++;                /* simple code is just the value */
      }
      else
      {
        r.e = e[*p - s];        /* non-simple--look up in lists */
     cbe:	8a 04 08             	mov    (%eax,%ecx,1),%al
        r.v.n = d[*p++ - s];
     cc1:	89 5c 24 4c          	mov    %ebx,0x4c(%esp)
     cc5:	8b 9c 24 20 06 00 00 	mov    0x620(%esp),%ebx
        r.e = (uch)(*p < 256 ? 32 : 31);  /* 256 is end-of-block code */
        r.v.n = (ush)*p++;                /* simple code is just the value */
      }
      else
      {
        r.e = e[*p - s];        /* non-simple--look up in lists */
     ccc:	88 44 24 20          	mov    %al,0x20(%esp)
        r.v.n = d[*p++ - s];
     cd0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
     cd4:	66 8b 04 4b          	mov    (%ebx,%ecx,2),%ax
     cd8:	89 44 24 3c          	mov    %eax,0x3c(%esp)
     cdc:	e9 c5 fd ff ff       	jmp    aa6 <_huft_build+0x3d6>
     ce1:	8b 8c 9c a4 00 00 00 	mov    0xa4(%esp,%ebx,4),%ecx
     ce8:	e9 01 fb ff ff       	jmp    7ee <_huft_build+0x11e>
     ced:	8d 76 00             	lea    0x0(%esi),%esi

00000cf0 <_inflate_dynamic>:


static int inflate_dynamic(__G)
  __GDEF
/* decompress an inflated type 2 (dynamic Huffman codes) block. */
{
     cf0:	55                   	push   %ebp
     cf1:	57                   	push   %edi
     cf2:	56                   	push   %esi
     cf3:	89 c6                	mov    %eax,%esi
     cf5:	53                   	push   %ebx
     cf6:	81 ec 5c 05 00 00    	sub    $0x55c,%esp
  int retval = 0;       /* error code returned: initialized to "no error" */


  /* make local bit buffer */
  Trace((stderr, "\ndynamic block"));
  b = G.bb;
     cfc:	8b 80 3c 0b 01 00    	mov    0x10b3c(%eax),%eax
  k = G.bk;
     d02:	8b 8e 40 0b 01 00    	mov    0x10b40(%esi),%ecx
  int retval = 0;       /* error code returned: initialized to "no error" */


  /* make local bit buffer */
  Trace((stderr, "\ndynamic block"));
  b = G.bb;
     d08:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  k = G.bk;


  /* read in table lengths */
  NEEDBITS(5)
     d0c:	83 f9 04             	cmp    $0x4,%ecx
     d0f:	7f 62                	jg     d73 <_inflate_dynamic+0x83>
     d11:	89 c3                	mov    %eax,%ebx
     d13:	eb 2a                	jmp    d3f <_inflate_dynamic+0x4f>
     d15:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     d1b:	8d 50 01             	lea    0x1(%eax),%edx
     d1e:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     d24:	0f b6 38             	movzbl (%eax),%edi
     d27:	81 e7 ff 00 00 00    	and    $0xff,%edi
     d2d:	89 f8                	mov    %edi,%eax
     d2f:	d3 e0                	shl    %cl,%eax
     d31:	83 c1 08             	add    $0x8,%ecx
     d34:	09 c3                	or     %eax,%ebx
     d36:	83 f9 04             	cmp    $0x4,%ecx
     d39:	0f 8f 60 03 00 00    	jg     109f <_inflate_dynamic+0x3af>
     d3f:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     d45:	85 c0                	test   %eax,%eax
     d47:	8d 50 ff             	lea    -0x1(%eax),%edx
     d4a:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     d50:	7f c3                	jg     d15 <_inflate_dynamic+0x25>
     d52:	89 34 24             	mov    %esi,(%esp)
     d55:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     d59:	e8 00 00 00 00       	call   d5e <_inflate_dynamic+0x6e>
     d5e:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     d62:	83 f8 ff             	cmp    $0xffffffff,%eax
     d65:	75 c8                	jne    d2f <_inflate_dynamic+0x3f>
     d67:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
     d6b:	85 c9                	test   %ecx,%ecx
     d6d:	0f 88 e6 02 00 00    	js     1059 <_inflate_dynamic+0x369>
  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
  DUMPBITS(5)
     d73:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     d77:	83 e9 05             	sub    $0x5,%ecx
     d7a:	c1 e8 05             	shr    $0x5,%eax
  NEEDBITS(5)
     d7d:	83 f9 04             	cmp    $0x4,%ecx


  /* read in table lengths */
  NEEDBITS(5)
  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
  DUMPBITS(5)
     d80:	89 44 24 30          	mov    %eax,0x30(%esp)
  NEEDBITS(5)
     d84:	7f 68                	jg     dee <_inflate_dynamic+0xfe>
     d86:	89 c3                	mov    %eax,%ebx
     d88:	eb 30                	jmp    dba <_inflate_dynamic+0xca>
     d8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     d90:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     d96:	8d 50 01             	lea    0x1(%eax),%edx
     d99:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     d9f:	0f b6 38             	movzbl (%eax),%edi
     da2:	81 e7 ff 00 00 00    	and    $0xff,%edi
     da8:	89 f8                	mov    %edi,%eax
     daa:	d3 e0                	shl    %cl,%eax
     dac:	83 c1 08             	add    $0x8,%ecx
     daf:	09 c3                	or     %eax,%ebx
     db1:	83 f9 04             	cmp    $0x4,%ecx
     db4:	0f 8f ee 02 00 00    	jg     10a8 <_inflate_dynamic+0x3b8>
     dba:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     dc0:	85 c0                	test   %eax,%eax
     dc2:	8d 50 ff             	lea    -0x1(%eax),%edx
     dc5:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     dcb:	7f c3                	jg     d90 <_inflate_dynamic+0xa0>
     dcd:	89 34 24             	mov    %esi,(%esp)
     dd0:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     dd4:	e8 00 00 00 00       	call   dd9 <_inflate_dynamic+0xe9>
     dd9:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     ddd:	83 f8 ff             	cmp    $0xffffffff,%eax
     de0:	75 c8                	jne    daa <_inflate_dynamic+0xba>
     de2:	89 5c 24 30          	mov    %ebx,0x30(%esp)
     de6:	85 c9                	test   %ecx,%ecx
     de8:	0f 88 6b 02 00 00    	js     1059 <_inflate_dynamic+0x369>
  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
  DUMPBITS(5)
     dee:	8b 7c 24 30          	mov    0x30(%esp),%edi
     df2:	83 e9 05             	sub    $0x5,%ecx
     df5:	c1 ef 05             	shr    $0x5,%edi
  NEEDBITS(4)
     df8:	83 f9 03             	cmp    $0x3,%ecx
     dfb:	7e 28                	jle    e25 <_inflate_dynamic+0x135>
     dfd:	eb 56                	jmp    e55 <_inflate_dynamic+0x165>
     dff:	90                   	nop
     e00:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     e06:	8d 50 01             	lea    0x1(%eax),%edx
     e09:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     e0f:	8a 18                	mov    (%eax),%bl
     e11:	81 e3 ff 00 00 00    	and    $0xff,%ebx
     e17:	89 d8                	mov    %ebx,%eax
     e19:	d3 e0                	shl    %cl,%eax
     e1b:	83 c1 08             	add    $0x8,%ecx
     e1e:	09 c7                	or     %eax,%edi
     e20:	83 f9 03             	cmp    $0x3,%ecx
     e23:	7f 30                	jg     e55 <_inflate_dynamic+0x165>
     e25:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     e2b:	85 c0                	test   %eax,%eax
     e2d:	8d 50 ff             	lea    -0x1(%eax),%edx
     e30:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     e36:	7f c8                	jg     e00 <_inflate_dynamic+0x110>
     e38:	89 34 24             	mov    %esi,(%esp)
     e3b:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     e3f:	e8 00 00 00 00       	call   e44 <_inflate_dynamic+0x154>
     e44:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     e48:	83 f8 ff             	cmp    $0xffffffff,%eax
     e4b:	75 cc                	jne    e19 <_inflate_dynamic+0x129>
     e4d:	85 c9                	test   %ecx,%ecx
     e4f:	0f 88 04 02 00 00    	js     1059 <_inflate_dynamic+0x369>
  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
     e55:	89 f8                	mov    %edi,%eax
  DUMPBITS(4)
     e57:	8d 59 fc             	lea    -0x4(%ecx),%ebx
  DUMPBITS(5)
  NEEDBITS(5)
  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
  DUMPBITS(5)
  NEEDBITS(4)
  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
     e5a:	83 e0 0f             	and    $0xf,%eax
     e5d:	89 d9                	mov    %ebx,%ecx
     e5f:	83 c0 04             	add    $0x4,%eax
  DUMPBITS(4)
     e62:	31 ed                	xor    %ebp,%ebp
  DUMPBITS(5)
  NEEDBITS(5)
  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
  DUMPBITS(5)
  NEEDBITS(4)
  nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
     e64:	89 44 24 34          	mov    %eax,0x34(%esp)
     e68:	89 c3                	mov    %eax,%ebx
  DUMPBITS(4)
     e6a:	c1 ef 04             	shr    $0x4,%edi
     e6d:	eb 21                	jmp    e90 <_inflate_dynamic+0x1a0>
     e6f:	90                   	nop


  /* read in bit-length-code lengths */
  for (j = 0; j < nb; j++)
  {
    NEEDBITS(3)
     e70:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     e76:	8d 50 01             	lea    0x1(%eax),%edx
     e79:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     e7f:	8a 10                	mov    (%eax),%dl
     e81:	81 e2 ff 00 00 00    	and    $0xff,%edx
     e87:	89 d0                	mov    %edx,%eax
     e89:	d3 e0                	shl    %cl,%eax
     e8b:	09 c7                	or     %eax,%edi
     e8d:	83 c1 08             	add    $0x8,%ecx
     e90:	83 f9 02             	cmp    $0x2,%ecx
     e93:	7f 30                	jg     ec5 <_inflate_dynamic+0x1d5>
     e95:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     e9b:	85 c0                	test   %eax,%eax
     e9d:	8d 50 ff             	lea    -0x1(%eax),%edx
     ea0:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     ea6:	7f c8                	jg     e70 <_inflate_dynamic+0x180>
     ea8:	89 34 24             	mov    %esi,(%esp)
     eab:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     eaf:	e8 00 00 00 00       	call   eb4 <_inflate_dynamic+0x1c4>
     eb4:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     eb8:	83 f8 ff             	cmp    $0xffffffff,%eax
     ebb:	75 cc                	jne    e89 <_inflate_dynamic+0x199>
     ebd:	85 c9                	test   %ecx,%ecx
     ebf:	0f 88 94 01 00 00    	js     1059 <_inflate_dynamic+0x369>
    ll[border[j]] = (unsigned)b & 7;
     ec5:	8b 04 ad 80 01 00 00 	mov    0x180(,%ebp,4),%eax
     ecc:	89 fa                	mov    %edi,%edx
     ece:	83 e2 07             	and    $0x7,%edx
  if (nl > MAXLITLENS || nd > MAXDISTS)
    return 1;                   /* bad lengths */


  /* read in bit-length-code lengths */
  for (j = 0; j < nb; j++)
     ed1:	45                   	inc    %ebp
  {
    NEEDBITS(3)
    ll[border[j]] = (unsigned)b & 7;
    DUMPBITS(3)
     ed2:	c1 ef 03             	shr    $0x3,%edi
     ed5:	83 e9 03             	sub    $0x3,%ecx

  /* read in bit-length-code lengths */
  for (j = 0; j < nb; j++)
  {
    NEEDBITS(3)
    ll[border[j]] = (unsigned)b & 7;
     ed8:	89 54 84 50          	mov    %edx,0x50(%esp,%eax,4)
  if (nl > MAXLITLENS || nd > MAXDISTS)
    return 1;                   /* bad lengths */


  /* read in bit-length-code lengths */
  for (j = 0; j < nb; j++)
     edc:	39 eb                	cmp    %ebp,%ebx
     ede:	75 b0                	jne    e90 <_inflate_dynamic+0x1a0>
     ee0:	89 cb                	mov    %ecx,%ebx
     ee2:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  {
    NEEDBITS(3)
    ll[border[j]] = (unsigned)b & 7;
    DUMPBITS(3)
  }
  for (; j < 19; j++)
     ee6:	83 f9 13             	cmp    $0x13,%ecx
     ee9:	8d 04 8d 80 01 00 00 	lea    0x180(,%ecx,4),%eax
     ef0:	74 14                	je     f06 <_inflate_dynamic+0x216>
    ll[border[j]] = 0;
     ef2:	8b 10                	mov    (%eax),%edx
     ef4:	83 c0 04             	add    $0x4,%eax
  {
    NEEDBITS(3)
    ll[border[j]] = (unsigned)b & 7;
    DUMPBITS(3)
  }
  for (; j < 19; j++)
     ef7:	3d cc 01 00 00       	cmp    $0x1cc,%eax
    ll[border[j]] = 0;
     efc:	c7 44 94 50 00 00 00 	movl   $0x0,0x50(%esp,%edx,4)
     f03:	00 
  {
    NEEDBITS(3)
    ll[border[j]] = (unsigned)b & 7;
    DUMPBITS(3)
  }
  for (; j < 19; j++)
     f04:	75 ec                	jne    ef2 <_inflate_dynamic+0x202>
    ll[border[j]] = 0;


  /* build decoding table for trees--single level, 7 bit lookup */
  bl = 7;
  retval = huft_build(__G__ ll, 19, 19, NULL, NULL, &tl, &bl);
     f06:	8d 44 24 48          	lea    0x48(%esp),%eax
     f0a:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
     f11:	00 
     f12:	89 44 24 1c          	mov    %eax,0x1c(%esp)
     f16:	8d 44 24 40          	lea    0x40(%esp),%eax
     f1a:	89 44 24 18          	mov    %eax,0x18(%esp)
     f1e:	8d 44 24 50          	lea    0x50(%esp),%eax
     f22:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
     f29:	00 
     f2a:	c7 44 24 0c 13 00 00 	movl   $0x13,0xc(%esp)
     f31:	00 
     f32:	c7 44 24 08 13 00 00 	movl   $0x13,0x8(%esp)
     f39:	00 
     f3a:	89 44 24 04          	mov    %eax,0x4(%esp)
     f3e:	89 34 24             	mov    %esi,(%esp)
  for (; j < 19; j++)
    ll[border[j]] = 0;


  /* build decoding table for trees--single level, 7 bit lookup */
  bl = 7;
     f41:	c7 44 24 48 07 00 00 	movl   $0x7,0x48(%esp)
     f48:	00 
  retval = huft_build(__G__ ll, 19, 19, NULL, NULL, &tl, &bl);
     f49:	e8 82 f7 ff ff       	call   6d0 <_huft_build>
  if (bl == 0)                  /* no bit lengths */
     f4e:	8b 54 24 48          	mov    0x48(%esp),%edx
     f52:	85 d2                	test   %edx,%edx
     f54:	0f 84 5c 01 00 00    	je     10b6 <_inflate_dynamic+0x3c6>
    retval = 1;
  if (retval)
     f5a:	85 c0                	test   %eax,%eax
     f5c:	0f 85 4f 01 00 00    	jne    10b1 <_inflate_dynamic+0x3c1>
  k = G.bk;


  /* read in table lengths */
  NEEDBITS(5)
  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
     f62:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp


  /* read in literal and distance code lengths */
  n = nl + nd;
  m = mask_bits[bl];
  i = l = 0;
     f66:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
     f6d:	00 
  k = G.bk;


  /* read in table lengths */
  NEEDBITS(5)
  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
     f6e:	83 e5 1f             	and    $0x1f,%ebp
     f71:	8d 85 01 01 00 00    	lea    0x101(%ebp),%eax


  /* read in literal and distance code lengths */
  n = nl + nd;
  m = mask_bits[bl];
  i = l = 0;
     f77:	31 ed                	xor    %ebp,%ebp
  k = G.bk;


  /* read in table lengths */
  NEEDBITS(5)
  nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
     f79:	89 c1                	mov    %eax,%ecx
     f7b:	89 44 24 38          	mov    %eax,0x38(%esp)
  DUMPBITS(5)
  NEEDBITS(5)
  nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
     f7f:	8b 44 24 30          	mov    0x30(%esp),%eax
     f83:	83 e0 1f             	and    $0x1f,%eax
     f86:	40                   	inc    %eax
     f87:	89 44 24 3c          	mov    %eax,0x3c(%esp)
    return retval;              /* incomplete code set */
  }


  /* read in literal and distance code lengths */
  n = nl + nd;
     f8b:	01 c8                	add    %ecx,%eax
     f8d:	89 44 24 30          	mov    %eax,0x30(%esp)
  m = mask_bits[bl];
     f91:	8b 04 95 00 00 00 00 	mov    0x0(,%edx,4),%eax
     f98:	89 44 24 34          	mov    %eax,0x34(%esp)
     f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     fa0:	89 d9                	mov    %ebx,%ecx
  i = l = 0;
  while (i < n)
  {
    NEEDBITS(bl)
     fa2:	39 d3                	cmp    %edx,%ebx
     fa4:	7c 2c                	jl     fd2 <_inflate_dynamic+0x2e2>
     fa6:	eb 58                	jmp    1000 <_inflate_dynamic+0x310>
     fa8:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
     fae:	8d 50 01             	lea    0x1(%eax),%edx
     fb1:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
     fb7:	8a 18                	mov    (%eax),%bl
     fb9:	81 e3 ff 00 00 00    	and    $0xff,%ebx
     fbf:	89 d8                	mov    %ebx,%eax
     fc1:	d3 e0                	shl    %cl,%eax
     fc3:	83 c1 08             	add    $0x8,%ecx
     fc6:	09 c7                	or     %eax,%edi
     fc8:	3b 4c 24 48          	cmp    0x48(%esp),%ecx
     fcc:	0f 8d d2 01 00 00    	jge    11a4 <_inflate_dynamic+0x4b4>
     fd2:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
     fd8:	85 c0                	test   %eax,%eax
     fda:	8d 50 ff             	lea    -0x1(%eax),%edx
     fdd:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
     fe3:	7f c3                	jg     fa8 <_inflate_dynamic+0x2b8>
     fe5:	89 34 24             	mov    %esi,(%esp)
     fe8:	89 4c 24 28          	mov    %ecx,0x28(%esp)
     fec:	e8 00 00 00 00       	call   ff1 <_inflate_dynamic+0x301>
     ff1:	8b 4c 24 28          	mov    0x28(%esp),%ecx
     ff5:	83 f8 ff             	cmp    $0xffffffff,%eax
     ff8:	75 c7                	jne    fc1 <_inflate_dynamic+0x2d1>
     ffa:	89 cb                	mov    %ecx,%ebx
     ffc:	85 c9                	test   %ecx,%ecx
     ffe:	78 59                	js     1059 <_inflate_dynamic+0x369>
    j = (td = tl + ((unsigned)b & m))->b;
    1000:	8b 54 24 34          	mov    0x34(%esp),%edx
    1004:	8b 44 24 40          	mov    0x40(%esp),%eax
    1008:	21 fa                	and    %edi,%edx
    100a:	8d 04 d0             	lea    (%eax,%edx,8),%eax
    DUMPBITS(j)
    100d:	31 d2                	xor    %edx,%edx
  m = mask_bits[bl];
  i = l = 0;
  while (i < n)
  {
    NEEDBITS(bl)
    j = (td = tl + ((unsigned)b & m))->b;
    100f:	89 44 24 44          	mov    %eax,0x44(%esp)
    DUMPBITS(j)
    1013:	8a 48 01             	mov    0x1(%eax),%cl
    1016:	8a 50 01             	mov    0x1(%eax),%dl
    1019:	d3 ef                	shr    %cl,%edi
    j = td->v.n;
    101b:	8b 48 04             	mov    0x4(%eax),%ecx
  i = l = 0;
  while (i < n)
  {
    NEEDBITS(bl)
    j = (td = tl + ((unsigned)b & m))->b;
    DUMPBITS(j)
    101e:	29 d3                	sub    %edx,%ebx
    j = td->v.n;
    1020:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
    1026:	89 c8                	mov    %ecx,%eax
    if (j < 16)                 /* length of code in bits (0..15) */
    1028:	83 f9 0f             	cmp    $0xf,%ecx
    102b:	0f 87 af 00 00 00    	ja     10e0 <_inflate_dynamic+0x3f0>
      ll[i++] = l = j;          /* save last length in l */
    1031:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    1035:	89 c5                	mov    %eax,%ebp
    1037:	89 44 8c 50          	mov    %eax,0x50(%esp,%ecx,4)
    103b:	8d 41 01             	lea    0x1(%ecx),%eax
    103e:	89 44 24 2c          	mov    %eax,0x2c(%esp)

  /* read in literal and distance code lengths */
  n = nl + nd;
  m = mask_bits[bl];
  i = l = 0;
  while (i < n)
    1042:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    1046:	39 4c 24 30          	cmp    %ecx,0x30(%esp)
    104a:	0f 86 de 02 00 00    	jbe    132e <_inflate_dynamic+0x63e>
    1050:	8b 54 24 48          	mov    0x48(%esp),%edx
    1054:	e9 47 ff ff ff       	jmp    fa0 <_inflate_dynamic+0x2b0>
  b = G.bb;
  k = G.bk;


  /* read in table lengths */
  NEEDBITS(5)
    1059:	be 01 00 00 00       	mov    $0x1,%esi
  /* decompress until an end-of-block code */
  retval = inflate_codes(__G__ tl, td, bl, bd);

cleanup_and_exit:
  /* free the decoding tables, return */
  huft_free(tl);
    105e:	8b 5c 24 40          	mov    0x40(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1062:	85 db                	test   %ebx,%ebx
    1064:	74 12                	je     1078 <_inflate_dynamic+0x388>
  {
    q = (--p)->v.t;
    1066:	8d 43 f8             	lea    -0x8(%ebx),%eax
    1069:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    106c:	89 04 24             	mov    %eax,(%esp)
    106f:	e8 00 00 00 00       	call   1074 <_inflate_dynamic+0x384>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1074:	85 db                	test   %ebx,%ebx
    1076:	75 ee                	jne    1066 <_inflate_dynamic+0x376>
  retval = inflate_codes(__G__ tl, td, bl, bd);

cleanup_and_exit:
  /* free the decoding tables, return */
  huft_free(tl);
  huft_free(td);
    1078:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    107c:	85 db                	test   %ebx,%ebx
    107e:	74 12                	je     1092 <_inflate_dynamic+0x3a2>
  {
    q = (--p)->v.t;
    1080:	8d 43 f8             	lea    -0x8(%ebx),%eax
    1083:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    1086:	89 04 24             	mov    %eax,(%esp)
    1089:	e8 00 00 00 00       	call   108e <_inflate_dynamic+0x39e>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    108e:	85 db                	test   %ebx,%ebx
    1090:	75 ee                	jne    1080 <_inflate_dynamic+0x390>

cleanup_and_exit:
  /* free the decoding tables, return */
  huft_free(tl);
  huft_free(td);
  return retval;
    1092:	89 f0                	mov    %esi,%eax
}
    1094:	81 c4 5c 05 00 00    	add    $0x55c,%esp
    109a:	5b                   	pop    %ebx
    109b:	5e                   	pop    %esi
    109c:	5f                   	pop    %edi
    109d:	5d                   	pop    %ebp
    109e:	c3                   	ret    
    109f:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
    10a3:	e9 cb fc ff ff       	jmp    d73 <_inflate_dynamic+0x83>
    10a8:	89 5c 24 30          	mov    %ebx,0x30(%esp)
    10ac:	e9 3d fd ff ff       	jmp    dee <_inflate_dynamic+0xfe>
  retval = huft_build(__G__ ll, 19, 19, NULL, NULL, &tl, &bl);
  if (bl == 0)                  /* no bit lengths */
    retval = 1;
  if (retval)
  {
    if (retval == 1)
    10b1:	83 f8 01             	cmp    $0x1,%eax
    10b4:	75 de                	jne    1094 <_inflate_dynamic+0x3a4>
      huft_free(tl);
    10b6:	8b 5c 24 40          	mov    0x40(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    10ba:	85 db                	test   %ebx,%ebx
    10bc:	74 12                	je     10d0 <_inflate_dynamic+0x3e0>
  {
    q = (--p)->v.t;
    10be:	8d 43 f8             	lea    -0x8(%ebx),%eax
    10c1:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    10c4:	89 04 24             	mov    %eax,(%esp)
    10c7:	e8 00 00 00 00       	call   10cc <_inflate_dynamic+0x3dc>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    10cc:	85 db                	test   %ebx,%ebx
    10ce:	75 ee                	jne    10be <_inflate_dynamic+0x3ce>
cleanup_and_exit:
  /* free the decoding tables, return */
  huft_free(tl);
  huft_free(td);
  return retval;
}
    10d0:	81 c4 5c 05 00 00    	add    $0x55c,%esp
    10d6:	b8 01 00 00 00       	mov    $0x1,%eax
    10db:	5b                   	pop    %ebx
    10dc:	5e                   	pop    %esi
    10dd:	5f                   	pop    %edi
    10de:	5d                   	pop    %ebp
    10df:	c3                   	ret    
    j = (td = tl + ((unsigned)b & m))->b;
    DUMPBITS(j)
    j = td->v.n;
    if (j < 16)                 /* length of code in bits (0..15) */
      ll[i++] = l = j;          /* save last length in l */
    else if (j == 16)           /* repeat last length 3 to 6 times */
    10e0:	83 f9 10             	cmp    $0x10,%ecx
    10e3:	0f 84 c2 00 00 00    	je     11ab <_inflate_dynamic+0x4bb>
      if ((unsigned)i + j > n)
        return 1;
      while (j--)
        ll[i++] = l;
    }
    else if (j == 17)           /* 3 to 10 zero length codes */
    10e9:	83 f9 11             	cmp    $0x11,%ecx
    10ec:	0f 84 72 01 00 00    	je     1264 <_inflate_dynamic+0x574>
    10f2:	89 d9                	mov    %ebx,%ecx
        ll[i++] = 0;
      l = 0;
    }
    else                        /* j == 18: 11 to 138 zero length codes */
    {
      NEEDBITS(7)
    10f4:	83 fb 06             	cmp    $0x6,%ebx
    10f7:	7e 30                	jle    1129 <_inflate_dynamic+0x439>
    10f9:	eb 60                	jmp    115b <_inflate_dynamic+0x46b>
    10fb:	90                   	nop
    10fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1100:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
    1106:	8d 50 01             	lea    0x1(%eax),%edx
    1109:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
    110f:	8a 18                	mov    (%eax),%bl
    1111:	81 e3 ff 00 00 00    	and    $0xff,%ebx
    1117:	89 d8                	mov    %ebx,%eax
    1119:	d3 e0                	shl    %cl,%eax
    111b:	83 c1 08             	add    $0x8,%ecx
    111e:	09 c7                	or     %eax,%edi
    1120:	83 f9 06             	cmp    $0x6,%ecx
    1123:	0f 8f 34 01 00 00    	jg     125d <_inflate_dynamic+0x56d>
    1129:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
    112f:	85 c0                	test   %eax,%eax
    1131:	8d 50 ff             	lea    -0x1(%eax),%edx
    1134:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
    113a:	7f c4                	jg     1100 <_inflate_dynamic+0x410>
    113c:	89 34 24             	mov    %esi,(%esp)
    113f:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    1143:	e8 00 00 00 00       	call   1148 <_inflate_dynamic+0x458>
    1148:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    114c:	83 f8 ff             	cmp    $0xffffffff,%eax
    114f:	75 c8                	jne    1119 <_inflate_dynamic+0x429>
    1151:	89 cb                	mov    %ecx,%ebx
    1153:	85 c9                	test   %ecx,%ecx
    1155:	0f 88 fe fe ff ff    	js     1059 <_inflate_dynamic+0x369>
      j = 11 + ((unsigned)b & 0x7f);
    115b:	89 fa                	mov    %edi,%edx
      DUMPBITS(7)
      if ((unsigned)i + j > n)
    115d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
      l = 0;
    }
    else                        /* j == 18: 11 to 138 zero length codes */
    {
      NEEDBITS(7)
      j = 11 + ((unsigned)b & 0x7f);
    1161:	83 e2 7f             	and    $0x7f,%edx
      DUMPBITS(7)
    1164:	83 eb 07             	sub    $0x7,%ebx
    1167:	c1 ef 07             	shr    $0x7,%edi
      if ((unsigned)i + j > n)
    116a:	8d 44 10 0b          	lea    0xb(%eax,%edx,1),%eax
    116e:	39 44 24 30          	cmp    %eax,0x30(%esp)
    1172:	0f 82 58 ff ff ff    	jb     10d0 <_inflate_dynamic+0x3e0>
    1178:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    117c:	8d 44 8c 50          	lea    0x50(%esp,%ecx,4),%eax
    1180:	8d 4c 11 0b          	lea    0xb(%ecx,%edx,1),%ecx
    1184:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
    1188:	8d 54 8c 50          	lea    0x50(%esp,%ecx,4),%edx
    118c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return 1;
      while (j--)
        ll[i++] = 0;
    1190:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    1196:	83 c0 04             	add    $0x4,%eax
      NEEDBITS(7)
      j = 11 + ((unsigned)b & 0x7f);
      DUMPBITS(7)
      if ((unsigned)i + j > n)
        return 1;
      while (j--)
    1199:	39 d0                	cmp    %edx,%eax
    119b:	75 f3                	jne    1190 <_inflate_dynamic+0x4a0>
        ll[i++] = 0;
      l = 0;
    119d:	31 ed                	xor    %ebp,%ebp
    119f:	e9 9e fe ff ff       	jmp    1042 <_inflate_dynamic+0x352>
    11a4:	89 cb                	mov    %ecx,%ebx
    11a6:	e9 55 fe ff ff       	jmp    1000 <_inflate_dynamic+0x310>
    j = td->v.n;
    if (j < 16)                 /* length of code in bits (0..15) */
      ll[i++] = l = j;          /* save last length in l */
    else if (j == 16)           /* repeat last length 3 to 6 times */
    {
      NEEDBITS(2)
    11ab:	83 fb 01             	cmp    $0x1,%ebx
    11ae:	7f 5f                	jg     120f <_inflate_dynamic+0x51f>
    11b0:	89 d9                	mov    %ebx,%ecx
    11b2:	eb 29                	jmp    11dd <_inflate_dynamic+0x4ed>
    11b4:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
    11ba:	8d 50 01             	lea    0x1(%eax),%edx
    11bd:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
    11c3:	8a 18                	mov    (%eax),%bl
    11c5:	81 e3 ff 00 00 00    	and    $0xff,%ebx
    11cb:	89 d8                	mov    %ebx,%eax
    11cd:	d3 e0                	shl    %cl,%eax
    11cf:	83 c1 08             	add    $0x8,%ecx
    11d2:	09 c7                	or     %eax,%edi
    11d4:	83 f9 01             	cmp    $0x1,%ecx
    11d7:	0f 8f 46 01 00 00    	jg     1323 <_inflate_dynamic+0x633>
    11dd:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
    11e3:	85 c0                	test   %eax,%eax
    11e5:	8d 50 ff             	lea    -0x1(%eax),%edx
    11e8:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
    11ee:	7f c4                	jg     11b4 <_inflate_dynamic+0x4c4>
    11f0:	89 34 24             	mov    %esi,(%esp)
    11f3:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    11f7:	e8 00 00 00 00       	call   11fc <_inflate_dynamic+0x50c>
    11fc:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    1200:	83 f8 ff             	cmp    $0xffffffff,%eax
    1203:	75 c8                	jne    11cd <_inflate_dynamic+0x4dd>
    1205:	89 cb                	mov    %ecx,%ebx
    1207:	85 c9                	test   %ecx,%ecx
    1209:	0f 88 4a fe ff ff    	js     1059 <_inflate_dynamic+0x369>
      j = 3 + ((unsigned)b & 3);
    120f:	89 f8                	mov    %edi,%eax
      DUMPBITS(2)
    1211:	83 eb 02             	sub    $0x2,%ebx
    1214:	c1 ef 02             	shr    $0x2,%edi
    if (j < 16)                 /* length of code in bits (0..15) */
      ll[i++] = l = j;          /* save last length in l */
    else if (j == 16)           /* repeat last length 3 to 6 times */
    {
      NEEDBITS(2)
      j = 3 + ((unsigned)b & 3);
    1217:	83 e0 03             	and    $0x3,%eax
    121a:	89 44 24 28          	mov    %eax,0x28(%esp)
    121e:	8d 50 03             	lea    0x3(%eax),%edx
      DUMPBITS(2)
      if ((unsigned)i + j > n)
    1221:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    1225:	01 d0                	add    %edx,%eax
    1227:	39 44 24 30          	cmp    %eax,0x30(%esp)
    122b:	0f 82 9f fe ff ff    	jb     10d0 <_inflate_dynamic+0x3e0>
    1231:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    1235:	8d 4c 84 50          	lea    0x50(%esp,%eax,4),%ecx
    1239:	31 c0                	xor    %eax,%eax
    123b:	90                   	nop
    123c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return 1;
      while (j--)
        ll[i++] = l;
    1240:	89 2c 81             	mov    %ebp,(%ecx,%eax,4)
    1243:	40                   	inc    %eax
      NEEDBITS(2)
      j = 3 + ((unsigned)b & 3);
      DUMPBITS(2)
      if ((unsigned)i + j > n)
        return 1;
      while (j--)
    1244:	39 d0                	cmp    %edx,%eax
    1246:	75 f8                	jne    1240 <_inflate_dynamic+0x550>
    1248:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    124c:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    1250:	8d 44 08 03          	lea    0x3(%eax,%ecx,1),%eax
    1254:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    1258:	e9 e5 fd ff ff       	jmp    1042 <_inflate_dynamic+0x352>
    125d:	89 cb                	mov    %ecx,%ebx
    125f:	e9 f7 fe ff ff       	jmp    115b <_inflate_dynamic+0x46b>
        ll[i++] = l;
    }
    else if (j == 17)           /* 3 to 10 zero length codes */
    {
      NEEDBITS(3)
    1264:	83 fb 02             	cmp    $0x2,%ebx
    1267:	7f 62                	jg     12cb <_inflate_dynamic+0x5db>
    1269:	89 d9                	mov    %ebx,%ecx
    126b:	eb 2c                	jmp    1299 <_inflate_dynamic+0x5a9>
    126d:	8d 76 00             	lea    0x0(%esi),%esi
    1270:	8b 86 e8 08 01 00    	mov    0x108e8(%esi),%eax
    1276:	8d 50 01             	lea    0x1(%eax),%edx
    1279:	89 96 e8 08 01 00    	mov    %edx,0x108e8(%esi)
    127f:	8a 18                	mov    (%eax),%bl
    1281:	81 e3 ff 00 00 00    	and    $0xff,%ebx
    1287:	89 d8                	mov    %ebx,%eax
    1289:	d3 e0                	shl    %cl,%eax
    128b:	83 c1 08             	add    $0x8,%ecx
    128e:	09 c7                	or     %eax,%edi
    1290:	83 f9 02             	cmp    $0x2,%ecx
    1293:	0f 8f 91 00 00 00    	jg     132a <_inflate_dynamic+0x63a>
    1299:	8b 86 ec 08 01 00    	mov    0x108ec(%esi),%eax
    129f:	85 c0                	test   %eax,%eax
    12a1:	8d 50 ff             	lea    -0x1(%eax),%edx
    12a4:	89 96 ec 08 01 00    	mov    %edx,0x108ec(%esi)
    12aa:	7f c4                	jg     1270 <_inflate_dynamic+0x580>
    12ac:	89 34 24             	mov    %esi,(%esp)
    12af:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    12b3:	e8 00 00 00 00       	call   12b8 <_inflate_dynamic+0x5c8>
    12b8:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    12bc:	83 f8 ff             	cmp    $0xffffffff,%eax
    12bf:	75 c8                	jne    1289 <_inflate_dynamic+0x599>
    12c1:	89 cb                	mov    %ecx,%ebx
    12c3:	85 c9                	test   %ecx,%ecx
    12c5:	0f 88 8e fd ff ff    	js     1059 <_inflate_dynamic+0x369>
      j = 3 + ((unsigned)b & 7);
    12cb:	89 fa                	mov    %edi,%edx
      DUMPBITS(3)
      if ((unsigned)i + j > n)
    12cd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
        ll[i++] = l;
    }
    else if (j == 17)           /* 3 to 10 zero length codes */
    {
      NEEDBITS(3)
      j = 3 + ((unsigned)b & 7);
    12d1:	83 e2 07             	and    $0x7,%edx
      DUMPBITS(3)
    12d4:	83 eb 03             	sub    $0x3,%ebx
    12d7:	c1 ef 03             	shr    $0x3,%edi
      if ((unsigned)i + j > n)
    12da:	8d 44 10 03          	lea    0x3(%eax,%edx,1),%eax
    12de:	39 44 24 30          	cmp    %eax,0x30(%esp)
    12e2:	0f 82 e8 fd ff ff    	jb     10d0 <_inflate_dynamic+0x3e0>
    12e8:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    12ec:	8d 44 8c 50          	lea    0x50(%esp,%ecx,4),%eax
    12f0:	8d 4c 11 03          	lea    0x3(%ecx,%edx,1),%ecx
    12f4:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
    12f8:	8d 54 8c 50          	lea    0x50(%esp,%ecx,4),%edx
    12fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return 1;
      while (j--)
        ll[i++] = 0;
    1300:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    1306:	83 c0 04             	add    $0x4,%eax
      NEEDBITS(3)
      j = 3 + ((unsigned)b & 7);
      DUMPBITS(3)
      if ((unsigned)i + j > n)
        return 1;
      while (j--)
    1309:	39 d0                	cmp    %edx,%eax
    130b:	0f 84 8c fe ff ff    	je     119d <_inflate_dynamic+0x4ad>
        ll[i++] = 0;
    1311:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    1317:	83 c0 04             	add    $0x4,%eax
      NEEDBITS(3)
      j = 3 + ((unsigned)b & 7);
      DUMPBITS(3)
      if ((unsigned)i + j > n)
        return 1;
      while (j--)
    131a:	39 d0                	cmp    %edx,%eax
    131c:	75 e2                	jne    1300 <_inflate_dynamic+0x610>
    131e:	e9 7a fe ff ff       	jmp    119d <_inflate_dynamic+0x4ad>
    1323:	89 cb                	mov    %ecx,%ebx
    1325:	e9 e5 fe ff ff       	jmp    120f <_inflate_dynamic+0x51f>
    132a:	89 cb                	mov    %ecx,%ebx
    132c:	eb 9d                	jmp    12cb <_inflate_dynamic+0x5db>
    }
  }


  /* free decoding table for trees */
  huft_free(tl);
    132e:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1332:	85 ed                	test   %ebp,%ebp
    1334:	74 12                	je     1348 <_inflate_dynamic+0x658>
  {
    q = (--p)->v.t;
    1336:	8d 45 f8             	lea    -0x8(%ebp),%eax
    1339:	8b 6d fc             	mov    -0x4(%ebp),%ebp
    free((zvoid *)p);
    133c:	89 04 24             	mov    %eax,(%esp)
    133f:	e8 00 00 00 00       	call   1344 <_inflate_dynamic+0x654>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1344:	85 ed                	test   %ebp,%ebp
    1346:	75 ee                	jne    1336 <_inflate_dynamic+0x646>


  /* build the decoding tables for literal/length and distance codes */
  bl = lbits;
#ifdef USE_DEFLATE64
  retval = huft_build(__G__ ll, nl, 257, G.cplens, G.cplext, &tl, &bl);
    1348:	8d 44 24 48          	lea    0x48(%esp),%eax
  /* free decoding table for trees */
  huft_free(tl);


  /* restore the global bit buffer */
  G.bb = b;
    134c:	89 be 3c 0b 01 00    	mov    %edi,0x10b3c(%esi)
  G.bk = k;
    1352:	89 9e 40 0b 01 00    	mov    %ebx,0x10b40(%esi)


  /* build the decoding tables for literal/length and distance codes */
  bl = lbits;
#ifdef USE_DEFLATE64
  retval = huft_build(__G__ ll, nl, 257, G.cplens, G.cplext, &tl, &bl);
    1358:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    135c:	8d 44 24 40          	lea    0x40(%esp),%eax
  G.bb = b;
  G.bk = k;


  /* build the decoding tables for literal/length and distance codes */
  bl = lbits;
    1360:	c7 44 24 48 09 00 00 	movl   $0x9,0x48(%esp)
    1367:	00 
#ifdef USE_DEFLATE64
  retval = huft_build(__G__ ll, nl, 257, G.cplens, G.cplext, &tl, &bl);
    1368:	89 44 24 18          	mov    %eax,0x18(%esp)
    136c:	8b 86 30 0b 01 00    	mov    0x10b30(%esi),%eax
    1372:	89 44 24 14          	mov    %eax,0x14(%esp)
    1376:	8b 86 2c 0b 01 00    	mov    0x10b2c(%esi),%eax
    137c:	c7 44 24 0c 01 01 00 	movl   $0x101,0xc(%esp)
    1383:	00 
    1384:	89 44 24 10          	mov    %eax,0x10(%esp)
    1388:	8b 44 24 38          	mov    0x38(%esp),%eax
    138c:	89 44 24 08          	mov    %eax,0x8(%esp)
    1390:	8d 44 24 50          	lea    0x50(%esp),%eax
    1394:	89 44 24 04          	mov    %eax,0x4(%esp)
    1398:	89 34 24             	mov    %esi,(%esp)
    139b:	e8 30 f3 ff ff       	call   6d0 <_huft_build>
#else
  retval = huft_build(__G__ ll, nl, 257, cplens, cplext, &tl, &bl);
#endif
  if (bl == 0)                  /* no literals or lengths */
    13a0:	8b 4c 24 48          	mov    0x48(%esp),%ecx
    13a4:	85 c9                	test   %ecx,%ecx
    13a6:	0f 84 ef 00 00 00    	je     149b <_inflate_dynamic+0x7ab>
    retval = 1;
  if (retval)
    13ac:	85 c0                	test   %eax,%eax
    13ae:	0f 85 de 00 00 00    	jne    1492 <_inflate_dynamic+0x7a2>
  bd = (dbits <= bl+1 ? dbits : bl+1);
#else
  bd = dbits;
#endif
#ifdef USE_DEFLATE64
  retval = huft_build(__G__ ll + nl, nd, 0, cpdist, G.cpdext, &td, &bd);
    13b4:	8d 44 24 4c          	lea    0x4c(%esp),%eax
  /* Adjust the requested distance base table size so that a distance code
     fetch never tries to get bits behind an immediatly following end-of-block
     code. */
  bd = (dbits <= bl+1 ? dbits : bl+1);
#else
  bd = dbits;
    13b8:	c7 44 24 4c 06 00 00 	movl   $0x6,0x4c(%esp)
    13bf:	00 
#endif
#ifdef USE_DEFLATE64
  retval = huft_build(__G__ ll + nl, nd, 0, cpdist, G.cpdext, &td, &bd);
    13c0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    13c4:	8d 44 24 44          	lea    0x44(%esp),%eax
    13c8:	89 44 24 18          	mov    %eax,0x18(%esp)
    13cc:	8b 86 34 0b 01 00    	mov    0x10b34(%esi),%eax
    13d2:	c7 44 24 10 80 00 00 	movl   $0x80,0x10(%esp)
    13d9:	00 
    13da:	89 44 24 14          	mov    %eax,0x14(%esp)
    13de:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    13e2:	89 44 24 08          	mov    %eax,0x8(%esp)
    13e6:	8b 44 24 38          	mov    0x38(%esp),%eax
    13ea:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    13f1:	00 
    13f2:	89 34 24             	mov    %esi,(%esp)
    13f5:	8d 44 84 50          	lea    0x50(%esp,%eax,4),%eax
    13f9:	89 44 24 04          	mov    %eax,0x4(%esp)
    13fd:	e8 ce f2 ff ff       	call   6d0 <_huft_build>
    1402:	89 c7                	mov    %eax,%edi
#else
  retval = huft_build(__G__ ll + nl, nd, 0, cpdist, cpdext, &td, &bd);
#endif
#ifdef PKZIP_BUG_WORKAROUND
  if (retval == 1)
    1404:	83 f8 01             	cmp    $0x1,%eax
    1407:	0f 84 0b 01 00 00    	je     1518 <_inflate_dynamic+0x828>
    retval = 0;
#endif
  if (bd == 0 && nl > 257)    /* lengths but no distances */
    140d:	8b 54 24 4c          	mov    0x4c(%esp),%edx
    1411:	81 7c 24 38 01 01 00 	cmpl   $0x101,0x38(%esp)
    1418:	00 
    1419:	0f 84 ca 00 00 00    	je     14e9 <_inflate_dynamic+0x7f9>
    141f:	85 d2                	test   %edx,%edx
    1421:	0f 85 c2 00 00 00    	jne    14e9 <_inflate_dynamic+0x7f9>
    retval = 1;
  if (retval)
  {
    if (retval == 1) {
      if (!uO.qflag)
    1427:	8b 46 38             	mov    0x38(%esi),%eax
    142a:	85 c0                	test   %eax,%eax
    142c:	75 24                	jne    1452 <_inflate_dynamic+0x762>
        MESSAGE((uch *)"(incomplete d-tree)  ", 21L, 1);
    142e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    1435:	00 
    1436:	c7 44 24 08 15 00 00 	movl   $0x15,0x8(%esp)
    143d:	00 
    143e:	c7 44 24 04 16 00 00 	movl   $0x16,0x4(%esp)
    1445:	00 
    1446:	89 34 24             	mov    %esi,(%esp)
    1449:	ff 96 44 0b 01 00    	call   *0x10b44(%esi)
    144f:	83 ec 10             	sub    $0x10,%esp
      huft_free(td);
    1452:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1456:	85 db                	test   %ebx,%ebx
    1458:	74 12                	je     146c <_inflate_dynamic+0x77c>
  {
    q = (--p)->v.t;
    145a:	8d 43 f8             	lea    -0x8(%ebx),%eax
    145d:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    1460:	89 04 24             	mov    %eax,(%esp)
    1463:	e8 00 00 00 00       	call   1468 <_inflate_dynamic+0x778>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1468:	85 db                	test   %ebx,%ebx
    146a:	75 ee                	jne    145a <_inflate_dynamic+0x76a>
#ifdef PKZIP_BUG_WORKAROUND
  if (retval == 1)
    retval = 0;
#endif
  if (bd == 0 && nl > 257)    /* lengths but no distances */
    retval = 1;
    146c:	bf 01 00 00 00       	mov    $0x1,%edi
    if (retval == 1) {
      if (!uO.qflag)
        MESSAGE((uch *)"(incomplete d-tree)  ", 21L, 1);
      huft_free(td);
    }
    huft_free(tl);
    1471:	8b 5c 24 40          	mov    0x40(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1475:	85 db                	test   %ebx,%ebx
    1477:	74 12                	je     148b <_inflate_dynamic+0x79b>
  {
    q = (--p)->v.t;
    1479:	8d 43 f8             	lea    -0x8(%ebx),%eax
    147c:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    147f:	89 04 24             	mov    %eax,(%esp)
    1482:	e8 00 00 00 00       	call   1487 <_inflate_dynamic+0x797>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1487:	85 db                	test   %ebx,%ebx
    1489:	75 ee                	jne    1479 <_inflate_dynamic+0x789>
    148b:	89 f8                	mov    %edi,%eax
    148d:	e9 02 fc ff ff       	jmp    1094 <_inflate_dynamic+0x3a4>
#endif
  if (bl == 0)                  /* no literals or lengths */
    retval = 1;
  if (retval)
  {
    if (retval == 1) {
    1492:	83 f8 01             	cmp    $0x1,%eax
    1495:	0f 85 f9 fb ff ff    	jne    1094 <_inflate_dynamic+0x3a4>
      if (!uO.qflag)
    149b:	8b 56 38             	mov    0x38(%esi),%edx
    149e:	85 d2                	test   %edx,%edx
    14a0:	75 24                	jne    14c6 <_inflate_dynamic+0x7d6>
        MESSAGE((uch *)"(incomplete l-tree)  ", 21L, 1);
    14a2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    14a9:	00 
    14aa:	c7 44 24 08 15 00 00 	movl   $0x15,0x8(%esp)
    14b1:	00 
    14b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    14b9:	00 
    14ba:	89 34 24             	mov    %esi,(%esp)
    14bd:	ff 96 44 0b 01 00    	call   *0x10b44(%esi)
    14c3:	83 ec 10             	sub    $0x10,%esp
      huft_free(tl);
    14c6:	8b 5c 24 40          	mov    0x40(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    14ca:	85 db                	test   %ebx,%ebx
    14cc:	0f 84 fe fb ff ff    	je     10d0 <_inflate_dynamic+0x3e0>
  {
    q = (--p)->v.t;
    14d2:	8d 43 f8             	lea    -0x8(%ebx),%eax
    14d5:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    14d8:	89 04 24             	mov    %eax,(%esp)
    14db:	e8 00 00 00 00       	call   14e0 <_inflate_dynamic+0x7f0>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    14e0:	85 db                	test   %ebx,%ebx
    14e2:	75 ee                	jne    14d2 <_inflate_dynamic+0x7e2>
    14e4:	e9 e7 fb ff ff       	jmp    10d0 <_inflate_dynamic+0x3e0>
  if (retval == 1)
    retval = 0;
#endif
  if (bd == 0 && nl > 257)    /* lengths but no distances */
    retval = 1;
  if (retval)
    14e9:	85 ff                	test   %edi,%edi
    14eb:	75 84                	jne    1471 <_inflate_dynamic+0x781>
    huft_free(tl);
    return retval;
  }

  /* decompress until an end-of-block code */
  retval = inflate_codes(__G__ tl, td, bl, bd);
    14ed:	8b 44 24 48          	mov    0x48(%esp),%eax
    14f1:	89 34 24             	mov    %esi,(%esp)
    14f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    14f8:	8b 44 24 44          	mov    0x44(%esp),%eax
    14fc:	89 44 24 08          	mov    %eax,0x8(%esp)
    1500:	8b 44 24 40          	mov    0x40(%esp),%eax
    1504:	89 54 24 10          	mov    %edx,0x10(%esp)
    1508:	89 44 24 04          	mov    %eax,0x4(%esp)
    150c:	e8 ef ea ff ff       	call   0 <_inflate_codes>
    1511:	89 c6                	mov    %eax,%esi
    1513:	e9 46 fb ff ff       	jmp    105e <_inflate_dynamic+0x36e>
#endif
#ifdef PKZIP_BUG_WORKAROUND
  if (retval == 1)
    retval = 0;
#endif
  if (bd == 0 && nl > 257)    /* lengths but no distances */
    1518:	8b 54 24 4c          	mov    0x4c(%esp),%edx
    151c:	81 7c 24 38 01 01 00 	cmpl   $0x101,0x38(%esp)
    1523:	00 
    1524:	74 c7                	je     14ed <_inflate_dynamic+0x7fd>
    1526:	85 d2                	test   %edx,%edx
    1528:	0f 84 f9 fe ff ff    	je     1427 <_inflate_dynamic+0x737>
    152e:	eb bd                	jmp    14ed <_inflate_dynamic+0x7fd>

00001530 <_inflate_fixed>:
static int inflate_fixed(__G)
     __GDEF
/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
   either replace this with a custom decoder, or at least precompute the
   Huffman tables. */
{
    1530:	57                   	push   %edi
    1531:	56                   	push   %esi
    1532:	53                   	push   %ebx
    1533:	89 c6                	mov    %eax,%esi
    1535:	81 ec a0 04 00 00    	sub    $0x4a0,%esp
  /* if first time, set up tables for fixed blocks */
  Trace((stderr, "\nliteral block"));
  if (G.fixed_tl == (struct huft *)NULL)
    153b:	8b 80 fc 0a 01 00    	mov    0x10afc(%eax),%eax
    1541:	85 c0                	test   %eax,%eax
    1543:	74 3b                	je     1580 <_inflate_fixed+0x50>
      return i;
    }
  }

  /* decompress until an end-of-block code */
  return inflate_codes(__G__ G.fixed_tl, G.fixed_td,
    1545:	8b 96 08 0b 01 00    	mov    0x10b08(%esi),%edx
    154b:	89 34 24             	mov    %esi,(%esp)
    154e:	89 54 24 10          	mov    %edx,0x10(%esp)
    1552:	8b 96 04 0b 01 00    	mov    0x10b04(%esi),%edx
    1558:	89 54 24 0c          	mov    %edx,0xc(%esp)
    155c:	8b 96 00 0b 01 00    	mov    0x10b00(%esi),%edx
    1562:	89 54 24 08          	mov    %edx,0x8(%esp)
    1566:	89 44 24 04          	mov    %eax,0x4(%esp)
    156a:	e8 91 ea ff ff       	call   0 <_inflate_codes>
                             G.fixed_bl, G.fixed_bd);
}
    156f:	81 c4 a0 04 00 00    	add    $0x4a0,%esp
    1575:	5b                   	pop    %ebx
    1576:	5e                   	pop    %esi
    1577:	5f                   	pop    %edi
    1578:	c3                   	ret    
    1579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    1580:	8d 7c 24 20          	lea    0x20(%esp),%edi
    1584:	8d 84 24 60 02 00 00 	lea    0x260(%esp),%eax
    158b:	89 fb                	mov    %edi,%ebx
   either replace this with a custom decoder, or at least precompute the
   Huffman tables. */
{
  /* if first time, set up tables for fixed blocks */
  Trace((stderr, "\nliteral block"));
  if (G.fixed_tl == (struct huft *)NULL)
    158d:	89 fa                	mov    %edi,%edx
    158f:	90                   	nop
    int i;                /* temporary variable */
    unsigned l[288];      /* length list for huft_build */

    /* literal table */
    for (i = 0; i < 144; i++)
      l[i] = 8;
    1590:	c7 02 08 00 00 00    	movl   $0x8,(%edx)
    1596:	83 c2 04             	add    $0x4,%edx
  {
    int i;                /* temporary variable */
    unsigned l[288];      /* length list for huft_build */

    /* literal table */
    for (i = 0; i < 144; i++)
    1599:	39 c2                	cmp    %eax,%edx
    159b:	75 f3                	jne    1590 <_inflate_fixed+0x60>
    159d:	8d 84 24 20 04 00 00 	lea    0x420(%esp),%eax
      l[i] = 8;
    for (; i < 256; i++)
      l[i] = 9;
    15a4:	c7 02 09 00 00 00    	movl   $0x9,(%edx)
    15aa:	83 c2 04             	add    $0x4,%edx
    unsigned l[288];      /* length list for huft_build */

    /* literal table */
    for (i = 0; i < 144; i++)
      l[i] = 8;
    for (; i < 256; i++)
    15ad:	39 c2                	cmp    %eax,%edx
    15af:	75 f3                	jne    15a4 <_inflate_fixed+0x74>
    15b1:	8d 84 24 80 04 00 00 	lea    0x480(%esp),%eax
      l[i] = 9;
    for (; i < 280; i++)
      l[i] = 7;
    15b8:	c7 02 07 00 00 00    	movl   $0x7,(%edx)
    15be:	83 c2 04             	add    $0x4,%edx
    /* literal table */
    for (i = 0; i < 144; i++)
      l[i] = 8;
    for (; i < 256; i++)
      l[i] = 9;
    for (; i < 280; i++)
    15c1:	39 c2                	cmp    %eax,%edx
    15c3:	75 f3                	jne    15b8 <_inflate_fixed+0x88>
    15c5:	8d 84 24 a0 04 00 00 	lea    0x4a0(%esp),%eax
    15cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
      l[i] = 7;
    for (; i < 288; i++)          /* make a complete, but wrong code set */
      l[i] = 8;
    15d0:	c7 02 08 00 00 00    	movl   $0x8,(%edx)
    15d6:	83 c2 04             	add    $0x4,%edx
      l[i] = 8;
    for (; i < 256; i++)
      l[i] = 9;
    for (; i < 280; i++)
      l[i] = 7;
    for (; i < 288; i++)          /* make a complete, but wrong code set */
    15d9:	39 c2                	cmp    %eax,%edx
    15db:	75 f3                	jne    15d0 <_inflate_fixed+0xa0>
      l[i] = 8;
    G.fixed_bl = 7;
#ifdef USE_DEFLATE64
    if ((i = huft_build(__G__ l, 288, 257, G.cplens, G.cplext,
    15dd:	8d 86 04 0b 01 00    	lea    0x10b04(%esi),%eax
      l[i] = 9;
    for (; i < 280; i++)
      l[i] = 7;
    for (; i < 288; i++)          /* make a complete, but wrong code set */
      l[i] = 8;
    G.fixed_bl = 7;
    15e3:	c7 86 04 0b 01 00 07 	movl   $0x7,0x10b04(%esi)
    15ea:	00 00 00 
#ifdef USE_DEFLATE64
    if ((i = huft_build(__G__ l, 288, 257, G.cplens, G.cplext,
    15ed:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    15f1:	8d 86 fc 0a 01 00    	lea    0x10afc(%esi),%eax
    15f7:	89 44 24 18          	mov    %eax,0x18(%esp)
    15fb:	8b 86 30 0b 01 00    	mov    0x10b30(%esi),%eax
    1601:	89 44 24 14          	mov    %eax,0x14(%esp)
    1605:	8b 86 2c 0b 01 00    	mov    0x10b2c(%esi),%eax
    160b:	89 44 24 10          	mov    %eax,0x10(%esp)
    160f:	c7 44 24 0c 01 01 00 	movl   $0x101,0xc(%esp)
    1616:	00 
    1617:	c7 44 24 08 20 01 00 	movl   $0x120,0x8(%esp)
    161e:	00 
    161f:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1623:	89 34 24             	mov    %esi,(%esp)
    1626:	e8 a5 f0 ff ff       	call   6d0 <_huft_build>
    162b:	85 c0                	test   %eax,%eax
    162d:	0f 85 af 00 00 00    	jne    16e2 <_inflate_fixed+0x1b2>
    1633:	8d 84 24 a0 00 00 00 	lea    0xa0(%esp),%eax
    163a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
      return i;
    }

    /* distance table */
    for (i = 0; i < MAXDISTS; i++)      /* make an incomplete code set */
      l[i] = 5;
    1640:	c7 03 05 00 00 00    	movl   $0x5,(%ebx)
    1646:	83 c3 04             	add    $0x4,%ebx
      G.fixed_tl = (struct huft *)NULL;
      return i;
    }

    /* distance table */
    for (i = 0; i < MAXDISTS; i++)      /* make an incomplete code set */
    1649:	39 c3                	cmp    %eax,%ebx
    164b:	75 f3                	jne    1640 <_inflate_fixed+0x110>
      l[i] = 5;
    G.fixed_bd = 5;
#ifdef USE_DEFLATE64
    if ((i = huft_build(__G__ l, MAXDISTS, 0, cpdist, G.cpdext,
    164d:	8d 86 08 0b 01 00    	lea    0x10b08(%esi),%eax
    1653:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1657:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    165b:	8d 86 00 0b 01 00    	lea    0x10b00(%esi),%eax
    1661:	89 44 24 18          	mov    %eax,0x18(%esp)
    1665:	8b 86 34 0b 01 00    	mov    0x10b34(%esi),%eax
    }

    /* distance table */
    for (i = 0; i < MAXDISTS; i++)      /* make an incomplete code set */
      l[i] = 5;
    G.fixed_bd = 5;
    166b:	c7 86 08 0b 01 00 05 	movl   $0x5,0x10b08(%esi)
    1672:	00 00 00 
#ifdef USE_DEFLATE64
    if ((i = huft_build(__G__ l, MAXDISTS, 0, cpdist, G.cpdext,
    1675:	89 44 24 14          	mov    %eax,0x14(%esp)
    1679:	c7 44 24 10 80 00 00 	movl   $0x80,0x10(%esp)
    1680:	00 
    1681:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1688:	00 
    1689:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
    1690:	00 
    1691:	89 34 24             	mov    %esi,(%esp)
    1694:	e8 37 f0 ff ff       	call   6d0 <_huft_build>
    1699:	89 c7                	mov    %eax,%edi
    169b:	83 f8 01             	cmp    $0x1,%eax
    169e:	7e 56                	jle    16f6 <_inflate_fixed+0x1c6>
#else
    if ((i = huft_build(__G__ l, MAXDISTS, 0, cpdist, cpdext,
                        &G.fixed_td, &G.fixed_bd)) > 1)
#endif
    {
      huft_free(G.fixed_tl);
    16a0:	8b 9e fc 0a 01 00    	mov    0x10afc(%esi),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    16a6:	85 db                	test   %ebx,%ebx
    16a8:	74 18                	je     16c2 <_inflate_fixed+0x192>
    16aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  {
    q = (--p)->v.t;
    16b0:	8d 43 f8             	lea    -0x8(%ebx),%eax
    16b3:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    16b6:	89 04 24             	mov    %eax,(%esp)
    16b9:	e8 00 00 00 00       	call   16be <_inflate_fixed+0x18e>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    16be:	85 db                	test   %ebx,%ebx
    16c0:	75 ee                	jne    16b0 <_inflate_fixed+0x180>
    if ((i = huft_build(__G__ l, MAXDISTS, 0, cpdist, cpdext,
                        &G.fixed_td, &G.fixed_bd)) > 1)
#endif
    {
      huft_free(G.fixed_tl);
      G.fixed_td = G.fixed_tl = (struct huft *)NULL;
    16c2:	c7 86 fc 0a 01 00 00 	movl   $0x0,0x10afc(%esi)
    16c9:	00 00 00 
    16cc:	c7 86 00 0b 01 00 00 	movl   $0x0,0x10b00(%esi)
    16d3:	00 00 00 
  }

  /* decompress until an end-of-block code */
  return inflate_codes(__G__ G.fixed_tl, G.fixed_td,
                             G.fixed_bl, G.fixed_bd);
}
    16d6:	81 c4 a0 04 00 00    	add    $0x4a0,%esp
                        &G.fixed_td, &G.fixed_bd)) > 1)
#endif
    {
      huft_free(G.fixed_tl);
      G.fixed_td = G.fixed_tl = (struct huft *)NULL;
      return i;
    16dc:	89 f8                	mov    %edi,%eax
  }

  /* decompress until an end-of-block code */
  return inflate_codes(__G__ G.fixed_tl, G.fixed_td,
                             G.fixed_bl, G.fixed_bd);
}
    16de:	5b                   	pop    %ebx
    16df:	5e                   	pop    %esi
    16e0:	5f                   	pop    %edi
    16e1:	c3                   	ret    
#else
    if ((i = huft_build(__G__ l, 288, 257, cplens, cplext,
                        &G.fixed_tl, &G.fixed_bl)) != 0)
#endif
    {
      G.fixed_tl = (struct huft *)NULL;
    16e2:	c7 86 fc 0a 01 00 00 	movl   $0x0,0x10afc(%esi)
    16e9:	00 00 00 
  }

  /* decompress until an end-of-block code */
  return inflate_codes(__G__ G.fixed_tl, G.fixed_td,
                             G.fixed_bl, G.fixed_bd);
}
    16ec:	81 c4 a0 04 00 00    	add    $0x4a0,%esp
    16f2:	5b                   	pop    %ebx
    16f3:	5e                   	pop    %esi
    16f4:	5f                   	pop    %edi
    16f5:	c3                   	ret    
    16f6:	8b 86 fc 0a 01 00    	mov    0x10afc(%esi),%eax
    16fc:	e9 44 fe ff ff       	jmp    1545 <_inflate_fixed+0x15>
    1701:	eb 0d                	jmp    1710 <_inflate>
    1703:	90                   	nop
    1704:	90                   	nop
    1705:	90                   	nop
    1706:	90                   	nop
    1707:	90                   	nop
    1708:	90                   	nop
    1709:	90                   	nop
    170a:	90                   	nop
    170b:	90                   	nop
    170c:	90                   	nop
    170d:	90                   	nop
    170e:	90                   	nop
    170f:	90                   	nop

00001710 <_inflate>:

int inflate(__G__ is_defl64)
    __GDEF
    int is_defl64;
/* decompress an inflated entry */
{
    1710:	55                   	push   %ebp
    1711:	57                   	push   %edi
    1712:	56                   	push   %esi
    1713:	53                   	push   %ebx
    1714:	83 ec 2c             	sub    $0x2c,%esp
    1717:	8b 5c 24 40          	mov    0x40(%esp),%ebx
#ifdef DEBUG
  unsigned h = 0;       /* maximum struct huft's malloc'ed */
#endif

#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
  if (G.redirect_slide)
    171b:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    1721:	85 c0                	test   %eax,%eax
    1723:	0f 84 0d 03 00 00    	je     1a36 <_inflate+0x326>
    wsize = G.redirect_size, redirSlide = G.redirect_buffer;
    1729:	8b 83 b0 00 00 00    	mov    0xb0(%ebx),%eax
    172f:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
    1735:	8b 83 b4 00 00 00    	mov    0xb4(%ebx),%eax
    173b:	89 83 bc 00 00 00    	mov    %eax,0xbc(%ebx)
  G.wp = 0;
  G.bk = 0;
  G.bb = 0;

#ifdef USE_DEFLATE64
  if (is_defl64) {
    1741:	8b 44 24 44          	mov    0x44(%esp),%eax
  else
    wsize = WSIZE, redirSlide = slide;   /* how they're #defined if !DLL */
#endif

  /* initialize window, bit buffer */
  G.wp = 0;
    1745:	c7 83 38 0b 01 00 00 	movl   $0x0,0x10b38(%ebx)
    174c:	00 00 00 
  G.bk = 0;
    174f:	c7 83 40 0b 01 00 00 	movl   $0x0,0x10b40(%ebx)
    1756:	00 00 00 
  G.bb = 0;
    1759:	c7 83 3c 0b 01 00 00 	movl   $0x0,0x10b3c(%ebx)
    1760:	00 00 00 

#ifdef USE_DEFLATE64
  if (is_defl64) {
    1763:	85 c0                	test   %eax,%eax
    1765:	0f 84 78 02 00 00    	je     19e3 <_inflate+0x2d3>
    G.cplens = cplens64;
    G.cplext = cplext64;
    G.cpdext = cpdext64;
    G.fixed_tl = G.fixed_tl64;
    176b:	8b 83 0c 0b 01 00    	mov    0x10b0c(%ebx),%eax
  G.bk = 0;
  G.bb = 0;

#ifdef USE_DEFLATE64
  if (is_defl64) {
    G.cplens = cplens64;
    1771:	c7 83 2c 0b 01 00 40 	movl   $0x140,0x10b2c(%ebx)
    1778:	01 00 00 
    G.cplext = cplext64;
    G.cpdext = cpdext64;
    G.fixed_tl = G.fixed_tl64;
    177b:	89 83 fc 0a 01 00    	mov    %eax,0x10afc(%ebx)
    G.fixed_bl = G.fixed_bl64;
    1781:	8b 83 14 0b 01 00    	mov    0x10b14(%ebx),%eax
    1787:	89 83 04 0b 01 00    	mov    %eax,0x10b04(%ebx)
    G.fixed_td = G.fixed_td64;
    178d:	8b 83 10 0b 01 00    	mov    0x10b10(%ebx),%eax
    1793:	89 83 00 0b 01 00    	mov    %eax,0x10b00(%ebx)
    G.fixed_bd = G.fixed_bd64;
    1799:	8b 83 18 0b 01 00    	mov    0x10b18(%ebx),%eax
  G.bb = 0;

#ifdef USE_DEFLATE64
  if (is_defl64) {
    G.cplens = cplens64;
    G.cplext = cplext64;
    179f:	c7 83 30 0b 01 00 e0 	movl   $0xe0,0x10b30(%ebx)
    17a6:	00 00 00 
    G.cpdext = cpdext64;
    17a9:	c7 83 34 0b 01 00 60 	movl   $0x60,0x10b34(%ebx)
    17b0:	00 00 00 
    G.fixed_tl = G.fixed_tl64;
    G.fixed_bl = G.fixed_bl64;
    G.fixed_td = G.fixed_td64;
    G.fixed_bd = G.fixed_bd64;
    17b3:	89 83 08 0b 01 00    	mov    %eax,0x10b08(%ebx)

int inflate(__G__ is_defl64)
    __GDEF
    int is_defl64;
/* decompress an inflated entry */
{
    17b9:	31 c9                	xor    %ecx,%ecx
    17bb:	31 f6                	xor    %esi,%esi
    17bd:	eb 22                	jmp    17e1 <_inflate+0xd1>
    17bf:	90                   	nop
  b = G.bb;
  k = G.bk;


  /* read in last block bit */
  NEEDBITS(1)
    17c0:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
    17c6:	8d 50 01             	lea    0x1(%eax),%edx
    17c9:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
    17cf:	0f b6 38             	movzbl (%eax),%edi
    17d2:	81 e7 ff 00 00 00    	and    $0xff,%edi
    17d8:	89 f8                	mov    %edi,%eax
    17da:	d3 e0                	shl    %cl,%eax
    17dc:	09 c6                	or     %eax,%esi
    17de:	83 c1 08             	add    $0x8,%ecx
    17e1:	85 c9                	test   %ecx,%ecx
    17e3:	7f 30                	jg     1815 <_inflate+0x105>
    17e5:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
    17eb:	85 c0                	test   %eax,%eax
    17ed:	8d 50 ff             	lea    -0x1(%eax),%edx
    17f0:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
    17f6:	7f c8                	jg     17c0 <_inflate+0xb0>
    17f8:	89 1c 24             	mov    %ebx,(%esp)
    17fb:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    17ff:	e8 00 00 00 00       	call   1804 <_inflate+0xf4>
    1804:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1808:	83 f8 ff             	cmp    $0xffffffff,%eax
    180b:	75 cd                	jne    17da <_inflate+0xca>
    180d:	85 c9                	test   %ecx,%ecx
    180f:	0f 85 90 01 00 00    	jne    19a5 <_inflate+0x295>
  *e = (int)b & 1;
    1815:	89 f7                	mov    %esi,%edi
  DUMPBITS(1)
    1817:	49                   	dec    %ecx
    1818:	d1 ee                	shr    %esi
  k = G.bk;


  /* read in last block bit */
  NEEDBITS(1)
  *e = (int)b & 1;
    181a:	83 e7 01             	and    $0x1,%edi
  DUMPBITS(1)


  /* read in block type */
  NEEDBITS(2)
    181d:	83 f9 01             	cmp    $0x1,%ecx
    1820:	7e 27                	jle    1849 <_inflate+0x139>
    1822:	eb 55                	jmp    1879 <_inflate+0x169>
    1824:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
    182a:	8d 50 01             	lea    0x1(%eax),%edx
    182d:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
    1833:	8a 10                	mov    (%eax),%dl
    1835:	81 e2 ff 00 00 00    	and    $0xff,%edx
    183b:	89 d0                	mov    %edx,%eax
    183d:	d3 e0                	shl    %cl,%eax
    183f:	83 c1 08             	add    $0x8,%ecx
    1842:	09 c6                	or     %eax,%esi
    1844:	83 f9 01             	cmp    $0x1,%ecx
    1847:	7f 30                	jg     1879 <_inflate+0x169>
    1849:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
    184f:	85 c0                	test   %eax,%eax
    1851:	8d 50 ff             	lea    -0x1(%eax),%edx
    1854:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
    185a:	7f c8                	jg     1824 <_inflate+0x114>
    185c:	89 1c 24             	mov    %ebx,(%esp)
    185f:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    1863:	e8 00 00 00 00       	call   1868 <_inflate+0x158>
    1868:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    186c:	83 f8 ff             	cmp    $0xffffffff,%eax
    186f:	75 cc                	jne    183d <_inflate+0x12d>
    1871:	85 c9                	test   %ecx,%ecx
    1873:	0f 88 2c 01 00 00    	js     19a5 <_inflate+0x295>
  t = (unsigned)b & 3;
    1879:	89 f2                	mov    %esi,%edx
  DUMPBITS(2)
    187b:	8d 41 fe             	lea    -0x2(%ecx),%eax
    187e:	c1 ee 02             	shr    $0x2,%esi
  DUMPBITS(1)


  /* read in block type */
  NEEDBITS(2)
  t = (unsigned)b & 3;
    1881:	83 e2 03             	and    $0x3,%edx
  DUMPBITS(2)


  /* restore the global bit buffer */
  G.bb = b;
    1884:	89 b3 3c 0b 01 00    	mov    %esi,0x10b3c(%ebx)
  G.bk = k;
    188a:	89 83 40 0b 01 00    	mov    %eax,0x10b40(%ebx)


  /* inflate that block type */
  if (t == 2)
    1890:	83 fa 02             	cmp    $0x2,%edx
    1893:	0f 84 19 01 00 00    	je     19b2 <_inflate+0x2a2>
    return inflate_dynamic(__G);
  if (t == 0)
    1899:	85 d2                	test   %edx,%edx
    189b:	74 14                	je     18b1 <_inflate+0x1a1>
    return inflate_stored(__G);
  if (t == 1)
    189d:	4a                   	dec    %edx
    189e:	0f 84 36 01 00 00    	je     19da <_inflate+0x2ca>
    return inflate_fixed(__G);


  /* bad block type */
  retval = 2;
    18a4:	b8 02 00 00 00       	mov    $0x2,%eax
  }
#endif

  /* flush out redirSlide and return (success, unless final FLUSH failed) */
  return (FLUSH(G.wp));
}
    18a9:	83 c4 2c             	add    $0x2c,%esp
    18ac:	5b                   	pop    %ebx
    18ad:	5e                   	pop    %esi
    18ae:	5f                   	pop    %edi
    18af:	5d                   	pop    %ebp
    18b0:	c3                   	ret    
  k = G.bk;
  w = G.wp;                       /* initialize window position */


  /* go to byte boundary */
  n = k & 7;
    18b1:	89 c1                	mov    %eax,%ecx

  /* make local copies of globals */
  Trace((stderr, "\nstored block"));
  b = G.bb;                       /* initialize bit buffer */
  k = G.bk;
  w = G.wp;                       /* initialize window position */
    18b3:	8b ab 38 0b 01 00    	mov    0x10b38(%ebx),%ebp


  /* go to byte boundary */
  n = k & 7;
    18b9:	83 e1 07             	and    $0x7,%ecx
  DUMPBITS(n);
    18bc:	29 c8                	sub    %ecx,%eax
    18be:	d3 ee                	shr    %cl,%esi
    18c0:	89 c1                	mov    %eax,%ecx


  /* get the length and its complement */
  NEEDBITS(16)
    18c2:	83 f8 0f             	cmp    $0xf,%eax
    18c5:	7e 2e                	jle    18f5 <_inflate+0x1e5>
    18c7:	eb 5c                	jmp    1925 <_inflate+0x215>
    18c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    18d0:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
    18d6:	8d 50 01             	lea    0x1(%eax),%edx
    18d9:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
    18df:	8a 10                	mov    (%eax),%dl
    18e1:	81 e2 ff 00 00 00    	and    $0xff,%edx
    18e7:	89 d0                	mov    %edx,%eax
    18e9:	d3 e0                	shl    %cl,%eax
    18eb:	83 c1 08             	add    $0x8,%ecx
    18ee:	09 c6                	or     %eax,%esi
    18f0:	83 f9 0f             	cmp    $0xf,%ecx
    18f3:	7f 30                	jg     1925 <_inflate+0x215>
    18f5:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
    18fb:	85 c0                	test   %eax,%eax
    18fd:	8d 50 ff             	lea    -0x1(%eax),%edx
    1900:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
    1906:	7f c8                	jg     18d0 <_inflate+0x1c0>
    1908:	89 1c 24             	mov    %ebx,(%esp)
    190b:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    190f:	e8 00 00 00 00       	call   1914 <_inflate+0x204>
    1914:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1918:	83 f8 ff             	cmp    $0xffffffff,%eax
    191b:	75 cc                	jne    18e9 <_inflate+0x1d9>
    191d:	85 c9                	test   %ecx,%ecx
    191f:	0f 88 80 00 00 00    	js     19a5 <_inflate+0x295>
  n = ((unsigned)b & 0xffff);
    1925:	89 f0                	mov    %esi,%eax
  DUMPBITS(16)
    1927:	83 e9 10             	sub    $0x10,%ecx
    192a:	c1 ee 10             	shr    $0x10,%esi
  DUMPBITS(n);


  /* get the length and its complement */
  NEEDBITS(16)
  n = ((unsigned)b & 0xffff);
    192d:	25 ff ff 00 00       	and    $0xffff,%eax
    1932:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  DUMPBITS(16)
  NEEDBITS(16)
    1936:	83 f9 0f             	cmp    $0xf,%ecx
    1939:	7e 2a                	jle    1965 <_inflate+0x255>
    193b:	eb 54                	jmp    1991 <_inflate+0x281>
    193d:	8d 76 00             	lea    0x0(%esi),%esi
    1940:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
    1946:	8d 50 01             	lea    0x1(%eax),%edx
    1949:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
    194f:	8a 10                	mov    (%eax),%dl
    1951:	81 e2 ff 00 00 00    	and    $0xff,%edx
    1957:	89 d0                	mov    %edx,%eax
    1959:	d3 e0                	shl    %cl,%eax
    195b:	83 c1 08             	add    $0x8,%ecx
    195e:	09 c6                	or     %eax,%esi
    1960:	83 f9 0f             	cmp    $0xf,%ecx
    1963:	7f 2c                	jg     1991 <_inflate+0x281>
    1965:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
    196b:	85 c0                	test   %eax,%eax
    196d:	8d 50 ff             	lea    -0x1(%eax),%edx
    1970:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
    1976:	7f c8                	jg     1940 <_inflate+0x230>
    1978:	89 1c 24             	mov    %ebx,(%esp)
    197b:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    197f:	e8 00 00 00 00       	call   1984 <_inflate+0x274>
    1984:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1988:	83 f8 ff             	cmp    $0xffffffff,%eax
    198b:	75 cc                	jne    1959 <_inflate+0x249>
    198d:	85 c9                	test   %ecx,%ecx
    198f:	78 14                	js     19a5 <_inflate+0x295>
  if (n != (unsigned)((~b) & 0xffff))
    1991:	89 f0                	mov    %esi,%eax
    1993:	83 f0 ff             	xor    $0xffffffff,%eax
    1996:	25 ff ff 00 00       	and    $0xffff,%eax
    199b:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
    199f:	0f 84 17 01 00 00    	je     1abc <_inflate+0x3ac>
  }
#endif

  /* flush out redirSlide and return (success, unless final FLUSH failed) */
  return (FLUSH(G.wp));
}
    19a5:	83 c4 2c             	add    $0x2c,%esp
  b = G.bb;
  k = G.bk;


  /* read in last block bit */
  NEEDBITS(1)
    19a8:	b8 01 00 00 00       	mov    $0x1,%eax
  }
#endif

  /* flush out redirSlide and return (success, unless final FLUSH failed) */
  return (FLUSH(G.wp));
}
    19ad:	5b                   	pop    %ebx
    19ae:	5e                   	pop    %esi
    19af:	5f                   	pop    %edi
    19b0:	5d                   	pop    %ebp
    19b1:	c3                   	ret    
  G.bk = k;


  /* inflate that block type */
  if (t == 2)
    return inflate_dynamic(__G);
    19b2:	89 d8                	mov    %ebx,%eax
    19b4:	e8 37 f3 ff ff       	call   cf0 <_inflate_dynamic>
  /* decompress until the last block */
  do {
#ifdef DEBUG
    G.hufts = 0;
#endif
    if ((r = inflate_block(__G__ &e)) != 0)
    19b9:	85 c0                	test   %eax,%eax
    19bb:	0f 85 e8 fe ff ff    	jne    18a9 <_inflate+0x199>
      return r;
#ifdef DEBUG
    if (G.hufts > h)
      h = G.hufts;
#endif
  } while (!e);
    19c1:	85 ff                	test   %edi,%edi
    19c3:	0f 85 88 00 00 00    	jne    1a51 <_inflate+0x341>
    19c9:	8b b3 3c 0b 01 00    	mov    0x10b3c(%ebx),%esi
    19cf:	8b 8b 40 0b 01 00    	mov    0x10b40(%ebx),%ecx
    19d5:	e9 07 fe ff ff       	jmp    17e1 <_inflate+0xd1>
  if (t == 2)
    return inflate_dynamic(__G);
  if (t == 0)
    return inflate_stored(__G);
  if (t == 1)
    return inflate_fixed(__G);
    19da:	89 d8                	mov    %ebx,%eax
    19dc:	e8 4f fb ff ff       	call   1530 <_inflate_fixed>
    19e1:	eb d6                	jmp    19b9 <_inflate+0x2a9>
    G.fixed_bd = G.fixed_bd64;
  } else {
    G.cplens = cplens32;
    G.cplext = cplext32;
    G.cpdext = cpdext32;
    G.fixed_tl = G.fixed_tl32;
    19e3:	8b 83 1c 0b 01 00    	mov    0x10b1c(%ebx),%eax
    G.fixed_tl = G.fixed_tl64;
    G.fixed_bl = G.fixed_bl64;
    G.fixed_td = G.fixed_td64;
    G.fixed_bd = G.fixed_bd64;
  } else {
    G.cplens = cplens32;
    19e9:	c7 83 2c 0b 01 00 00 	movl   $0x100,0x10b2c(%ebx)
    19f0:	01 00 00 
    G.cplext = cplext32;
    G.cpdext = cpdext32;
    G.fixed_tl = G.fixed_tl32;
    19f3:	89 83 fc 0a 01 00    	mov    %eax,0x10afc(%ebx)
    G.fixed_bl = G.fixed_bl32;
    19f9:	8b 83 24 0b 01 00    	mov    0x10b24(%ebx),%eax
    19ff:	89 83 04 0b 01 00    	mov    %eax,0x10b04(%ebx)
    G.fixed_td = G.fixed_td32;
    1a05:	8b 83 20 0b 01 00    	mov    0x10b20(%ebx),%eax
    1a0b:	89 83 00 0b 01 00    	mov    %eax,0x10b00(%ebx)
    G.fixed_bd = G.fixed_bd32;
    1a11:	8b 83 28 0b 01 00    	mov    0x10b28(%ebx),%eax
    G.fixed_bl = G.fixed_bl64;
    G.fixed_td = G.fixed_td64;
    G.fixed_bd = G.fixed_bd64;
  } else {
    G.cplens = cplens32;
    G.cplext = cplext32;
    1a17:	c7 83 30 0b 01 00 c0 	movl   $0xc0,0x10b30(%ebx)
    1a1e:	00 00 00 
    G.cpdext = cpdext32;
    1a21:	c7 83 34 0b 01 00 40 	movl   $0x40,0x10b34(%ebx)
    1a28:	00 00 00 
    G.fixed_tl = G.fixed_tl32;
    G.fixed_bl = G.fixed_bl32;
    G.fixed_td = G.fixed_td32;
    G.fixed_bd = G.fixed_bd32;
    1a2b:	89 83 08 0b 01 00    	mov    %eax,0x10b08(%ebx)
    1a31:	e9 83 fd ff ff       	jmp    17b9 <_inflate+0xa9>

#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
  if (G.redirect_slide)
    wsize = G.redirect_size, redirSlide = G.redirect_buffer;
  else
    wsize = WSIZE, redirSlide = slide;   /* how they're #defined if !DLL */
    1a36:	8d 83 dc 08 00 00    	lea    0x8dc(%ebx),%eax
    1a3c:	c7 83 ac 00 00 00 00 	movl   $0x10000,0xac(%ebx)
    1a43:	00 01 00 
    1a46:	89 83 bc 00 00 00    	mov    %eax,0xbc(%ebx)
    1a4c:	e9 f0 fc ff ff       	jmp    1741 <_inflate+0x31>

  Trace((stderr, "\n%u bytes in Huffman tables (%u/entry)\n",
         h * (unsigned)sizeof(struct huft), (unsigned)sizeof(struct huft)));

#ifdef USE_DEFLATE64
  if (is_defl64) {
    1a51:	8b 54 24 44          	mov    0x44(%esp),%edx
    G.fixed_tl64 = G.fixed_tl;
    1a55:	8b 83 fc 0a 01 00    	mov    0x10afc(%ebx),%eax

  Trace((stderr, "\n%u bytes in Huffman tables (%u/entry)\n",
         h * (unsigned)sizeof(struct huft), (unsigned)sizeof(struct huft)));

#ifdef USE_DEFLATE64
  if (is_defl64) {
    1a5b:	85 d2                	test   %edx,%edx
    1a5d:	0f 85 04 01 00 00    	jne    1b67 <_inflate+0x457>
    G.fixed_tl64 = G.fixed_tl;
    G.fixed_bl64 = G.fixed_bl;
    G.fixed_td64 = G.fixed_td;
    G.fixed_bd64 = G.fixed_bd;
  } else {
    G.fixed_tl32 = G.fixed_tl;
    1a63:	89 83 1c 0b 01 00    	mov    %eax,0x10b1c(%ebx)
    G.fixed_bl32 = G.fixed_bl;
    1a69:	8b 83 04 0b 01 00    	mov    0x10b04(%ebx),%eax
    1a6f:	89 83 24 0b 01 00    	mov    %eax,0x10b24(%ebx)
    G.fixed_td32 = G.fixed_td;
    1a75:	8b 83 00 0b 01 00    	mov    0x10b00(%ebx),%eax
    1a7b:	89 83 20 0b 01 00    	mov    %eax,0x10b20(%ebx)
    G.fixed_bd32 = G.fixed_bd;
    1a81:	8b 83 08 0b 01 00    	mov    0x10b08(%ebx),%eax
    1a87:	89 83 28 0b 01 00    	mov    %eax,0x10b28(%ebx)
  }
#endif

  /* flush out redirSlide and return (success, unless final FLUSH failed) */
  return (FLUSH(G.wp));
    1a8d:	8b 83 a0 09 01 00    	mov    0x109a0(%ebx),%eax
    1a93:	85 c0                	test   %eax,%eax
    1a95:	0f 84 04 01 00 00    	je     1b9f <_inflate+0x48f>
    1a9b:	8b 83 38 0b 01 00    	mov    0x10b38(%ebx),%eax
    1aa1:	89 44 24 08          	mov    %eax,0x8(%esp)
    1aa5:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
    1aab:	89 1c 24             	mov    %ebx,(%esp)
    1aae:	89 44 24 04          	mov    %eax,0x4(%esp)
    1ab2:	e8 00 00 00 00       	call   1ab7 <_inflate+0x3a7>
    1ab7:	e9 ed fd ff ff       	jmp    18a9 <_inflate+0x199>
    return 1;                   /* error in compressed data */
  DUMPBITS(16)


  /* read and output the compressed data */
  while (n--)
    1abc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  n = ((unsigned)b & 0xffff);
  DUMPBITS(16)
  NEEDBITS(16)
  if (n != (unsigned)((~b) & 0xffff))
    return 1;                   /* error in compressed data */
  DUMPBITS(16)
    1ac0:	83 e9 10             	sub    $0x10,%ecx
    1ac3:	c1 ee 10             	shr    $0x10,%esi


  /* read and output the compressed data */
  while (n--)
    1ac6:	85 c0                	test   %eax,%eax
    1ac8:	0f 84 82 00 00 00    	je     1b50 <_inflate+0x440>
    1ace:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
    1ad2:	89 c7                	mov    %eax,%edi
    1ad4:	eb 20                	jmp    1af6 <_inflate+0x3e6>
  {
    NEEDBITS(8)
    1ad6:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
    1adc:	8d 50 01             	lea    0x1(%eax),%edx
    1adf:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
    1ae5:	8a 10                	mov    (%eax),%dl
    1ae7:	81 e2 ff 00 00 00    	and    $0xff,%edx
    1aed:	89 d0                	mov    %edx,%eax
    1aef:	d3 e0                	shl    %cl,%eax
    1af1:	09 c6                	or     %eax,%esi
    1af3:	83 c1 08             	add    $0x8,%ecx
    1af6:	83 f9 07             	cmp    $0x7,%ecx
    1af9:	7f 30                	jg     1b2b <_inflate+0x41b>
    1afb:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
    1b01:	85 c0                	test   %eax,%eax
    1b03:	8d 50 ff             	lea    -0x1(%eax),%edx
    1b06:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
    1b0c:	7f c8                	jg     1ad6 <_inflate+0x3c6>
    1b0e:	89 1c 24             	mov    %ebx,(%esp)
    1b11:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    1b15:	e8 00 00 00 00       	call   1b1a <_inflate+0x40a>
    1b1a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1b1e:	83 f8 ff             	cmp    $0xffffffff,%eax
    1b21:	75 cc                	jne    1aef <_inflate+0x3df>
    1b23:	85 c9                	test   %ecx,%ecx
    1b25:	0f 88 7a fe ff ff    	js     19a5 <_inflate+0x295>
    redirSlide[w++] = (uch)b;
    1b2b:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
    1b31:	89 f2                	mov    %esi,%edx
    1b33:	88 14 28             	mov    %dl,(%eax,%ebp,1)
    if (w == wsize)
    1b36:	45                   	inc    %ebp
    1b37:	3b ab ac 00 00 00    	cmp    0xac(%ebx),%ebp
    1b3d:	0f 84 85 00 00 00    	je     1bc8 <_inflate+0x4b8>
    {
      if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
      w = 0;
    }
    DUMPBITS(8)
    1b43:	c1 ee 08             	shr    $0x8,%esi
    1b46:	83 e9 08             	sub    $0x8,%ecx
    return 1;                   /* error in compressed data */
  DUMPBITS(16)


  /* read and output the compressed data */
  while (n--)
    1b49:	4f                   	dec    %edi
    1b4a:	75 aa                	jne    1af6 <_inflate+0x3e6>
    1b4c:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
    DUMPBITS(8)
  }


  /* restore the globals from the locals */
  G.wp = (unsigned)w;             /* restore global window pointer */
    1b50:	89 ab 38 0b 01 00    	mov    %ebp,0x10b38(%ebx)
  G.bb = b;                       /* restore global bit buffer */
    1b56:	89 b3 3c 0b 01 00    	mov    %esi,0x10b3c(%ebx)
  G.bk = k;
    1b5c:	89 8b 40 0b 01 00    	mov    %ecx,0x10b40(%ebx)
    1b62:	e9 5a fe ff ff       	jmp    19c1 <_inflate+0x2b1>
  Trace((stderr, "\n%u bytes in Huffman tables (%u/entry)\n",
         h * (unsigned)sizeof(struct huft), (unsigned)sizeof(struct huft)));

#ifdef USE_DEFLATE64
  if (is_defl64) {
    G.fixed_tl64 = G.fixed_tl;
    1b67:	89 83 0c 0b 01 00    	mov    %eax,0x10b0c(%ebx)
    G.fixed_bl64 = G.fixed_bl;
    1b6d:	8b 83 04 0b 01 00    	mov    0x10b04(%ebx),%eax
    1b73:	89 83 14 0b 01 00    	mov    %eax,0x10b14(%ebx)
    G.fixed_td64 = G.fixed_td;
    1b79:	8b 83 00 0b 01 00    	mov    0x10b00(%ebx),%eax
    1b7f:	89 83 10 0b 01 00    	mov    %eax,0x10b10(%ebx)
    G.fixed_bd64 = G.fixed_bd;
    1b85:	8b 83 08 0b 01 00    	mov    0x10b08(%ebx),%eax
    1b8b:	89 83 18 0b 01 00    	mov    %eax,0x10b18(%ebx)
    G.fixed_bd32 = G.fixed_bd;
  }
#endif

  /* flush out redirSlide and return (success, unless final FLUSH failed) */
  return (FLUSH(G.wp));
    1b91:	8b 83 a0 09 01 00    	mov    0x109a0(%ebx),%eax
    1b97:	85 c0                	test   %eax,%eax
    1b99:	0f 85 fc fe ff ff    	jne    1a9b <_inflate+0x38b>
    1b9f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1ba6:	00 
    1ba7:	8b 83 38 0b 01 00    	mov    0x10b38(%ebx),%eax
    1bad:	89 44 24 08          	mov    %eax,0x8(%esp)
    1bb1:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
    1bb7:	89 1c 24             	mov    %ebx,(%esp)
    1bba:	89 44 24 04          	mov    %eax,0x4(%esp)
    1bbe:	e8 00 00 00 00       	call   1bc3 <_inflate+0x4b3>
    1bc3:	e9 e1 fc ff ff       	jmp    18a9 <_inflate+0x199>
  {
    NEEDBITS(8)
    redirSlide[w++] = (uch)b;
    if (w == wsize)
    {
      if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
    1bc8:	8b 83 a0 09 01 00    	mov    0x109a0(%ebx),%eax
    1bce:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    1bd2:	85 c0                	test   %eax,%eax
    1bd4:	74 29                	je     1bff <_inflate+0x4ef>
    1bd6:	89 6c 24 08          	mov    %ebp,0x8(%esp)
    1bda:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
    1be0:	89 1c 24             	mov    %ebx,(%esp)
    1be3:	89 44 24 04          	mov    %eax,0x4(%esp)
    1be7:	e8 00 00 00 00       	call   1bec <_inflate+0x4dc>
    1bec:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1bf0:	85 c0                	test   %eax,%eax
    1bf2:	0f 85 b1 fc ff ff    	jne    18a9 <_inflate+0x199>
      w = 0;
    1bf8:	31 ed                	xor    %ebp,%ebp
    1bfa:	e9 44 ff ff ff       	jmp    1b43 <_inflate+0x433>
  {
    NEEDBITS(8)
    redirSlide[w++] = (uch)b;
    if (w == wsize)
    {
      if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
    1bff:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1c06:	00 
    1c07:	89 6c 24 08          	mov    %ebp,0x8(%esp)
    1c0b:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
    1c11:	89 1c 24             	mov    %ebx,(%esp)
    1c14:	89 44 24 04          	mov    %eax,0x4(%esp)
    1c18:	e8 00 00 00 00       	call   1c1d <_inflate+0x50d>
    1c1d:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1c21:	eb cd                	jmp    1bf0 <_inflate+0x4e0>
    1c23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001c30 <_huft_free>:
int huft_free(t)
struct huft *t;         /* table to free */
/* Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
    1c30:	53                   	push   %ebx
    1c31:	83 ec 18             	sub    $0x18,%esp
    1c34:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1c38:	85 db                	test   %ebx,%ebx
    1c3a:	74 16                	je     1c52 <_huft_free+0x22>
    1c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  {
    q = (--p)->v.t;
    1c40:	8d 43 f8             	lea    -0x8(%ebx),%eax
    1c43:	8b 5b fc             	mov    -0x4(%ebx),%ebx
    free((zvoid *)p);
    1c46:	89 04 24             	mov    %eax,(%esp)
    1c49:	e8 00 00 00 00       	call   1c4e <_huft_free+0x1e>
  register struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
    1c4e:	85 db                	test   %ebx,%ebx
    1c50:	75 ee                	jne    1c40 <_huft_free+0x10>
    q = (--p)->v.t;
    free((zvoid *)p);
    p = q;
  }
  return 0;
}
    1c52:	83 c4 18             	add    $0x18,%esp
    1c55:	31 c0                	xor    %eax,%eax
    1c57:	5b                   	pop    %ebx
    1c58:	c3                   	ret    
    1c59:	90                   	nop
    1c5a:	90                   	nop
    1c5b:	90                   	nop
    1c5c:	90                   	nop
    1c5d:	90                   	nop
    1c5e:	90                   	nop
    1c5f:	90                   	nop

list.o:     file format pe-i386


Disassembly of section .text:

00000000 <_get_time_stamp>:

int get_time_stamp(__G__ last_modtime, nmember)  /* return PK-type error code */
    __GDEF
    time_t *last_modtime;
    ulg *nmember;
{
   0:	55                   	push   %ebp
   1:	57                   	push   %edi
   2:	56                   	push   %esi
   3:	53                   	push   %ebx
   4:	83 ec 6c             	sub    $0x6c,%esp
    int do_this_file=FALSE, error, error_in_archive=PK_COOL;
   7:	31 ed                	xor    %ebp,%ebp
    on information in the central directory alone.  Thus we have a single,
    large loop through the entire directory, searching for the latest time
    stamp.
  ---------------------------------------------------------------------------*/

    *last_modtime = 0L;         /* assuming no zipfile data older than 1970 */
   9:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax

int get_time_stamp(__G__ last_modtime, nmember)  /* return PK-type error code */
    __GDEF
    time_t *last_modtime;
    ulg *nmember;
{
  10:	8b 9c 24 80 00 00 00 	mov    0x80(%esp),%ebx

    *last_modtime = 0L;         /* assuming no zipfile data older than 1970 */
    *nmember = 0L;
    G.pInfo = &info;

    for (j = 1L;; j++) {
  17:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
  1e:	00 
int get_time_stamp(__G__ last_modtime, nmember)  /* return PK-type error code */
    __GDEF
    time_t *last_modtime;
    ulg *nmember;
{
    int do_this_file=FALSE, error, error_in_archive=PK_COOL;
  1f:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  26:	00 
    on information in the central directory alone.  Thus we have a single,
    large loop through the entire directory, searching for the latest time
    stamp.
  ---------------------------------------------------------------------------*/

    *last_modtime = 0L;         /* assuming no zipfile data older than 1970 */
  27:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *nmember = 0L;
  2d:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
  34:	8d bb c8 00 00 00    	lea    0xc8(%ebx),%edi
/************************/

static int fn_is_dir(__G)    /* returns TRUE if G.filename is directory */
    __GDEF
{
    extent fn_len = strlen(G.filename);
  3a:	8d b3 e0 09 01 00    	lea    0x109e0(%ebx),%esi
    large loop through the entire directory, searching for the latest time
    stamp.
  ---------------------------------------------------------------------------*/

    *last_modtime = 0L;         /* assuming no zipfile data older than 1970 */
    *nmember = 0L;
  40:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    G.pInfo = &info;
  46:	8d 44 24 40          	lea    0x40(%esp),%eax
  4a:	89 83 d8 08 00 00    	mov    %eax,0x8d8(%ebx)

    for (j = 1L;; j++) {

        if (readbuf(__G__ G.sig, 4) == 0)
  50:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  57:	00 
  58:	89 7c 24 04          	mov    %edi,0x4(%esp)
  5c:	89 1c 24             	mov    %ebx,(%esp)
  5f:	e8 00 00 00 00       	call   64 <_get_time_stamp+0x64>
  64:	85 c0                	test   %eax,%eax
  66:	0f 84 0c 03 00 00    	je     378 <_get_time_stamp+0x378>
            return PK_EOF;
        if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a CentDir entry? */
  6c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  73:	00 
  74:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  7b:	00 
  7c:	89 3c 24             	mov    %edi,(%esp)
  7f:	e8 00 00 00 00       	call   84 <_get_time_stamp+0x84>
  84:	85 c0                	test   %eax,%eax
  86:	0f 85 99 02 00 00    	jne    325 <_get_time_stamp+0x325>
                     ((char *)slide, LoadFarString(ReportMsg)));
                return PK_BADERR;   /* sig not found */
            }
        }
        /* process_cdir_file_hdr() sets pInfo->lcflag: */
        if ((error = process_cdir_file_hdr(__G)) != PK_COOL)
  8c:	89 1c 24             	mov    %ebx,(%esp)
  8f:	e8 00 00 00 00       	call   94 <_get_time_stamp+0x94>
  94:	85 c0                	test   %eax,%eax
  96:	0f 85 d4 02 00 00    	jne    370 <_get_time_stamp+0x370>
            return error;       /* only PK_EOF defined */
        if ((error = do_string(__G__ G.crec.filename_length, DS_FN)) != PK_OK)
  9c:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  a3:	00 
  a4:	31 c0                	xor    %eax,%eax
  a6:	66 8b 83 54 09 01 00 	mov    0x10954(%ebx),%ax
  ad:	89 1c 24             	mov    %ebx,(%esp)
  b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  b4:	e8 00 00 00 00       	call   b9 <_get_time_stamp+0xb9>
  b9:	85 c0                	test   %eax,%eax
  bb:	74 0d                	je     ca <_get_time_stamp+0xca>
        {        /*  ^-- (uses pInfo->lcflag) */
            error_in_archive = error;
            if (error > PK_WARN)   /* fatal:  can't continue */
  bd:	83 f8 01             	cmp    $0x1,%eax
  c0:	0f 8f aa 02 00 00    	jg     370 <_get_time_stamp+0x370>
  c6:	89 44 24 24          	mov    %eax,0x24(%esp)
                return error;
        }
        if (G.extra_field != (uch *)NULL) {
  ca:	8b 83 18 09 01 00    	mov    0x10918(%ebx),%eax
  d0:	85 c0                	test   %eax,%eax
  d2:	74 12                	je     e6 <_get_time_stamp+0xe6>
            free(G.extra_field);
  d4:	89 04 24             	mov    %eax,(%esp)
  d7:	e8 00 00 00 00       	call   dc <_get_time_stamp+0xdc>
            G.extra_field = (uch *)NULL;
  dc:	c7 83 18 09 01 00 00 	movl   $0x0,0x10918(%ebx)
  e3:	00 00 00 
        }
        if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD))
  e6:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  ed:	00 
  ee:	31 c0                	xor    %eax,%eax
  f0:	66 8b 83 56 09 01 00 	mov    0x10956(%ebx),%ax
  f7:	89 1c 24             	mov    %ebx,(%esp)
  fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  fe:	e8 00 00 00 00       	call   103 <_get_time_stamp+0x103>
 103:	85 c0                	test   %eax,%eax
 105:	74 0d                	je     114 <_get_time_stamp+0x114>
            != 0)
        {
            error_in_archive = error;
            if (error > PK_WARN)      /* fatal */
 107:	83 f8 01             	cmp    $0x1,%eax
 10a:	0f 8f 60 02 00 00    	jg     370 <_get_time_stamp+0x370>
 110:	89 44 24 24          	mov    %eax,0x24(%esp)
                return error;
        }
        if (!G.process_all_files) {   /* check if specified on command line */
 114:	8b 43 74             	mov    0x74(%ebx),%eax
 117:	85 c0                	test   %eax,%eax
 119:	75 71                	jne    18c <_get_time_stamp+0x18c>
            unsigned i;

            if (G.filespecs == 0)
 11b:	8b 4b 6c             	mov    0x6c(%ebx),%ecx
 11e:	85 c9                	test   %ecx,%ecx
 120:	0f 84 5d 01 00 00    	je     283 <_get_time_stamp+0x283>
 126:	31 ed                	xor    %ebp,%ebp
 128:	eb 0c                	jmp    136 <_get_time_stamp+0x136>
 12a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                do_this_file = TRUE;
            else {  /* check if this entry matches an `include' argument */
                do_this_file = FALSE;
                for (i = 0; i < G.filespecs; i++)
 130:	45                   	inc    %ebp
 131:	39 6b 6c             	cmp    %ebp,0x6c(%ebx)
 134:	76 51                	jbe    187 <_get_time_stamp+0x187>
                    if (match(G.filename, G.pfnames[i], uO.C_flag WISEP)) {
 136:	8b 43 18             	mov    0x18(%ebx),%eax
 139:	89 44 24 08          	mov    %eax,0x8(%esp)
 13d:	8b 83 c0 00 00 00    	mov    0xc0(%ebx),%eax
 143:	8b 04 a8             	mov    (%eax,%ebp,4),%eax
 146:	89 34 24             	mov    %esi,(%esp)
 149:	89 44 24 04          	mov    %eax,0x4(%esp)
 14d:	e8 00 00 00 00       	call   152 <_get_time_stamp+0x152>
 152:	85 c0                	test   %eax,%eax
 154:	74 da                	je     130 <_get_time_stamp+0x130>
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 156:	8b 4b 70             	mov    0x70(%ebx),%ecx
 159:	85 c9                	test   %ecx,%ecx
 15b:	74 53                	je     1b0 <_get_time_stamp+0x1b0>
                return error;
        }
        if (!G.process_all_files) {   /* check if specified on command line */
            unsigned i;

            if (G.filespecs == 0)
 15d:	31 ed                	xor    %ebp,%ebp
 15f:	eb 06                	jmp    167 <_get_time_stamp+0x167>
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 161:	45                   	inc    %ebp
 162:	39 6b 70             	cmp    %ebp,0x70(%ebx)
 165:	76 49                	jbe    1b0 <_get_time_stamp+0x1b0>
                    if (match(G.filename, G.pxnames[i], uO.C_flag WISEP)) {
 167:	8b 43 18             	mov    0x18(%ebx),%eax
 16a:	89 44 24 08          	mov    %eax,0x8(%esp)
 16e:	8b 83 c4 00 00 00    	mov    0xc4(%ebx),%eax
 174:	8b 04 a8             	mov    (%eax,%ebp,4),%eax
 177:	89 34 24             	mov    %esi,(%esp)
 17a:	89 44 24 04          	mov    %eax,0x4(%esp)
 17e:	e8 00 00 00 00       	call   183 <_get_time_stamp+0x183>
 183:	85 c0                	test   %eax,%eax
 185:	74 da                	je     161 <_get_time_stamp+0x161>
 187:	8b 43 74             	mov    0x74(%ebx),%eax
                        do_this_file = FALSE;  /* ^-- ignore case in match */
 18a:	31 ed                	xor    %ebp,%ebp
         * specified, check the time for this file.  Either way, get rid of the
         * file comment and go back for the next file.
         * Directory entries are always ignored, to stay compatible with both
         * Zip and PKZIP.
         */
        if ((G.process_all_files || do_this_file) && !fn_is_dir(__G)) {
 18c:	09 e8                	or     %ebp,%eax
 18e:	75 30                	jne    1c0 <_get_time_stamp+0x1c0>
 190:	31 ed                	xor    %ebp,%ebp
                if (*last_modtime < modtime)
                    *last_modtime = modtime;
            }
            ++*nmember;
        }
        SKIP_(G.crec.file_comment_length)
 192:	8b 83 58 09 01 00    	mov    0x10958(%ebx),%eax
 198:	66 85 c0             	test   %ax,%ax
 19b:	0f 85 af 00 00 00    	jne    250 <_get_time_stamp+0x250>

    *last_modtime = 0L;         /* assuming no zipfile data older than 1970 */
    *nmember = 0L;
    G.pInfo = &info;

    for (j = 1L;; j++) {
 1a1:	8b 44 24 28          	mov    0x28(%esp),%eax
 1a5:	40                   	inc    %eax
 1a6:	89 44 24 28          	mov    %eax,0x28(%esp)
            }
            ++*nmember;
        }
        SKIP_(G.crec.file_comment_length)

    } /* end for-loop (j: files in central directory) */
 1aa:	e9 a1 fe ff ff       	jmp    50 <_get_time_stamp+0x50>
 1af:	90                   	nop
 1b0:	8b 43 74             	mov    0x74(%ebx),%eax
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 1b3:	bd 01 00 00 00       	mov    $0x1,%ebp
         * specified, check the time for this file.  Either way, get rid of the
         * file comment and go back for the next file.
         * Directory entries are always ignored, to stay compatible with both
         * Zip and PKZIP.
         */
        if ((G.process_all_files || do_this_file) && !fn_is_dir(__G)) {
 1b8:	09 e8                	or     %ebp,%eax
 1ba:	74 d4                	je     190 <_get_time_stamp+0x190>
 1bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
/************************/

static int fn_is_dir(__G)    /* returns TRUE if G.filename is directory */
    __GDEF
{
    extent fn_len = strlen(G.filename);
 1c0:	89 34 24             	mov    %esi,(%esp)
 1c3:	e8 00 00 00 00       	call   1c8 <_get_time_stamp+0x1c8>
    register char   endc;

    return  fn_len > 0 &&
 1c8:	85 c0                	test   %eax,%eax
 1ca:	0f 85 d3 00 00 00    	jne    2a3 <_get_time_stamp+0x2a3>
         * Directory entries are always ignored, to stay compatible with both
         * Zip and PKZIP.
         */
        if ((G.process_all_files || do_this_file) && !fn_is_dir(__G)) {
#ifdef USE_EF_UT_TIME
            if (G.extra_field &&
 1d0:	8b 83 18 09 01 00    	mov    0x10918(%ebx),%eax
 1d6:	85 c0                	test   %eax,%eax
 1d8:	0f 84 23 01 00 00    	je     301 <_get_time_stamp+0x301>
#ifdef IZ_CHECK_TZ
                G.tz_is_valid &&
#endif
                (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
 1de:	8d 54 24 34          	lea    0x34(%esp),%edx
 1e2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 1e9:	00 
 1ea:	89 54 24 10          	mov    %edx,0x10(%esp)
 1ee:	8b 8b 44 09 01 00    	mov    0x10944(%ebx),%ecx
 1f4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 1fb:	00 
 1fc:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
 200:	31 c9                	xor    %ecx,%ecx
 202:	66 8b 8b 56 09 01 00 	mov    0x10956(%ebx),%cx
 209:	89 04 24             	mov    %eax,(%esp)
 20c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 210:	e8 00 00 00 00       	call   215 <_get_time_stamp+0x215>
         * Directory entries are always ignored, to stay compatible with both
         * Zip and PKZIP.
         */
        if ((G.process_all_files || do_this_file) && !fn_is_dir(__G)) {
#ifdef USE_EF_UT_TIME
            if (G.extra_field &&
 215:	a8 01                	test   $0x1,%al
 217:	0f 84 e4 00 00 00    	je     301 <_get_time_stamp+0x301>
#endif
                (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
                                  G.crec.last_mod_dos_datetime, &z_utime, NULL)
                 & EB_UT_FL_MTIME))
            {
                if (*last_modtime < z_utime.mtime)
 21d:	8b 94 24 84 00 00 00 	mov    0x84(%esp),%edx
 224:	8b 44 24 38          	mov    0x38(%esp),%eax
 228:	39 02                	cmp    %eax,(%edx)
 22a:	7d 04                	jge    230 <_get_time_stamp+0x230>
#endif /* USE_EF_UT_TIME */
            {
                time_t modtime = dos_to_unix_time(G.crec.last_mod_dos_datetime);

                if (*last_modtime < modtime)
                    *last_modtime = modtime;
 22c:	89 02                	mov    %eax,(%edx)
 22e:	66 90                	xchg   %ax,%ax
            }
            ++*nmember;
 230:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
 237:	8b 10                	mov    (%eax),%edx
 239:	42                   	inc    %edx
 23a:	89 10                	mov    %edx,(%eax)
        }
        SKIP_(G.crec.file_comment_length)
 23c:	8b 83 58 09 01 00    	mov    0x10958(%ebx),%eax
 242:	66 85 c0             	test   %ax,%ax
 245:	0f 84 56 ff ff ff    	je     1a1 <_get_time_stamp+0x1a1>
 24b:	90                   	nop
 24c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 250:	25 ff ff 00 00       	and    $0xffff,%eax
 255:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 25c:	00 
 25d:	89 44 24 04          	mov    %eax,0x4(%esp)
 261:	89 1c 24             	mov    %ebx,(%esp)
 264:	e8 00 00 00 00       	call   269 <_get_time_stamp+0x269>
 269:	85 c0                	test   %eax,%eax
 26b:	0f 84 30 ff ff ff    	je     1a1 <_get_time_stamp+0x1a1>
 271:	83 f8 01             	cmp    $0x1,%eax
 274:	0f 8f f6 00 00 00    	jg     370 <_get_time_stamp+0x370>
 27a:	89 44 24 24          	mov    %eax,0x24(%esp)
 27e:	e9 1e ff ff ff       	jmp    1a1 <_get_time_stamp+0x1a1>
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 283:	8b 43 70             	mov    0x70(%ebx),%eax
 286:	85 c0                	test   %eax,%eax
 288:	0f 85 cf fe ff ff    	jne    15d <_get_time_stamp+0x15d>
/************************/

static int fn_is_dir(__G)    /* returns TRUE if G.filename is directory */
    __GDEF
{
    extent fn_len = strlen(G.filename);
 28e:	89 34 24             	mov    %esi,(%esp)
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 291:	bd 01 00 00 00       	mov    $0x1,%ebp
/************************/

static int fn_is_dir(__G)    /* returns TRUE if G.filename is directory */
    __GDEF
{
    extent fn_len = strlen(G.filename);
 296:	e8 00 00 00 00       	call   29b <_get_time_stamp+0x29b>
    register char   endc;

    return  fn_len > 0 &&
 29b:	85 c0                	test   %eax,%eax
 29d:	0f 84 2d ff ff ff    	je     1d0 <_get_time_stamp+0x1d0>
            ((endc = lastchar(G.filename, fn_len)) == '/' ||
 2a3:	89 44 24 04          	mov    %eax,0x4(%esp)
 2a7:	89 34 24             	mov    %esi,(%esp)
 2aa:	e8 00 00 00 00       	call   2af <_get_time_stamp+0x2af>
 2af:	8a 08                	mov    (%eax),%cl
    __GDEF
{
    extent fn_len = strlen(G.filename);
    register char   endc;

    return  fn_len > 0 &&
 2b1:	80 f9 2f             	cmp    $0x2f,%cl
 2b4:	0f 84 d8 fe ff ff    	je     192 <_get_time_stamp+0x192>
            ((endc = lastchar(G.filename, fn_len)) == '/' ||
             (G.pInfo->hostnum == FS_FAT_ && !MBSCHR(G.filename, '/') &&
 2ba:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
{
    extent fn_len = strlen(G.filename);
    register char   endc;

    return  fn_len > 0 &&
            ((endc = lastchar(G.filename, fn_len)) == '/' ||
 2c0:	80 78 13 00          	cmpb   $0x0,0x13(%eax)
 2c4:	0f 85 06 ff ff ff    	jne    1d0 <_get_time_stamp+0x1d0>
             (G.pInfo->hostnum == FS_FAT_ && !MBSCHR(G.filename, '/') &&
 2ca:	c7 44 24 04 2f 00 00 	movl   $0x2f,0x4(%esp)
 2d1:	00 
 2d2:	89 34 24             	mov    %esi,(%esp)
 2d5:	88 4c 24 2f          	mov    %cl,0x2f(%esp)
 2d9:	e8 00 00 00 00       	call   2de <_get_time_stamp+0x2de>
 2de:	85 c0                	test   %eax,%eax
 2e0:	0f 85 ea fe ff ff    	jne    1d0 <_get_time_stamp+0x1d0>
 2e6:	8a 4c 24 2f          	mov    0x2f(%esp),%cl
 2ea:	80 f9 5c             	cmp    $0x5c,%cl
 2ed:	0f 84 9f fe ff ff    	je     192 <_get_time_stamp+0x192>
         * Directory entries are always ignored, to stay compatible with both
         * Zip and PKZIP.
         */
        if ((G.process_all_files || do_this_file) && !fn_is_dir(__G)) {
#ifdef USE_EF_UT_TIME
            if (G.extra_field &&
 2f3:	8b 83 18 09 01 00    	mov    0x10918(%ebx),%eax
 2f9:	85 c0                	test   %eax,%eax
 2fb:	0f 85 dd fe ff ff    	jne    1de <_get_time_stamp+0x1de>
                if (*last_modtime < z_utime.mtime)
                    *last_modtime = z_utime.mtime;
            } else
#endif /* USE_EF_UT_TIME */
            {
                time_t modtime = dos_to_unix_time(G.crec.last_mod_dos_datetime);
 301:	8b 83 44 09 01 00    	mov    0x10944(%ebx),%eax
 307:	89 04 24             	mov    %eax,(%esp)
 30a:	e8 00 00 00 00       	call   30f <_get_time_stamp+0x30f>

                if (*last_modtime < modtime)
 30f:	8b 94 24 84 00 00 00 	mov    0x84(%esp),%edx
 316:	3b 02                	cmp    (%edx),%eax
 318:	0f 8e 12 ff ff ff    	jle    230 <_get_time_stamp+0x230>
                    *last_modtime = modtime;
 31e:	89 02                	mov    %eax,(%edx)
 320:	e9 0b ff ff ff       	jmp    230 <_get_time_stamp+0x230>
    for (j = 1L;; j++) {

        if (readbuf(__G__ G.sig, 4) == 0)
            return PK_EOF;
        if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a CentDir entry? */
            if (((unsigned)(j - 1) & (unsigned)0xFFFF) ==
 325:	8b 54 24 28          	mov    0x28(%esp),%edx
 329:	89 d0                	mov    %edx,%eax
 32b:	48                   	dec    %eax
 32c:	66 39 83 6e 09 01 00 	cmp    %ax,0x1096e(%ebx)
 333:	75 50                	jne    385 <_get_time_stamp+0x385>

/*---------------------------------------------------------------------------
    Double check that we're back at the end-of-central-directory record.
  ---------------------------------------------------------------------------*/

    if (strncmp(G.sig, end_central_sig, 4)) {   /* just to make sure again */
 335:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 33c:	00 
 33d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 344:	00 
 345:	89 3c 24             	mov    %edi,(%esp)
 348:	e8 00 00 00 00       	call   34d <_get_time_stamp+0x34d>
 34d:	85 c0                	test   %eax,%eax
 34f:	0f 85 a3 00 00 00    	jne    3f8 <_get_time_stamp+0x3f8>
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
        error_in_archive = PK_WARN;
    }
    if (*nmember == 0L && error_in_archive <= PK_WARN)
        error_in_archive = PK_FIND;
 355:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
 35c:	8b 10                	mov    (%eax),%edx
 35e:	b8 0b 00 00 00       	mov    $0xb,%eax
 363:	85 d2                	test   %edx,%edx
 365:	0f 45 44 24 24       	cmovne 0x24(%esp),%eax
 36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

    return error_in_archive;

} /* end function get_time_stamp() */
 370:	83 c4 6c             	add    $0x6c,%esp
 373:	5b                   	pop    %ebx
 374:	5e                   	pop    %esi
 375:	5f                   	pop    %edi
 376:	5d                   	pop    %ebp
 377:	c3                   	ret    
 378:	83 c4 6c             	add    $0x6c,%esp
    G.pInfo = &info;

    for (j = 1L;; j++) {

        if (readbuf(__G__ G.sig, 4) == 0)
            return PK_EOF;
 37b:	b8 33 00 00 00       	mov    $0x33,%eax
    if (*nmember == 0L && error_in_archive <= PK_WARN)
        error_in_archive = PK_FIND;

    return error_in_archive;

} /* end function get_time_stamp() */
 380:	5b                   	pop    %ebx
 381:	5e                   	pop    %esi
 382:	5f                   	pop    %edi
 383:	5d                   	pop    %ebp
 384:	c3                   	ret    
                 * number of directory entries -> probably, the regular
                 * end of the central directory has been reached
                 */
                break;
            } else {
                Info(slide, 0x401,
 385:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
 38b:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
 391:	89 54 24 08          	mov    %edx,0x8(%esp)
 395:	89 3c 24             	mov    %edi,(%esp)
 398:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 39f:	00 
 3a0:	e8 00 00 00 00       	call   3a5 <_get_time_stamp+0x3a5>
 3a5:	89 7c 24 04          	mov    %edi,0x4(%esp)
 3a9:	89 1c 24             	mov    %ebx,(%esp)
 3ac:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
 3b3:	00 
 3b4:	89 44 24 08          	mov    %eax,0x8(%esp)
 3b8:	ff d6                	call   *%esi
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
 3ba:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
                 * number of directory entries -> probably, the regular
                 * end of the central directory has been reached
                 */
                break;
            } else {
                Info(slide, 0x401,
 3c0:	83 ec 10             	sub    $0x10,%esp
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
 3c3:	89 3c 24             	mov    %edi,(%esp)
 3c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 3cd:	00 
 3ce:	e8 00 00 00 00       	call   3d3 <_get_time_stamp+0x3d3>
 3d3:	89 7c 24 04          	mov    %edi,0x4(%esp)
 3d7:	89 1c 24             	mov    %ebx,(%esp)
 3da:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
 3e1:	00 
 3e2:	89 44 24 08          	mov    %eax,0x8(%esp)
 3e6:	ff d6                	call   *%esi
                     ((char *)slide, LoadFarString(ReportMsg)));
                return PK_BADERR;   /* sig not found */
 3e8:	b8 03 00 00 00       	mov    $0x3,%eax
                 */
                break;
            } else {
                Info(slide, 0x401,
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
 3ed:	83 ec 10             	sub    $0x10,%esp
    if (*nmember == 0L && error_in_archive <= PK_WARN)
        error_in_archive = PK_FIND;

    return error_in_archive;

} /* end function get_time_stamp() */
 3f0:	83 c4 6c             	add    $0x6c,%esp
 3f3:	5b                   	pop    %ebx
 3f4:	5e                   	pop    %esi
 3f5:	5f                   	pop    %edi
 3f6:	5d                   	pop    %ebp
 3f7:	c3                   	ret    
/*---------------------------------------------------------------------------
    Double check that we're back at the end-of-central-directory record.
  ---------------------------------------------------------------------------*/

    if (strncmp(G.sig, end_central_sig, 4)) {   /* just to make sure again */
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
 3f8:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
 3fe:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
 404:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 40b:	00 
 40c:	89 3c 24             	mov    %edi,(%esp)
 40f:	e8 00 00 00 00       	call   414 <_get_time_stamp+0x414>
 414:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
 41b:	00 
 41c:	89 44 24 08          	mov    %eax,0x8(%esp)
 420:	89 7c 24 04          	mov    %edi,0x4(%esp)
 424:	89 1c 24             	mov    %ebx,(%esp)
 427:	ff d6                	call   *%esi
 429:	83 ec 10             	sub    $0x10,%esp
        error_in_archive = PK_WARN;
 42c:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
 433:	00 
 434:	e9 1c ff ff ff       	jmp    355 <_get_time_stamp+0x355>
 439:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000440 <_ratio>:
/* Function ratio() */    /* also used by ZipInfo routines */
/********************/

int ratio(uc, c)
    ulg uc, c;
{
 440:	53                   	push   %ebx
    ulg denom;

    if (uc == 0)
        return 0;
 441:	31 c0                	xor    %eax,%eax
/* Function ratio() */    /* also used by ZipInfo routines */
/********************/

int ratio(uc, c)
    ulg uc, c;
{
 443:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    ulg denom;

    if (uc == 0)
 447:	85 c9                	test   %ecx,%ecx
 449:	74 2c                	je     477 <_ratio+0x37>
        return 0;
    if (uc > 2000000L) {    /* risk signed overflow if multiply numerator */
 44b:	81 f9 80 84 1e 00    	cmp    $0x1e8480,%ecx
 451:	76 2d                	jbe    480 <_ratio+0x40>
        denom = uc / 1000L;
 453:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
 458:	89 c8                	mov    %ecx,%eax
 45a:	f7 e2                	mul    %edx
 45c:	89 d3                	mov    %edx,%ebx
 45e:	c1 eb 06             	shr    $0x6,%ebx
        return ((uc >= c) ?
            (int) ((uc-c + (denom>>1)) / denom) :
 461:	3b 4c 24 0c          	cmp    0xc(%esp),%ecx
 465:	72 3d                	jb     4a4 <_ratio+0x64>
 467:	c1 ea 07             	shr    $0x7,%edx
 46a:	8b 44 24 0c          	mov    0xc(%esp),%eax
 46e:	29 c1                	sub    %eax,%ecx
 470:	8d 04 11             	lea    (%ecx,%edx,1),%eax
 473:	31 d2                	xor    %edx,%edx
 475:	f7 f3                	div    %ebx
        denom = uc;
        return ((uc >= c) ?
            (int) ((1000L*(uc-c) + (denom>>1)) / denom) :
          -((int) ((1000L*(c-uc) + (denom>>1)) / denom)));
    }                            /* ^^^^^^^^ rounding */
}
 477:	5b                   	pop    %ebx
 478:	c3                   	ret    
 479:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            (int) ((uc-c + (denom>>1)) / denom) :
          -((int) ((c-uc + (denom>>1)) / denom)));
    } else {             /* ^^^^^^^^ rounding */
        denom = uc;
        return ((uc >= c) ?
            (int) ((1000L*(uc-c) + (denom>>1)) / denom) :
 480:	3b 4c 24 0c          	cmp    0xc(%esp),%ecx
 484:	72 31                	jb     4b7 <_ratio+0x77>
 486:	8b 54 24 0c          	mov    0xc(%esp),%edx
 48a:	89 c8                	mov    %ecx,%eax
 48c:	29 d0                	sub    %edx,%eax
          -((int) ((1000L*(c-uc) + (denom>>1)) / denom)));
    }                            /* ^^^^^^^^ rounding */
}
 48e:	5b                   	pop    %ebx
            (int) ((uc-c + (denom>>1)) / denom) :
          -((int) ((c-uc + (denom>>1)) / denom)));
    } else {             /* ^^^^^^^^ rounding */
        denom = uc;
        return ((uc >= c) ?
            (int) ((1000L*(uc-c) + (denom>>1)) / denom) :
 48f:	8d 04 80             	lea    (%eax,%eax,4),%eax
 492:	8d 04 80             	lea    (%eax,%eax,4),%eax
 495:	8d 14 80             	lea    (%eax,%eax,4),%edx
 498:	89 c8                	mov    %ecx,%eax
 49a:	d1 e8                	shr    %eax
 49c:	8d 04 d0             	lea    (%eax,%edx,8),%eax
 49f:	31 d2                	xor    %edx,%edx
 4a1:	f7 f1                	div    %ecx
          -((int) ((1000L*(c-uc) + (denom>>1)) / denom)));
    }                            /* ^^^^^^^^ rounding */
}
 4a3:	c3                   	ret    
        return 0;
    if (uc > 2000000L) {    /* risk signed overflow if multiply numerator */
        denom = uc / 1000L;
        return ((uc >= c) ?
            (int) ((uc-c + (denom>>1)) / denom) :
          -((int) ((c-uc + (denom>>1)) / denom)));
 4a4:	c1 ea 07             	shr    $0x7,%edx
 4a7:	8b 44 24 0c          	mov    0xc(%esp),%eax
 4ab:	29 c8                	sub    %ecx,%eax
 4ad:	01 d0                	add    %edx,%eax
 4af:	31 d2                	xor    %edx,%edx
 4b1:	f7 f3                	div    %ebx
    if (uc == 0)
        return 0;
    if (uc > 2000000L) {    /* risk signed overflow if multiply numerator */
        denom = uc / 1000L;
        return ((uc >= c) ?
            (int) ((uc-c + (denom>>1)) / denom) :
 4b3:	f7 d8                	neg    %eax
        denom = uc;
        return ((uc >= c) ?
            (int) ((1000L*(uc-c) + (denom>>1)) / denom) :
          -((int) ((1000L*(c-uc) + (denom>>1)) / denom)));
    }                            /* ^^^^^^^^ rounding */
}
 4b5:	5b                   	pop    %ebx
 4b6:	c3                   	ret    
          -((int) ((c-uc + (denom>>1)) / denom)));
    } else {             /* ^^^^^^^^ rounding */
        denom = uc;
        return ((uc >= c) ?
            (int) ((1000L*(uc-c) + (denom>>1)) / denom) :
          -((int) ((1000L*(c-uc) + (denom>>1)) / denom)));
 4b7:	8b 44 24 0c          	mov    0xc(%esp),%eax
    }                            /* ^^^^^^^^ rounding */
}
 4bb:	5b                   	pop    %ebx
          -((int) ((c-uc + (denom>>1)) / denom)));
    } else {             /* ^^^^^^^^ rounding */
        denom = uc;
        return ((uc >= c) ?
            (int) ((1000L*(uc-c) + (denom>>1)) / denom) :
          -((int) ((1000L*(c-uc) + (denom>>1)) / denom)));
 4bc:	29 c8                	sub    %ecx,%eax
 4be:	8d 04 80             	lea    (%eax,%eax,4),%eax
 4c1:	8d 04 80             	lea    (%eax,%eax,4),%eax
 4c4:	8d 14 80             	lea    (%eax,%eax,4),%edx
 4c7:	89 c8                	mov    %ecx,%eax
 4c9:	d1 e8                	shr    %eax
 4cb:	8d 04 d0             	lea    (%eax,%edx,8),%eax
 4ce:	31 d2                	xor    %edx,%edx
 4d0:	f7 f1                	div    %ecx
            (int) ((uc-c + (denom>>1)) / denom) :
          -((int) ((c-uc + (denom>>1)) / denom)));
    } else {             /* ^^^^^^^^ rounding */
        denom = uc;
        return ((uc >= c) ?
            (int) ((1000L*(uc-c) + (denom>>1)) / denom) :
 4d2:	f7 d8                	neg    %eax
          -((int) ((1000L*(c-uc) + (denom>>1)) / denom)));
    }                            /* ^^^^^^^^ rounding */
}
 4d4:	c3                   	ret    
 4d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 4d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000004e0 <_list_files>:
/* Function list_files() */
/*************************/

int list_files(__G)    /* return PK-type error code */
    __GDEF
{
 4e0:	55                   	push   %ebp
 4e1:	57                   	push   %edi
 4e2:	56                   	push   %esi
 4e3:	53                   	push   %ebx
 4e4:	81 ec cc 00 00 00    	sub    $0xcc,%esp
 4ea:	8b ac 24 e0 00 00 00 	mov    0xe0(%esp),%ebp
   16717  Defl:X     5252  69%  11-03-97 06:40  1ce0f189  WHERE
--------          -------  ---                            -------
   64159            20502  68%                            3 files
  ---------------------------------------------------------------------------*/

    G.pInfo = &info;
 4f1:	8d 84 24 a0 00 00 00 	lea    0xa0(%esp),%eax
 4f8:	89 85 d8 08 00 00    	mov    %eax,0x8d8(%ebp)
    date_format = DATE_FORMAT;
 4fe:	e8 00 00 00 00       	call   503 <_list_files+0x23>
 503:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    dt_sepchar = DATE_SEPCHAR;
 507:	e8 00 00 00 00       	call   50c <_list_files+0x2c>
 50c:	8d 85 c8 00 00 00    	lea    0xc8(%ebp),%eax
#ifdef USE_EF_UT_TIME
    iztimes z_utime;
    struct tm *t;
#endif
    unsigned yr, mo, dy, hh, mm;
    ulg csiz, tot_csize=0L, tot_ucsize=0L;
 512:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%esp)
 519:	00 
 51a:	89 44 24 58          	mov    %eax,0x58(%esp)
 51e:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
 525:	00 
    char sgn, cfactorstr[10];
    int longhdr=(uO.vflag>1);
#endif
    int date_format;
    char dt_sepchar;
    ulg j, members=0L;
 526:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%esp)
 52d:	00 
               LoadFarString(Headers[longhdr][0]),
               LoadFarStringSmall(Headers[longhdr][1])));
    }
#endif /* !WINDLL */

    for (j = 1L;;j++) {
 52e:	c7 44 24 5c 01 00 00 	movl   $0x1,0x5c(%esp)
 535:	00 
/*************************/

int list_files(__G)    /* return PK-type error code */
    __GDEF
{
    int do_this_file=FALSE, cfactor, error, error_in_archive=PK_COOL;
 536:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
 53d:	00 
 53e:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
 545:	00 
    }
#endif /* !WINDLL */

    for (j = 1L;;j++) {

        if (readbuf(__G__ G.sig, 4) == 0)
 546:	8b 7c 24 58          	mov    0x58(%esp),%edi
 54a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 551:	00 
 552:	89 7c 24 04          	mov    %edi,0x4(%esp)
 556:	89 2c 24             	mov    %ebp,(%esp)
 559:	e8 00 00 00 00       	call   55e <_list_files+0x7e>
 55e:	85 c0                	test   %eax,%eax
 560:	0f 84 65 05 00 00    	je     acb <_list_files+0x5eb>
            return PK_EOF;
        if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a CentDir entry? */
 566:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 56d:	00 
 56e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 575:	00 
 576:	89 3c 24             	mov    %edi,(%esp)
 579:	e8 00 00 00 00       	call   57e <_list_files+0x9e>
 57e:	89 44 24 4c          	mov    %eax,0x4c(%esp)
 582:	85 c0                	test   %eax,%eax
 584:	0f 85 e4 04 00 00    	jne    a6e <_list_files+0x58e>
                     ((char *)slide, LoadFarString(ReportMsg)));
                return PK_BADERR;   /* sig not found */
            }
        }
        /* process_cdir_file_hdr() sets pInfo->hostnum, pInfo->lcflag, ...: */
        if ((error = process_cdir_file_hdr(__G)) != PK_COOL)
 58a:	89 2c 24             	mov    %ebp,(%esp)
 58d:	e8 00 00 00 00       	call   592 <_list_files+0xb2>
 592:	85 c0                	test   %eax,%eax
 594:	0f 85 26 05 00 00    	jne    ac0 <_list_files+0x5e0>
         * which, if member names were specified on the command line, check in
         * with match() to see if the current file is one of them, and make a
         * note of it if it is.
         */

        if ((error = do_string(__G__ G.crec.filename_length, DS_FN)) !=
 59a:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
 5a1:	00 
 5a2:	31 c0                	xor    %eax,%eax
 5a4:	66 8b 85 54 09 01 00 	mov    0x10954(%ebp),%ax
 5ab:	89 2c 24             	mov    %ebp,(%esp)
 5ae:	89 44 24 04          	mov    %eax,0x4(%esp)
 5b2:	e8 00 00 00 00       	call   5b7 <_list_files+0xd7>
 5b7:	85 c0                	test   %eax,%eax
 5b9:	74 0d                	je     5c8 <_list_files+0xe8>
             PK_COOL)   /*  ^--(uses pInfo->lcflag) */
        {
            error_in_archive = error;
            if (error > PK_WARN)   /* fatal:  can't continue */
 5bb:	83 f8 01             	cmp    $0x1,%eax
 5be:	0f 8f fc 04 00 00    	jg     ac0 <_list_files+0x5e0>
 5c4:	89 44 24 50          	mov    %eax,0x50(%esp)
                return error;
        }
        if (G.extra_field != (uch *)NULL) {
 5c8:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
 5ce:	85 c0                	test   %eax,%eax
 5d0:	74 12                	je     5e4 <_list_files+0x104>
            free(G.extra_field);
 5d2:	89 04 24             	mov    %eax,(%esp)
 5d5:	e8 00 00 00 00       	call   5da <_list_files+0xfa>
            G.extra_field = (uch *)NULL;
 5da:	c7 85 18 09 01 00 00 	movl   $0x0,0x10918(%ebp)
 5e1:	00 00 00 
        }
        if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD))
 5e4:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 5eb:	00 
 5ec:	31 c0                	xor    %eax,%eax
 5ee:	66 8b 85 56 09 01 00 	mov    0x10956(%ebp),%ax
 5f5:	89 2c 24             	mov    %ebp,(%esp)
 5f8:	89 44 24 04          	mov    %eax,0x4(%esp)
 5fc:	e8 00 00 00 00       	call   601 <_list_files+0x121>
 601:	85 c0                	test   %eax,%eax
 603:	74 0d                	je     612 <_list_files+0x132>
            != 0)
        {
            error_in_archive = error;
            if (error > PK_WARN)      /* fatal */
 605:	83 f8 01             	cmp    $0x1,%eax
 608:	0f 8f b2 04 00 00    	jg     ac0 <_list_files+0x5e0>
 60e:	89 44 24 50          	mov    %eax,0x50(%esp)
                return error;
        }
        if (!G.process_all_files) {   /* check if specified on command line */
 612:	8b 45 74             	mov    0x74(%ebp),%eax
 615:	85 c0                	test   %eax,%eax
 617:	0f 85 7f 00 00 00    	jne    69c <_list_files+0x1bc>
            unsigned i;

            if (G.filespecs == 0)
 61d:	8b 45 6c             	mov    0x6c(%ebp),%eax
 620:	85 c0                	test   %eax,%eax
 622:	0f 84 38 03 00 00    	je     960 <_list_files+0x480>
 628:	8d 9d e0 09 01 00    	lea    0x109e0(%ebp),%ebx
 62e:	31 f6                	xor    %esi,%esi
 630:	eb 06                	jmp    638 <_list_files+0x158>
                do_this_file = TRUE;
            else {  /* check if this entry matches an `include' argument */
                do_this_file = FALSE;
                for (i = 0; i < G.filespecs; i++)
 632:	46                   	inc    %esi
 633:	39 75 6c             	cmp    %esi,0x6c(%ebp)
 636:	76 59                	jbe    691 <_list_files+0x1b1>
                    if (match(G.filename, G.pfnames[i], uO.C_flag WISEP)) {
 638:	8b 45 18             	mov    0x18(%ebp),%eax
 63b:	89 44 24 08          	mov    %eax,0x8(%esp)
 63f:	8b 85 c0 00 00 00    	mov    0xc0(%ebp),%eax
 645:	8b 04 b0             	mov    (%eax,%esi,4),%eax
 648:	89 1c 24             	mov    %ebx,(%esp)
 64b:	89 44 24 04          	mov    %eax,0x4(%esp)
 64f:	e8 00 00 00 00       	call   654 <_list_files+0x174>
 654:	85 c0                	test   %eax,%eax
 656:	74 da                	je     632 <_list_files+0x152>
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 658:	8b 55 70             	mov    0x70(%ebp),%edx
 65b:	85 d2                	test   %edx,%edx
 65d:	0f 84 bd 02 00 00    	je     920 <_list_files+0x440>
                return error;
        }
        if (!G.process_all_files) {   /* check if specified on command line */
            unsigned i;

            if (G.filespecs == 0)
 663:	31 f6                	xor    %esi,%esi
 665:	eb 0a                	jmp    671 <_list_files+0x191>
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 667:	46                   	inc    %esi
 668:	39 75 70             	cmp    %esi,0x70(%ebp)
 66b:	0f 86 af 02 00 00    	jbe    920 <_list_files+0x440>
                    if (match(G.filename, G.pxnames[i], uO.C_flag WISEP)) {
 671:	8b 45 18             	mov    0x18(%ebp),%eax
 674:	89 44 24 08          	mov    %eax,0x8(%esp)
 678:	8b 85 c4 00 00 00    	mov    0xc4(%ebp),%eax
 67e:	8b 04 b0             	mov    (%eax,%esi,4),%eax
 681:	89 1c 24             	mov    %ebx,(%esp)
 684:	89 44 24 04          	mov    %eax,0x4(%esp)
 688:	e8 00 00 00 00       	call   68d <_list_files+0x1ad>
 68d:	85 c0                	test   %eax,%eax
 68f:	74 d6                	je     667 <_list_files+0x187>
 691:	8b 45 74             	mov    0x74(%ebp),%eax
                        do_this_file = FALSE;  /* ^-- ignore case in match */
 694:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
 69b:	00 
         * If current file was specified on command line, or if no names were
         * specified, do the listing for this file.  Otherwise, get rid of the
         * file comment and go back for the next file.
         */

        if (G.process_all_files || do_this_file) {
 69c:	0b 44 24 40          	or     0x40(%esp),%eax
 6a0:	0f 84 8f 02 00 00    	je     935 <_list_files+0x455>
                    ef_len -= (ef_size + EB_HEADSIZE);
                }
            }
#endif
#ifdef USE_EF_UT_TIME
            if (G.extra_field &&
 6a6:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
 6ac:	85 c0                	test   %eax,%eax
 6ae:	74 42                	je     6f2 <_list_files+0x212>
#ifdef IZ_CHECK_TZ
                G.tz_is_valid &&
#endif
                (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
 6b0:	8d 94 24 94 00 00 00 	lea    0x94(%esp),%edx
 6b7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 6be:	00 
 6bf:	89 54 24 10          	mov    %edx,0x10(%esp)
 6c3:	8b 95 44 09 01 00    	mov    0x10944(%ebp),%edx
 6c9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 6d0:	00 
 6d1:	89 54 24 0c          	mov    %edx,0xc(%esp)
 6d5:	31 d2                	xor    %edx,%edx
 6d7:	66 8b 95 56 09 01 00 	mov    0x10956(%ebp),%dx
 6de:	89 04 24             	mov    %eax,(%esp)
 6e1:	89 54 24 04          	mov    %edx,0x4(%esp)
 6e5:	e8 00 00 00 00       	call   6ea <_list_files+0x20a>
                    ef_len -= (ef_size + EB_HEADSIZE);
                }
            }
#endif
#ifdef USE_EF_UT_TIME
            if (G.extra_field &&
 6ea:	a8 01                	test   $0x1,%al
 6ec:	0f 85 2e 03 00 00    	jne    a20 <_list_files+0x540>
                hh = (unsigned)(t->tm_hour);
                mm = (unsigned)(t->tm_min);
            } else
#endif /* USE_EF_UT_TIME */
            {
                yr = ((((unsigned)(G.crec.last_mod_dos_datetime >> 25) & 0x7f)
 6f2:	8b 8d 44 09 01 00    	mov    0x10944(%ebp),%ecx
 6f8:	bf 64 00 00 00       	mov    $0x64,%edi
 6fd:	89 c8                	mov    %ecx,%eax
 6ff:	31 d2                	xor    %edx,%edx
 701:	c1 e8 19             	shr    $0x19,%eax
                       + 80) % (unsigned)100);
 704:	83 c0 50             	add    $0x50,%eax
                hh = (unsigned)(t->tm_hour);
                mm = (unsigned)(t->tm_min);
            } else
#endif /* USE_EF_UT_TIME */
            {
                yr = ((((unsigned)(G.crec.last_mod_dos_datetime >> 25) & 0x7f)
 707:	f7 f7                	div    %edi
                       + 80) % (unsigned)100);
                mo = ((unsigned)(G.crec.last_mod_dos_datetime >> 21) & 0x0f);
 709:	89 c8                	mov    %ecx,%eax
                hh = (unsigned)(t->tm_hour);
                mm = (unsigned)(t->tm_min);
            } else
#endif /* USE_EF_UT_TIME */
            {
                yr = ((((unsigned)(G.crec.last_mod_dos_datetime >> 25) & 0x7f)
 70b:	89 54 24 54          	mov    %edx,0x54(%esp)
                       + 80) % (unsigned)100);
                mo = ((unsigned)(G.crec.last_mod_dos_datetime >> 21) & 0x0f);
 70f:	c1 e8 15             	shr    $0x15,%eax
 712:	83 e0 0f             	and    $0xf,%eax
 715:	89 44 24 44          	mov    %eax,0x44(%esp)
                dy = ((unsigned)(G.crec.last_mod_dos_datetime >> 16) & 0x1f);
 719:	89 c8                	mov    %ecx,%eax
 71b:	c1 e8 10             	shr    $0x10,%eax
 71e:	83 e0 1f             	and    $0x1f,%eax
 721:	89 44 24 48          	mov    %eax,0x48(%esp)
                hh = (((unsigned)G.crec.last_mod_dos_datetime >> 11) & 0x1f);
 725:	89 c8                	mov    %ecx,%eax
 727:	c1 e8 0b             	shr    $0xb,%eax
                mm = (((unsigned)G.crec.last_mod_dos_datetime >> 5) & 0x3f);
 72a:	c1 e9 05             	shr    $0x5,%ecx
            {
                yr = ((((unsigned)(G.crec.last_mod_dos_datetime >> 25) & 0x7f)
                       + 80) % (unsigned)100);
                mo = ((unsigned)(G.crec.last_mod_dos_datetime >> 21) & 0x0f);
                dy = ((unsigned)(G.crec.last_mod_dos_datetime >> 16) & 0x1f);
                hh = (((unsigned)G.crec.last_mod_dos_datetime >> 11) & 0x1f);
 72d:	83 e0 1f             	and    $0x1f,%eax
                mm = (((unsigned)G.crec.last_mod_dos_datetime >> 5) & 0x3f);
 730:	83 e1 3f             	and    $0x3f,%ecx
            {
                yr = ((((unsigned)(G.crec.last_mod_dos_datetime >> 25) & 0x7f)
                       + 80) % (unsigned)100);
                mo = ((unsigned)(G.crec.last_mod_dos_datetime >> 21) & 0x0f);
                dy = ((unsigned)(G.crec.last_mod_dos_datetime >> 16) & 0x1f);
                hh = (((unsigned)G.crec.last_mod_dos_datetime >> 11) & 0x1f);
 733:	89 44 24 60          	mov    %eax,0x60(%esp)
                mm = (((unsigned)G.crec.last_mod_dos_datetime >> 5) & 0x3f);
 737:	89 4c 24 64          	mov    %ecx,0x64(%esp)
 73b:	90                   	nop
 73c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            }
            /* permute date so it displays according to nat'l convention
             * ('methnum' is not yet set, it is used as temporary buffer) */
            switch (date_format) {
 740:	8b 44 24 7c          	mov    0x7c(%esp),%eax
 744:	83 f8 01             	cmp    $0x1,%eax
 747:	0f 84 74 02 00 00    	je     9c1 <_list_files+0x4e1>
 74d:	83 f8 02             	cmp    $0x2,%eax
 750:	75 18                	jne    76a <_list_files+0x28a>
                case DF_YMD:
                    methnum = mo;
                    mo = yr; yr = dy; dy = methnum;
 752:	8b 5c 24 48          	mov    0x48(%esp),%ebx
                hh = (((unsigned)G.crec.last_mod_dos_datetime >> 11) & 0x1f);
                mm = (((unsigned)G.crec.last_mod_dos_datetime >> 5) & 0x3f);
            }
            /* permute date so it displays according to nat'l convention
             * ('methnum' is not yet set, it is used as temporary buffer) */
            switch (date_format) {
 756:	8b 44 24 54          	mov    0x54(%esp),%eax
                case DF_YMD:
                    methnum = mo;
                    mo = yr; yr = dy; dy = methnum;
 75a:	89 5c 24 54          	mov    %ebx,0x54(%esp)
 75e:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 762:	89 5c 24 48          	mov    %ebx,0x48(%esp)
 766:	89 44 24 44          	mov    %eax,0x44(%esp)
                case DF_DMY:
                    methnum = mo;
                    mo = dy; dy = methnum;
            }

            csiz = G.crec.csize;
 76a:	8b 9d 4c 09 01 00    	mov    0x1094c(%ebp),%ebx
            if (G.crec.general_purpose_bit_flag & 1)
 770:	8b b5 40 09 01 00    	mov    0x10940(%ebp),%esi
                csiz -= 12;   /* if encrypted, don't count encryption header */
 776:	89 f7                	mov    %esi,%edi
 778:	83 e7 01             	and    $0x1,%edi
 77b:	8d 43 f4             	lea    -0xc(%ebx),%eax
 77e:	0f 45 d8             	cmovne %eax,%ebx
            if ((cfactor = ratio(G.crec.ucsize, csiz)) < 0) {
 781:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 785:	8b 85 50 09 01 00    	mov    0x10950(%ebp),%eax
 78b:	89 04 24             	mov    %eax,(%esp)
 78e:	e8 ad fc ff ff       	call   440 <_ratio>
 793:	85 c0                	test   %eax,%eax
                cfactor = (-cfactor + 5) / 10;
            } else {
#ifndef WINDLL
                sgn = ' ';
#endif
                cfactor = (cfactor + 5) / 10;
 795:	8d 48 05             	lea    0x5(%eax),%ecx
            }

            csiz = G.crec.csize;
            if (G.crec.general_purpose_bit_flag & 1)
                csiz -= 12;   /* if encrypted, don't count encryption header */
            if ((cfactor = ratio(G.crec.ucsize, csiz)) < 0) {
 798:	0f 88 72 02 00 00    	js     a10 <_list_files+0x530>
                cfactor = (-cfactor + 5) / 10;
            } else {
#ifndef WINDLL
                sgn = ' ';
#endif
                cfactor = (cfactor + 5) / 10;
 79e:	89 c8                	mov    %ecx,%eax
 7a0:	ba 67 66 66 66       	mov    $0x66666667,%edx
 7a5:	f7 ea                	imul   %edx
 7a7:	c1 f9 1f             	sar    $0x1f,%ecx
            }

            methnum = MIN(G.crec.compression_method, NUM_METHODS);
 7aa:	66 8b 85 42 09 01 00 	mov    0x10942(%ebp),%ax
                cfactor = (-cfactor + 5) / 10;
            } else {
#ifndef WINDLL
                sgn = ' ';
#endif
                cfactor = (cfactor + 5) / 10;
 7b1:	c1 fa 02             	sar    $0x2,%edx
 7b4:	29 ca                	sub    %ecx,%edx
            }

            methnum = MIN(G.crec.compression_method, NUM_METHODS);
 7b6:	66 83 f8 0c          	cmp    $0xc,%ax
                cfactor = (-cfactor + 5) / 10;
            } else {
#ifndef WINDLL
                sgn = ' ';
#endif
                cfactor = (cfactor + 5) / 10;
 7ba:	89 54 24 68          	mov    %edx,0x68(%esp)
            }

            methnum = MIN(G.crec.compression_method, NUM_METHODS);
 7be:	0f 86 b2 01 00 00    	jbe    976 <_list_files+0x496>
 7c4:	89 44 24 6c          	mov    %eax,0x6c(%esp)
            zfstrcpy(methbuf, method[methnum]);
 7c8:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 7cf:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
 7d6:	00 
 7d7:	89 04 24             	mov    %eax,(%esp)
 7da:	e8 00 00 00 00       	call   7df <_list_files+0x2ff>
            if (methnum == DEFLATED || methnum == ENHDEFLATED) {
                methbuf[5] = dtype[(G.crec.general_purpose_bit_flag>>1) & 3];
            } else if (methnum >= NUM_METHODS) {
                sprintf(&methbuf[4], "%03u", G.crec.compression_method);
 7df:	8b 44 24 6c          	mov    0x6c(%esp),%eax
 7e3:	31 d2                	xor    %edx,%edx
 7e5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 7ec:	00 
 7ed:	66 89 c2             	mov    %ax,%dx
 7f0:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
 7f7:	89 54 24 08          	mov    %edx,0x8(%esp)
 7fb:	89 04 24             	mov    %eax,(%esp)
 7fe:	e8 00 00 00 00       	call   803 <_list_files+0x323>
 803:	8b bd 40 09 01 00    	mov    0x10940(%ebp),%edi
 809:	83 e7 01             	and    $0x1,%edi
 80c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#endif /* DOS_FLX_NLM_OS2_W32 || THEOS || UNIX */
#endif /* 0 */

#ifdef WINDLL
            /* send data to application for formatting and printing */
            (*G.lpUserFunctions->SendApplicationMessage)(G.crec.ucsize, csiz,
 810:	8b 85 58 0b 01 00    	mov    0x10b58(%ebp),%eax
 816:	8b b5 48 09 01 00    	mov    0x10948(%ebp),%esi
 81c:	66 83 ff 01          	cmp    $0x1,%di
 820:	19 ff                	sbb    %edi,%edi
 822:	8b 40 10             	mov    0x10(%eax),%eax
 825:	89 44 24 6c          	mov    %eax,0x6c(%esp)
              (unsigned)cfactor, mo, dy, yr, hh, mm,
              (char)(G.pInfo->lcflag ? '^' : ' '),
              (LPSTR)fnfilter(G.filename, slide), (LPSTR)methbuf, G.crec.crc32,
 829:	8d 85 dc 08 00 00    	lea    0x8dc(%ebp),%eax
 82f:	89 44 24 04          	mov    %eax,0x4(%esp)
 833:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
 839:	89 04 24             	mov    %eax,(%esp)
#endif /* DOS_FLX_NLM_OS2_W32 || THEOS || UNIX */
#endif /* 0 */

#ifdef WINDLL
            /* send data to application for formatting and printing */
            (*G.lpUserFunctions->SendApplicationMessage)(G.crec.ucsize, csiz,
 83c:	83 e7 db             	and    $0xffffffdb,%edi
              (unsigned)cfactor, mo, dy, yr, hh, mm,
              (char)(G.pInfo->lcflag ? '^' : ' '),
              (LPSTR)fnfilter(G.filename, slide), (LPSTR)methbuf, G.crec.crc32,
 83f:	e8 00 00 00 00       	call   844 <_list_files+0x364>

#ifdef WINDLL
            /* send data to application for formatting and printing */
            (*G.lpUserFunctions->SendApplicationMessage)(G.crec.ucsize, csiz,
              (unsigned)cfactor, mo, dy, yr, hh, mm,
              (char)(G.pInfo->lcflag ? '^' : ' '),
 844:	8b 95 d8 08 00 00    	mov    0x8d8(%ebp),%edx
 84a:	8a 52 18             	mov    0x18(%edx),%dl
#endif /* DOS_FLX_NLM_OS2_W32 || THEOS || UNIX */
#endif /* 0 */

#ifdef WINDLL
            /* send data to application for formatting and printing */
            (*G.lpUserFunctions->SendApplicationMessage)(G.crec.ucsize, csiz,
 84d:	83 c7 45             	add    $0x45,%edi
              (unsigned)cfactor, mo, dy, yr, hh, mm,
              (char)(G.pInfo->lcflag ? '^' : ' '),
 850:	83 e2 10             	and    $0x10,%edx
#endif /* DOS_FLX_NLM_OS2_W32 || THEOS || UNIX */
#endif /* 0 */

#ifdef WINDLL
            /* send data to application for formatting and printing */
            (*G.lpUserFunctions->SendApplicationMessage)(G.crec.ucsize, csiz,
 853:	8d 8c 24 8c 00 00 00 	lea    0x8c(%esp),%ecx
 85a:	80 fa 01             	cmp    $0x1,%dl
 85d:	89 7c 24 30          	mov    %edi,0x30(%esp)
 861:	19 d2                	sbb    %edx,%edx
 863:	89 4c 24 28          	mov    %ecx,0x28(%esp)
 867:	8b 7c 24 64          	mov    0x64(%esp),%edi
 86b:	8b 4c 24 60          	mov    0x60(%esp),%ecx
 86f:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
 873:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 877:	8b 7c 24 54          	mov    0x54(%esp),%edi
 87b:	8b 4c 24 48          	mov    0x48(%esp),%ecx
 87f:	83 e2 c2             	and    $0xffffffc2,%edx
 882:	89 7c 24 14          	mov    %edi,0x14(%esp)
 886:	83 c2 5e             	add    $0x5e,%edx
 889:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 88d:	8b 7c 24 44          	mov    0x44(%esp),%edi
 891:	8b 4c 24 68          	mov    0x68(%esp),%ecx
 895:	89 54 24 20          	mov    %edx,0x20(%esp)
 899:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 89d:	89 74 24 2c          	mov    %esi,0x2c(%esp)
 8a1:	89 44 24 24          	mov    %eax,0x24(%esp)
 8a5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 8a9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8ad:	8b 85 50 09 01 00    	mov    0x10950(%ebp),%eax
 8b3:	89 04 24             	mov    %eax,(%esp)
 8b6:	ff 54 24 6c          	call   *0x6c(%esp)
                  (G.pInfo->lcflag? '^':' ')));
#endif
            fnprint(__G);
#endif /* ?WINDLL */

            if ((error = do_string(__G__ G.crec.file_comment_length,
 8ba:	8b 45 38             	mov    0x38(%ebp),%eax
#endif /* DOS_FLX_NLM_OS2_W32 || THEOS || UNIX */
#endif /* 0 */

#ifdef WINDLL
            /* send data to application for formatting and printing */
            (*G.lpUserFunctions->SendApplicationMessage)(G.crec.ucsize, csiz,
 8bd:	83 ec 34             	sub    $0x34,%esp
                  (G.pInfo->lcflag? '^':' ')));
#endif
            fnprint(__G);
#endif /* ?WINDLL */

            if ((error = do_string(__G__ G.crec.file_comment_length,
 8c0:	85 c0                	test   %eax,%eax
 8c2:	b8 05 00 00 00       	mov    $0x5,%eax
 8c7:	0f 45 44 24 4c       	cmovne 0x4c(%esp),%eax
 8cc:	89 44 24 08          	mov    %eax,0x8(%esp)
 8d0:	31 c0                	xor    %eax,%eax
 8d2:	66 8b 85 58 09 01 00 	mov    0x10958(%ebp),%ax
 8d9:	89 2c 24             	mov    %ebp,(%esp)
 8dc:	89 44 24 04          	mov    %eax,0x4(%esp)
 8e0:	e8 00 00 00 00       	call   8e5 <_list_files+0x405>
 8e5:	85 c0                	test   %eax,%eax
 8e7:	74 0d                	je     8f6 <_list_files+0x416>
                                   QCOND? DISPL_8 : SKIP)) != 0)
            {
                error_in_archive = error;  /* might be just warning */
                if (error > PK_WARN)       /* fatal */
 8e9:	83 f8 01             	cmp    $0x1,%eax
 8ec:	0f 8f ce 01 00 00    	jg     ac0 <_list_files+0x5e0>
 8f2:	89 44 24 50          	mov    %eax,0x50(%esp)
                    return error;
            }
            tot_ucsize += G.crec.ucsize;
 8f6:	8b 74 24 78          	mov    0x78(%esp),%esi
            tot_csize += csiz;
 8fa:	8b 7c 24 74          	mov    0x74(%esp),%edi
            ++members;
 8fe:	8b 44 24 70          	mov    0x70(%esp),%eax
            {
                error_in_archive = error;  /* might be just warning */
                if (error > PK_WARN)       /* fatal */
                    return error;
            }
            tot_ucsize += G.crec.ucsize;
 902:	8b 8d 50 09 01 00    	mov    0x10950(%ebp),%ecx
 908:	01 ce                	add    %ecx,%esi
            tot_csize += csiz;
 90a:	01 df                	add    %ebx,%edi
            ++members;
 90c:	40                   	inc    %eax
            {
                error_in_archive = error;  /* might be just warning */
                if (error > PK_WARN)       /* fatal */
                    return error;
            }
            tot_ucsize += G.crec.ucsize;
 90d:	89 74 24 78          	mov    %esi,0x78(%esp)
            tot_csize += csiz;
 911:	89 7c 24 74          	mov    %edi,0x74(%esp)
            ++members;
 915:	89 44 24 70          	mov    %eax,0x70(%esp)
 919:	eb 31                	jmp    94c <_list_files+0x46c>
 91b:	90                   	nop
 91c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 920:	8b 45 74             	mov    0x74(%ebp),%eax
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 923:	c7 44 24 40 01 00 00 	movl   $0x1,0x40(%esp)
 92a:	00 
         * If current file was specified on command line, or if no names were
         * specified, do the listing for this file.  Otherwise, get rid of the
         * file comment and go back for the next file.
         */

        if (G.process_all_files || do_this_file) {
 92b:	0b 44 24 40          	or     0x40(%esp),%eax
 92f:	0f 85 71 fd ff ff    	jne    6a6 <_list_files+0x1c6>
#endif
#ifdef OS2DLL
            } /* end of "if (G.processExternally) {...} else {..." */
#endif
        } else {        /* not listing this file */
            SKIP_(G.crec.file_comment_length)
 935:	8b 9d 58 09 01 00    	mov    0x10958(%ebp),%ebx
 93b:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
 942:	00 
 943:	66 85 db             	test   %bx,%bx
 946:	0f 85 8a 00 00 00    	jne    9d6 <_list_files+0x4f6>
               LoadFarString(Headers[longhdr][0]),
               LoadFarStringSmall(Headers[longhdr][1])));
    }
#endif /* !WINDLL */

    for (j = 1L;;j++) {
 94c:	8b 5c 24 5c          	mov    0x5c(%esp),%ebx
 950:	43                   	inc    %ebx
 951:	89 5c 24 5c          	mov    %ebx,0x5c(%esp)
            } /* end of "if (G.processExternally) {...} else {..." */
#endif
        } else {        /* not listing this file */
            SKIP_(G.crec.file_comment_length)
        }
    } /* end for-loop (j: files in central directory) */
 955:	e9 ec fb ff ff       	jmp    546 <_list_files+0x66>
 95a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 960:	8b 45 70             	mov    0x70(%ebp),%eax
 963:	85 c0                	test   %eax,%eax
 965:	0f 84 e6 01 00 00    	je     b51 <_list_files+0x671>
 96b:	8d 9d e0 09 01 00    	lea    0x109e0(%ebp),%ebx
 971:	e9 ed fc ff ff       	jmp    663 <_list_files+0x183>
                sgn = ' ';
#endif
                cfactor = (cfactor + 5) / 10;
            }

            methnum = MIN(G.crec.compression_method, NUM_METHODS);
 976:	31 d2                	xor    %edx,%edx
 978:	66 89 c2             	mov    %ax,%dx
            zfstrcpy(methbuf, method[methnum]);
 97b:	89 54 24 6c          	mov    %edx,0x6c(%esp)
 97f:	8d 04 d5 20 00 00 00 	lea    0x20(,%edx,8),%eax
 986:	89 44 24 04          	mov    %eax,0x4(%esp)
 98a:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 991:	89 04 24             	mov    %eax,(%esp)
 994:	e8 00 00 00 00       	call   999 <_list_files+0x4b9>
            if (methnum == DEFLATED || methnum == ENHDEFLATED) {
 999:	8b 54 24 6c          	mov    0x6c(%esp),%edx
 99d:	83 ea 08             	sub    $0x8,%edx
 9a0:	83 fa 01             	cmp    $0x1,%edx
 9a3:	0f 87 67 fe ff ff    	ja     810 <_list_files+0x330>
                methbuf[5] = dtype[(G.crec.general_purpose_bit_flag>>1) & 3];
 9a9:	66 d1 ee             	shr    %si
 9ac:	83 e6 03             	and    $0x3,%esi
 9af:	8a 86 08 00 00 00    	mov    0x8(%esi),%al
 9b5:	88 84 24 91 00 00 00 	mov    %al,0x91(%esp)
 9bc:	e9 4f fe ff ff       	jmp    810 <_list_files+0x330>
 9c1:	8b 44 24 44          	mov    0x44(%esp),%eax
                    methnum = mo;
                    mo = yr; yr = dy; dy = methnum;
                    break;
                case DF_DMY:
                    methnum = mo;
                    mo = dy; dy = methnum;
 9c5:	8b 5c 24 48          	mov    0x48(%esp),%ebx
 9c9:	89 5c 24 44          	mov    %ebx,0x44(%esp)
 9cd:	89 44 24 48          	mov    %eax,0x48(%esp)
 9d1:	e9 94 fd ff ff       	jmp    76a <_list_files+0x28a>
#endif
#ifdef OS2DLL
            } /* end of "if (G.processExternally) {...} else {..." */
#endif
        } else {        /* not listing this file */
            SKIP_(G.crec.file_comment_length)
 9d6:	31 c0                	xor    %eax,%eax
 9d8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 9df:	00 
 9e0:	66 89 d8             	mov    %bx,%ax
 9e3:	89 2c 24             	mov    %ebp,(%esp)
 9e6:	89 44 24 04          	mov    %eax,0x4(%esp)
 9ea:	e8 00 00 00 00       	call   9ef <_list_files+0x50f>
 9ef:	85 c0                	test   %eax,%eax
 9f1:	0f 84 55 ff ff ff    	je     94c <_list_files+0x46c>
 9f7:	83 f8 01             	cmp    $0x1,%eax
 9fa:	0f 8f c0 00 00 00    	jg     ac0 <_list_files+0x5e0>
 a00:	89 44 24 50          	mov    %eax,0x50(%esp)
 a04:	e9 43 ff ff ff       	jmp    94c <_list_files+0x46c>
 a09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                csiz -= 12;   /* if encrypted, don't count encryption header */
            if ((cfactor = ratio(G.crec.ucsize, csiz)) < 0) {
#ifndef WINDLL
                sgn = '-';
#endif
                cfactor = (-cfactor + 5) / 10;
 a10:	b9 05 00 00 00       	mov    $0x5,%ecx
 a15:	29 c1                	sub    %eax,%ecx
 a17:	e9 82 fd ff ff       	jmp    79e <_list_files+0x2be>
 a1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
                                  G.crec.last_mod_dos_datetime, &z_utime, NULL)
                 & EB_UT_FL_MTIME))
            {
                TIMET_TO_NATIVE(z_utime.mtime)   /* NOP unless MSC 7.0, Mac */
                t = localtime(&(z_utime.mtime));
 a20:	8d 84 24 98 00 00 00 	lea    0x98(%esp),%eax
 a27:	89 04 24             	mov    %eax,(%esp)
 a2a:	e8 00 00 00 00       	call   a2f <_list_files+0x54f>
 a2f:	89 c1                	mov    %eax,%ecx
            } else
                t = (struct tm *)NULL;
            if (t != (struct tm *)NULL) {
 a31:	85 c0                	test   %eax,%eax
 a33:	0f 84 b9 fc ff ff    	je     6f2 <_list_files+0x212>
                mo = (unsigned)(t->tm_mon + 1);
 a39:	8b 40 10             	mov    0x10(%eax),%eax
                dy = (unsigned)(t->tm_mday);
                yr = (unsigned)(t->tm_year % 100);
 a3c:	bf 64 00 00 00       	mov    $0x64,%edi
                TIMET_TO_NATIVE(z_utime.mtime)   /* NOP unless MSC 7.0, Mac */
                t = localtime(&(z_utime.mtime));
            } else
                t = (struct tm *)NULL;
            if (t != (struct tm *)NULL) {
                mo = (unsigned)(t->tm_mon + 1);
 a41:	40                   	inc    %eax
 a42:	89 44 24 44          	mov    %eax,0x44(%esp)
                dy = (unsigned)(t->tm_mday);
 a46:	8b 41 0c             	mov    0xc(%ecx),%eax
 a49:	89 44 24 48          	mov    %eax,0x48(%esp)
                yr = (unsigned)(t->tm_year % 100);
 a4d:	8b 41 14             	mov    0x14(%ecx),%eax
 a50:	89 c2                	mov    %eax,%edx
 a52:	c1 fa 1f             	sar    $0x1f,%edx
 a55:	f7 ff                	idiv   %edi
                hh = (unsigned)(t->tm_hour);
 a57:	8b 41 08             	mov    0x8(%ecx),%eax
            } else
                t = (struct tm *)NULL;
            if (t != (struct tm *)NULL) {
                mo = (unsigned)(t->tm_mon + 1);
                dy = (unsigned)(t->tm_mday);
                yr = (unsigned)(t->tm_year % 100);
 a5a:	89 54 24 54          	mov    %edx,0x54(%esp)
                hh = (unsigned)(t->tm_hour);
 a5e:	89 44 24 60          	mov    %eax,0x60(%esp)
                mm = (unsigned)(t->tm_min);
 a62:	8b 41 04             	mov    0x4(%ecx),%eax
 a65:	89 44 24 64          	mov    %eax,0x64(%esp)
 a69:	e9 d2 fc ff ff       	jmp    740 <_list_files+0x260>
    for (j = 1L;;j++) {

        if (readbuf(__G__ G.sig, 4) == 0)
            return PK_EOF;
        if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a CentDir entry? */
            if (((unsigned)(j - 1) & (unsigned)0xFFFF) ==
 a6e:	8b 7c 24 5c          	mov    0x5c(%esp),%edi
 a72:	89 f8                	mov    %edi,%eax
 a74:	48                   	dec    %eax
 a75:	66 39 85 6e 09 01 00 	cmp    %ax,0x1096e(%ebp)
 a7c:	75 5d                	jne    adb <_list_files+0x5fb>
/*---------------------------------------------------------------------------
    Print footer line and totals (compressed size, uncompressed size, number
    of members in zipfile).
  ---------------------------------------------------------------------------*/

    if (uO.qflag < 2
 a7e:	83 7d 38 01          	cmpl   $0x1,0x38(%ebp)
 a82:	0f 8e 17 01 00 00    	jle    b9f <_list_files+0x6bf>

/*---------------------------------------------------------------------------
    Double check that we're back at the end-of-central-directory record.
  ---------------------------------------------------------------------------*/

    if (strncmp(G.sig, end_central_sig, 4)) {   /* just to make sure again */
 a88:	8b 44 24 58          	mov    0x58(%esp),%eax
 a8c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 a93:	00 
 a94:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 a9b:	00 
 a9c:	89 04 24             	mov    %eax,(%esp)
 a9f:	e8 00 00 00 00       	call   aa4 <_list_files+0x5c4>
 aa4:	85 c0                	test   %eax,%eax
 aa6:	0f 85 b2 00 00 00    	jne    b5e <_list_files+0x67e>
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
        error_in_archive = PK_WARN;   /* didn't find sig */
    }
    if (members == 0L && error_in_archive <= PK_WARN)
        error_in_archive = PK_FIND;
 aac:	8b 4c 24 70          	mov    0x70(%esp),%ecx
 ab0:	b8 0b 00 00 00       	mov    $0xb,%eax
 ab5:	85 c9                	test   %ecx,%ecx
 ab7:	0f 45 44 24 50       	cmovne 0x50(%esp),%eax
 abc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    return error_in_archive;

} /* end function list_files() */
 ac0:	81 c4 cc 00 00 00    	add    $0xcc,%esp
 ac6:	5b                   	pop    %ebx
 ac7:	5e                   	pop    %esi
 ac8:	5f                   	pop    %edi
 ac9:	5d                   	pop    %ebp
 aca:	c3                   	ret    
 acb:	81 c4 cc 00 00 00    	add    $0xcc,%esp
#endif /* !WINDLL */

    for (j = 1L;;j++) {

        if (readbuf(__G__ G.sig, 4) == 0)
            return PK_EOF;
 ad1:	b8 33 00 00 00       	mov    $0x33,%eax
    if (members == 0L && error_in_archive <= PK_WARN)
        error_in_archive = PK_FIND;

    return error_in_archive;

} /* end function list_files() */
 ad6:	5b                   	pop    %ebx
 ad7:	5e                   	pop    %esi
 ad8:	5f                   	pop    %edi
 ad9:	5d                   	pop    %ebp
 ada:	c3                   	ret    
                 * number of directory entries -> probably, the regular
                 * end of the central directory has been reached
                 */
                break;
            } else {
                Info(slide, 0x401,
 adb:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
 ae1:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
 ae7:	89 7c 24 08          	mov    %edi,0x8(%esp)
 aeb:	89 1c 24             	mov    %ebx,(%esp)
 aee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 af5:	00 
 af6:	e8 00 00 00 00       	call   afb <_list_files+0x61b>
 afb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 aff:	89 2c 24             	mov    %ebp,(%esp)
 b02:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
 b09:	00 
 b0a:	89 44 24 08          	mov    %eax,0x8(%esp)
 b0e:	ff d6                	call   *%esi
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
 b10:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
                 * number of directory entries -> probably, the regular
                 * end of the central directory has been reached
                 */
                break;
            } else {
                Info(slide, 0x401,
 b16:	83 ec 10             	sub    $0x10,%esp
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
 b19:	89 1c 24             	mov    %ebx,(%esp)
 b1c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 b23:	00 
 b24:	e8 00 00 00 00       	call   b29 <_list_files+0x649>
 b29:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 b2d:	89 2c 24             	mov    %ebp,(%esp)
 b30:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
 b37:	00 
 b38:	89 44 24 08          	mov    %eax,0x8(%esp)
 b3c:	ff d6                	call   *%esi
                     ((char *)slide, LoadFarString(ReportMsg)));
                return PK_BADERR;   /* sig not found */
 b3e:	b8 03 00 00 00       	mov    $0x3,%eax
                 */
                break;
            } else {
                Info(slide, 0x401,
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
 b43:	83 ec 10             	sub    $0x10,%esp
    if (members == 0L && error_in_archive <= PK_WARN)
        error_in_archive = PK_FIND;

    return error_in_archive;

} /* end function list_files() */
 b46:	81 c4 cc 00 00 00    	add    $0xcc,%esp
 b4c:	5b                   	pop    %ebx
 b4d:	5e                   	pop    %esi
 b4e:	5f                   	pop    %edi
 b4f:	5d                   	pop    %ebp
 b50:	c3                   	ret    
                        do_this_file = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
 b51:	c7 44 24 40 01 00 00 	movl   $0x1,0x40(%esp)
 b58:	00 
 b59:	e9 48 fb ff ff       	jmp    6a6 <_list_files+0x1c6>
/*---------------------------------------------------------------------------
    Double check that we're back at the end-of-central-directory record.
  ---------------------------------------------------------------------------*/

    if (strncmp(G.sig, end_central_sig, 4)) {   /* just to make sure again */
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
 b5e:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
 b64:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
 b6a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 b71:	00 
 b72:	89 1c 24             	mov    %ebx,(%esp)
 b75:	e8 00 00 00 00       	call   b7a <_list_files+0x69a>
 b7a:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
 b81:	00 
 b82:	89 44 24 08          	mov    %eax,0x8(%esp)
 b86:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 b8a:	89 2c 24             	mov    %ebp,(%esp)
 b8d:	ff d6                	call   *%esi
 b8f:	83 ec 10             	sub    $0x10,%esp
        error_in_archive = PK_WARN;   /* didn't find sig */
 b92:	c7 44 24 50 01 00 00 	movl   $0x1,0x50(%esp)
 b99:	00 
 b9a:	e9 0d ff ff ff       	jmp    aac <_list_files+0x5cc>
    if (uO.qflag < 2
#ifdef OS2DLL
                     && !G.processExternally
#endif
                                            ) {
        if ((cfactor = ratio(tot_ucsize, tot_csize)) < 0) {
 b9f:	8b 44 24 74          	mov    0x74(%esp),%eax
 ba3:	89 44 24 04          	mov    %eax,0x4(%esp)
 ba7:	8b 44 24 78          	mov    0x78(%esp),%eax
 bab:	89 04 24             	mov    %eax,(%esp)
 bae:	e8 8d f8 ff ff       	call   440 <_ratio>
 bb3:	85 c0                	test   %eax,%eax
            cfactor = (-cfactor + 5) / 10;
        } else {
#ifndef WINDLL
            sgn = ' ';
#endif
            cfactor = (cfactor + 5) / 10;
 bb5:	8d 48 05             	lea    0x5(%eax),%ecx
    if (uO.qflag < 2
#ifdef OS2DLL
                     && !G.processExternally
#endif
                                            ) {
        if ((cfactor = ratio(tot_ucsize, tot_csize)) < 0) {
 bb8:	79 07                	jns    bc1 <_list_files+0x6e1>
#ifndef WINDLL
            sgn = '-';
#endif
            cfactor = (-cfactor + 5) / 10;
 bba:	b9 05 00 00 00       	mov    $0x5,%ecx
 bbf:	29 c1                	sub    %eax,%ecx
        } else {
#ifndef WINDLL
            sgn = ' ';
#endif
            cfactor = (cfactor + 5) / 10;
 bc1:	89 c8                	mov    %ecx,%eax
 bc3:	ba 67 66 66 66       	mov    $0x66666667,%edx
 bc8:	f7 ea                	imul   %edx
 bca:	89 d0                	mov    %edx,%eax
        }
#ifdef WINDLL
        /* pass the totals back to the calling application */
        G.lpUserFunctions->TotalSizeComp = tot_csize;
 bcc:	8b 95 58 0b 01 00    	mov    0x10b58(%ebp),%edx
            cfactor = (-cfactor + 5) / 10;
        } else {
#ifndef WINDLL
            sgn = ' ';
#endif
            cfactor = (cfactor + 5) / 10;
 bd2:	c1 f8 02             	sar    $0x2,%eax
        }
#ifdef WINDLL
        /* pass the totals back to the calling application */
        G.lpUserFunctions->TotalSizeComp = tot_csize;
 bd5:	8b 5c 24 74          	mov    0x74(%esp),%ebx
            cfactor = (-cfactor + 5) / 10;
        } else {
#ifndef WINDLL
            sgn = ' ';
#endif
            cfactor = (cfactor + 5) / 10;
 bd9:	c1 f9 1f             	sar    $0x1f,%ecx
        }
#ifdef WINDLL
        /* pass the totals back to the calling application */
        G.lpUserFunctions->TotalSizeComp = tot_csize;
 bdc:	89 5a 18             	mov    %ebx,0x18(%edx)
            cfactor = (-cfactor + 5) / 10;
        } else {
#ifndef WINDLL
            sgn = ' ';
#endif
            cfactor = (cfactor + 5) / 10;
 bdf:	29 c8                	sub    %ecx,%eax
        }
#ifdef WINDLL
        /* pass the totals back to the calling application */
        G.lpUserFunctions->TotalSizeComp = tot_csize;
        G.lpUserFunctions->TotalSize = tot_ucsize;
 be1:	8b 5c 24 78          	mov    0x78(%esp),%ebx
        G.lpUserFunctions->CompFactor = (ulg)cfactor;
 be5:	89 42 20             	mov    %eax,0x20(%edx)
        G.lpUserFunctions->NumMembers = members;
 be8:	8b 44 24 70          	mov    0x70(%esp),%eax
            cfactor = (cfactor + 5) / 10;
        }
#ifdef WINDLL
        /* pass the totals back to the calling application */
        G.lpUserFunctions->TotalSizeComp = tot_csize;
        G.lpUserFunctions->TotalSize = tot_ucsize;
 bec:	89 5a 1c             	mov    %ebx,0x1c(%edx)
        G.lpUserFunctions->CompFactor = (ulg)cfactor;
        G.lpUserFunctions->NumMembers = members;
 bef:	89 42 24             	mov    %eax,0x24(%edx)
 bf2:	e9 91 fe ff ff       	jmp    a88 <_list_files+0x5a8>
 bf7:	89 f6                	mov    %esi,%esi
 bf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000c00 <_fnprint>:
/*  Function fnprint()  */    /* also used by ZipInfo routines */
/************************/

void fnprint(__G)    /* print filename (after filtering) and newline */
    __GDEF
{
 c00:	56                   	push   %esi
 c01:	53                   	push   %ebx
 c02:	83 ec 14             	sub    $0x14,%esp
 c05:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    char *name = fnfilter(G.filename, slide);
 c09:	8d 83 dc 08 00 00    	lea    0x8dc(%ebx),%eax
 c0f:	89 44 24 04          	mov    %eax,0x4(%esp)
 c13:	8d 83 e0 09 01 00    	lea    0x109e0(%ebx),%eax
 c19:	89 04 24             	mov    %eax,(%esp)
 c1c:	e8 00 00 00 00       	call   c21 <_fnprint+0x21>

    (*G.message)((zvoid *)&G, (uch *)name, (ulg)strlen(name), 0);
 c21:	89 04 24             	mov    %eax,(%esp)
/************************/

void fnprint(__G)    /* print filename (after filtering) and newline */
    __GDEF
{
    char *name = fnfilter(G.filename, slide);
 c24:	89 c6                	mov    %eax,%esi

    (*G.message)((zvoid *)&G, (uch *)name, (ulg)strlen(name), 0);
 c26:	e8 00 00 00 00       	call   c2b <_fnprint+0x2b>
 c2b:	89 74 24 04          	mov    %esi,0x4(%esp)
 c2f:	89 1c 24             	mov    %ebx,(%esp)
 c32:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 c39:	00 
 c3a:	89 44 24 08          	mov    %eax,0x8(%esp)
 c3e:	ff 93 44 0b 01 00    	call   *0x10b44(%ebx)
 c44:	83 ec 10             	sub    $0x10,%esp
    (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);
 c47:	89 1c 24             	mov    %ebx,(%esp)
 c4a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 c51:	00 
 c52:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 c59:	00 
 c5a:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
 c61:	00 
 c62:	ff 93 44 0b 01 00    	call   *0x10b44(%ebx)
 c68:	83 ec 10             	sub    $0x10,%esp

} /* end function fnprint() */
 c6b:	83 c4 14             	add    $0x14,%esp
 c6e:	5b                   	pop    %ebx
 c6f:	5e                   	pop    %esi
 c70:	c3                   	ret    
 c71:	90                   	nop
 c72:	90                   	nop
 c73:	90                   	nop
 c74:	90                   	nop
 c75:	90                   	nop
 c76:	90                   	nop
 c77:	90                   	nop
 c78:	90                   	nop
 c79:	90                   	nop
 c7a:	90                   	nop
 c7b:	90                   	nop
 c7c:	90                   	nop
 c7d:	90                   	nop
 c7e:	90                   	nop
 c7f:	90                   	nop

match.o:     file format pe-i386


Disassembly of section .text:

00000000 <_recmatch>:
    __WDLDEF              /* directory sepchar for WildStopAtDir mode, or 0 */
/* Recursively compare the sh pattern p with the string s and return 1 if
 * they match, and 0 or 2 if they don't or if there is a syntax error in the
 * pattern.  This routine recurses on itself no more deeply than the number
 * of characters in the pattern. */
{
   0:	55                   	push   %ebp
   1:	57                   	push   %edi
   2:	56                   	push   %esi
   3:	53                   	push   %ebx
   4:	83 ec 2c             	sub    $0x2c,%esp
   7:	89 c6                	mov    %eax,%esi
   9:	89 cd                	mov    %ecx,%ebp
   b:	8b 3d 00 00 00 00    	mov    0x0,%edi
  11:	89 54 24 14          	mov    %edx,0x14(%esp)
    unsigned int c;       /* pattern char or start of range in [-] loop */

    /* Get first character, the pattern for new recmatch calls follows */
    c = *p; INCSTR(p);
  15:	8b 07                	mov    (%edi),%eax
  17:	31 db                	xor    %ebx,%ebx
  19:	8a 1e                	mov    (%esi),%bl
  1b:	89 34 24             	mov    %esi,(%esp)
  1e:	89 44 24 04          	mov    %eax,0x4(%esp)
  22:	e8 00 00 00 00       	call   27 <_recmatch+0x27>
  27:	01 c6                	add    %eax,%esi

    /* If that was the end of the pattern, match if string empty too */
    if (c == 0)
  29:	85 db                	test   %ebx,%ebx
  2b:	0f 84 0d 03 00 00    	je     33e <_recmatch+0x33e>
        return *s == 0;

    /* '?' (or '%') matches any character (but not an empty string). */
    if (c == WILDCHAR)
  31:	83 fb 3f             	cmp    $0x3f,%ebx
  34:	0f 84 96 00 00 00    	je     d0 <_recmatch+0xd0>
    /* '*' matches any number of characters, including zero */
#ifdef AMIGA
    if (c == '#' && *p == '?')     /* "#?" is Amiga-ese for "*" */
        c = '*', p++;
#endif /* AMIGA */
    if (c == '*') {
  3a:	83 fb 2a             	cmp    $0x2a,%ebx
  3d:	0f 84 12 03 00 00    	je     355 <_recmatch+0x355>
                return (int)c;
        return 2;       /* 2 means give up--match will return false */
    }

    /* Parse and process the list of characters and ranges in brackets */
    if (c == BEG_RANGE) {
  43:	83 fb 5b             	cmp    $0x5b,%ebx
  46:	0f 84 c4 00 00 00    	je     110 <_recmatch+0x110>
        return r ? recmatch(q + CLEN(q), s + CLEN(s), ic __WDL) : 0;
                                        /* bracket match failed */
    }

    /* if escape ('\\'), just compare next character */
    if (c == '\\' && (c = *p++) == 0)     /* if \ at end, then syntax error */
  4c:	83 fb 5c             	cmp    $0x5c,%ebx
  4f:	0f 84 1b 01 00 00    	je     170 <_recmatch+0x170>
    /* just a character--compare it */
#ifdef QDOS
    return QMatch(Case((uch)c), Case(*s)) ?
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
#else
    return Case((uch)c) == Case(*s) ?
  55:	85 ed                	test   %ebp,%ebp
  57:	0f 84 97 00 00 00    	je     f4 <_recmatch+0xf4>
  5d:	88 da                	mov    %bl,%dl
  5f:	81 fb bf 00 00 00    	cmp    $0xbf,%ebx
  65:	0f 86 25 01 00 00    	jbe    190 <_recmatch+0x190>
  6b:	80 fb d7             	cmp    $0xd7,%bl
  6e:	0f 95 c1             	setne  %cl
  71:	80 fb de             	cmp    $0xde,%bl
  74:	0f 96 c0             	setbe  %al
  77:	21 c8                	and    %ecx,%eax
  79:	84 c0                	test   %al,%al
  7b:	74 07                	je     84 <_recmatch+0x84>
  7d:	83 ca 20             	or     $0x20,%edx
  80:	31 db                	xor    %ebx,%ebx
  82:	88 d3                	mov    %dl,%bl
  84:	8b 44 24 14          	mov    0x14(%esp),%eax
  88:	8a 00                	mov    (%eax),%al
  8a:	3c bf                	cmp    $0xbf,%al
  8c:	0f 86 f0 00 00 00    	jbe    182 <_recmatch+0x182>
  92:	3c d7                	cmp    $0xd7,%al
  94:	0f 95 c1             	setne  %cl
  97:	3c de                	cmp    $0xde,%al
  99:	0f 96 c2             	setbe  %dl
  9c:	21 d1                	and    %edx,%ecx
  9e:	31 d2                	xor    %edx,%edx
  a0:	84 c9                	test   %cl,%cl
  a2:	88 c2                	mov    %al,%dl
  a4:	74 07                	je     ad <_recmatch+0xad>
  a6:	83 c8 20             	or     $0x20,%eax
  a9:	31 d2                	xor    %edx,%edx
  ab:	88 c2                	mov    %al,%dl
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
  ad:	39 d3                	cmp    %edx,%ebx
  af:	75 4f                	jne    100 <_recmatch+0x100>
  b1:	8b 07                	mov    (%edi),%eax
  b3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  bb:	89 1c 24             	mov    %ebx,(%esp)
  be:	e8 00 00 00 00       	call   c3 <_recmatch+0xc3>
  c3:	89 d9                	mov    %ebx,%ecx
  c5:	01 c1                	add    %eax,%ecx
  c7:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  cb:	e9 45 ff ff ff       	jmp    15 <_recmatch+0x15>
#ifdef WILD_STOP_AT_DIR
        /* If uO.W_flag is non-zero, it won't match '/' */
        return (*s && (!sepc || *s != (uch)sepc))
               ? recmatch(p, s + CLEN(s), ic, sepc) : 0;
#else
        return *s ? recmatch(p, s + CLEN(s), ic) : 0;
  d0:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  d4:	80 3b 00             	cmpb   $0x0,(%ebx)
  d7:	74 27                	je     100 <_recmatch+0x100>
  d9:	8b 07                	mov    (%edi),%eax
  db:	89 1c 24             	mov    %ebx,(%esp)
  de:	89 44 24 04          	mov    %eax,0x4(%esp)
  e2:	e8 00 00 00 00       	call   e7 <_recmatch+0xe7>
  e7:	89 da                	mov    %ebx,%edx
  e9:	01 c2                	add    %eax,%edx
  eb:	89 54 24 14          	mov    %edx,0x14(%esp)
  ef:	e9 21 ff ff ff       	jmp    15 <_recmatch+0x15>
    /* just a character--compare it */
#ifdef QDOS
    return QMatch(Case((uch)c), Case(*s)) ?
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
#else
    return Case((uch)c) == Case(*s) ?
  f4:	8b 44 24 14          	mov    0x14(%esp),%eax
  f8:	31 d2                	xor    %edx,%edx
  fa:	8a 10                	mov    (%eax),%dl
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
  fc:	39 d3                	cmp    %edx,%ebx
  fe:	74 b1                	je     b1 <_recmatch+0xb1>
#ifdef WILD_STOP_AT_DIR
        /* If uO.W_flag is non-zero, it won't match '/' */
        return (*s && (!sepc || *s != (uch)sepc))
               ? recmatch(p, s + CLEN(s), ic, sepc) : 0;
#else
        return *s ? recmatch(p, s + CLEN(s), ic) : 0;
 100:	31 c0                	xor    %eax,%eax
#else
    return Case((uch)c) == Case(*s) ?
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
#endif

} /* end function recmatch() */
 102:	83 c4 2c             	add    $0x2c,%esp
 105:	5b                   	pop    %ebx
 106:	5e                   	pop    %esi
 107:	5f                   	pop    %edi
 108:	5d                   	pop    %ebp
 109:	c3                   	ret    
 10a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    if (c == BEG_RANGE) {
        int e;          /* flag true if next char to be taken literally */
        ZCONST uch *q;  /* pointer to end of [-] group */
        int r;          /* flag true to match anything but the range */

        if (*s == 0)                            /* need a character to match */
 110:	8b 44 24 14          	mov    0x14(%esp),%eax
 114:	80 38 00             	cmpb   $0x0,(%eax)
 117:	74 e7                	je     100 <_recmatch+0x100>
            return 0;
        p += (r = (*p == '!' || *p == '^'));    /* see if reverse */
 119:	80 3e 5e             	cmpb   $0x5e,(%esi)
 11c:	0f 94 c2             	sete   %dl
 11f:	80 3e 21             	cmpb   $0x21,(%esi)
 122:	0f 94 c0             	sete   %al
 125:	09 c2                	or     %eax,%edx
 127:	31 c0                	xor    %eax,%eax
 129:	88 d0                	mov    %dl,%al
 12b:	88 54 24 1f          	mov    %dl,0x1f(%esp)
 12f:	01 f0                	add    %esi,%eax
 131:	89 c6                	mov    %eax,%esi
 133:	89 44 24 10          	mov    %eax,0x10(%esp)
        for (q = p, e = 0; *q; INCSTR(q))       /* find closing bracket */
 137:	8a 00                	mov    (%eax),%al
 139:	84 c0                	test   %al,%al
 13b:	74 c3                	je     100 <_recmatch+0x100>
 13d:	30 db                	xor    %bl,%bl
 13f:	eb 1e                	jmp    15f <_recmatch+0x15f>
            if (e)
                e = 0;
            else
                if (*q == '\\')      /* GRR:  change to ^ for MS-DOS, OS/2? */
 141:	3c 5c                	cmp    $0x5c,%al
 143:	74 22                	je     167 <_recmatch+0x167>
                    e = 1;
                else if (*q == END_RANGE)
 145:	3c 5d                	cmp    $0x5d,%al
 147:	74 57                	je     1a0 <_recmatch+0x1a0>
        int r;          /* flag true to match anything but the range */

        if (*s == 0)                            /* need a character to match */
            return 0;
        p += (r = (*p == '!' || *p == '^'));    /* see if reverse */
        for (q = p, e = 0; *q; INCSTR(q))       /* find closing bracket */
 149:	8b 07                	mov    (%edi),%eax
 14b:	89 34 24             	mov    %esi,(%esp)
 14e:	89 44 24 04          	mov    %eax,0x4(%esp)
 152:	e8 00 00 00 00       	call   157 <_recmatch+0x157>
 157:	01 c6                	add    %eax,%esi
 159:	8a 06                	mov    (%esi),%al
 15b:	84 c0                	test   %al,%al
 15d:	74 a1                	je     100 <_recmatch+0x100>
            if (e)
 15f:	85 db                	test   %ebx,%ebx
 161:	74 de                	je     141 <_recmatch+0x141>
                e = 0;
 163:	31 db                	xor    %ebx,%ebx
 165:	eb e2                	jmp    149 <_recmatch+0x149>
            else
                if (*q == '\\')      /* GRR:  change to ^ for MS-DOS, OS/2? */
                    e = 1;
 167:	bb 01 00 00 00       	mov    $0x1,%ebx
 16c:	eb db                	jmp    149 <_recmatch+0x149>
 16e:	66 90                	xchg   %ax,%ax
        return r ? recmatch(q + CLEN(q), s + CLEN(s), ic __WDL) : 0;
                                        /* bracket match failed */
    }

    /* if escape ('\\'), just compare next character */
    if (c == '\\' && (c = *p++) == 0)     /* if \ at end, then syntax error */
 170:	31 db                	xor    %ebx,%ebx
 172:	8d 46 01             	lea    0x1(%esi),%eax
 175:	8a 1e                	mov    (%esi),%bl
 177:	85 db                	test   %ebx,%ebx
 179:	74 85                	je     100 <_recmatch+0x100>
 17b:	89 c6                	mov    %eax,%esi
 17d:	e9 d3 fe ff ff       	jmp    55 <_recmatch+0x55>
    /* just a character--compare it */
#ifdef QDOS
    return QMatch(Case((uch)c), Case(*s)) ?
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
#else
    return Case((uch)c) == Case(*s) ?
 182:	8d 50 bf             	lea    -0x41(%eax),%edx
 185:	80 fa 19             	cmp    $0x19,%dl
 188:	0f 96 c1             	setbe  %cl
 18b:	e9 0e ff ff ff       	jmp    9e <_recmatch+0x9e>
 190:	8d 43 bf             	lea    -0x41(%ebx),%eax
 193:	3c 19                	cmp    $0x19,%al
 195:	0f 96 c0             	setbe  %al
 198:	e9 dc fe ff ff       	jmp    79 <_recmatch+0x79>
 19d:	8d 76 00             	lea    0x0(%esi),%esi
                    e = 1;
                else if (*q == END_RANGE)
                    break;
        if (*q != END_RANGE)         /* nothing matches if bad syntax */
            return 0;
        for (c = 0, e = (*p == '-'); p < q; INCSTR(p)) {
 1a0:	8b 44 24 10          	mov    0x10(%esp),%eax
 1a4:	31 d2                	xor    %edx,%edx
 1a6:	80 38 2d             	cmpb   $0x2d,(%eax)
 1a9:	0f 94 c2             	sete   %dl
 1ac:	31 db                	xor    %ebx,%ebx
 1ae:	39 c6                	cmp    %eax,%esi
 1b0:	0f 86 ed 00 00 00    	jbe    2a3 <_recmatch+0x2a3>
 1b6:	89 74 24 18          	mov    %esi,0x18(%esp)
 1ba:	89 d6                	mov    %edx,%esi
 1bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            /* go through the list */
            if (!e && *p == '\\')               /* set escape flag if \ */
 1c0:	85 f6                	test   %esi,%esi
 1c2:	75 16                	jne    1da <_recmatch+0x1da>
 1c4:	8b 44 24 10          	mov    0x10(%esp),%eax
 1c8:	8a 00                	mov    (%eax),%al
 1ca:	3c 5c                	cmp    $0x5c,%al
 1cc:	0f 84 4e 01 00 00    	je     320 <_recmatch+0x320>
                e = 1;
            else if (!e && *p == '-')           /* set start of range if - */
 1d2:	3c 2d                	cmp    $0x2d,%al
 1d4:	0f 84 56 01 00 00    	je     330 <_recmatch+0x330>
                c = *(p-1);
            else {
                unsigned int cc = Case(*s);
 1da:	8b 44 24 14          	mov    0x14(%esp),%eax
 1de:	85 ed                	test   %ebp,%ebp
 1e0:	0f 84 fa 00 00 00    	je     2e0 <_recmatch+0x2e0>
 1e6:	8a 00                	mov    (%eax),%al
 1e8:	3c bf                	cmp    $0xbf,%al
 1ea:	0f 86 20 01 00 00    	jbe    310 <_recmatch+0x310>
 1f0:	3c d7                	cmp    $0xd7,%al
 1f2:	0f 95 c1             	setne  %cl
 1f5:	3c de                	cmp    $0xde,%al
 1f7:	0f 96 c2             	setbe  %dl
 1fa:	21 ca                	and    %ecx,%edx
 1fc:	31 c9                	xor    %ecx,%ecx
 1fe:	84 d2                	test   %dl,%dl
 200:	88 c1                	mov    %al,%cl
 202:	74 07                	je     20b <_recmatch+0x20b>
 204:	83 c8 20             	or     $0x20,%eax
 207:	31 c9                	xor    %ecx,%ecx
 209:	88 c1                	mov    %al,%cl

                if (*(p+1) != '-')
 20b:	8b 44 24 10          	mov    0x10(%esp),%eax
 20f:	80 78 01 2d          	cmpb   $0x2d,0x1(%eax)
 213:	74 5c                	je     271 <_recmatch+0x271>
                    for (c = c ? c : *p; c <= *p; c++)  /* compare range */
 215:	85 db                	test   %ebx,%ebx
 217:	75 47                	jne    260 <_recmatch+0x260>
 219:	31 db                	xor    %ebx,%ebx
 21b:	8a 18                	mov    (%eax),%bl
 21d:	89 de                	mov    %ebx,%esi
 21f:	eb 25                	jmp    246 <_recmatch+0x246>
                        if ((unsigned)Case(c) == cc) /* typecast for MSC bug */
 221:	80 fb d7             	cmp    $0xd7,%bl
 224:	0f 95 c2             	setne  %dl
 227:	80 fb de             	cmp    $0xde,%bl
 22a:	0f 96 c0             	setbe  %al
 22d:	21 c2                	and    %eax,%edx
 22f:	89 d8                	mov    %ebx,%eax
 231:	83 c8 20             	or     $0x20,%eax
 234:	84 d2                	test   %dl,%dl
 236:	0f 44 c3             	cmove  %ebx,%eax
 239:	39 c1                	cmp    %eax,%ecx
 23b:	0f 84 af 00 00 00    	je     2f0 <_recmatch+0x2f0>
                c = *(p-1);
            else {
                unsigned int cc = Case(*s);

                if (*(p+1) != '-')
                    for (c = c ? c : *p; c <= *p; c++)  /* compare range */
 241:	43                   	inc    %ebx
 242:	39 de                	cmp    %ebx,%esi
 244:	72 2b                	jb     271 <_recmatch+0x271>
 246:	89 d8                	mov    %ebx,%eax
                        if ((unsigned)Case(c) == cc) /* typecast for MSC bug */
 248:	85 ed                	test   %ebp,%ebp
 24a:	74 ed                	je     239 <_recmatch+0x239>
 24c:	81 fb bf 00 00 00    	cmp    $0xbf,%ebx
 252:	77 cd                	ja     221 <_recmatch+0x221>
 254:	8d 43 bf             	lea    -0x41(%ebx),%eax
 257:	3c 19                	cmp    $0x19,%al
 259:	0f 96 c2             	setbe  %dl
 25c:	eb d1                	jmp    22f <_recmatch+0x22f>
 25e:	66 90                	xchg   %ax,%ax
                c = *(p-1);
            else {
                unsigned int cc = Case(*s);

                if (*(p+1) != '-')
                    for (c = c ? c : *p; c <= *p; c++)  /* compare range */
 260:	8b 44 24 10          	mov    0x10(%esp),%eax
 264:	0f b6 30             	movzbl (%eax),%esi
 267:	81 e6 ff 00 00 00    	and    $0xff,%esi
 26d:	39 de                	cmp    %ebx,%esi
 26f:	73 d5                	jae    246 <_recmatch+0x246>
                        if ((unsigned)Case(c) == cc) /* typecast for MSC bug */
                            return r ? 0 : recmatch(q + 1, s + 1, ic __WDL);
                c = e = 0;   /* clear range, escape flags */
 271:	31 f6                	xor    %esi,%esi
 273:	31 db                	xor    %ebx,%ebx
                    e = 1;
                else if (*q == END_RANGE)
                    break;
        if (*q != END_RANGE)         /* nothing matches if bad syntax */
            return 0;
        for (c = 0, e = (*p == '-'); p < q; INCSTR(p)) {
 275:	8b 07                	mov    (%edi),%eax
 277:	89 44 24 04          	mov    %eax,0x4(%esp)
 27b:	8b 44 24 10          	mov    0x10(%esp),%eax
 27f:	89 04 24             	mov    %eax,(%esp)
 282:	e8 00 00 00 00       	call   287 <_recmatch+0x287>
 287:	8b 54 24 10          	mov    0x10(%esp),%edx
 28b:	01 c2                	add    %eax,%edx
 28d:	89 54 24 10          	mov    %edx,0x10(%esp)
 291:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 295:	39 4c 24 18          	cmp    %ecx,0x18(%esp)
 299:	0f 87 21 ff ff ff    	ja     1c0 <_recmatch+0x1c0>
 29f:	8b 74 24 18          	mov    0x18(%esp),%esi
                        if ((unsigned)Case(c) == cc) /* typecast for MSC bug */
                            return r ? 0 : recmatch(q + 1, s + 1, ic __WDL);
                c = e = 0;   /* clear range, escape flags */
            }
        }
        return r ? recmatch(q + CLEN(q), s + CLEN(s), ic __WDL) : 0;
 2a3:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
 2a8:	0f 84 52 fe ff ff    	je     100 <_recmatch+0x100>
 2ae:	8b 07                	mov    (%edi),%eax
 2b0:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 2b4:	89 44 24 04          	mov    %eax,0x4(%esp)
 2b8:	89 1c 24             	mov    %ebx,(%esp)
 2bb:	e8 00 00 00 00       	call   2c0 <_recmatch+0x2c0>
 2c0:	89 d9                	mov    %ebx,%ecx
 2c2:	01 c1                	add    %eax,%ecx
 2c4:	8b 07                	mov    (%edi),%eax
 2c6:	89 44 24 04          	mov    %eax,0x4(%esp)
 2ca:	89 34 24             	mov    %esi,(%esp)
 2cd:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 2d1:	e8 00 00 00 00       	call   2d6 <_recmatch+0x2d6>
 2d6:	01 c6                	add    %eax,%esi
 2d8:	e9 38 fd ff ff       	jmp    15 <_recmatch+0x15>
 2dd:	8d 76 00             	lea    0x0(%esi),%esi
            if (!e && *p == '\\')               /* set escape flag if \ */
                e = 1;
            else if (!e && *p == '-')           /* set start of range if - */
                c = *(p-1);
            else {
                unsigned int cc = Case(*s);
 2e0:	31 c9                	xor    %ecx,%ecx
 2e2:	8a 08                	mov    (%eax),%cl
 2e4:	e9 22 ff ff ff       	jmp    20b <_recmatch+0x20b>
 2e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 2f0:	8b 74 24 18          	mov    0x18(%esp),%esi

                if (*(p+1) != '-')
                    for (c = c ? c : *p; c <= *p; c++)  /* compare range */
                        if ((unsigned)Case(c) == cc) /* typecast for MSC bug */
                            return r ? 0 : recmatch(q + 1, s + 1, ic __WDL);
 2f4:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
 2f9:	0f 85 01 fe ff ff    	jne    100 <_recmatch+0x100>
 2ff:	8b 4c 24 14          	mov    0x14(%esp),%ecx
 303:	46                   	inc    %esi
 304:	41                   	inc    %ecx
 305:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 309:	e9 07 fd ff ff       	jmp    15 <_recmatch+0x15>
 30e:	66 90                	xchg   %ax,%ax
            if (!e && *p == '\\')               /* set escape flag if \ */
                e = 1;
            else if (!e && *p == '-')           /* set start of range if - */
                c = *(p-1);
            else {
                unsigned int cc = Case(*s);
 310:	8d 50 bf             	lea    -0x41(%eax),%edx
 313:	80 fa 19             	cmp    $0x19,%dl
 316:	0f 96 c2             	setbe  %dl
 319:	e9 de fe ff ff       	jmp    1fc <_recmatch+0x1fc>
 31e:	66 90                	xchg   %ax,%ax
        if (*q != END_RANGE)         /* nothing matches if bad syntax */
            return 0;
        for (c = 0, e = (*p == '-'); p < q; INCSTR(p)) {
            /* go through the list */
            if (!e && *p == '\\')               /* set escape flag if \ */
                e = 1;
 320:	be 01 00 00 00       	mov    $0x1,%esi
 325:	e9 4b ff ff ff       	jmp    275 <_recmatch+0x275>
 32a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            else if (!e && *p == '-')           /* set start of range if - */
                c = *(p-1);
 330:	8b 44 24 10          	mov    0x10(%esp),%eax
 334:	31 db                	xor    %ebx,%ebx
 336:	8a 58 ff             	mov    -0x1(%eax),%bl
 339:	e9 37 ff ff ff       	jmp    275 <_recmatch+0x275>
    /* Get first character, the pattern for new recmatch calls follows */
    c = *p; INCSTR(p);

    /* If that was the end of the pattern, match if string empty too */
    if (c == 0)
        return *s == 0;
 33e:	8b 44 24 14          	mov    0x14(%esp),%eax
 342:	80 38 00             	cmpb   $0x0,(%eax)
 345:	0f 94 c0             	sete   %al
#else
    return Case((uch)c) == Case(*s) ?
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
#endif

} /* end function recmatch() */
 348:	83 c4 2c             	add    $0x2c,%esp
    /* Get first character, the pattern for new recmatch calls follows */
    c = *p; INCSTR(p);

    /* If that was the end of the pattern, match if string empty too */
    if (c == 0)
        return *s == 0;
 34b:	25 ff 00 00 00       	and    $0xff,%eax
#else
    return Case((uch)c) == Case(*s) ?
           recmatch(p, s + CLEN(s), ic __WDL) : 0;
#endif

} /* end function recmatch() */
 350:	5b                   	pop    %ebx
 351:	5e                   	pop    %esi
 352:	5f                   	pop    %edi
 353:	5d                   	pop    %ebp
 354:	c3                   	ret    
          ++p;        /* move p behind the second '*' */
          /* and continue with the non-W_flag code variant */
        }
#endif /* WILD_STOP_AT_DIR */
        if (*p == 0)
            return 1;
 355:	b8 01 00 00 00       	mov    $0x1,%eax
          /* "**": this matches slashes */
          ++p;        /* move p behind the second '*' */
          /* and continue with the non-W_flag code variant */
        }
#endif /* WILD_STOP_AT_DIR */
        if (*p == 0)
 35a:	80 3e 00             	cmpb   $0x0,(%esi)
 35d:	0f 84 9f fd ff ff    	je     102 <_recmatch+0x102>
            return 1;
        for (; *s; INCSTR(s))
 363:	8b 44 24 14          	mov    0x14(%esp),%eax
 367:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 36b:	80 38 00             	cmpb   $0x0,(%eax)
 36e:	74 28                	je     398 <_recmatch+0x398>
            if ((c = recmatch(p, s, ic __WDL)) != 0)
 370:	89 e9                	mov    %ebp,%ecx
 372:	89 da                	mov    %ebx,%edx
 374:	89 f0                	mov    %esi,%eax
 376:	e8 85 fc ff ff       	call   0 <_recmatch>
 37b:	85 c0                	test   %eax,%eax
 37d:	0f 85 7f fd ff ff    	jne    102 <_recmatch+0x102>
          /* and continue with the non-W_flag code variant */
        }
#endif /* WILD_STOP_AT_DIR */
        if (*p == 0)
            return 1;
        for (; *s; INCSTR(s))
 383:	8b 07                	mov    (%edi),%eax
 385:	89 1c 24             	mov    %ebx,(%esp)
 388:	89 44 24 04          	mov    %eax,0x4(%esp)
 38c:	e8 00 00 00 00       	call   391 <_recmatch+0x391>
 391:	01 c3                	add    %eax,%ebx
 393:	80 3b 00             	cmpb   $0x0,(%ebx)
 396:	75 d8                	jne    370 <_recmatch+0x370>
            if ((c = recmatch(p, s, ic __WDL)) != 0)
                return (int)c;
        return 2;       /* 2 means give up--match will return false */
 398:	b8 02 00 00 00       	mov    $0x2,%eax
 39d:	e9 60 fd ff ff       	jmp    102 <_recmatch+0x102>
 3a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 3a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000003b0 <_match>:

int match(string, pattern, ignore_case __WDL)
    ZCONST char *string, *pattern;
    int ignore_case;
    __WDLDEF
{
 3b0:	83 ec 0c             	sub    $0xc,%esp
        j = recmatch((uch *)dospattern, (uch *)string, ignore_case __WDL);
        free(dospattern);
        return j == 1;
    } else
#endif /* MSDOS && DOSWILD */
    return recmatch((uch *)pattern, (uch *)string, ignore_case __WDL) == 1;
 3b3:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 3b7:	8b 54 24 10          	mov    0x10(%esp),%edx
 3bb:	8b 44 24 14          	mov    0x14(%esp),%eax
 3bf:	e8 3c fc ff ff       	call   0 <_recmatch>
 3c4:	48                   	dec    %eax
 3c5:	0f 94 c0             	sete   %al
 3c8:	25 ff 00 00 00       	and    $0xff,%eax
}
 3cd:	83 c4 0c             	add    $0xc,%esp
 3d0:	c3                   	ret    
 3d1:	eb 0d                	jmp    3e0 <_iswild>
 3d3:	90                   	nop
 3d4:	90                   	nop
 3d5:	90                   	nop
 3d6:	90                   	nop
 3d7:	90                   	nop
 3d8:	90                   	nop
 3d9:	90                   	nop
 3da:	90                   	nop
 3db:	90                   	nop
 3dc:	90                   	nop
 3dd:	90                   	nop
 3de:	90                   	nop
 3df:	90                   	nop

000003e0 <_iswild>:



int iswild(p)        /* originally only used for stat()-bug workaround in */
    ZCONST char *p;  /*  VAX C, Turbo/Borland C, Watcom C, Atari MiNT libs; */
{                    /*  now used in process_zipfiles() as well */
 3e0:	56                   	push   %esi
 3e1:	53                   	push   %ebx
 3e2:	83 ec 14             	sub    $0x14,%esp
    for (; *p; INCSTR(p))
 3e5:	8b 35 00 00 00 00    	mov    0x0,%esi



int iswild(p)        /* originally only used for stat()-bug workaround in */
    ZCONST char *p;  /*  VAX C, Turbo/Borland C, Watcom C, Atari MiNT libs; */
{                    /*  now used in process_zipfiles() as well */
 3eb:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    for (; *p; INCSTR(p))
 3ef:	8a 03                	mov    (%ebx),%al
 3f1:	84 c0                	test   %al,%al
 3f3:	75 2a                	jne    41f <_iswild+0x3f>
 3f5:	eb 39                	jmp    430 <_iswild+0x50>
        else if (*p == '%' || *p == '*')
#else /* !VMS */
#ifdef AMIGA
        else if (*p == '?' || *p == '*' || (*p=='#' && p[1]=='?') || *p == '[')
#else /* !AMIGA */
        else if (*p == '?' || *p == '*' || *p == '[')
 3f7:	3c 2a                	cmp    $0x2a,%al
 3f9:	0f 94 c1             	sete   %cl
 3fc:	3c 3f                	cmp    $0x3f,%al
 3fe:	0f 94 c2             	sete   %dl
 401:	08 d1                	or     %dl,%cl
 403:	75 33                	jne    438 <_iswild+0x58>
 405:	3c 5b                	cmp    $0x5b,%al
 407:	74 2f                	je     438 <_iswild+0x58>


int iswild(p)        /* originally only used for stat()-bug workaround in */
    ZCONST char *p;  /*  VAX C, Turbo/Borland C, Watcom C, Atari MiNT libs; */
{                    /*  now used in process_zipfiles() as well */
    for (; *p; INCSTR(p))
 409:	8b 06                	mov    (%esi),%eax
 40b:	89 1c 24             	mov    %ebx,(%esp)
 40e:	89 44 24 04          	mov    %eax,0x4(%esp)
 412:	e8 00 00 00 00       	call   417 <_iswild+0x37>
 417:	01 c3                	add    %eax,%ebx
 419:	8a 03                	mov    (%ebx),%al
 41b:	84 c0                	test   %al,%al
 41d:	74 11                	je     430 <_iswild+0x50>
        if (*p == '\\' && *(p+1))
 41f:	3c 5c                	cmp    $0x5c,%al
 421:	75 d4                	jne    3f7 <_iswild+0x17>
            ++p;
 423:	80 7b 01 01          	cmpb   $0x1,0x1(%ebx)
 427:	83 db ff             	sbb    $0xffffffff,%ebx
 42a:	eb dd                	jmp    409 <_iswild+0x29>
 42c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            return TRUE;
#endif

    return FALSE;

} /* end function iswild() */
 430:	83 c4 14             	add    $0x14,%esp
            return (int)p;
#else
            return TRUE;
#endif

    return FALSE;
 433:	31 c0                	xor    %eax,%eax

} /* end function iswild() */
 435:	5b                   	pop    %ebx
 436:	5e                   	pop    %esi
 437:	c3                   	ret    
 438:	83 c4 14             	add    $0x14,%esp
#endif /* ?VMS */
#endif /* ?THEOS */
#ifdef QDOS
            return (int)p;
#else
            return TRUE;
 43b:	b8 01 00 00 00       	mov    $0x1,%eax
#endif

    return FALSE;

} /* end function iswild() */
 440:	5b                   	pop    %ebx
 441:	5e                   	pop    %esi
 442:	c3                   	ret    
 443:	90                   	nop
 444:	90                   	nop
 445:	90                   	nop
 446:	90                   	nop
 447:	90                   	nop
 448:	90                   	nop
 449:	90                   	nop
 44a:	90                   	nop
 44b:	90                   	nop
 44c:	90                   	nop
 44d:	90                   	nop
 44e:	90                   	nop
 44f:	90                   	nop

nt.o:     file format pe-i386


Disassembly of section .text:

00000000 <_Initialize.part.0>:

VOLUMECAPS g_VolumeCaps;
CRITICAL_SECTION VolumeCapsLock;


static BOOL Initialize(VOID)
   0:	57                   	push   %edi
   1:	56                   	push   %esi
   2:	53                   	push   %ebx
   3:	83 ec 40             	sub    $0x40,%esp
    HANDLE hMutex;
    HANDLE hOldMutex;

    if(bInitialized) return TRUE;

    hMutex = CreateMutex(NULL, TRUE, NULL);
   6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   d:	00 
   e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  15:	00 
  16:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1d:	e8 00 00 00 00       	call   22 <_Initialize.part.0+0x22>
  22:	83 ec 0c             	sub    $0xc,%esp
  25:	89 c6                	mov    %eax,%esi
    if(hMutex == NULL) return FALSE;
  27:	85 c0                	test   %eax,%eax
  29:	74 5a                	je     85 <_Initialize.part.0+0x85>

    hOldMutex = (HANDLE)InterlockedExchange((LPLONG)&hInitMutex, (LONG)hMutex);
  2b:	89 44 24 04          	mov    %eax,0x4(%esp)
  2f:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  36:	e8 00 00 00 00       	call   3b <_Initialize.part.0+0x3b>
  3b:	89 c3                	mov    %eax,%ebx

    if(hOldMutex != NULL) {
  3d:	85 c0                	test   %eax,%eax
    if(bInitialized) return TRUE;

    hMutex = CreateMutex(NULL, TRUE, NULL);
    if(hMutex == NULL) return FALSE;

    hOldMutex = (HANDLE)InterlockedExchange((LPLONG)&hInitMutex, (LONG)hMutex);
  3f:	52                   	push   %edx
  40:	52                   	push   %edx

    if(hOldMutex != NULL) {
  41:	74 4d                	je     90 <_Initialize.part.0+0x90>
        /* somebody setup the mutex already */
        InterlockedExchange((LPLONG)&hInitMutex, (LONG)hOldMutex);
  43:	89 44 24 04          	mov    %eax,0x4(%esp)
  47:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  4e:	e8 00 00 00 00       	call   53 <_Initialize.part.0+0x53>
  53:	50                   	push   %eax
  54:	50                   	push   %eax

        CloseHandle(hMutex); /* close new, un-needed mutex */
  55:	89 34 24             	mov    %esi,(%esp)
  58:	e8 00 00 00 00       	call   5d <_Initialize.part.0+0x5d>
  5d:	50                   	push   %eax

        /* wait for initialization to complete and return status */
        WaitForSingleObject(hOldMutex, INFINITE);
  5e:	89 1c 24             	mov    %ebx,(%esp)
  61:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  68:	ff 
  69:	e8 00 00 00 00       	call   6e <_Initialize.part.0+0x6e>
  6e:	50                   	push   %eax
  6f:	50                   	push   %eax
        ReleaseMutex(hOldMutex);
  70:	89 1c 24             	mov    %ebx,(%esp)
  73:	e8 00 00 00 00       	call   78 <_Initialize.part.0+0x78>
  78:	50                   	push   %eax

        return bInitialized;
  79:	a1 0c 00 00 00       	mov    0xc,%eax
    bInitialized = TRUE;

    ReleaseMutex(hMutex); /* release correct mutex */

    return TRUE;
}
  7e:	83 c4 40             	add    $0x40,%esp
  81:	5b                   	pop    %ebx
  82:	5e                   	pop    %esi
  83:	5f                   	pop    %edi
  84:	c3                   	ret    
  85:	83 c4 40             	add    $0x40,%esp
    HANDLE hOldMutex;

    if(bInitialized) return TRUE;

    hMutex = CreateMutex(NULL, TRUE, NULL);
    if(hMutex == NULL) return FALSE;
  88:	31 c0                	xor    %eax,%eax
    bInitialized = TRUE;

    ReleaseMutex(hMutex); /* release correct mutex */

    return TRUE;
}
  8a:	5b                   	pop    %ebx
  8b:	5e                   	pop    %esi
  8c:	5f                   	pop    %edi
  8d:	c3                   	ret    
  8e:	66 90                	xchg   %ax,%ax
        return bInitialized;
    }

    /* initialize module level resources */

    InitializeCriticalSection( &VolumeCapsLock );
  90:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  97:	e8 00 00 00 00       	call   9c <_Initialize.part.0+0x9c>
    memset(&g_VolumeCaps, 0, sizeof(VOLUMECAPS));
  9c:	ba 00 00 00 00       	mov    $0x0,%edx
  a1:	89 d8                	mov    %ebx,%eax
  a3:	b9 48 00 00 00       	mov    $0x48,%ecx
        return bInitialized;
    }

    /* initialize module level resources */

    InitializeCriticalSection( &VolumeCapsLock );
  a8:	57                   	push   %edi
    memset(&g_VolumeCaps, 0, sizeof(VOLUMECAPS));
  a9:	89 d7                	mov    %edx,%edi
  ab:	f3 ab                	rep stos %eax,%es:(%edi)

       note that enabling privileges is only relevant on the local machine;
       when accessing files that are on a remote machine, any privileges
       that are present on the remote machine get enabled by default. */

    if(!OpenProcessToken(GetCurrentProcess(),
  ad:	e8 00 00 00 00       	call   b2 <_Initialize.part.0+0xb2>
  b2:	8d 54 24 2c          	lea    0x2c(%esp),%edx
  b6:	89 54 24 08          	mov    %edx,0x8(%esp)
  ba:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  c1:	00 
  c2:	89 04 24             	mov    %eax,(%esp)
  c5:	e8 00 00 00 00       	call   ca <_Initialize.part.0+0xca>
  ca:	83 ec 0c             	sub    $0xc,%esp
  cd:	85 c0                	test   %eax,%eax
  cf:	75 1f                	jne    f0 <_Initialize.part.0+0xf0>

    InitLocalPrivileges();

    bInitialized = TRUE;

    ReleaseMutex(hMutex); /* release correct mutex */
  d1:	89 34 24             	mov    %esi,(%esp)
    InitializeCriticalSection( &VolumeCapsLock );
    memset(&g_VolumeCaps, 0, sizeof(VOLUMECAPS));

    InitLocalPrivileges();

    bInitialized = TRUE;
  d4:	c7 05 0c 00 00 00 01 	movl   $0x1,0xc
  db:	00 00 00 

    ReleaseMutex(hMutex); /* release correct mutex */
  de:	e8 00 00 00 00       	call   e3 <_Initialize.part.0+0xe3>
  e3:	50                   	push   %eax

    return TRUE;
  e4:	b8 01 00 00 00       	mov    $0x1,%eax
}
  e9:	83 c4 40             	add    $0x40,%esp
  ec:	5b                   	pop    %ebx
  ed:	5e                   	pop    %esi
  ee:	5f                   	pop    %edi
  ef:	c3                   	ret    
        return;

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if(LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &tp.Privileges[0].Luid)) {
  f0:	8d 5c 24 34          	lea    0x34(%esp),%ebx
  f4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  fb:	00 
  fc:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 100:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)

    if(!OpenProcessToken(GetCurrentProcess(),
        TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken))
        return;

    tp.PrivilegeCount = 1;
 107:	c7 44 24 30 01 00 00 	movl   $0x1,0x30(%esp)
 10e:	00 
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
 10f:	c7 44 24 3c 02 00 00 	movl   $0x2,0x3c(%esp)
 116:	00 

    if(LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &tp.Privileges[0].Luid)) {
 117:	e8 00 00 00 00       	call   11c <_Initialize.part.0+0x11c>
 11c:	83 ec 0c             	sub    $0xc,%esp
 11f:	85 c0                	test   %eax,%eax
 121:	0f 85 89 00 00 00    	jne    1b0 <_Initialize.part.0+0x1b0>
    }

    /* try to enable SeSystemSecurityPrivilege, if SeRestorePrivilege not
       present; if this succeeds, we can write the Sacl */

    if(!g_bRestorePrivilege &&
 127:	8b 0d 04 00 00 00    	mov    0x4,%ecx
 12d:	85 c9                	test   %ecx,%ecx
 12f:	74 0f                	je     140 <_Initialize.part.0+0x140>

        if(AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL) &&
           GetLastError() == ERROR_SUCCESS) g_bSaclPrivilege = TRUE;
    }

    CloseHandle(hToken);
 131:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 135:	89 04 24             	mov    %eax,(%esp)
 138:	e8 00 00 00 00       	call   13d <_Initialize.part.0+0x13d>
 13d:	52                   	push   %edx
 13e:	eb 91                	jmp    d1 <_Initialize.part.0+0xd1>

    /* try to enable SeSystemSecurityPrivilege, if SeRestorePrivilege not
       present; if this succeeds, we can write the Sacl */

    if(!g_bRestorePrivilege &&
        LookupPrivilegeValue(NULL, SE_SECURITY_NAME, &tp.Privileges[0].Luid)) {
 140:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 144:	c7 44 24 04 13 00 00 	movl   $0x13,0x4(%esp)
 14b:	00 
 14c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 153:	e8 00 00 00 00       	call   158 <_Initialize.part.0+0x158>
 158:	83 ec 0c             	sub    $0xc,%esp
    }

    /* try to enable SeSystemSecurityPrivilege, if SeRestorePrivilege not
       present; if this succeeds, we can write the Sacl */

    if(!g_bRestorePrivilege &&
 15b:	85 c0                	test   %eax,%eax
 15d:	74 d2                	je     131 <_Initialize.part.0+0x131>
        LookupPrivilegeValue(NULL, SE_SECURITY_NAME, &tp.Privileges[0].Luid)) {

        if(AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL) &&
 15f:	8d 44 24 30          	lea    0x30(%esp),%eax
 163:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 16a:	00 
 16b:	89 44 24 08          	mov    %eax,0x8(%esp)
 16f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 173:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 17a:	00 
 17b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 182:	00 
 183:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 18a:	00 
 18b:	89 04 24             	mov    %eax,(%esp)
 18e:	e8 00 00 00 00       	call   193 <_Initialize.part.0+0x193>
 193:	83 ec 18             	sub    $0x18,%esp
 196:	85 c0                	test   %eax,%eax
 198:	74 97                	je     131 <_Initialize.part.0+0x131>
           GetLastError() == ERROR_SUCCESS) g_bSaclPrivilege = TRUE;
 19a:	e8 00 00 00 00       	call   19f <_Initialize.part.0+0x19f>
       present; if this succeeds, we can write the Sacl */

    if(!g_bRestorePrivilege &&
        LookupPrivilegeValue(NULL, SE_SECURITY_NAME, &tp.Privileges[0].Luid)) {

        if(AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL) &&
 19f:	85 c0                	test   %eax,%eax
 1a1:	75 8e                	jne    131 <_Initialize.part.0+0x131>
           GetLastError() == ERROR_SUCCESS) g_bSaclPrivilege = TRUE;
 1a3:	c7 05 00 00 00 00 01 	movl   $0x1,0x0
 1aa:	00 00 00 
 1ad:	eb 82                	jmp    131 <_Initialize.part.0+0x131>
 1af:	90                   	nop
    if(LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &tp.Privileges[0].Luid)) {

        /* try to enable SeRestorePrivilege; if this succeeds, we can write
           all aspects of the security descriptor */

        if(AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL) &&
 1b0:	8d 44 24 30          	lea    0x30(%esp),%eax
 1b4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 1bb:	00 
 1bc:	89 44 24 08          	mov    %eax,0x8(%esp)
 1c0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 1c4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 1cb:	00 
 1cc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 1d3:	00 
 1d4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 1db:	00 
 1dc:	89 04 24             	mov    %eax,(%esp)
 1df:	e8 00 00 00 00       	call   1e4 <_Initialize.part.0+0x1e4>
 1e4:	83 ec 18             	sub    $0x18,%esp
 1e7:	85 c0                	test   %eax,%eax
 1e9:	0f 84 38 ff ff ff    	je     127 <_Initialize.part.0+0x127>
           GetLastError() == ERROR_SUCCESS) g_bRestorePrivilege = TRUE;
 1ef:	e8 00 00 00 00       	call   1f4 <_Initialize.part.0+0x1f4>
    if(LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &tp.Privileges[0].Luid)) {

        /* try to enable SeRestorePrivilege; if this succeeds, we can write
           all aspects of the security descriptor */

        if(AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL) &&
 1f4:	85 c0                	test   %eax,%eax
 1f6:	0f 85 2b ff ff ff    	jne    127 <_Initialize.part.0+0x127>
           GetLastError() == ERROR_SUCCESS) g_bRestorePrivilege = TRUE;
 1fc:	c7 05 04 00 00 00 01 	movl   $0x1,0x4
 203:	00 00 00 
 206:	e9 26 ff ff ff       	jmp    131 <_Initialize.part.0+0x131>
 20b:	90                   	nop
 20c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000210 <_ValidateSecurity>:
    return TRUE;
}


BOOL ValidateSecurity(uch *securitydata)
{
 210:	57                   	push   %edi
 211:	56                   	push   %esi
 212:	53                   	push   %ebx
 213:	83 ec 20             	sub    $0x20,%esp
    PACL pAcl;
    PSID pSid;
    BOOL bAclPresent;
    BOOL bDefaulted;

    if(!IsWinNT()) return TRUE; /* don't do anything if not on WinNT */
 216:	e8 00 00 00 00       	call   21b <_ValidateSecurity+0xb>
 21b:	85 c0                	test   %eax,%eax
 21d:	75 11                	jne    230 <_ValidateSecurity+0x20>
 21f:	b8 01 00 00 00       	mov    $0x1,%eax
    if(pSid != NULL) {
        if(!IsValidSid(pSid)) return FALSE;
    }

    return TRUE;
}
 224:	83 c4 20             	add    $0x20,%esp
 227:	5b                   	pop    %ebx
 228:	5e                   	pop    %esi
 229:	5f                   	pop    %edi
 22a:	c3                   	ret    
 22b:	90                   	nop
 22c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    BOOL bAclPresent;
    BOOL bDefaulted;

    if(!IsWinNT()) return TRUE; /* don't do anything if not on WinNT */

    if(!IsValidSecurityDescriptor(sd)) return FALSE;
 230:	8b 44 24 30          	mov    0x30(%esp),%eax
 234:	89 04 24             	mov    %eax,(%esp)
 237:	e8 00 00 00 00       	call   23c <_ValidateSecurity+0x2c>
 23c:	85 c0                	test   %eax,%eax
 23e:	53                   	push   %ebx
 23f:	75 0f                	jne    250 <_ValidateSecurity+0x40>
    if(pSid != NULL) {
        if(!IsValidSid(pSid)) return FALSE;
    }

    return TRUE;
}
 241:	83 c4 20             	add    $0x20,%esp
    BOOL bAclPresent;
    BOOL bDefaulted;

    if(!IsWinNT()) return TRUE; /* don't do anything if not on WinNT */

    if(!IsValidSecurityDescriptor(sd)) return FALSE;
 244:	31 c0                	xor    %eax,%eax
    if(pSid != NULL) {
        if(!IsValidSid(pSid)) return FALSE;
    }

    return TRUE;
}
 246:	5b                   	pop    %ebx
 247:	5e                   	pop    %esi
 248:	5f                   	pop    %edi
 249:	c3                   	ret    
 24a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

    if(!IsValidSecurityDescriptor(sd)) return FALSE;

    /* verify Dacl integrity */

    if(!GetSecurityDescriptorDacl(sd, &bAclPresent, &pAcl, &bDefaulted))
 250:	8d 5c 24 1c          	lea    0x1c(%esp),%ebx
 254:	8d 74 24 10          	lea    0x10(%esp),%esi
 258:	8d 7c 24 18          	lea    0x18(%esp),%edi
 25c:	8b 44 24 30          	mov    0x30(%esp),%eax
 260:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 264:	89 74 24 08          	mov    %esi,0x8(%esp)
 268:	89 7c 24 04          	mov    %edi,0x4(%esp)
 26c:	89 04 24             	mov    %eax,(%esp)
 26f:	e8 00 00 00 00       	call   274 <_ValidateSecurity+0x64>
 274:	83 ec 10             	sub    $0x10,%esp
 277:	85 c0                	test   %eax,%eax
 279:	74 c6                	je     241 <_ValidateSecurity+0x31>
        return FALSE;

    if(bAclPresent) {
 27b:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 27f:	85 c9                	test   %ecx,%ecx
 281:	74 11                	je     294 <_ValidateSecurity+0x84>
        if(!IsValidAcl(pAcl)) return FALSE;
 283:	8b 44 24 10          	mov    0x10(%esp),%eax
 287:	89 04 24             	mov    %eax,(%esp)
 28a:	e8 00 00 00 00       	call   28f <_ValidateSecurity+0x7f>
 28f:	85 c0                	test   %eax,%eax
 291:	52                   	push   %edx
 292:	74 ad                	je     241 <_ValidateSecurity+0x31>
    }

    /* verify Sacl integrity */

    if(!GetSecurityDescriptorSacl(sd, &bAclPresent, &pAcl, &bDefaulted))
 294:	8b 44 24 30          	mov    0x30(%esp),%eax
 298:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 29c:	89 74 24 08          	mov    %esi,0x8(%esp)
 2a0:	89 7c 24 04          	mov    %edi,0x4(%esp)
 2a4:	89 04 24             	mov    %eax,(%esp)
 2a7:	e8 00 00 00 00       	call   2ac <_ValidateSecurity+0x9c>
 2ac:	83 ec 10             	sub    $0x10,%esp
 2af:	85 c0                	test   %eax,%eax
 2b1:	74 8e                	je     241 <_ValidateSecurity+0x31>
        return FALSE;

    if(bAclPresent) {
 2b3:	8b 7c 24 18          	mov    0x18(%esp),%edi
 2b7:	85 ff                	test   %edi,%edi
 2b9:	74 15                	je     2d0 <_ValidateSecurity+0xc0>
        if(!IsValidAcl(pAcl)) return FALSE;
 2bb:	8b 44 24 10          	mov    0x10(%esp),%eax
 2bf:	89 04 24             	mov    %eax,(%esp)
 2c2:	e8 00 00 00 00       	call   2c7 <_ValidateSecurity+0xb7>
 2c7:	85 c0                	test   %eax,%eax
 2c9:	56                   	push   %esi
 2ca:	0f 84 71 ff ff ff    	je     241 <_ValidateSecurity+0x31>
    }

    /* verify owner integrity */

    if(!GetSecurityDescriptorOwner(sd, &pSid, &bDefaulted))
 2d0:	8d 74 24 14          	lea    0x14(%esp),%esi
 2d4:	8b 44 24 30          	mov    0x30(%esp),%eax
 2d8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 2dc:	89 74 24 04          	mov    %esi,0x4(%esp)
 2e0:	89 04 24             	mov    %eax,(%esp)
 2e3:	e8 00 00 00 00       	call   2e8 <_ValidateSecurity+0xd8>
 2e8:	83 ec 0c             	sub    $0xc,%esp
 2eb:	85 c0                	test   %eax,%eax
 2ed:	0f 84 4e ff ff ff    	je     241 <_ValidateSecurity+0x31>
        return FALSE;

    if(pSid != NULL) {
 2f3:	8b 44 24 14          	mov    0x14(%esp),%eax
 2f7:	85 c0                	test   %eax,%eax
 2f9:	74 11                	je     30c <_ValidateSecurity+0xfc>
        if(!IsValidSid(pSid)) return FALSE;
 2fb:	89 04 24             	mov    %eax,(%esp)
 2fe:	e8 00 00 00 00       	call   303 <_ValidateSecurity+0xf3>
 303:	85 c0                	test   %eax,%eax
 305:	51                   	push   %ecx
 306:	0f 84 35 ff ff ff    	je     241 <_ValidateSecurity+0x31>
    }

    /* verify group integrity */

    if(!GetSecurityDescriptorGroup(sd, &pSid, &bDefaulted))
 30c:	8b 44 24 30          	mov    0x30(%esp),%eax
 310:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 314:	89 74 24 04          	mov    %esi,0x4(%esp)
 318:	89 04 24             	mov    %eax,(%esp)
 31b:	e8 00 00 00 00       	call   320 <_ValidateSecurity+0x110>
 320:	83 ec 0c             	sub    $0xc,%esp
 323:	85 c0                	test   %eax,%eax
 325:	0f 84 16 ff ff ff    	je     241 <_ValidateSecurity+0x31>
        return FALSE;

    if(pSid != NULL) {
 32b:	8b 44 24 14          	mov    0x14(%esp),%eax
 32f:	85 c0                	test   %eax,%eax
 331:	0f 84 e8 fe ff ff    	je     21f <_ValidateSecurity+0xf>
        if(!IsValidSid(pSid)) return FALSE;
 337:	89 04 24             	mov    %eax,(%esp)
 33a:	e8 00 00 00 00       	call   33f <_ValidateSecurity+0x12f>
 33f:	85 c0                	test   %eax,%eax
    PACL pAcl;
    PSID pSid;
    BOOL bAclPresent;
    BOOL bDefaulted;

    if(!IsWinNT()) return TRUE; /* don't do anything if not on WinNT */
 341:	0f 95 c0             	setne  %al

    if(!GetSecurityDescriptorGroup(sd, &pSid, &bDefaulted))
        return FALSE;

    if(pSid != NULL) {
        if(!IsValidSid(pSid)) return FALSE;
 344:	52                   	push   %edx
    PACL pAcl;
    PSID pSid;
    BOOL bAclPresent;
    BOOL bDefaulted;

    if(!IsWinNT()) return TRUE; /* don't do anything if not on WinNT */
 345:	25 ff 00 00 00       	and    $0xff,%eax
 34a:	e9 d5 fe ff ff       	jmp    224 <_ValidateSecurity+0x14>
 34f:	90                   	nop

00000350 <_GetVolumeCaps>:
BOOL GetVolumeCaps(
    char *rootpath,         /* filepath, or NULL */
    char *name,             /* filename associated with rootpath */
    PVOLUMECAPS VolumeCaps  /* result structure describing capabilities */
    )
{
 350:	55                   	push   %ebp
 351:	57                   	push   %edi
 352:	56                   	push   %esi
 353:	53                   	push   %ebx
 354:	81 ec 4c 01 00 00    	sub    $0x14c,%esp
    char TempRootPath[MAX_PATH + 1];
    DWORD cchTempRootPath = 0;
    BOOL bSuccess = TRUE;   /* assume success until told otherwise */

    if(!bInitialized) if(!Initialize()) return FALSE;
 35a:	8b 0d 0c 00 00 00    	mov    0xc,%ecx
BOOL GetVolumeCaps(
    char *rootpath,         /* filepath, or NULL */
    char *name,             /* filename associated with rootpath */
    PVOLUMECAPS VolumeCaps  /* result structure describing capabilities */
    )
{
 360:	8b 9c 24 60 01 00 00 	mov    0x160(%esp),%ebx
    char TempRootPath[MAX_PATH + 1];
    DWORD cchTempRootPath = 0;
    BOOL bSuccess = TRUE;   /* assume success until told otherwise */

    if(!bInitialized) if(!Initialize()) return FALSE;
 367:	85 c9                	test   %ecx,%ecx
 369:	75 16                	jne    381 <_GetVolumeCaps+0x31>
 36b:	e8 90 fc ff ff       	call   0 <_Initialize.part.0>
 370:	85 c0                	test   %eax,%eax
 372:	75 0d                	jne    381 <_GetVolumeCaps+0x31>
    }

    LeaveCriticalSection( &VolumeCapsLock ); /* release lock */

    return bSuccess;
}
 374:	81 c4 4c 01 00 00    	add    $0x14c,%esp
{
    char TempRootPath[MAX_PATH + 1];
    DWORD cchTempRootPath = 0;
    BOOL bSuccess = TRUE;   /* assume success until told otherwise */

    if(!bInitialized) if(!Initialize()) return FALSE;
 37a:	31 c0                	xor    %eax,%eax
    }

    LeaveCriticalSection( &VolumeCapsLock ); /* release lock */

    return bSuccess;
}
 37c:	5b                   	pop    %ebx
 37d:	5e                   	pop    %esi
 37e:	5f                   	pop    %edi
 37f:	5d                   	pop    %ebp
 380:	c3                   	ret    
    char *name,             /* filename associated with rootpath */
    PVOLUMECAPS VolumeCaps  /* result structure describing capabilities */
    )
{
    char TempRootPath[MAX_PATH + 1];
    DWORD cchTempRootPath = 0;
 381:	31 f6                	xor    %esi,%esi

    /* process the input path to produce a consistent path suitable for
       compare operations and also suitable for certain picky Win32 API
       that don't like forward slashes */

    if(rootpath != NULL && rootpath[0] != '\0') {
 383:	85 db                	test   %ebx,%ebx
 385:	74 09                	je     390 <_GetVolumeCaps+0x40>
 387:	80 3b 00             	cmpb   $0x0,(%ebx)
 38a:	0f 85 80 01 00 00    	jne    510 <_GetVolumeCaps+0x1c0>
        }

    } /* if path != NULL */

    /* grab lock protecting cached entry */
    EnterCriticalSection( &VolumeCapsLock );
 390:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 397:	e8 00 00 00 00       	call   39c <_GetVolumeCaps+0x4c>

    if(!g_VolumeCaps.bValid ||
 39c:	a1 00 00 00 00       	mov    0x0,%eax
 3a1:	85 c0                	test   %eax,%eax
        }

    } /* if path != NULL */

    /* grab lock protecting cached entry */
    EnterCriticalSection( &VolumeCapsLock );
 3a3:	55                   	push   %ebp

    if(!g_VolumeCaps.bValid ||
 3a4:	0f 85 9c 00 00 00    	jne    446 <_GetVolumeCaps+0xf6>
        DWORD dwFileSystemFlags;
        DWORD dwRemotePrivileges = 0;
        BOOL bRemote = FALSE;

        /* release lock during expensive operations */
        LeaveCriticalSection( &VolumeCapsLock );
 3aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 3b1:	e8 00 00 00 00       	call   3b6 <_GetVolumeCaps+0x66>

        bSuccess = GetVolumeInformation(
 3b6:	ba 00 00 00 00       	mov    $0x0,%edx
        DWORD dwFileSystemFlags;
        DWORD dwRemotePrivileges = 0;
        BOOL bRemote = FALSE;

        /* release lock during expensive operations */
        LeaveCriticalSection( &VolumeCapsLock );
 3bb:	57                   	push   %edi

        bSuccess = GetVolumeInformation(
 3bc:	8d 44 24 3b          	lea    0x3b(%esp),%eax
 3c0:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 3c7:	00 
 3c8:	80 7c 24 3b 00       	cmpb   $0x0,0x3b(%esp)
 3cd:	0f 44 c2             	cmove  %edx,%eax
 3d0:	8d 54 24 30          	lea    0x30(%esp),%edx
 3d4:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 3db:	00 
 3dc:	89 54 24 14          	mov    %edx,0x14(%esp)
 3e0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 3e7:	00 
 3e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 3ef:	00 
 3f0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 3f7:	00 
 3f8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 3ff:	00 
 400:	89 04 24             	mov    %eax,(%esp)
 403:	e8 00 00 00 00       	call   408 <_GetVolumeCaps+0xb8>
 408:	83 ec 20             	sub    $0x20,%esp
 40b:	89 c3                	mov    %eax,%ebx


        /* only if target volume supports Acls, and we were told to use
           privileges do we need to go out and test for the remote case */

        if(bSuccess && (dwFileSystemFlags & FS_PERSISTENT_ACLS) &&
 40d:	85 c0                	test   %eax,%eax
 40f:	0f 85 93 00 00 00    	jne    4a8 <_GetVolumeCaps+0x158>
                GetRemotePrivilegesSet(name, &dwRemotePrivileges);
            }
        }

        /* always take the lock again, since we release it below */
        EnterCriticalSection( &VolumeCapsLock );
 415:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 41c:	e8 00 00 00 00       	call   421 <_GetVolumeCaps+0xd1>
        g_VolumeCaps.dwFileAttributes = VolumeCaps->dwFileAttributes;

        /* give caller results */
        memcpy(VolumeCaps, &g_VolumeCaps, sizeof(VOLUMECAPS));
    } else {
        g_VolumeCaps.bValid = FALSE;
 421:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 428:	00 00 00 
                GetRemotePrivilegesSet(name, &dwRemotePrivileges);
            }
        }

        /* always take the lock again, since we release it below */
        EnterCriticalSection( &VolumeCapsLock );
 42b:	50                   	push   %eax
        memcpy(VolumeCaps, &g_VolumeCaps, sizeof(VOLUMECAPS));
    } else {
        g_VolumeCaps.bValid = FALSE;
    }

    LeaveCriticalSection( &VolumeCapsLock ); /* release lock */
 42c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 433:	e8 00 00 00 00       	call   438 <_GetVolumeCaps+0xe8>

    return bSuccess;
 438:	89 d8                	mov    %ebx,%eax
        memcpy(VolumeCaps, &g_VolumeCaps, sizeof(VOLUMECAPS));
    } else {
        g_VolumeCaps.bValid = FALSE;
    }

    LeaveCriticalSection( &VolumeCapsLock ); /* release lock */
 43a:	51                   	push   %ecx

    return bSuccess;
}
 43b:	81 c4 4c 01 00 00    	add    $0x14c,%esp
 441:	5b                   	pop    %ebx
 442:	5e                   	pop    %esi
 443:	5f                   	pop    %edi
 444:	5d                   	pop    %ebp
 445:	c3                   	ret    

    /* grab lock protecting cached entry */
    EnterCriticalSection( &VolumeCapsLock );

    if(!g_VolumeCaps.bValid ||
       lstrcmpi(g_VolumeCaps.RootPath, TempRootPath) != 0)
 446:	8d 7c 24 3b          	lea    0x3b(%esp),%edi
 44a:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
 451:	89 7c 24 04          	mov    %edi,0x4(%esp)
 455:	e8 00 00 00 00       	call   45a <_GetVolumeCaps+0x10a>
    } /* if path != NULL */

    /* grab lock protecting cached entry */
    EnterCriticalSection( &VolumeCapsLock );

    if(!g_VolumeCaps.bValid ||
 45a:	85 c0                	test   %eax,%eax
       lstrcmpi(g_VolumeCaps.RootPath, TempRootPath) != 0)
 45c:	53                   	push   %ebx
 45d:	53                   	push   %ebx
    PVOLUMECAPS VolumeCaps  /* result structure describing capabilities */
    )
{
    char TempRootPath[MAX_PATH + 1];
    DWORD cchTempRootPath = 0;
    BOOL bSuccess = TRUE;   /* assume success until told otherwise */
 45e:	bb 01 00 00 00       	mov    $0x1,%ebx
    } /* if path != NULL */

    /* grab lock protecting cached entry */
    EnterCriticalSection( &VolumeCapsLock );

    if(!g_VolumeCaps.bValid ||
 463:	0f 85 41 ff ff ff    	jne    3aa <_GetVolumeCaps+0x5a>
        }
    }

    if(bSuccess) {
        /* copy input elements */
        g_VolumeCaps.bUsePrivileges = VolumeCaps->bUsePrivileges;
 469:	8b 84 24 68 01 00 00 	mov    0x168(%esp),%eax
 470:	8b 40 04             	mov    0x4(%eax),%eax
 473:	a3 04 00 00 00       	mov    %eax,0x4
        g_VolumeCaps.dwFileAttributes = VolumeCaps->dwFileAttributes;
 478:	8b 84 24 68 01 00 00 	mov    0x168(%esp),%eax
 47f:	8b 40 14             	mov    0x14(%eax),%eax

        /* give caller results */
        memcpy(VolumeCaps, &g_VolumeCaps, sizeof(VOLUMECAPS));
 482:	c7 44 24 08 20 01 00 	movl   $0x120,0x8(%esp)
 489:	00 
    }

    if(bSuccess) {
        /* copy input elements */
        g_VolumeCaps.bUsePrivileges = VolumeCaps->bUsePrivileges;
        g_VolumeCaps.dwFileAttributes = VolumeCaps->dwFileAttributes;
 48a:	a3 14 00 00 00       	mov    %eax,0x14

        /* give caller results */
        memcpy(VolumeCaps, &g_VolumeCaps, sizeof(VOLUMECAPS));
 48f:	8b 84 24 68 01 00 00 	mov    0x168(%esp),%eax
 496:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 49d:	00 
 49e:	89 04 24             	mov    %eax,(%esp)
 4a1:	e8 00 00 00 00       	call   4a6 <_GetVolumeCaps+0x156>
 4a6:	eb 84                	jmp    42c <_GetVolumeCaps+0xdc>


        /* only if target volume supports Acls, and we were told to use
           privileges do we need to go out and test for the remote case */

        if(bSuccess && (dwFileSystemFlags & FS_PERSISTENT_ACLS) &&
 4a8:	f6 44 24 30 08       	testb  $0x8,0x30(%esp)
 4ad:	0f 85 bd 00 00 00    	jne    570 <_GetVolumeCaps+0x220>
 4b3:	8d 7c 24 3b          	lea    0x3b(%esp),%edi
    {

        /* no match found, build up new entry */

        DWORD dwFileSystemFlags;
        DWORD dwRemotePrivileges = 0;
 4b7:	31 ed                	xor    %ebp,%ebp
        BOOL bRemote = FALSE;
 4b9:	31 d2                	xor    %edx,%edx
                GetRemotePrivilegesSet(name, &dwRemotePrivileges);
            }
        }

        /* always take the lock again, since we release it below */
        EnterCriticalSection( &VolumeCapsLock );
 4bb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 4c2:	89 54 24 28          	mov    %edx,0x28(%esp)
 4c6:	e8 00 00 00 00       	call   4cb <_GetVolumeCaps+0x17b>

        /* replace the existing data if successful */
        if(bSuccess) {

            lstrcpynA(g_VolumeCaps.RootPath, TempRootPath, cchTempRootPath+1);
 4cb:	46                   	inc    %esi
                GetRemotePrivilegesSet(name, &dwRemotePrivileges);
            }
        }

        /* always take the lock again, since we release it below */
        EnterCriticalSection( &VolumeCapsLock );
 4cc:	52                   	push   %edx

        /* replace the existing data if successful */
        if(bSuccess) {

            lstrcpynA(g_VolumeCaps.RootPath, TempRootPath, cchTempRootPath+1);
 4cd:	89 74 24 08          	mov    %esi,0x8(%esp)
 4d1:	89 7c 24 04          	mov    %edi,0x4(%esp)
 4d5:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
 4dc:	e8 00 00 00 00       	call   4e1 <_GetVolumeCaps+0x191>
            g_VolumeCaps.dwFileSystemFlags = dwFileSystemFlags;
            g_VolumeCaps.bRemote = bRemote;
            g_VolumeCaps.dwRemotePrivileges = dwRemotePrivileges;
 4e1:	89 2d 10 00 00 00    	mov    %ebp,0x10
        EnterCriticalSection( &VolumeCapsLock );

        /* replace the existing data if successful */
        if(bSuccess) {

            lstrcpynA(g_VolumeCaps.RootPath, TempRootPath, cchTempRootPath+1);
 4e7:	83 ec 0c             	sub    $0xc,%esp
            g_VolumeCaps.dwFileSystemFlags = dwFileSystemFlags;
            g_VolumeCaps.bRemote = bRemote;
            g_VolumeCaps.dwRemotePrivileges = dwRemotePrivileges;
            g_VolumeCaps.bValid = TRUE;
 4ea:	c7 05 00 00 00 00 01 	movl   $0x1,0x0
 4f1:	00 00 00 

        /* replace the existing data if successful */
        if(bSuccess) {

            lstrcpynA(g_VolumeCaps.RootPath, TempRootPath, cchTempRootPath+1);
            g_VolumeCaps.dwFileSystemFlags = dwFileSystemFlags;
 4f4:	8b 44 24 30          	mov    0x30(%esp),%eax
            g_VolumeCaps.bRemote = bRemote;
 4f8:	8b 54 24 28          	mov    0x28(%esp),%edx

        /* replace the existing data if successful */
        if(bSuccess) {

            lstrcpynA(g_VolumeCaps.RootPath, TempRootPath, cchTempRootPath+1);
            g_VolumeCaps.dwFileSystemFlags = dwFileSystemFlags;
 4fc:	a3 08 00 00 00       	mov    %eax,0x8
            g_VolumeCaps.bRemote = bRemote;
 501:	89 15 0c 00 00 00    	mov    %edx,0xc
 507:	e9 5d ff ff ff       	jmp    469 <_GetVolumeCaps+0x119>
 50c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
       that don't like forward slashes */

    if(rootpath != NULL && rootpath[0] != '\0') {
        DWORD i;

        cchTempRootPath = lstrlen(rootpath);
 510:	89 1c 24             	mov    %ebx,(%esp)
 513:	e8 00 00 00 00       	call   518 <_GetVolumeCaps+0x1c8>
 518:	89 c6                	mov    %eax,%esi
        if(cchTempRootPath > MAX_PATH) return FALSE;
 51a:	3d 04 01 00 00       	cmp    $0x104,%eax
       that don't like forward slashes */

    if(rootpath != NULL && rootpath[0] != '\0') {
        DWORD i;

        cchTempRootPath = lstrlen(rootpath);
 51f:	52                   	push   %edx
        if(cchTempRootPath > MAX_PATH) return FALSE;
 520:	0f 87 4e fe ff ff    	ja     374 <_GetVolumeCaps+0x24>
 526:	8d 40 01             	lea    0x1(%eax),%eax
 529:	31 d2                	xor    %edx,%edx
 52b:	8d 7c 24 3b          	lea    0x3b(%esp),%edi

        /* copy input, converting forward slashes to back slashes as we go */

        for(i = 0 ; i <= cchTempRootPath ; i++) {
            if(rootpath[i] == '/') TempRootPath[i] = '\\';
 52f:	bd 5c 00 00 00       	mov    $0x5c,%ebp
 534:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
 537:	80 f9 2f             	cmp    $0x2f,%cl
 53a:	0f 44 cd             	cmove  %ebp,%ecx
 53d:	88 0c 17             	mov    %cl,(%edi,%edx,1)
        cchTempRootPath = lstrlen(rootpath);
        if(cchTempRootPath > MAX_PATH) return FALSE;

        /* copy input, converting forward slashes to back slashes as we go */

        for(i = 0 ; i <= cchTempRootPath ; i++) {
 540:	42                   	inc    %edx
 541:	39 c2                	cmp    %eax,%edx
 543:	75 ef                	jne    534 <_GetVolumeCaps+0x1e4>
                       slightly different logic which isn't available today.
                       This is required because directories can point at
                       different servers which have differing capabilities.
         */

        if(TempRootPath[0] == '\\' && TempRootPath[1] == '\\') {
 545:	8a 54 24 3c          	mov    0x3c(%esp),%dl
 549:	80 7c 24 3b 5c       	cmpb   $0x5c,0x3b(%esp)
 54e:	0f 84 cc 01 00 00    	je     720 <_GetVolumeCaps+0x3d0>
                cchTempRootPath++;
            }

        } else {

            if(TempRootPath[1] == ':') {
 554:	80 fa 3a             	cmp    $0x3a,%dl
 557:	0f 84 f8 01 00 00    	je     755 <_GetVolumeCaps+0x405>
                TempRootPath[3] = '\0';
                cchTempRootPath = 3;
            } else {

                /* must be file on current drive */
                TempRootPath[0] = '\0';
 55d:	c6 44 24 3b 00       	movb   $0x0,0x3b(%esp)
                cchTempRootPath = 0;
 562:	31 f6                	xor    %esi,%esi
 564:	e9 27 fe ff ff       	jmp    390 <_GetVolumeCaps+0x40>
 569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi


        /* only if target volume supports Acls, and we were told to use
           privileges do we need to go out and test for the remote case */

        if(bSuccess && (dwFileSystemFlags & FS_PERSISTENT_ACLS) &&
 570:	8b 84 24 68 01 00 00 	mov    0x168(%esp),%eax
 577:	8b 48 04             	mov    0x4(%eax),%ecx
 57a:	85 c9                	test   %ecx,%ecx
 57c:	0f 84 31 ff ff ff    	je     4b3 <_GetVolumeCaps+0x163>
           VolumeCaps->bUsePrivileges)
        {
            if(GetDriveType( (TempRootPath[0] == '\0') ? NULL : TempRootPath )
 582:	80 7c 24 3b 00       	cmpb   $0x0,0x3b(%esp)
 587:	0f 85 c3 00 00 00    	jne    650 <_GetVolumeCaps+0x300>
 58d:	31 c0                	xor    %eax,%eax
 58f:	8d 7c 24 3b          	lea    0x3b(%esp),%edi
 593:	89 04 24             	mov    %eax,(%esp)
 596:	e8 00 00 00 00       	call   59b <_GetVolumeCaps+0x24b>
 59b:	83 f8 04             	cmp    $0x4,%eax
 59e:	52                   	push   %edx
 59f:	0f 85 12 ff ff ff    	jne    4b7 <_GetVolumeCaps+0x167>

    *dwRemotePrivileges = 0;

    /* see if we have the SeRestorePrivilege */

    hFile = CreateFileA(
 5a5:	8b 84 24 64 01 00 00 	mov    0x164(%esp),%eax
 5ac:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 5b3:	00 
 5b4:	c7 44 24 14 00 00 00 	movl   $0x2000000,0x14(%esp)
 5bb:	02 
 5bc:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
 5c3:	00 
 5c4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 5cb:	00 
 5cc:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
 5d3:	00 
 5d4:	c7 44 24 04 00 00 0e 	movl   $0x10e0000,0x4(%esp)
 5db:	01 
 5dc:	89 04 24             	mov    %eax,(%esp)
 5df:	e8 00 00 00 00       	call   5e4 <_GetVolumeCaps+0x294>
 5e4:	83 ec 1c             	sub    $0x1c,%esp
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL
        );

    if(hFile != INVALID_HANDLE_VALUE) {
 5e7:	83 f8 ff             	cmp    $0xffffffff,%eax
 5ea:	0f 84 a9 01 00 00    	je     799 <_GetVolumeCaps+0x449>
          SACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION |
          GROUP_SECURITY_INFORMATION;
        PSECURITY_DESCRIPTOR sd;
        DWORD cbBuf = 0;

        GetKernelObjectSecurity(hFile, si, NULL, cbBuf, &cbBuf);
 5f0:	8d 6c 24 34          	lea    0x34(%esp),%ebp
 5f4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 5fb:	00 
 5fc:	89 6c 24 10          	mov    %ebp,0x10(%esp)
 600:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 607:	00 
 608:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
 60f:	00 
 610:	89 04 24             	mov    %eax,(%esp)
           read/write to simulate it */
        SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION |
          SACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION |
          GROUP_SECURITY_INFORMATION;
        PSECURITY_DESCRIPTOR sd;
        DWORD cbBuf = 0;
 613:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
 61a:	00 

        GetKernelObjectSecurity(hFile, si, NULL, cbBuf, &cbBuf);
 61b:	89 44 24 28          	mov    %eax,0x28(%esp)
 61f:	e8 00 00 00 00       	call   624 <_GetVolumeCaps+0x2d4>
 624:	83 ec 14             	sub    $0x14,%esp

        if(ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
 627:	e8 00 00 00 00       	call   62c <_GetVolumeCaps+0x2dc>
 62c:	8b 54 24 28          	mov    0x28(%esp),%edx
 630:	83 f8 7a             	cmp    $0x7a,%eax
 633:	74 26                	je     65b <_GetVolumeCaps+0x30b>

static VOID GetRemotePrivilegesSet(char *FileName, PDWORD dwRemotePrivileges)
{
    HANDLE hFile;

    *dwRemotePrivileges = 0;
 635:	31 ed                	xor    %ebp,%ebp
                }
                HeapFree(GetProcessHeap(), 0, sd);
            }
        }

        CloseHandle(hFile);
 637:	89 14 24             	mov    %edx,(%esp)
 63a:	e8 00 00 00 00       	call   63f <_GetVolumeCaps+0x2ef>
           VolumeCaps->bUsePrivileges)
        {
            if(GetDriveType( (TempRootPath[0] == '\0') ? NULL : TempRootPath )
               == DRIVE_REMOTE)
            {
                bRemote = TRUE;
 63f:	ba 01 00 00 00       	mov    $0x1,%edx
                }
                HeapFree(GetProcessHeap(), 0, sd);
            }
        }

        CloseHandle(hFile);
 644:	50                   	push   %eax
 645:	e9 71 fe ff ff       	jmp    4bb <_GetVolumeCaps+0x16b>
 64a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
           privileges do we need to go out and test for the remote case */

        if(bSuccess && (dwFileSystemFlags & FS_PERSISTENT_ACLS) &&
           VolumeCaps->bUsePrivileges)
        {
            if(GetDriveType( (TempRootPath[0] == '\0') ? NULL : TempRootPath )
 650:	8d 7c 24 3b          	lea    0x3b(%esp),%edi
 654:	89 f8                	mov    %edi,%eax
 656:	e9 38 ff ff ff       	jmp    593 <_GetVolumeCaps+0x243>
        DWORD cbBuf = 0;

        GetKernelObjectSecurity(hFile, si, NULL, cbBuf, &cbBuf);

        if(ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
            if((sd = HeapAlloc(GetProcessHeap(), 0, cbBuf)) != NULL) {
 65b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
 65f:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 663:	89 4c 24 28          	mov    %ecx,0x28(%esp)
 667:	e8 00 00 00 00       	call   66c <_GetVolumeCaps+0x31c>
 66c:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 670:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 677:	00 
 678:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 67c:	89 04 24             	mov    %eax,(%esp)
 67f:	e8 00 00 00 00       	call   684 <_GetVolumeCaps+0x334>
 684:	83 ec 0c             	sub    $0xc,%esp
 687:	89 c1                	mov    %eax,%ecx
 689:	85 c0                	test   %eax,%eax
 68b:	89 44 24 28          	mov    %eax,0x28(%esp)
 68f:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 693:	74 a0                	je     635 <_GetVolumeCaps+0x2e5>
                if(GetKernelObjectSecurity(hFile, si, sd, cbBuf, &cbBuf)) {
 695:	8b 44 24 34          	mov    0x34(%esp),%eax
 699:	89 14 24             	mov    %edx,(%esp)
 69c:	89 6c 24 10          	mov    %ebp,0x10(%esp)
 6a0:	89 44 24 0c          	mov    %eax,0xc(%esp)
 6a4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 6a8:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
 6af:	00 
 6b0:	e8 00 00 00 00       	call   6b5 <_GetVolumeCaps+0x365>
 6b5:	83 ec 14             	sub    $0x14,%esp
 6b8:	85 c0                	test   %eax,%eax
 6ba:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 6be:	75 2f                	jne    6ef <_GetVolumeCaps+0x39f>

static VOID GetRemotePrivilegesSet(char *FileName, PDWORD dwRemotePrivileges)
{
    HANDLE hFile;

    *dwRemotePrivileges = 0;
 6c0:	31 ed                	xor    %ebp,%ebp
 6c2:	89 54 24 2c          	mov    %edx,0x2c(%esp)
            if((sd = HeapAlloc(GetProcessHeap(), 0, cbBuf)) != NULL) {
                if(GetKernelObjectSecurity(hFile, si, sd, cbBuf, &cbBuf)) {
                    if(SetKernelObjectSecurity(hFile, si, sd))
                        *dwRemotePrivileges |= OVERRIDE_RESTORE;
                }
                HeapFree(GetProcessHeap(), 0, sd);
 6c6:	e8 00 00 00 00       	call   6cb <_GetVolumeCaps+0x37b>
 6cb:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 6cf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 6d6:	00 
 6d7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 6db:	89 04 24             	mov    %eax,(%esp)
 6de:	e8 00 00 00 00       	call   6e3 <_GetVolumeCaps+0x393>
 6e3:	83 ec 0c             	sub    $0xc,%esp
 6e6:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 6ea:	e9 48 ff ff ff       	jmp    637 <_GetVolumeCaps+0x2e7>
        GetKernelObjectSecurity(hFile, si, NULL, cbBuf, &cbBuf);

        if(ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
            if((sd = HeapAlloc(GetProcessHeap(), 0, cbBuf)) != NULL) {
                if(GetKernelObjectSecurity(hFile, si, sd, cbBuf, &cbBuf)) {
                    if(SetKernelObjectSecurity(hFile, si, sd))
 6ef:	8b 44 24 28          	mov    0x28(%esp),%eax
 6f3:	89 14 24             	mov    %edx,(%esp)
 6f6:	89 44 24 08          	mov    %eax,0x8(%esp)
 6fa:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
 701:	00 
 702:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 706:	e8 00 00 00 00       	call   70b <_GetVolumeCaps+0x3bb>
 70b:	83 ec 0c             	sub    $0xc,%esp
 70e:	85 c0                	test   %eax,%eax
 710:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 714:	74 aa                	je     6c0 <_GetVolumeCaps+0x370>
                        *dwRemotePrivileges |= OVERRIDE_RESTORE;
 716:	bd 02 00 00 00       	mov    $0x2,%ebp
 71b:	eb a5                	jmp    6c2 <_GetVolumeCaps+0x372>
 71d:	8d 76 00             	lea    0x0(%esi),%esi
                       slightly different logic which isn't available today.
                       This is required because directories can point at
                       different servers which have differing capabilities.
         */

        if(TempRootPath[0] == '\\' && TempRootPath[1] == '\\') {
 720:	80 fa 5c             	cmp    $0x5c,%dl
 723:	0f 85 2b fe ff ff    	jne    554 <_GetVolumeCaps+0x204>
            DWORD slash = 0;

            for(i = 2 ; i < cchTempRootPath ; i++) {
 729:	83 fe 02             	cmp    $0x2,%esi
 72c:	0f 86 5e fc ff ff    	jbe    390 <_GetVolumeCaps+0x40>
 732:	31 c9                	xor    %ecx,%ecx
 734:	ba 02 00 00 00       	mov    $0x2,%edx
 739:	eb 0a                	jmp    745 <_GetVolumeCaps+0x3f5>
 73b:	90                   	nop
 73c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 740:	42                   	inc    %edx
 741:	39 d6                	cmp    %edx,%esi
 743:	74 24                	je     769 <_GetVolumeCaps+0x419>
                if(TempRootPath[i] == '\\') {
 745:	80 3c 17 5c          	cmpb   $0x5c,(%edi,%edx,1)
 749:	75 f5                	jne    740 <_GetVolumeCaps+0x3f0>
                    slash++;

                    if(slash == 2) {
 74b:	49                   	dec    %ecx
 74c:	74 3e                	je     78c <_GetVolumeCaps+0x43c>
 74e:	b9 01 00 00 00       	mov    $0x1,%ecx
 753:	eb eb                	jmp    740 <_GetVolumeCaps+0x3f0>
        } else {

            if(TempRootPath[1] == ':') {

                /* drive letter specified, truncate to root */
                TempRootPath[2] = '\\';
 755:	c6 44 24 3d 5c       	movb   $0x5c,0x3d(%esp)
                TempRootPath[3] = '\0';
 75a:	c6 44 24 3e 00       	movb   $0x0,0x3e(%esp)
                cchTempRootPath = 3;
 75f:	be 03 00 00 00       	mov    $0x3,%esi
 764:	e9 27 fc ff ff       	jmp    390 <_GetVolumeCaps+0x40>
            }

            /* if there was only one slash found, just tack another onto the
               end */

            if(slash == 1 && TempRootPath[cchTempRootPath] != '\\') {
 769:	49                   	dec    %ecx
 76a:	0f 85 20 fc ff ff    	jne    390 <_GetVolumeCaps+0x40>
 770:	80 7c 34 3b 5c       	cmpb   $0x5c,0x3b(%esp,%esi,1)
 775:	0f 84 15 fc ff ff    	je     390 <_GetVolumeCaps+0x40>
                TempRootPath[cchTempRootPath] = TempRootPath[0]; /* '\\' */
 77b:	c6 44 34 3b 5c       	movb   $0x5c,0x3b(%esp,%esi,1)
                TempRootPath[cchTempRootPath+1] = '\0';
 780:	c6 44 04 3b 00       	movb   $0x0,0x3b(%esp,%eax,1)
 785:	89 c6                	mov    %eax,%esi
 787:	e9 04 fc ff ff       	jmp    390 <_GetVolumeCaps+0x40>
            for(i = 2 ; i < cchTempRootPath ; i++) {
                if(TempRootPath[i] == '\\') {
                    slash++;

                    if(slash == 2) {
                        i++;
 78c:	8d 72 01             	lea    0x1(%edx),%esi
                        TempRootPath[i] = '\0';
 78f:	c6 44 34 3b 00       	movb   $0x0,0x3b(%esp,%esi,1)
 794:	e9 f7 fb ff ff       	jmp    390 <_GetVolumeCaps+0x40>
    } else {

        /* see if we have the SeSecurityPrivilege */
        /* note we don't need this if we have SeRestorePrivilege */

        hFile = CreateFileA(
 799:	8b 84 24 64 01 00 00 	mov    0x164(%esp),%eax
 7a0:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 7a7:	00 
 7a8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 7af:	00 
 7b0:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
 7b7:	00 
 7b8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 7bf:	00 
 7c0:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
 7c7:	00 
 7c8:	c7 44 24 04 00 00 00 	movl   $0x1000000,0x4(%esp)
 7cf:	01 
 7d0:	89 04 24             	mov    %eax,(%esp)
 7d3:	e8 00 00 00 00       	call   7d8 <_GetVolumeCaps+0x488>
 7d8:	83 ec 1c             	sub    $0x1c,%esp
            OPEN_EXISTING,
            0,
            NULL
            );

        if(hFile != INVALID_HANDLE_VALUE) {
 7db:	83 f8 ff             	cmp    $0xffffffff,%eax
 7de:	74 18                	je     7f8 <_GetVolumeCaps+0x4a8>
            CloseHandle(hFile);
 7e0:	89 04 24             	mov    %eax,(%esp)
 7e3:	e8 00 00 00 00       	call   7e8 <_GetVolumeCaps+0x498>
           VolumeCaps->bUsePrivileges)
        {
            if(GetDriveType( (TempRootPath[0] == '\0') ? NULL : TempRootPath )
               == DRIVE_REMOTE)
            {
                bRemote = TRUE;
 7e8:	ba 01 00 00 00       	mov    $0x1,%edx
            0,
            NULL
            );

        if(hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
 7ed:	55                   	push   %ebp
            *dwRemotePrivileges |= OVERRIDE_SACL;
 7ee:	bd 04 00 00 00       	mov    $0x4,%ebp
 7f3:	e9 c3 fc ff ff       	jmp    4bb <_GetVolumeCaps+0x16b>

static VOID GetRemotePrivilegesSet(char *FileName, PDWORD dwRemotePrivileges)
{
    HANDLE hFile;

    *dwRemotePrivileges = 0;
 7f8:	31 ed                	xor    %ebp,%ebp
           VolumeCaps->bUsePrivileges)
        {
            if(GetDriveType( (TempRootPath[0] == '\0') ? NULL : TempRootPath )
               == DRIVE_REMOTE)
            {
                bRemote = TRUE;
 7fa:	ba 01 00 00 00       	mov    $0x1,%edx
 7ff:	e9 b7 fc ff ff       	jmp    4bb <_GetVolumeCaps+0x16b>
 804:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000810 <_SecuritySet>:
    return bSuccess;
}


BOOL SecuritySet(char *resource, PVOLUMECAPS VolumeCaps, uch *securitydata)
{
 810:	57                   	push   %edi
 811:	56                   	push   %esi
 812:	53                   	push   %ebx
 813:	83 ec 30             	sub    $0x30,%esp
    DWORD dwRev;
    BOOL bRestorePrivilege = FALSE;
    BOOL bSaclPrivilege = FALSE;
    BOOL bSuccess;

    if(!bInitialized) if(!Initialize()) return FALSE;
 816:	a1 0c 00 00 00       	mov    0xc,%eax
    return bSuccess;
}


BOOL SecuritySet(char *resource, PVOLUMECAPS VolumeCaps, uch *securitydata)
{
 81b:	8b 74 24 44          	mov    0x44(%esp),%esi
    DWORD dwRev;
    BOOL bRestorePrivilege = FALSE;
    BOOL bSaclPrivilege = FALSE;
    BOOL bSuccess;

    if(!bInitialized) if(!Initialize()) return FALSE;
 81f:	85 c0                	test   %eax,%eax
 821:	75 12                	jne    835 <_SecuritySet+0x25>
 823:	e8 d8 f7 ff ff       	call   0 <_Initialize.part.0>
 828:	85 c0                	test   %eax,%eax
 82a:	75 09                	jne    835 <_SecuritySet+0x25>
 82c:	31 c0                	xor    %eax,%eax
    bSuccess = SetKernelObjectSecurity(hFile, RequestedInfo, sd);

    CloseHandle(hFile);

    return bSuccess;
}
 82e:	83 c4 30             	add    $0x30,%esp
 831:	5b                   	pop    %ebx
 832:	5e                   	pop    %esi
 833:	5f                   	pop    %edi
 834:	c3                   	ret    
        dwFlags |= FILE_FLAG_BACKUP_SEMANTICS;
    }

    /* evaluate the input security descriptor and act accordingly */

    if(!IsValidSecurityDescriptor(sd))
 835:	8b 44 24 48          	mov    0x48(%esp),%eax

    /* defer directory processing */

    if(VolumeCaps->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        /* opening a directory requires FILE_FLAG_BACKUP_SEMANTICS */
        dwFlags |= FILE_FLAG_BACKUP_SEMANTICS;
 839:	8b 5e 14             	mov    0x14(%esi),%ebx
 83c:	c1 e3 15             	shl    $0x15,%ebx
    }

    /* evaluate the input security descriptor and act accordingly */

    if(!IsValidSecurityDescriptor(sd))
 83f:	89 04 24             	mov    %eax,(%esp)
 842:	e8 00 00 00 00       	call   847 <_SecuritySet+0x37>

    /* defer directory processing */

    if(VolumeCaps->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        /* opening a directory requires FILE_FLAG_BACKUP_SEMANTICS */
        dwFlags |= FILE_FLAG_BACKUP_SEMANTICS;
 847:	81 e3 00 00 00 02    	and    $0x2000000,%ebx
    }

    /* evaluate the input security descriptor and act accordingly */

    if(!IsValidSecurityDescriptor(sd))
 84d:	85 c0                	test   %eax,%eax
 84f:	57                   	push   %edi
 850:	74 da                	je     82c <_SecuritySet+0x1c>
        return FALSE;

    if(!GetSecurityDescriptorControl(sd, &sdc, &dwRev))
 852:	8d 44 24 2c          	lea    0x2c(%esp),%eax
 856:	89 44 24 08          	mov    %eax,0x8(%esp)
 85a:	8d 44 24 2a          	lea    0x2a(%esp),%eax
 85e:	89 44 24 04          	mov    %eax,0x4(%esp)
 862:	8b 44 24 48          	mov    0x48(%esp),%eax
 866:	89 04 24             	mov    %eax,(%esp)
 869:	e8 00 00 00 00       	call   86e <_SecuritySet+0x5e>
 86e:	83 ec 0c             	sub    $0xc,%esp
 871:	85 c0                	test   %eax,%eax
 873:	74 b7                	je     82c <_SecuritySet+0x1c>
        return FALSE;

    /* setup privilege usage based on if told we can use privileges, and if so,
       what privileges we have */

    if(VolumeCaps->bUsePrivileges) {
 875:	8b 4e 04             	mov    0x4(%esi),%ecx
 878:	85 c9                	test   %ecx,%ecx
 87a:	74 54                	je     8d0 <_SecuritySet+0xc0>
        if(VolumeCaps->bRemote) {
 87c:	8b 56 0c             	mov    0xc(%esi),%edx
 87f:	85 d2                	test   %edx,%edx
 881:	0f 85 c9 00 00 00    	jne    950 <_SecuritySet+0x140>
            if(VolumeCaps->dwRemotePrivileges & OVERRIDE_SACL)
                bSaclPrivilege = TRUE;

        } else {
            /* use local privileges */
            bRestorePrivilege = g_bRestorePrivilege;
 887:	8b 15 04 00 00 00    	mov    0x4,%edx
            bSaclPrivilege = g_bSaclPrivilege;
 88d:	8b 0d 00 00 00 00    	mov    0x0,%ecx


    /* if a Dacl is present write Dacl out */
    /* if we have SeRestorePrivilege, write owner and group info out */

    if(sdc & SE_DACL_PRESENT) {
 893:	66 8b 44 24 2a       	mov    0x2a(%esp),%ax
 898:	a8 04                	test   $0x4,%al
 89a:	0f 84 c5 00 00 00    	je     965 <_SecuritySet+0x155>
        dwDesiredAccess |= WRITE_DAC;
        RequestedInfo |= DACL_SECURITY_INFORMATION;

        if(bRestorePrivilege) {
 8a0:	85 d2                	test   %edx,%edx
 8a2:	0f 85 dc 00 00 00    	jne    984 <_SecuritySet+0x174>
    }

    /* if a Sacl is present and we have either SeRestorePrivilege or
       SeSystemSecurityPrivilege try to write Sacl out */

    if((sdc & SE_SACL_PRESENT) && (bRestorePrivilege || bSaclPrivilege)) {
 8a8:	a8 10                	test   $0x10,%al
    /* if a Dacl is present write Dacl out */
    /* if we have SeRestorePrivilege, write owner and group info out */

    if(sdc & SE_DACL_PRESENT) {
        dwDesiredAccess |= WRITE_DAC;
        RequestedInfo |= DACL_SECURITY_INFORMATION;
 8aa:	bf 04 00 00 00       	mov    $0x4,%edi

    /* if a Dacl is present write Dacl out */
    /* if we have SeRestorePrivilege, write owner and group info out */

    if(sdc & SE_DACL_PRESENT) {
        dwDesiredAccess |= WRITE_DAC;
 8af:	b8 00 00 04 00       	mov    $0x40000,%eax
    }

    /* if a Sacl is present and we have either SeRestorePrivilege or
       SeSystemSecurityPrivilege try to write Sacl out */

    if((sdc & SE_SACL_PRESENT) && (bRestorePrivilege || bSaclPrivilege)) {
 8b4:	74 2f                	je     8e5 <_SecuritySet+0xd5>
 8b6:	09 d1                	or     %edx,%ecx
 8b8:	74 2b                	je     8e5 <_SecuritySet+0xd5>
 8ba:	83 cf 08             	or     $0x8,%edi
 8bd:	0d 00 00 00 01       	or     $0x1000000,%eax

    if(RequestedInfo == 0)  /* nothing to do */
        return FALSE;

    if(bRestorePrivilege)
        dwFlags |= FILE_FLAG_BACKUP_SEMANTICS;
 8c2:	85 d2                	test   %edx,%edx
 8c4:	ba 00 00 00 02       	mov    $0x2000000,%edx
 8c9:	0f 45 da             	cmovne %edx,%ebx
 8cc:	eb 17                	jmp    8e5 <_SecuritySet+0xd5>
 8ce:	66 90                	xchg   %ax,%ax


    /* if a Dacl is present write Dacl out */
    /* if we have SeRestorePrivilege, write owner and group info out */

    if(sdc & SE_DACL_PRESENT) {
 8d0:	f6 44 24 2a 04       	testb  $0x4,0x2a(%esp)
 8d5:	0f 84 51 ff ff ff    	je     82c <_SecuritySet+0x1c>
        dwDesiredAccess |= WRITE_DAC;
        RequestedInfo |= DACL_SECURITY_INFORMATION;
 8db:	bf 04 00 00 00       	mov    $0x4,%edi
 8e0:	b8 00 00 04 00       	mov    $0x40000,%eax
        return FALSE;

    if(bRestorePrivilege)
        dwFlags |= FILE_FLAG_BACKUP_SEMANTICS;

    hFile = CreateFileA(
 8e5:	89 44 24 04          	mov    %eax,0x4(%esp)
 8e9:	8b 44 24 40          	mov    0x40(%esp),%eax
 8ed:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 8f4:	00 
 8f5:	89 5c 24 14          	mov    %ebx,0x14(%esp)
 8f9:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
 900:	00 
 901:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 908:	00 
 909:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
 910:	00 
 911:	89 04 24             	mov    %eax,(%esp)
 914:	e8 00 00 00 00       	call   919 <_SecuritySet+0x109>
 919:	83 ec 1c             	sub    $0x1c,%esp
 91c:	89 c6                	mov    %eax,%esi
        OPEN_EXISTING,
        dwFlags,
        NULL
        );

    if(hFile == INVALID_HANDLE_VALUE)
 91e:	83 f8 ff             	cmp    $0xffffffff,%eax
 921:	0f 84 05 ff ff ff    	je     82c <_SecuritySet+0x1c>
        return FALSE;

    bSuccess = SetKernelObjectSecurity(hFile, RequestedInfo, sd);
 927:	8b 44 24 48          	mov    0x48(%esp),%eax
 92b:	89 7c 24 04          	mov    %edi,0x4(%esp)
 92f:	89 44 24 08          	mov    %eax,0x8(%esp)
 933:	89 34 24             	mov    %esi,(%esp)
 936:	e8 00 00 00 00       	call   93b <_SecuritySet+0x12b>
 93b:	83 ec 0c             	sub    $0xc,%esp
 93e:	89 c3                	mov    %eax,%ebx

    CloseHandle(hFile);
 940:	89 34 24             	mov    %esi,(%esp)
 943:	e8 00 00 00 00       	call   948 <_SecuritySet+0x138>
 948:	50                   	push   %eax

    return bSuccess;
 949:	89 d8                	mov    %ebx,%eax
 94b:	e9 de fe ff ff       	jmp    82e <_SecuritySet+0x1e>
       what privileges we have */

    if(VolumeCaps->bUsePrivileges) {
        if(VolumeCaps->bRemote) {
            /* use remotely determined privileges */
            if(VolumeCaps->dwRemotePrivileges & OVERRIDE_RESTORE)
 950:	8b 4e 10             	mov    0x10(%esi),%ecx
 953:	89 ca                	mov    %ecx,%edx
 955:	d1 ea                	shr    %edx
                bRestorePrivilege = TRUE;

            if(VolumeCaps->dwRemotePrivileges & OVERRIDE_SACL)
 957:	c1 e9 02             	shr    $0x2,%ecx
    DWORD dwFlags = 0;
    PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR)securitydata;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    SECURITY_INFORMATION RequestedInfo = 0;
    DWORD dwRev;
    BOOL bRestorePrivilege = FALSE;
 95a:	83 e2 01             	and    $0x1,%edx
    BOOL bSaclPrivilege = FALSE;
 95d:	83 e1 01             	and    $0x1,%ecx
 960:	e9 2e ff ff ff       	jmp    893 <_SecuritySet+0x83>
    }

    /* if a Sacl is present and we have either SeRestorePrivilege or
       SeSystemSecurityPrivilege try to write Sacl out */

    if((sdc & SE_SACL_PRESENT) && (bRestorePrivilege || bSaclPrivilege)) {
 965:	a8 10                	test   $0x10,%al
 967:	0f 84 bf fe ff ff    	je     82c <_SecuritySet+0x1c>
 96d:	09 d1                	or     %edx,%ecx
 96f:	0f 84 b7 fe ff ff    	je     82c <_SecuritySet+0x1c>
 975:	bf 08 00 00 00       	mov    $0x8,%edi
 97a:	b8 00 00 00 01       	mov    $0x1000000,%eax
 97f:	e9 3e ff ff ff       	jmp    8c2 <_SecuritySet+0xb2>
 984:	a8 10                	test   $0x10,%al
        dwDesiredAccess |= WRITE_DAC;
        RequestedInfo |= DACL_SECURITY_INFORMATION;

        if(bRestorePrivilege) {
            dwDesiredAccess |= WRITE_OWNER;
            RequestedInfo |= (OWNER_SECURITY_INFORMATION |
 986:	bf 07 00 00 00       	mov    $0x7,%edi
    if(sdc & SE_DACL_PRESENT) {
        dwDesiredAccess |= WRITE_DAC;
        RequestedInfo |= DACL_SECURITY_INFORMATION;

        if(bRestorePrivilege) {
            dwDesiredAccess |= WRITE_OWNER;
 98b:	b8 00 00 0c 00       	mov    $0xc0000,%eax
    }

    /* if a Sacl is present and we have either SeRestorePrivilege or
       SeSystemSecurityPrivilege try to write Sacl out */

    if((sdc & SE_SACL_PRESENT) && (bRestorePrivilege || bSaclPrivilege)) {
 990:	0f 85 20 ff ff ff    	jne    8b6 <_SecuritySet+0xa6>

    if(RequestedInfo == 0)  /* nothing to do */
        return FALSE;

    if(bRestorePrivilege)
        dwFlags |= FILE_FLAG_BACKUP_SEMANTICS;
 996:	bb 00 00 00 02       	mov    $0x2000000,%ebx
 99b:	e9 45 ff ff ff       	jmp    8e5 <_SecuritySet+0xd5>

process.o:     file format pe-i386


Disassembly of section .text:

00000000 <_find_ecrec>:
/*************************/

static int find_ecrec(__G__ searchlen)          /* return PK-class error */
    __GDEF
    long searchlen;
{
       0:	55                   	push   %ebp
       1:	57                   	push   %edi
       2:	56                   	push   %esi
       3:	53                   	push   %ebx
       4:	83 ec 4c             	sub    $0x4c,%esp
       7:	89 c3                	mov    %eax,%ebx

/*---------------------------------------------------------------------------
    Treat case of short zipfile separately.
  ---------------------------------------------------------------------------*/

    if (G.ziplen <= INBUFSIZ) {
       9:	8b 80 0c 09 01 00    	mov    0x1090c(%eax),%eax
       f:	3d 00 20 00 00       	cmp    $0x2000,%eax
      14:	0f 8e e9 01 00 00    	jle    203 <_find_ecrec+0x203>
    Zipfile is longer than INBUFSIZ:  may need to loop.  Start with short
    block at end of zipfile (if not TOO short).
  ---------------------------------------------------------------------------*/

    } else {
        if ((tail_len = G.ziplen % INBUFSIZ) > ECREC_SIZE) {
      1a:	89 c7                	mov    %eax,%edi
      1c:	81 e7 ff 1f 00 00    	and    $0x1fff,%edi
      22:	83 ff 12             	cmp    $0x12,%edi
      25:	0f 8f 32 03 00 00    	jg     35d <_find_ecrec+0x35d>
        Loop through blocks of zipfile data, starting at the end and going
        toward the beginning.  In general, need not check whole zipfile for
        signature, but may want to do so if testing.
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
      2b:	29 fa                	sub    %edi,%edx
                }
            }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
        } else
            G.cur_zipfile_bufstart = G.ziplen - tail_len;
      2d:	29 f8                	sub    %edi,%eax
      2f:	89 83 10 09 01 00    	mov    %eax,0x10910(%ebx)
        Loop through blocks of zipfile data, starting at the end and going
        toward the beginning.  In general, need not check whole zipfile for
        signature, but may want to do so if testing.
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
      35:	8d 8a fe 3f 00 00    	lea    0x3ffe(%edx),%ecx
      3b:	81 c2 ff 1f 00 00    	add    $0x1fff,%edx
      41:	0f 48 d1             	cmovs  %ecx,%edx
      44:	c1 fa 0d             	sar    $0xd,%edx
      47:	89 54 24 1c          	mov    %edx,0x1c(%esp)
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
      4b:	85 d2                	test   %edx,%edx
      4d:	0f 8e 04 02 00 00    	jle    257 <_find_ecrec+0x257>
/*************************/

static int find_ecrec(__G__ searchlen)          /* return PK-class error */
    __GDEF
    long searchlen;
{
      53:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
      5a:	00 
      5b:	90                   	nop
      5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
            G.cur_zipfile_bufstart -= INBUFSIZ;
      60:	2d 00 20 00 00       	sub    $0x2000,%eax
            lseek(G.zipfd, G.cur_zipfile_bufstart, SEEK_SET);
      65:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
      6c:	00 

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
            G.cur_zipfile_bufstart -= INBUFSIZ;
      6d:	89 83 10 09 01 00    	mov    %eax,0x10910(%ebx)
            lseek(G.zipfd, G.cur_zipfile_bufstart, SEEK_SET);
      73:	89 44 24 04          	mov    %eax,0x4(%esp)
      77:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
      7d:	89 04 24             	mov    %eax,(%esp)
      80:	e8 00 00 00 00       	call   85 <_find_ecrec+0x85>
            if ((G.incnt = read(G.zipfd,(char *)G.inbuf,INBUFSIZ))
      85:	8b 83 e4 08 01 00    	mov    0x108e4(%ebx),%eax
      8b:	89 44 24 04          	mov    %eax,0x4(%esp)
      8f:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
      95:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
      9c:	00 
      9d:	89 04 24             	mov    %eax,(%esp)
      a0:	e8 00 00 00 00       	call   a5 <_find_ecrec+0xa5>
      a5:	89 83 ec 08 01 00    	mov    %eax,0x108ec(%ebx)
      ab:	3d 00 20 00 00       	cmp    $0x2000,%eax
      b0:	0f 85 a1 01 00 00    	jne    257 <_find_ecrec+0x257>
                != INBUFSIZ)
                break;          /* fall through and fail */

            for (G.inptr = G.inbuf+INBUFSIZ-1;  G.inptr >= G.inbuf;
      b6:	8b bb e4 08 01 00    	mov    0x108e4(%ebx),%edi
      bc:	8d af ff 1f 00 00    	lea    0x1fff(%edi),%ebp
      c2:	8d 77 ff             	lea    -0x1(%edi),%esi
      c5:	89 ab e8 08 01 00    	mov    %ebp,0x108e8(%ebx)
      cb:	eb 12                	jmp    df <_find_ecrec+0xdf>
      cd:	8d 76 00             	lea    0x0(%esi),%esi
                 --G.inptr)
      d0:	4d                   	dec    %ebp
      d1:	89 ab e8 08 01 00    	mov    %ebp,0x108e8(%ebx)
            lseek(G.zipfd, G.cur_zipfile_bufstart, SEEK_SET);
            if ((G.incnt = read(G.zipfd,(char *)G.inbuf,INBUFSIZ))
                != INBUFSIZ)
                break;          /* fall through and fail */

            for (G.inptr = G.inbuf+INBUFSIZ-1;  G.inptr >= G.inbuf;
      d7:	39 f5                	cmp    %esi,%ebp
      d9:	0f 84 31 02 00 00    	je     310 <_find_ecrec+0x310>
                 --G.inptr)
                if ((native(*G.inptr) == 'P')  &&
      df:	80 7d 00 50          	cmpb   $0x50,0x0(%ebp)
      e3:	75 eb                	jne    d0 <_find_ecrec+0xd0>
                     !strncmp((char *)G.inptr, end_central_sig, 4)) {
      e5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
      ec:	00 
      ed:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
      f4:	00 
      f5:	89 2c 24             	mov    %ebp,(%esp)
      f8:	e8 00 00 00 00       	call   fd <_find_ecrec+0xfd>
                != INBUFSIZ)
                break;          /* fall through and fail */

            for (G.inptr = G.inbuf+INBUFSIZ-1;  G.inptr >= G.inbuf;
                 --G.inptr)
                if ((native(*G.inptr) == 'P')  &&
      fd:	85 c0                	test   %eax,%eax
      ff:	75 cf                	jne    d0 <_find_ecrec+0xd0>
                     !strncmp((char *)G.inptr, end_central_sig, 4)) {
                    G.incnt -= (int)(G.inptr - G.inbuf);
     101:	89 f8                	mov    %edi,%eax
     103:	29 e8                	sub    %ebp,%eax
     105:	05 00 20 00 00       	add    $0x2000,%eax
     10a:	89 83 ec 08 01 00    	mov    %eax,0x108ec(%ebx)
                    found = TRUE;
                    break;
                }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     110:	8b 83 1c 09 01 00    	mov    0x1091c(%ebx),%eax
     116:	66 8b 17             	mov    (%edi),%dx
     119:	66 89 10             	mov    %dx,(%eax)
     11c:	8a 4f 02             	mov    0x2(%edi),%cl
     11f:	88 48 02             	mov    %cl,0x2(%eax)
     122:	8b bb e4 08 01 00    	mov    0x108e4(%ebx),%edi
    Found the signature, so get the end-central data before returning.  Do
    any necessary machine-type conversions (byte ordering, structure padding
    compensation) by reading data into character array and copying to struct.
  ---------------------------------------------------------------------------*/

    G.real_ecrec_offset = G.cur_zipfile_bufstart + (G.inptr-G.inbuf);
     128:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
     12e:	8b 8b 10 09 01 00    	mov    0x10910(%ebx),%ecx
     134:	29 f8                	sub    %edi,%eax
      G.real_ecrec_offset, G.real_ecrec_offset);
    printf("    from beginning of file; offset %d (%.4Xh) within block\n",
      G.inptr-G.inbuf, G.inptr-G.inbuf);
#endif

    if (readbuf(__G__ (char *)byterec, ECREC_SIZE+4) == 0)
     136:	c7 44 24 08 16 00 00 	movl   $0x16,0x8(%esp)
     13d:	00 
    Found the signature, so get the end-central data before returning.  Do
    any necessary machine-type conversions (byte ordering, structure padding
    compensation) by reading data into character array and copying to struct.
  ---------------------------------------------------------------------------*/

    G.real_ecrec_offset = G.cur_zipfile_bufstart + (G.inptr-G.inbuf);
     13e:	01 c8                	add    %ecx,%eax
      G.real_ecrec_offset, G.real_ecrec_offset);
    printf("    from beginning of file; offset %d (%.4Xh) within block\n",
      G.inptr-G.inbuf, G.inptr-G.inbuf);
#endif

    if (readbuf(__G__ (char *)byterec, ECREC_SIZE+4) == 0)
     140:	89 1c 24             	mov    %ebx,(%esp)
    Found the signature, so get the end-central data before returning.  Do
    any necessary machine-type conversions (byte ordering, structure padding
    compensation) by reading data into character array and copying to struct.
  ---------------------------------------------------------------------------*/

    G.real_ecrec_offset = G.cur_zipfile_bufstart + (G.inptr-G.inbuf);
     143:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
      G.real_ecrec_offset, G.real_ecrec_offset);
    printf("    from beginning of file; offset %d (%.4Xh) within block\n",
      G.inptr-G.inbuf, G.inptr-G.inbuf);
#endif

    if (readbuf(__G__ (char *)byterec, ECREC_SIZE+4) == 0)
     149:	8d 44 24 2a          	lea    0x2a(%esp),%eax
     14d:	89 44 24 04          	mov    %eax,0x4(%esp)
     151:	e8 00 00 00 00       	call   156 <_find_ecrec+0x156>
     156:	89 c2                	mov    %eax,%edx
        return PK_EOF;
     158:	b8 33 00 00 00       	mov    $0x33,%eax
      G.real_ecrec_offset, G.real_ecrec_offset);
    printf("    from beginning of file; offset %d (%.4Xh) within block\n",
      G.inptr-G.inbuf, G.inptr-G.inbuf);
#endif

    if (readbuf(__G__ (char *)byterec, ECREC_SIZE+4) == 0)
     15d:	85 d2                	test   %edx,%edx
     15f:	0f 84 9e 01 00 00    	je     303 <_find_ecrec+0x303>
        return PK_EOF;

    G.ecrec.number_this_disk =
      makeword(&byterec[NUMBER_THIS_DISK]);
     165:	8d 44 24 2e          	lea    0x2e(%esp),%eax
     169:	89 04 24             	mov    %eax,(%esp)
     16c:	e8 00 00 00 00       	call   171 <_find_ecrec+0x171>
#endif

    if (readbuf(__G__ (char *)byterec, ECREC_SIZE+4) == 0)
        return PK_EOF;

    G.ecrec.number_this_disk =
     171:	66 89 83 68 09 01 00 	mov    %ax,0x10968(%ebx)
      makeword(&byterec[NUMBER_THIS_DISK]);
    G.ecrec.num_disk_start_cdir =
      makeword(&byterec[NUM_DISK_WITH_START_CENTRAL_DIR]);
     178:	8d 44 24 30          	lea    0x30(%esp),%eax
     17c:	89 04 24             	mov    %eax,(%esp)
     17f:	e8 00 00 00 00       	call   184 <_find_ecrec+0x184>
    if (readbuf(__G__ (char *)byterec, ECREC_SIZE+4) == 0)
        return PK_EOF;

    G.ecrec.number_this_disk =
      makeword(&byterec[NUMBER_THIS_DISK]);
    G.ecrec.num_disk_start_cdir =
     184:	66 89 83 6a 09 01 00 	mov    %ax,0x1096a(%ebx)
      makeword(&byterec[NUM_DISK_WITH_START_CENTRAL_DIR]);
    G.ecrec.num_entries_centrl_dir_ths_disk =
      makeword(&byterec[NUM_ENTRIES_CENTRL_DIR_THS_DISK]);
     18b:	8d 44 24 32          	lea    0x32(%esp),%eax
     18f:	89 04 24             	mov    %eax,(%esp)
     192:	e8 00 00 00 00       	call   197 <_find_ecrec+0x197>

    G.ecrec.number_this_disk =
      makeword(&byterec[NUMBER_THIS_DISK]);
    G.ecrec.num_disk_start_cdir =
      makeword(&byterec[NUM_DISK_WITH_START_CENTRAL_DIR]);
    G.ecrec.num_entries_centrl_dir_ths_disk =
     197:	66 89 83 6c 09 01 00 	mov    %ax,0x1096c(%ebx)
      makeword(&byterec[NUM_ENTRIES_CENTRL_DIR_THS_DISK]);
    G.ecrec.total_entries_central_dir =
      makeword(&byterec[TOTAL_ENTRIES_CENTRAL_DIR]);
     19e:	8d 44 24 34          	lea    0x34(%esp),%eax
     1a2:	89 04 24             	mov    %eax,(%esp)
     1a5:	e8 00 00 00 00       	call   1aa <_find_ecrec+0x1aa>
      makeword(&byterec[NUMBER_THIS_DISK]);
    G.ecrec.num_disk_start_cdir =
      makeword(&byterec[NUM_DISK_WITH_START_CENTRAL_DIR]);
    G.ecrec.num_entries_centrl_dir_ths_disk =
      makeword(&byterec[NUM_ENTRIES_CENTRL_DIR_THS_DISK]);
    G.ecrec.total_entries_central_dir =
     1aa:	66 89 83 6e 09 01 00 	mov    %ax,0x1096e(%ebx)
      makeword(&byterec[TOTAL_ENTRIES_CENTRAL_DIR]);
    G.ecrec.size_central_directory =
      makelong(&byterec[SIZE_CENTRAL_DIRECTORY]);
     1b1:	8d 44 24 36          	lea    0x36(%esp),%eax
     1b5:	89 04 24             	mov    %eax,(%esp)
     1b8:	e8 00 00 00 00       	call   1bd <_find_ecrec+0x1bd>
      makeword(&byterec[NUM_DISK_WITH_START_CENTRAL_DIR]);
    G.ecrec.num_entries_centrl_dir_ths_disk =
      makeword(&byterec[NUM_ENTRIES_CENTRL_DIR_THS_DISK]);
    G.ecrec.total_entries_central_dir =
      makeword(&byterec[TOTAL_ENTRIES_CENTRAL_DIR]);
    G.ecrec.size_central_directory =
     1bd:	89 83 70 09 01 00    	mov    %eax,0x10970(%ebx)
      makelong(&byterec[SIZE_CENTRAL_DIRECTORY]);
    G.ecrec.offset_start_central_directory =
      makelong(&byterec[OFFSET_START_CENTRAL_DIRECTORY]);
     1c3:	8d 44 24 3a          	lea    0x3a(%esp),%eax
     1c7:	89 04 24             	mov    %eax,(%esp)
     1ca:	e8 00 00 00 00       	call   1cf <_find_ecrec+0x1cf>
      makeword(&byterec[NUM_ENTRIES_CENTRL_DIR_THS_DISK]);
    G.ecrec.total_entries_central_dir =
      makeword(&byterec[TOTAL_ENTRIES_CENTRAL_DIR]);
    G.ecrec.size_central_directory =
      makelong(&byterec[SIZE_CENTRAL_DIRECTORY]);
    G.ecrec.offset_start_central_directory =
     1cf:	89 83 74 09 01 00    	mov    %eax,0x10974(%ebx)
      makelong(&byterec[OFFSET_START_CENTRAL_DIRECTORY]);
    G.ecrec.zipfile_comment_length =
      makeword(&byterec[ZIPFILE_COMMENT_LENGTH]);
     1d5:	8d 44 24 3e          	lea    0x3e(%esp),%eax
     1d9:	89 04 24             	mov    %eax,(%esp)
     1dc:	e8 00 00 00 00       	call   1e1 <_find_ecrec+0x1e1>

    G.expect_ecrec_offset = G.ecrec.offset_start_central_directory +
     1e1:	8b 93 70 09 01 00    	mov    0x10970(%ebx),%edx
      makeword(&byterec[TOTAL_ENTRIES_CENTRAL_DIR]);
    G.ecrec.size_central_directory =
      makelong(&byterec[SIZE_CENTRAL_DIRECTORY]);
    G.ecrec.offset_start_central_directory =
      makelong(&byterec[OFFSET_START_CENTRAL_DIRECTORY]);
    G.ecrec.zipfile_comment_length =
     1e7:	66 89 83 78 09 01 00 	mov    %ax,0x10978(%ebx)
      makeword(&byterec[ZIPFILE_COMMENT_LENGTH]);

    G.expect_ecrec_offset = G.ecrec.offset_start_central_directory +
     1ee:	8b 83 74 09 01 00    	mov    0x10974(%ebx),%eax
     1f4:	01 d0                	add    %edx,%eax
     1f6:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
                          G.ecrec.size_central_directory;
    return PK_COOL;
     1fc:	31 c0                	xor    %eax,%eax
     1fe:	e9 00 01 00 00       	jmp    303 <_find_ecrec+0x303>
/*---------------------------------------------------------------------------
    Treat case of short zipfile separately.
  ---------------------------------------------------------------------------*/

    if (G.ziplen <= INBUFSIZ) {
        lseek(G.zipfd, 0L, SEEK_SET);
     203:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     209:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     210:	00 
     211:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     218:	00 
     219:	89 04 24             	mov    %eax,(%esp)
     21c:	e8 00 00 00 00       	call   221 <_find_ecrec+0x221>
        if ((G.incnt = read(G.zipfd,(char *)G.inbuf,(unsigned int)G.ziplen))
     221:	8b 83 0c 09 01 00    	mov    0x1090c(%ebx),%eax
     227:	89 44 24 08          	mov    %eax,0x8(%esp)
     22b:	8b 83 e4 08 01 00    	mov    0x108e4(%ebx),%eax
     231:	89 44 24 04          	mov    %eax,0x4(%esp)
     235:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     23b:	89 04 24             	mov    %eax,(%esp)
     23e:	e8 00 00 00 00       	call   243 <_find_ecrec+0x243>
     243:	89 c5                	mov    %eax,%ebp
     245:	89 83 ec 08 01 00    	mov    %eax,0x108ec(%ebx)
     24b:	3b 83 0c 09 01 00    	cmp    0x1090c(%ebx),%eax
     251:	0f 84 d4 01 00 00    	je     42b <_find_ecrec+0x42b>
    it.  Print informational message and die a horrible death.
  ---------------------------------------------------------------------------*/

fail:
    if (!found) {
        if (uO.qflag || uO.zipinfo_mode)
     257:	8b 7b 38             	mov    0x38(%ebx),%edi
     25a:	85 ff                	test   %edi,%edi
     25c:	75 0d                	jne    26b <_find_ecrec+0x26b>
     25e:	8b 73 0c             	mov    0xc(%ebx),%esi
     261:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     267:	85 f6                	test   %esi,%esi
     269:	74 3e                	je     2a9 <_find_ecrec+0x2a9>
            Info(slide, 0x401, ((char *)slide, "[%s]\n", G.zipfn));
     26b:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     271:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     277:	89 44 24 08          	mov    %eax,0x8(%esp)
     27b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     282:	00 
     283:	89 2c 24             	mov    %ebp,(%esp)
     286:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     28c:	e8 00 00 00 00       	call   291 <_find_ecrec+0x291>
     291:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     298:	00 
     299:	89 44 24 08          	mov    %eax,0x8(%esp)
     29d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     2a1:	89 1c 24             	mov    %ebx,(%esp)
     2a4:	ff d6                	call   *%esi
     2a6:	83 ec 10             	sub    $0x10,%esp
        Info(slide, 0x401, ((char *)slide,
     2a9:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     2af:	89 ef                	mov    %ebp,%edi
     2b1:	be 08 00 00 00       	mov    $0x8,%esi
     2b6:	b8 00 01 00 00       	mov    $0x100,%eax
     2bb:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     2c1:	0f 85 be 01 00 00    	jne    485 <_find_ecrec+0x485>
     2c7:	f7 c7 02 00 00 00    	test   $0x2,%edi
     2cd:	0f 85 d2 01 00 00    	jne    4a5 <_find_ecrec+0x4a5>
     2d3:	89 c1                	mov    %eax,%ecx
     2d5:	c1 e9 02             	shr    $0x2,%ecx
     2d8:	a8 02                	test   $0x2,%al
     2da:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     2dc:	75 6e                	jne    34c <_find_ecrec+0x34c>
     2de:	a8 01                	test   $0x1,%al
     2e0:	75 62                	jne    344 <_find_ecrec+0x344>
     2e2:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     2e9:	00 
     2ea:	c7 44 24 08 ff 00 00 	movl   $0xff,0x8(%esp)
     2f1:	00 
     2f2:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     2f6:	89 1c 24             	mov    %ebx,(%esp)
     2f9:	ff d2                	call   *%edx
          LoadFarString(CentDirEndSigNotFound)));
        return PK_ERR;   /* failed */
     2fb:	b8 02 00 00 00       	mov    $0x2,%eax

fail:
    if (!found) {
        if (uO.qflag || uO.zipinfo_mode)
            Info(slide, 0x401, ((char *)slide, "[%s]\n", G.zipfn));
        Info(slide, 0x401, ((char *)slide,
     300:	83 ec 10             	sub    $0x10,%esp

    G.expect_ecrec_offset = G.ecrec.offset_start_central_directory +
                          G.ecrec.size_central_directory;
    return PK_COOL;

} /* end function find_ecrec() */
     303:	83 c4 4c             	add    $0x4c,%esp
     306:	5b                   	pop    %ebx
     307:	5e                   	pop    %esi
     308:	5f                   	pop    %edi
     309:	5d                   	pop    %ebp
     30a:	c3                   	ret    
     30b:	90                   	nop
     30c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                    G.incnt -= (int)(G.inptr - G.inbuf);
                    found = TRUE;
                    break;
                }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     310:	8b 83 1c 09 01 00    	mov    0x1091c(%ebx),%eax
     316:	66 8b 17             	mov    (%edi),%dx
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
     319:	8b 6c 24 18          	mov    0x18(%esp),%ebp
                    G.incnt -= (int)(G.inptr - G.inbuf);
                    found = TRUE;
                    break;
                }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     31d:	66 89 10             	mov    %dx,(%eax)
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
     320:	45                   	inc    %ebp
                    G.incnt -= (int)(G.inptr - G.inbuf);
                    found = TRUE;
                    break;
                }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     321:	8a 4f 02             	mov    0x2(%edi),%cl
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
     324:	89 6c 24 18          	mov    %ebp,0x18(%esp)
                    G.incnt -= (int)(G.inptr - G.inbuf);
                    found = TRUE;
                    break;
                }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     328:	88 48 02             	mov    %cl,0x2(%eax)
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
     32b:	8b 44 24 18          	mov    0x18(%esp),%eax
     32f:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
     333:	0f 8f 1e ff ff ff    	jg     257 <_find_ecrec+0x257>
     339:	8b 83 10 09 01 00    	mov    0x10910(%ebx),%eax
     33f:	e9 1c fd ff ff       	jmp    60 <_find_ecrec+0x60>

fail:
    if (!found) {
        if (uO.qflag || uO.zipinfo_mode)
            Info(slide, 0x401, ((char *)slide, "[%s]\n", G.zipfn));
        Info(slide, 0x401, ((char *)slide,
     344:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     347:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     34a:	eb 96                	jmp    2e2 <_find_ecrec+0x2e2>
     34c:	66 8b 0e             	mov    (%esi),%cx
     34f:	a8 01                	test   $0x1,%al
     351:	66 89 0f             	mov    %cx,(%edi)
     354:	b9 02 00 00 00       	mov    $0x2,%ecx
     359:	74 87                	je     2e2 <_find_ecrec+0x2e2>
     35b:	eb e7                	jmp    344 <_find_ecrec+0x344>
        if ((tail_len = G.ziplen % INBUFSIZ) > ECREC_SIZE) {
#ifdef USE_STRM_INPUT
            fseek((FILE *)G.zipfd, G.ziplen-tail_len, SEEK_SET);
            G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);
#else /* !USE_STRM_INPUT */
            G.cur_zipfile_bufstart = lseek(G.zipfd, G.ziplen-tail_len,
     35d:	29 f8                	sub    %edi,%eax
     35f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     366:	00 
     367:	89 44 24 04          	mov    %eax,0x4(%esp)
     36b:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     371:	89 04 24             	mov    %eax,(%esp)
     374:	89 54 24 18          	mov    %edx,0x18(%esp)
     378:	e8 00 00 00 00       	call   37d <_find_ecrec+0x37d>
              SEEK_SET);
#endif /* ?USE_STRM_INPUT */
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf,
     37d:	89 7c 24 08          	mov    %edi,0x8(%esp)
        if ((tail_len = G.ziplen % INBUFSIZ) > ECREC_SIZE) {
#ifdef USE_STRM_INPUT
            fseek((FILE *)G.zipfd, G.ziplen-tail_len, SEEK_SET);
            G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);
#else /* !USE_STRM_INPUT */
            G.cur_zipfile_bufstart = lseek(G.zipfd, G.ziplen-tail_len,
     381:	89 83 10 09 01 00    	mov    %eax,0x10910(%ebx)
              SEEK_SET);
#endif /* ?USE_STRM_INPUT */
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf,
     387:	8b 83 e4 08 01 00    	mov    0x108e4(%ebx),%eax
     38d:	89 44 24 04          	mov    %eax,0x4(%esp)
     391:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     397:	89 04 24             	mov    %eax,(%esp)
     39a:	e8 00 00 00 00       	call   39f <_find_ecrec+0x39f>
     39f:	8b 54 24 18          	mov    0x18(%esp),%edx
     3a3:	89 83 ec 08 01 00    	mov    %eax,0x108ec(%ebx)
     3a9:	39 c7                	cmp    %eax,%edi
     3ab:	0f 85 a6 fe ff ff    	jne    257 <_find_ecrec+0x257>
                (unsigned int)tail_len)) != (int)tail_len)
                goto fail;      /* it's expedient... */

            /* 'P' must be at least (ECREC_SIZE+4) bytes from end of zipfile */
            for (G.inptr = G.inbuf+(int)tail_len-(ECREC_SIZE+4);
     3b1:	8b ab e4 08 01 00    	mov    0x108e4(%ebx),%ebp
     3b7:	8d 74 3d ea          	lea    -0x16(%ebp,%edi,1),%esi
     3bb:	89 b3 e8 08 01 00    	mov    %esi,0x108e8(%ebx)
     3c1:	39 f5                	cmp    %esi,%ebp
     3c3:	76 1a                	jbe    3df <_find_ecrec+0x3df>
     3c5:	e9 f0 00 00 00       	jmp    4ba <_find_ecrec+0x4ba>
     3ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                 G.inptr >= G.inbuf;
                 --G.inptr) {
     3d0:	4e                   	dec    %esi
     3d1:	89 b3 e8 08 01 00    	mov    %esi,0x108e8(%ebx)
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf,
                (unsigned int)tail_len)) != (int)tail_len)
                goto fail;      /* it's expedient... */

            /* 'P' must be at least (ECREC_SIZE+4) bytes from end of zipfile */
            for (G.inptr = G.inbuf+(int)tail_len-(ECREC_SIZE+4);
     3d7:	39 f5                	cmp    %esi,%ebp
     3d9:	0f 87 db 00 00 00    	ja     4ba <_find_ecrec+0x4ba>
                 G.inptr >= G.inbuf;
                 --G.inptr) {
                if ( (*G.inptr == (uch)0x50) &&         /* ASCII 'P' */
     3df:	80 3e 50             	cmpb   $0x50,(%esi)
     3e2:	75 ec                	jne    3d0 <_find_ecrec+0x3d0>
                     !strncmp((char *)G.inptr, end_central_sig, 4)) {
     3e4:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     3eb:	00 
     3ec:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     3f3:	00 
     3f4:	89 34 24             	mov    %esi,(%esp)
     3f7:	89 54 24 18          	mov    %edx,0x18(%esp)
     3fb:	e8 00 00 00 00       	call   400 <_find_ecrec+0x400>

            /* 'P' must be at least (ECREC_SIZE+4) bytes from end of zipfile */
            for (G.inptr = G.inbuf+(int)tail_len-(ECREC_SIZE+4);
                 G.inptr >= G.inbuf;
                 --G.inptr) {
                if ( (*G.inptr == (uch)0x50) &&         /* ASCII 'P' */
     400:	8b 54 24 18          	mov    0x18(%esp),%edx
     404:	85 c0                	test   %eax,%eax
     406:	75 c8                	jne    3d0 <_find_ecrec+0x3d0>
                     !strncmp((char *)G.inptr, end_central_sig, 4)) {
                    G.incnt -= (int)(G.inptr - G.inbuf);
     408:	89 e8                	mov    %ebp,%eax
     40a:	29 f0                	sub    %esi,%eax
     40c:	01 c7                	add    %eax,%edi
                    found = TRUE;
                    break;
                }
            }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     40e:	8b 83 1c 09 01 00    	mov    0x1091c(%ebx),%eax
            for (G.inptr = G.inbuf+(int)tail_len-(ECREC_SIZE+4);
                 G.inptr >= G.inbuf;
                 --G.inptr) {
                if ( (*G.inptr == (uch)0x50) &&         /* ASCII 'P' */
                     !strncmp((char *)G.inptr, end_central_sig, 4)) {
                    G.incnt -= (int)(G.inptr - G.inbuf);
     414:	89 bb ec 08 01 00    	mov    %edi,0x108ec(%ebx)
                    found = TRUE;
                    break;
                }
            }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     41a:	8b 55 00             	mov    0x0(%ebp),%edx
     41d:	66 89 10             	mov    %dx,(%eax)
     420:	8a 4d 02             	mov    0x2(%ebp),%cl
     423:	88 48 02             	mov    %cl,0x2(%eax)
     426:	e9 f7 fc ff ff       	jmp    122 <_find_ecrec+0x122>
        lseek(G.zipfd, 0L, SEEK_SET);
        if ((G.incnt = read(G.zipfd,(char *)G.inbuf,(unsigned int)G.ziplen))
            == (int)G.ziplen)

            /* 'P' must be at least (ECREC_SIZE+4) bytes from end of zipfile */
            for (G.inptr = G.inbuf+(int)G.ziplen-(ECREC_SIZE+4);
     42b:	8b bb e4 08 01 00    	mov    0x108e4(%ebx),%edi
     431:	8d 74 07 ea          	lea    -0x16(%edi,%eax,1),%esi
     435:	89 b3 e8 08 01 00    	mov    %esi,0x108e8(%ebx)
     43b:	39 f7                	cmp    %esi,%edi
     43d:	76 14                	jbe    453 <_find_ecrec+0x453>
     43f:	e9 13 fe ff ff       	jmp    257 <_find_ecrec+0x257>
                 G.inptr >= G.inbuf;
                 --G.inptr) {
     444:	4e                   	dec    %esi
     445:	89 b3 e8 08 01 00    	mov    %esi,0x108e8(%ebx)
        lseek(G.zipfd, 0L, SEEK_SET);
        if ((G.incnt = read(G.zipfd,(char *)G.inbuf,(unsigned int)G.ziplen))
            == (int)G.ziplen)

            /* 'P' must be at least (ECREC_SIZE+4) bytes from end of zipfile */
            for (G.inptr = G.inbuf+(int)G.ziplen-(ECREC_SIZE+4);
     44b:	39 f7                	cmp    %esi,%edi
     44d:	0f 87 04 fe ff ff    	ja     257 <_find_ecrec+0x257>
                 G.inptr >= G.inbuf;
                 --G.inptr) {
                if ( (*G.inptr == (uch)0x50) &&         /* ASCII 'P' */
     453:	80 3e 50             	cmpb   $0x50,(%esi)
     456:	75 ec                	jne    444 <_find_ecrec+0x444>
                     !strncmp((char *)G.inptr, end_central_sig, 4)) {
     458:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     45f:	00 
     460:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     467:	00 
     468:	89 34 24             	mov    %esi,(%esp)
     46b:	e8 00 00 00 00       	call   470 <_find_ecrec+0x470>

            /* 'P' must be at least (ECREC_SIZE+4) bytes from end of zipfile */
            for (G.inptr = G.inbuf+(int)G.ziplen-(ECREC_SIZE+4);
                 G.inptr >= G.inbuf;
                 --G.inptr) {
                if ( (*G.inptr == (uch)0x50) &&         /* ASCII 'P' */
     470:	85 c0                	test   %eax,%eax
     472:	75 d0                	jne    444 <_find_ecrec+0x444>
                     !strncmp((char *)G.inptr, end_central_sig, 4)) {
                    G.incnt -= (int)(G.inptr - G.inbuf);
     474:	89 f8                	mov    %edi,%eax
     476:	29 f0                	sub    %esi,%eax
     478:	01 c5                	add    %eax,%ebp
     47a:	89 ab ec 08 01 00    	mov    %ebp,0x108ec(%ebx)
     480:	e9 a3 fc ff ff       	jmp    128 <_find_ecrec+0x128>

fail:
    if (!found) {
        if (uO.qflag || uO.zipinfo_mode)
            Info(slide, 0x401, ((char *)slide, "[%s]\n", G.zipfn));
        Info(slide, 0x401, ((char *)slide,
     485:	a0 08 00 00 00       	mov    0x8,%al
     48a:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
     490:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
     496:	be 09 00 00 00       	mov    $0x9,%esi
     49b:	b8 ff 00 00 00       	mov    $0xff,%eax
     4a0:	e9 22 fe ff ff       	jmp    2c7 <_find_ecrec+0x2c7>
     4a5:	66 8b 0e             	mov    (%esi),%cx
     4a8:	83 c7 02             	add    $0x2,%edi
     4ab:	66 89 4f fe          	mov    %cx,-0x2(%edi)
     4af:	83 c6 02             	add    $0x2,%esi
     4b2:	83 e8 02             	sub    $0x2,%eax
     4b5:	e9 19 fe ff ff       	jmp    2d3 <_find_ecrec+0x2d3>
     4ba:	29 fa                	sub    %edi,%edx
                    found = TRUE;
                    break;
                }
            }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     4bc:	8b 4d 00             	mov    0x0(%ebp),%ecx
     4bf:	8d 82 fe 3f 00 00    	lea    0x3ffe(%edx),%eax
     4c5:	81 c2 ff 1f 00 00    	add    $0x1fff,%edx
     4cb:	0f 49 c2             	cmovns %edx,%eax
     4ce:	c1 f8 0d             	sar    $0xd,%eax
     4d1:	85 c0                	test   %eax,%eax
            if ((G.incnt = read(G.zipfd, (char *)G.inbuf,
                (unsigned int)tail_len)) != (int)tail_len)
                goto fail;      /* it's expedient... */

            /* 'P' must be at least (ECREC_SIZE+4) bytes from end of zipfile */
            for (G.inptr = G.inbuf+(int)tail_len-(ECREC_SIZE+4);
     4d3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
                    found = TRUE;
                    break;
                }
            }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     4d7:	8b 83 1c 09 01 00    	mov    0x1091c(%ebx),%eax
     4dd:	0f 9f c2             	setg   %dl
     4e0:	66 89 08             	mov    %cx,(%eax)
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
     4e3:	84 d2                	test   %dl,%dl
                    found = TRUE;
                    break;
                }
            }
            /* sig may span block boundary: */
            memcpy((char *)G.hold, (char *)G.inbuf, 3);
     4e5:	8a 4d 02             	mov    0x2(%ebp),%cl
     4e8:	88 48 02             	mov    %cl,0x2(%eax)
      -----------------------------------------------------------------------*/

        numblks = (int)((searchlen - tail_len + (INBUFSIZ-1)) / INBUFSIZ);
        /*               ==amount=   ==done==   ==rounding==    =blksiz=  */

        for (i = 1;  !found && (i <= numblks);  ++i) {
     4eb:	0f 84 66 fd ff ff    	je     257 <_find_ecrec+0x257>
     4f1:	8b 83 10 09 01 00    	mov    0x10910(%ebx),%eax
     4f7:	e9 57 fb ff ff       	jmp    53 <_find_ecrec+0x53>
     4fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000500 <_free_G_buffers>:
/* Function free_G_buffers() */
/*****************************/

void free_G_buffers(__G)     /* releases all memory allocated in global vars */
    __GDEF
{
     500:	56                   	push   %esi
     501:	53                   	push   %ebx
     502:	83 ec 14             	sub    $0x14,%esp
     505:	8b 74 24 20          	mov    0x20(%esp),%esi

#ifdef SYSTEM_SPECIFIC_DTOR
    SYSTEM_SPECIFIC_DTOR(__G);
#endif

    inflate_free(__G);
     509:	89 34 24             	mov    %esi,(%esp)
     50c:	e8 00 00 00 00       	call   511 <_free_G_buffers+0x11>
    checkdir(__G__ (char *)NULL, END);
     511:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
     518:	00 
     519:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     520:	00 
     521:	89 34 24             	mov    %esi,(%esp)
     524:	e8 00 00 00 00       	call   529 <_free_G_buffers+0x29>
        free_crc_table();
        CRC_32_TAB = NULL;
    }
#endif

   if (G.key != (char *)NULL) {
     529:	8b 86 e4 0a 01 00    	mov    0x10ae4(%esi),%eax
     52f:	85 c0                	test   %eax,%eax
     531:	74 12                	je     545 <_free_G_buffers+0x45>
        free(G.key);
     533:	89 04 24             	mov    %eax,(%esp)
     536:	e8 00 00 00 00       	call   53b <_free_G_buffers+0x3b>
        G.key = (char *)NULL;
     53b:	c7 86 e4 0a 01 00 00 	movl   $0x0,0x10ae4(%esi)
     542:	00 00 00 
   }

   if (G.extra_field != (uch *)NULL) {
     545:	8b 86 18 09 01 00    	mov    0x10918(%esi),%eax
     54b:	85 c0                	test   %eax,%eax
     54d:	74 12                	je     561 <_free_G_buffers+0x61>
        free(G.extra_field);
     54f:	89 04 24             	mov    %eax,(%esp)
     552:	e8 00 00 00 00       	call   557 <_free_G_buffers+0x57>
        G.extra_field = (uch *)NULL;
     557:	c7 86 18 09 01 00 00 	movl   $0x0,0x10918(%esi)
     55e:	00 00 00 
   }

#if (!defined(VMS) && !defined(SMALL_MEM))
    /* VMS uses its own buffer scheme for textmode flush() */
    if (G.outbuf2) {
     561:	8b 86 d4 09 01 00    	mov    0x109d4(%esi),%eax
     567:	85 c0                	test   %eax,%eax
     569:	74 12                	je     57d <_free_G_buffers+0x7d>
        free(G.outbuf2);   /* malloc'd ONLY if unshrink and -a */
     56b:	89 04 24             	mov    %eax,(%esp)
     56e:	e8 00 00 00 00       	call   573 <_free_G_buffers+0x73>
        G.outbuf2 = (uch *)NULL;
     573:	c7 86 d4 09 01 00 00 	movl   $0x0,0x109d4(%esi)
     57a:	00 00 00 
    }
#endif

    if (G.outbuf)
     57d:	8b 86 cc 09 01 00    	mov    0x109cc(%esi),%eax
     583:	85 c0                	test   %eax,%eax
     585:	74 08                	je     58f <_free_G_buffers+0x8f>
        free(G.outbuf);
     587:	89 04 24             	mov    %eax,(%esp)
     58a:	e8 00 00 00 00       	call   58f <_free_G_buffers+0x8f>
    if (G.inbuf)
     58f:	8b 86 e4 08 01 00    	mov    0x108e4(%esi),%eax
     595:	85 c0                	test   %eax,%eax
     597:	74 08                	je     5a1 <_free_G_buffers+0xa1>
        free(G.inbuf);
     599:	89 04 24             	mov    %eax,(%esp)
     59c:	e8 00 00 00 00       	call   5a1 <_free_G_buffers+0xa1>
    G.inbuf = G.outbuf = (uch *)NULL;
     5a1:	c7 86 cc 09 01 00 00 	movl   $0x0,0x109cc(%esi)
     5a8:	00 00 00 
     5ab:	c7 86 e4 08 01 00 00 	movl   $0x0,0x108e4(%esi)
     5b2:	00 00 00 
     5b5:	8d 9e f4 00 00 00    	lea    0xf4(%esi),%ebx
     5bb:	81 c6 f4 08 00 00    	add    $0x8f4,%esi

#ifndef SFX
    for (i = 0; i < DIR_BLKSIZ; i++) {
        if (G.info[i].cfilname != (char Far *)NULL) {
     5c1:	8b 03                	mov    (%ebx),%eax
     5c3:	85 c0                	test   %eax,%eax
     5c5:	74 0e                	je     5d5 <_free_G_buffers+0xd5>
            zffree(G.info[i].cfilname);
     5c7:	89 04 24             	mov    %eax,(%esp)
     5ca:	e8 00 00 00 00       	call   5cf <_free_G_buffers+0xcf>
            G.info[i].cfilname = (char Far *)NULL;
     5cf:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
     5d5:	83 c3 20             	add    $0x20,%ebx
    if (G.inbuf)
        free(G.inbuf);
    G.inbuf = G.outbuf = (uch *)NULL;

#ifndef SFX
    for (i = 0; i < DIR_BLKSIZ; i++) {
     5d8:	39 f3                	cmp    %esi,%ebx
     5da:	75 e5                	jne    5c1 <_free_G_buffers+0xc1>
        free(G.area.Slide);
        G.area.Slide = (uch *)NULL;
    }
#endif

} /* end function free_G_buffers() */
     5dc:	83 c4 14             	add    $0x14,%esp
     5df:	5b                   	pop    %ebx
     5e0:	5e                   	pop    %esi
     5e1:	c3                   	ret    
     5e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     5e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000005f0 <_uz_end_central>:
/* Function uz_end_central() */
/*****************************/

int uz_end_central(__G)    /* return PK-type error code */
    __GDEF
{
     5f0:	55                   	push   %ebp
     5f1:	57                   	push   %edi
     5f2:	56                   	push   %esi
     5f3:	53                   	push   %ebx
     5f4:	83 ec 1c             	sub    $0x1c,%esp
     5f7:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    and fill buffer.
  ---------------------------------------------------------------------------*/

#ifdef WINDLL
    /* for comment button: */
    if ((!G.fValidate) && (G.lpUserFunctions != NULL))
     5fb:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
     601:	85 d2                	test   %edx,%edx
     603:	75 2b                	jne    630 <_uz_end_central+0x40>
     605:	8b 93 58 0b 01 00    	mov    0x10b58(%ebx),%edx
     60b:	85 d2                	test   %edx,%edx
     60d:	74 21                	je     630 <_uz_end_central+0x40>
       G.lpUserFunctions->cchComment = G.ecrec.zipfile_comment_length;
     60f:	8b b3 78 09 01 00    	mov    0x10978(%ebx),%esi
    if (G.ecrec.zipfile_comment_length && (uO.zflag > 0))
     615:	66 85 f6             	test   %si,%si
  ---------------------------------------------------------------------------*/

#ifdef WINDLL
    /* for comment button: */
    if ((!G.fValidate) && (G.lpUserFunctions != NULL))
       G.lpUserFunctions->cchComment = G.ecrec.zipfile_comment_length;
     618:	66 89 72 28          	mov    %si,0x28(%edx)
    if (G.ecrec.zipfile_comment_length && (uO.zflag > 0))
     61c:	75 1d                	jne    63b <_uz_end_central+0x4b>
     61e:	66 90                	xchg   %ax,%ax
        }
    }
#endif
    return error;

} /* end function uz_end_central() */
     620:	83 c4 1c             	add    $0x1c,%esp
/*****************************/

int uz_end_central(__G)    /* return PK-type error code */
    __GDEF
{
    int error = PK_COOL;
     623:	31 c0                	xor    %eax,%eax
        }
    }
#endif
    return error;

} /* end function uz_end_central() */
     625:	5b                   	pop    %ebx
     626:	5e                   	pop    %esi
     627:	5f                   	pop    %edi
     628:	5d                   	pop    %ebp
     629:	c3                   	ret    
     62a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     630:	8b b3 78 09 01 00    	mov    0x10978(%ebx),%esi

#ifdef WINDLL
    /* for comment button: */
    if ((!G.fValidate) && (G.lpUserFunctions != NULL))
       G.lpUserFunctions->cchComment = G.ecrec.zipfile_comment_length;
    if (G.ecrec.zipfile_comment_length && (uO.zflag > 0))
     636:	66 85 f6             	test   %si,%si
     639:	74 e5                	je     620 <_uz_end_central+0x30>
     63b:	8b 43 60             	mov    0x60(%ebx),%eax
     63e:	85 c0                	test   %eax,%eax
     640:	7e de                	jle    620 <_uz_end_central+0x30>
#endif /* ?WINDLL */
    {
#if (defined(SFX) && defined(CHEAP_SFX_AUTORUN))
        if (do_string(__G__ G.ecrec.zipfile_comment_length, CHECK_AUTORUN)) {
#else
        if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY)) {
     642:	31 c0                	xor    %eax,%eax
     644:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
     64b:	00 
     64c:	66 89 f0             	mov    %si,%ax
     64f:	89 1c 24             	mov    %ebx,(%esp)
     652:	89 44 24 04          	mov    %eax,0x4(%esp)
     656:	e8 00 00 00 00       	call   65b <_uz_end_central+0x6b>
     65b:	85 c0                	test   %eax,%eax
     65d:	74 c1                	je     620 <_uz_end_central+0x30>
#endif
            Info(slide, 0x401, ((char *)slide,
     65f:	8d 83 dc 08 00 00    	lea    0x8dc(%ebx),%eax
     665:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
     66b:	89 c7                	mov    %eax,%edi
     66d:	be 08 01 00 00       	mov    $0x108,%esi
     672:	ba 26 00 00 00       	mov    $0x26,%edx
     677:	a8 01                	test   $0x1,%al
     679:	75 55                	jne    6d0 <_uz_end_central+0xe0>
     67b:	f7 c7 02 00 00 00    	test   $0x2,%edi
     681:	75 6d                	jne    6f0 <_uz_end_central+0x100>
     683:	89 d1                	mov    %edx,%ecx
     685:	c1 e9 02             	shr    $0x2,%ecx
     688:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     68a:	f6 c2 02             	test   $0x2,%dl
     68d:	74 0b                	je     69a <_uz_end_central+0xaa>
     68f:	66 8b 0e             	mov    (%esi),%cx
     692:	66 89 0f             	mov    %cx,(%edi)
     695:	b9 02 00 00 00       	mov    $0x2,%ecx
     69a:	83 e2 01             	and    $0x1,%edx
     69d:	74 06                	je     6a5 <_uz_end_central+0xb5>
     69f:	8a 14 0e             	mov    (%esi,%ecx,1),%dl
     6a2:	88 14 0f             	mov    %dl,(%edi,%ecx,1)
     6a5:	89 1c 24             	mov    %ebx,(%esp)
     6a8:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     6af:	00 
     6b0:	c7 44 24 08 25 00 00 	movl   $0x25,0x8(%esp)
     6b7:	00 
     6b8:	89 44 24 04          	mov    %eax,0x4(%esp)
     6bc:	ff d5                	call   *%ebp
     6be:	b8 01 00 00 00       	mov    $0x1,%eax
     6c3:	83 ec 10             	sub    $0x10,%esp
        }
    }
#endif
    return error;

} /* end function uz_end_central() */
     6c6:	83 c4 1c             	add    $0x1c,%esp
     6c9:	5b                   	pop    %ebx
     6ca:	5e                   	pop    %esi
     6cb:	5f                   	pop    %edi
     6cc:	5d                   	pop    %ebp
     6cd:	c3                   	ret    
     6ce:	66 90                	xchg   %ax,%ax
#if (defined(SFX) && defined(CHEAP_SFX_AUTORUN))
        if (do_string(__G__ G.ecrec.zipfile_comment_length, CHECK_AUTORUN)) {
#else
        if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY)) {
#endif
            Info(slide, 0x401, ((char *)slide,
     6d0:	8a 0d 08 01 00 00    	mov    0x108,%cl
     6d6:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
     6dc:	88 8b dc 08 00 00    	mov    %cl,0x8dc(%ebx)
     6e2:	be 09 01 00 00       	mov    $0x109,%esi
     6e7:	b2 25                	mov    $0x25,%dl
     6e9:	eb 90                	jmp    67b <_uz_end_central+0x8b>
     6eb:	90                   	nop
     6ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     6f0:	66 8b 0e             	mov    (%esi),%cx
     6f3:	83 c7 02             	add    $0x2,%edi
     6f6:	66 89 4f fe          	mov    %cx,-0x2(%edi)
     6fa:	83 c6 02             	add    $0x2,%esi
     6fd:	83 ea 02             	sub    $0x2,%edx
     700:	eb 81                	jmp    683 <_uz_end_central+0x93>
     702:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000710 <_do_seekable>:
/**************************/

static int do_seekable(__G__ lastchance)        /* return PK-type error code */
    __GDEF
    int lastchance;
{
     710:	55                   	push   %ebp
     711:	57                   	push   %edi
     712:	56                   	push   %esi
     713:	53                   	push   %ebx
     714:	83 ec 4c             	sub    $0x4c,%esp
     717:	89 c3                	mov    %eax,%ebx
/*---------------------------------------------------------------------------
    Open the zipfile for reading in BINARY mode to prevent CR/LF translation,
    which would corrupt the bit streams.
  ---------------------------------------------------------------------------*/

    if (SSTAT(G.zipfn, &G.statbuf) ||
     719:	8d 80 7c 09 01 00    	lea    0x1097c(%eax),%eax
/**************************/

static int do_seekable(__G__ lastchance)        /* return PK-type error code */
    __GDEF
    int lastchance;
{
     71f:	89 d7                	mov    %edx,%edi
/*---------------------------------------------------------------------------
    Open the zipfile for reading in BINARY mode to prevent CR/LF translation,
    which would corrupt the bit streams.
  ---------------------------------------------------------------------------*/

    if (SSTAT(G.zipfn, &G.statbuf) ||
     721:	89 44 24 08          	mov    %eax,0x8(%esp)
     725:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     72b:	89 44 24 04          	mov    %eax,0x4(%esp)
     72f:	89 1c 24             	mov    %ebx,(%esp)
    /* static int no_ecrec = FALSE;  SKM: moved to globals.h */
    int maybe_exe=FALSE;
    int too_weird_to_continue=FALSE;
#ifdef TIMESTAMP
    time_t uxstamp;
    ulg nmember = 0L;
     732:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
     739:	00 
/*---------------------------------------------------------------------------
    Open the zipfile for reading in BINARY mode to prevent CR/LF translation,
    which would corrupt the bit streams.
  ---------------------------------------------------------------------------*/

    if (SSTAT(G.zipfn, &G.statbuf) ||
     73a:	e8 00 00 00 00       	call   73f <_do_seekable+0x2f>
     73f:	85 c0                	test   %eax,%eax
     741:	0f 85 ad 00 00 00    	jne    7f4 <_do_seekable+0xe4>
#ifdef THEOS
        (error = S_ISLIB(G.statbuf.st_mode)) != 0 ||
#endif
        (error = S_ISDIR(G.statbuf.st_mode)) != 0)
     747:	66 8b ab 82 09 01 00 	mov    0x10982(%ebx),%bp
     74e:	89 e8                	mov    %ebp,%eax
     750:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/*---------------------------------------------------------------------------
    Open the zipfile for reading in BINARY mode to prevent CR/LF translation,
    which would corrupt the bit streams.
  ---------------------------------------------------------------------------*/

    if (SSTAT(G.zipfn, &G.statbuf) ||
     755:	66 3d 00 40          	cmp    $0x4000,%ax
     759:	0f 85 b3 00 00 00    	jne    812 <_do_seekable+0x102>
        (error = S_ISLIB(G.statbuf.st_mode)) != 0 ||
#endif
        (error = S_ISDIR(G.statbuf.st_mode)) != 0)
    {
#ifndef SFX
        if (lastchance && (uO.qflag < 3)) {
     75f:	85 ff                	test   %edi,%edi
     761:	0f 84 c7 01 00 00    	je     92e <_do_seekable+0x21e>
     767:	83 7b 38 02          	cmpl   $0x2,0x38(%ebx)
     76b:	0f 8f bd 01 00 00    	jg     92e <_do_seekable+0x21e>
     771:	be 01 00 00 00       	mov    $0x1,%esi
                Info(slide, 1, ((char *)slide,
                  LoadFarString(CannotFindEitherZipfile), uO.zipinfo_mode?
                  LoadFarStringSmall(Zipnfo) : LoadFarStringSmall(Unzip),
                  G.wildzipfn, G.wildzipfn, G.zipfn));
#else /* !(UNIX || QDOS) */
            if (G.no_ecrec)
     776:	8b 8b c4 09 01 00    	mov    0x109c4(%ebx),%ecx
     77c:	85 c9                	test   %ecx,%ecx
     77e:	0f 84 3f 01 00 00    	je     8c3 <_do_seekable+0x1b3>
                Info(slide, 0x401, ((char *)slide,
     784:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
     78a:	8b 53 0c             	mov    0xc(%ebx),%edx
     78d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
     791:	85 d2                	test   %edx,%edx
     793:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     799:	0f 85 a1 01 00 00    	jne    940 <_do_seekable+0x230>
     79f:	8b ab 00 09 01 00    	mov    0x10900(%ebx),%ebp
     7a5:	b9 2e 01 00 00       	mov    $0x12e,%ecx
     7aa:	ba 58 07 00 00       	mov    $0x758,%edx
     7af:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     7b5:	89 44 24 14          	mov    %eax,0x14(%esp)
     7b9:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     7bd:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
     7c1:	89 54 24 08          	mov    %edx,0x8(%esp)
     7c5:	c7 44 24 04 c0 07 00 	movl   $0x7c0,0x4(%esp)
     7cc:	00 
     7cd:	89 3c 24             	mov    %edi,(%esp)
     7d0:	e8 00 00 00 00       	call   7d5 <_do_seekable+0xc5>
     7d5:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     7dc:	00 
     7dd:	89 44 24 08          	mov    %eax,0x8(%esp)
     7e1:	89 7c 24 04          	mov    %edi,0x4(%esp)
     7e5:	89 1c 24             	mov    %ebx,(%esp)
     7e8:	ff 54 24 2c          	call   *0x2c(%esp)
     7ec:	83 ec 10             	sub    $0x10,%esp
     7ef:	e9 2d 01 00 00       	jmp    921 <_do_seekable+0x211>
        (error = S_ISLIB(G.statbuf.st_mode)) != 0 ||
#endif
        (error = S_ISDIR(G.statbuf.st_mode)) != 0)
    {
#ifndef SFX
        if (lastchance && (uO.qflag < 3)) {
     7f4:	85 ff                	test   %edi,%edi
     7f6:	75 0d                	jne    805 <_do_seekable+0xf5>
            G.zipfn));
        if (lastchance)
            return error_in_archive;
        else {
            G.no_ecrec = TRUE;    /* assume we found wrong file:  e.g., */
            return PK_NOZIP;       /*  unzip instead of unzip.zip */
     7f8:	b8 09 00 00 00       	mov    $0x9,%eax
        }
    }
#endif
    return error_in_archive;

} /* end function do_seekable() */
     7fd:	83 c4 4c             	add    $0x4c,%esp
     800:	5b                   	pop    %ebx
     801:	5e                   	pop    %esi
     802:	5f                   	pop    %edi
     803:	5d                   	pop    %ebp
     804:	c3                   	ret    
        (error = S_ISLIB(G.statbuf.st_mode)) != 0 ||
#endif
        (error = S_ISDIR(G.statbuf.st_mode)) != 0)
    {
#ifndef SFX
        if (lastchance && (uO.qflag < 3)) {
     805:	83 7b 38 02          	cmpl   $0x2,0x38(%ebx)
     809:	7f ed                	jg     7f8 <_do_seekable+0xe8>
#ifdef TIMESTAMP
    time_t uxstamp;
    ulg nmember = 0L;
#endif
#endif
    int error=0, error_in_archive;
     80b:	31 f6                	xor    %esi,%esi
     80d:	e9 64 ff ff ff       	jmp    776 <_do_seekable+0x66>
#endif /* ?(UNIX || QDOS) */
        }
#endif /* !SFX */
        return error? IZ_DIR : PK_NOZIP;
    }
    G.ziplen = G.statbuf.st_size;
     812:	8b 83 90 09 01 00    	mov    0x10990(%ebx),%eax
#ifdef VMS
    if (check_format(__G))              /* check for variable-length format */
        return PK_ERR;
#endif

    if (open_input_file(__G))   /* this should never happen, given */
     818:	89 1c 24             	mov    %ebx,(%esp)
#endif /* ?(UNIX || QDOS) */
        }
#endif /* !SFX */
        return error? IZ_DIR : PK_NOZIP;
    }
    G.ziplen = G.statbuf.st_size;
     81b:	89 83 0c 09 01 00    	mov    %eax,0x1090c(%ebx)
#ifdef VMS
    if (check_format(__G))              /* check for variable-length format */
        return PK_ERR;
#endif

    if (open_input_file(__G))   /* this should never happen, given */
     821:	e8 00 00 00 00       	call   826 <_do_seekable+0x116>
     826:	85 c0                	test   %eax,%eax
     828:	75 ce                	jne    7f8 <_do_seekable+0xe8>
    add some to allow for appended garbage.  Since ZipInfo is often used as
    a debugging tool, search the whole zipfile if zipinfo_mode is true.
  ---------------------------------------------------------------------------*/

    /* initialize the CRC table pointer (once) */
    if (CRC_32_TAB == NULL) {
     82a:	8b 83 dc 08 01 00    	mov    0x108dc(%ebx),%eax
     830:	85 c0                	test   %eax,%eax
     832:	0f 84 b4 06 00 00    	je     eec <_do_seekable+0x7dc>
        }
    }

#if (!defined(SFX) || defined(SFX_EXDIR))
    /* check out if specified extraction root directory exists */
    if (uO.exdir != (char *)NULL && G.extract_flag) {
     838:	8b 43 04             	mov    0x4(%ebx),%eax
     83b:	85 c0                	test   %eax,%eax
     83d:	74 0e                	je     84d <_do_seekable+0x13d>
     83f:	8b b3 80 00 00 00    	mov    0x80(%ebx),%esi
     845:	85 f6                	test   %esi,%esi
     847:	0f 85 08 01 00 00    	jne    955 <_do_seekable+0x245>
        }
    }
#endif /* !SFX || SFX_EXDIR */

    G.cur_zipfile_bufstart = 0;
    G.inptr = G.inbuf;
     84d:	8b 83 e4 08 01 00    	mov    0x108e4(%ebx),%eax
            return (error == MPN_NOMEM ? PK_MEM : PK_ERR);
        }
    }
#endif /* !SFX || SFX_EXDIR */

    G.cur_zipfile_bufstart = 0;
     853:	c7 83 10 09 01 00 00 	movl   $0x0,0x10910(%ebx)
     85a:	00 00 00 
    G.inptr = G.inbuf;
     85d:	89 83 e8 08 01 00    	mov    %eax,0x108e8(%ebx)
#else
        Info(slide, 0, ((char *)slide, "Archive:  %s\n", G.zipfn));
#endif
#endif /* !WINDLL && !SFX */

    if ((
     863:	8b 43 0c             	mov    0xc(%ebx),%eax
     866:	85 c0                	test   %eax,%eax
     868:	0f 85 b7 03 00 00    	jne    c25 <_do_seekable+0x515>
         uO.zipinfo_mode &&
          ((error_in_archive = find_ecrec(__G__ G.ziplen)) != 0 ||
          (error_in_archive = zi_end_central(__G)) > PK_WARN))
        || (!uO.zipinfo_mode &&
#endif
          ((error_in_archive = find_ecrec(__G__ MIN(G.ziplen,66000L))) != 0 ||
     86e:	ba d0 01 01 00       	mov    $0x101d0,%edx
    if ((
#ifndef NO_ZIPINFO
         uO.zipinfo_mode &&
          ((error_in_archive = find_ecrec(__G__ G.ziplen)) != 0 ||
          (error_in_archive = zi_end_central(__G)) > PK_WARN))
        || (!uO.zipinfo_mode &&
     873:	89 d8                	mov    %ebx,%eax
#endif
          ((error_in_archive = find_ecrec(__G__ MIN(G.ziplen,66000L))) != 0 ||
     875:	81 bb 0c 09 01 00 d0 	cmpl   $0x101d0,0x1090c(%ebx)
     87c:	01 01 00 
     87f:	0f 4e 93 0c 09 01 00 	cmovle 0x1090c(%ebx),%edx
    if ((
#ifndef NO_ZIPINFO
         uO.zipinfo_mode &&
          ((error_in_archive = find_ecrec(__G__ G.ziplen)) != 0 ||
          (error_in_archive = zi_end_central(__G)) > PK_WARN))
        || (!uO.zipinfo_mode &&
     886:	e8 75 f7 ff ff       	call   0 <_find_ecrec>
     88b:	89 c6                	mov    %eax,%esi
     88d:	85 c0                	test   %eax,%eax
     88f:	0f 84 10 01 00 00    	je     9a5 <_do_seekable+0x295>
#endif
          ((error_in_archive = find_ecrec(__G__ MIN(G.ziplen,66000L))) != 0 ||
          (error_in_archive = uz_end_central(__G)) > PK_WARN)))
    {
        CLOSE_INFILE();
     895:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     89b:	89 04 24             	mov    %eax,(%esp)
     89e:	e8 00 00 00 00       	call   8a3 <_do_seekable+0x193>

#ifdef SFX
        ++lastchance;   /* avoid picky compiler warnings */
        return error_in_archive;
#else
        if (maybe_exe)
     8a3:	83 e5 40             	and    $0x40,%ebp
     8a6:	0f 85 a9 05 00 00    	jne    e55 <_do_seekable+0x745>
            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybeExe),
            G.zipfn));
        if (lastchance)
     8ac:	85 ff                	test   %edi,%edi
     8ae:	0f 85 35 04 00 00    	jne    ce9 <_do_seekable+0x5d9>
            return error_in_archive;
        else {
            G.no_ecrec = TRUE;    /* assume we found wrong file:  e.g., */
     8b4:	c7 83 c4 09 01 00 01 	movl   $0x1,0x109c4(%ebx)
     8bb:	00 00 00 
     8be:	e9 35 ff ff ff       	jmp    7f8 <_do_seekable+0xe8>
                Info(slide, 0x401, ((char *)slide,
                  LoadFarString(CannotFindZipfileDirMsg), uO.zipinfo_mode?
                  LoadFarStringSmall(Zipnfo) : LoadFarStringSmall(Unzip),
                  G.wildzipfn, uO.zipinfo_mode? "  " : "", G.zipfn));
            else
                Info(slide, 0x401, ((char *)slide,
     8c3:	8b 43 0c             	mov    0xc(%ebx),%eax
     8c6:	bd 58 07 00 00       	mov    $0x758,%ebp
     8cb:	85 c0                	test   %eax,%eax
     8cd:	b8 00 00 00 00       	mov    $0x0,%eax
     8d2:	0f 44 c5             	cmove  %ebp,%eax
     8d5:	8b 8b 04 09 01 00    	mov    0x10904(%ebx),%ecx
     8db:	8b 93 00 09 01 00    	mov    0x10900(%ebx),%edx
     8e1:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     8e7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     8eb:	89 54 24 0c          	mov    %edx,0xc(%esp)
     8ef:	89 44 24 08          	mov    %eax,0x8(%esp)
     8f3:	c7 44 24 04 80 07 00 	movl   $0x780,0x4(%esp)
     8fa:	00 
     8fb:	89 2c 24             	mov    %ebp,(%esp)
     8fe:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     904:	e8 00 00 00 00       	call   909 <_do_seekable+0x1f9>
     909:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     910:	00 
     911:	89 44 24 08          	mov    %eax,0x8(%esp)
     915:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     919:	89 1c 24             	mov    %ebx,(%esp)
     91c:	ff d7                	call   *%edi
     91e:	83 ec 10             	sub    $0x10,%esp
                  LoadFarStringSmall(Zipnfo) : LoadFarStringSmall(Unzip),
                  G.wildzipfn, G.zipfn));
#endif /* ?(UNIX || QDOS) */
        }
#endif /* !SFX */
        return error? IZ_DIR : PK_NOZIP;
     921:	b8 09 00 00 00       	mov    $0x9,%eax
     926:	85 f6                	test   %esi,%esi
     928:	0f 84 cf fe ff ff    	je     7fd <_do_seekable+0xed>
        }
    }
#endif
    return error_in_archive;

} /* end function do_seekable() */
     92e:	83 c4 4c             	add    $0x4c,%esp
                  LoadFarStringSmall(Zipnfo) : LoadFarStringSmall(Unzip),
                  G.wildzipfn, G.zipfn));
#endif /* ?(UNIX || QDOS) */
        }
#endif /* !SFX */
        return error? IZ_DIR : PK_NOZIP;
     931:	b8 4c 00 00 00       	mov    $0x4c,%eax
        }
    }
#endif
    return error_in_archive;

} /* end function do_seekable() */
     936:	5b                   	pop    %ebx
     937:	5e                   	pop    %esi
     938:	5f                   	pop    %edi
     939:	5d                   	pop    %ebp
     93a:	c3                   	ret    
     93b:	90                   	nop
     93c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                  LoadFarString(CannotFindEitherZipfile), uO.zipinfo_mode?
                  LoadFarStringSmall(Zipnfo) : LoadFarStringSmall(Unzip),
                  G.wildzipfn, G.wildzipfn, G.zipfn));
#else /* !(UNIX || QDOS) */
            if (G.no_ecrec)
                Info(slide, 0x401, ((char *)slide,
     940:	8b ab 00 09 01 00    	mov    0x10900(%ebx),%ebp
     946:	b9 2f 01 00 00       	mov    $0x12f,%ecx
     94b:	ba 00 00 00 00       	mov    $0x0,%edx
     950:	e9 5a fe ff ff       	jmp    7af <_do_seekable+0x9f>
    }

#if (!defined(SFX) || defined(SFX_EXDIR))
    /* check out if specified extraction root directory exists */
    if (uO.exdir != (char *)NULL && G.extract_flag) {
        G.create_dirs = !uO.fflag;
     955:	31 d2                	xor    %edx,%edx
     957:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
     95a:	85 c9                	test   %ecx,%ecx
        if ((error = checkdir(__G__ uO.exdir, ROOT)) > MPN_INF_SKIP) {
     95c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     963:	00 
    }

#if (!defined(SFX) || defined(SFX_EXDIR))
    /* check out if specified extraction root directory exists */
    if (uO.exdir != (char *)NULL && G.extract_flag) {
        G.create_dirs = !uO.fflag;
     964:	0f 94 c2             	sete   %dl
     967:	89 53 7c             	mov    %edx,0x7c(%ebx)
        if ((error = checkdir(__G__ uO.exdir, ROOT)) > MPN_INF_SKIP) {
     96a:	89 44 24 04          	mov    %eax,0x4(%esp)
     96e:	89 1c 24             	mov    %ebx,(%esp)
     971:	e8 00 00 00 00       	call   976 <_do_seekable+0x266>
     976:	89 c6                	mov    %eax,%esi
     978:	3d 00 02 00 00       	cmp    $0x200,%eax
     97d:	0f 8e ca fe ff ff    	jle    84d <_do_seekable+0x13d>
            /* out of memory, or file in way */
            CLOSE_INFILE();
     983:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     989:	89 04 24             	mov    %eax,(%esp)
     98c:	e8 00 00 00 00       	call   991 <_do_seekable+0x281>
            return (error == MPN_NOMEM ? PK_MEM : PK_ERR);
     991:	31 c0                	xor    %eax,%eax
     993:	81 fe 00 0a 00 00    	cmp    $0xa00,%esi
     999:	0f 94 c0             	sete   %al
     99c:	8d 44 00 02          	lea    0x2(%eax,%eax,1),%eax
     9a0:	e9 58 fe ff ff       	jmp    7fd <_do_seekable+0xed>
         uO.zipinfo_mode &&
          ((error_in_archive = find_ecrec(__G__ G.ziplen)) != 0 ||
          (error_in_archive = zi_end_central(__G)) > PK_WARN))
        || (!uO.zipinfo_mode &&
#endif
          ((error_in_archive = find_ecrec(__G__ MIN(G.ziplen,66000L))) != 0 ||
     9a5:	89 1c 24             	mov    %ebx,(%esp)
     9a8:	e8 43 fc ff ff       	call   5f0 <_uz_end_central>
     9ad:	89 c6                	mov    %eax,%esi
     9af:	83 f8 01             	cmp    $0x1,%eax
     9b2:	0f 8f dd fe ff ff    	jg     895 <_do_seekable+0x185>
            return PK_NOZIP;       /*  unzip instead of unzip.zip */
        }
#endif /* ?SFX */
    }

    if ((uO.zflag > 0) && !uO.zipinfo_mode) { /* unzip: zflag = comment ONLY */
     9b8:	8b 7b 60             	mov    0x60(%ebx),%edi
     9bb:	8b 43 0c             	mov    0xc(%ebx),%eax
     9be:	85 ff                	test   %edi,%edi
     9c0:	0f 8e ec 00 00 00    	jle    ab2 <_do_seekable+0x3a2>
     9c6:	85 c0                	test   %eax,%eax
     9c8:	0f 84 0d 03 00 00    	je     cdb <_do_seekable+0x5cb>
    error = !uO.zipinfo_mode && (G.ecrec.number_this_disk != 0);
#endif

#ifndef SFX
    if (uO.zipinfo_mode &&
        G.ecrec.number_this_disk != G.ecrec.num_disk_start_cdir)
     9ce:	8b 8b 68 09 01 00    	mov    0x10968(%ebx),%ecx
     9d4:	66 8b 83 6a 09 01 00 	mov    0x1096a(%ebx),%ax
#else
    error = !uO.zipinfo_mode && (G.ecrec.number_this_disk != 0);
#endif

#ifndef SFX
    if (uO.zipinfo_mode &&
     9db:	66 39 c1             	cmp    %ax,%cx
     9de:	0f 84 23 01 00 00    	je     b07 <_do_seekable+0x3f7>
        G.ecrec.number_this_disk != G.ecrec.num_disk_start_cdir)
    {
        if (G.ecrec.number_this_disk > G.ecrec.num_disk_start_cdir) {
            Info(slide, 0x401, ((char *)slide,
     9e4:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     9ea:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi

#ifndef SFX
    if (uO.zipinfo_mode &&
        G.ecrec.number_this_disk != G.ecrec.num_disk_start_cdir)
    {
        if (G.ecrec.number_this_disk > G.ecrec.num_disk_start_cdir) {
     9f0:	0f 86 a8 04 00 00    	jbe    e9e <_do_seekable+0x78e>
            Info(slide, 0x401, ((char *)slide,
     9f6:	31 d2                	xor    %edx,%edx
     9f8:	c7 44 24 04 80 06 00 	movl   $0x680,0x4(%esp)
     9ff:	00 
     a00:	66 89 c2             	mov    %ax,%dx
     a03:	31 c0                	xor    %eax,%eax
     a05:	66 89 c8             	mov    %cx,%ax
     a08:	89 54 24 10          	mov    %edx,0x10(%esp)
     a0c:	89 44 24 0c          	mov    %eax,0xc(%esp)
     a10:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     a16:	89 44 24 08          	mov    %eax,0x8(%esp)
     a1a:	89 3c 24             	mov    %edi,(%esp)
     a1d:	e8 00 00 00 00       	call   a22 <_do_seekable+0x312>
     a22:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     a29:	00 
     a2a:	89 44 24 08          	mov    %eax,0x8(%esp)
     a2e:	89 7c 24 04          	mov    %edi,0x4(%esp)
     a32:	89 1c 24             	mov    %ebx,(%esp)
     a35:	ff d6                	call   *%esi
              LoadFarString(CentDirNotInZipMsg), G.zipfn,
              G.ecrec.number_this_disk, G.ecrec.num_disk_start_cdir));
            error_in_archive = PK_FIND;
     a37:	be 0b 00 00 00       	mov    $0xb,%esi
#ifndef SFX
    if (uO.zipinfo_mode &&
        G.ecrec.number_this_disk != G.ecrec.num_disk_start_cdir)
    {
        if (G.ecrec.number_this_disk > G.ecrec.num_disk_start_cdir) {
            Info(slide, 0x401, ((char *)slide,
     a3c:	83 ec 10             	sub    $0x10,%esp
            error_in_archive = error;   /*  with (for example) a warning */
#ifndef SFX
    } /* end if (!too_weird_to_continue) */
#endif

    CLOSE_INFILE();
     a3f:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     a45:	89 04 24             	mov    %eax,(%esp)
     a48:	e8 00 00 00 00       	call   a4d <_do_seekable+0x33d>

#ifdef TIMESTAMP
    if (uO.T_flag && !uO.zipinfo_mode && (nmember > 0L)) {
     a4d:	8b 7b 48             	mov    0x48(%ebx),%edi
     a50:	89 f0                	mov    %esi,%eax
     a52:	85 ff                	test   %edi,%edi
     a54:	0f 84 a3 fd ff ff    	je     7fd <_do_seekable+0xed>
     a5a:	8b 4b 0c             	mov    0xc(%ebx),%ecx
     a5d:	85 c9                	test   %ecx,%ecx
     a5f:	0f 85 98 fd ff ff    	jne    7fd <_do_seekable+0xed>
     a65:	8b 54 24 3c          	mov    0x3c(%esp),%edx
     a69:	85 d2                	test   %edx,%edx
     a6b:	0f 84 8c fd ff ff    	je     7fd <_do_seekable+0xed>
# ifdef WIN32
        if (stamp_file(__G__ G.zipfn, uxstamp)) {       /* TIME-STAMP 'EM */
     a71:	8b 44 24 38          	mov    0x38(%esp),%eax
     a75:	89 1c 24             	mov    %ebx,(%esp)
     a78:	89 44 24 08          	mov    %eax,0x8(%esp)
     a7c:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     a82:	89 44 24 04          	mov    %eax,0x4(%esp)
     a86:	e8 00 00 00 00       	call   a8b <_do_seekable+0x37b>
     a8b:	89 c2                	mov    %eax,%edx
     a8d:	89 f0                	mov    %esi,%eax
     a8f:	85 d2                	test   %edx,%edx
     a91:	0f 84 66 fd ff ff    	je     7fd <_do_seekable+0xed>
# else
        if (stamp_file(G.zipfn, uxstamp)) {             /* TIME-STAMP 'EM */
# endif
            if (uO.qflag < 3)
     a97:	83 7b 38 02          	cmpl   $0x2,0x38(%ebx)
     a9b:	0f 8e 02 06 00 00    	jle    10a3 <_do_seekable+0x993>
                Info(slide, 0x201, ((char *)slide,
                  "warning:  cannot set time for %s\n", G.zipfn));
            if (error_in_archive < PK_WARN)
                error_in_archive = PK_WARN;
     aa1:	ba 01 00 00 00       	mov    $0x1,%edx
     aa6:	85 f6                	test   %esi,%esi
     aa8:	89 d0                	mov    %edx,%eax
     aaa:	0f 4f c6             	cmovg  %esi,%eax
     aad:	e9 4b fd ff ff       	jmp    7fd <_do_seekable+0xed>

#ifdef NO_MULTIPART
    error = !uO.zipinfo_mode && (G.ecrec.number_this_disk == 1) &&
            (G.ecrec.num_disk_start_cdir == 1);
#else
    error = !uO.zipinfo_mode && (G.ecrec.number_this_disk != 0);
     ab2:	85 c0                	test   %eax,%eax
     ab4:	0f 85 14 ff ff ff    	jne    9ce <_do_seekable+0x2be>
     aba:	66 83 bb 68 09 01 00 	cmpw   $0x0,0x10968(%ebx)
     ac1:	00 
     ac2:	74 43                	je     b07 <_do_seekable+0x3f7>
#endif
    }

    if (!too_weird_to_continue) {  /* (relatively) normal zipfile:  go for it */
        if (error) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybePakBug),
     ac4:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     aca:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     ad0:	89 34 24             	mov    %esi,(%esp)
     ad3:	89 44 24 08          	mov    %eax,0x8(%esp)
     ad7:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
     ade:	00 
     adf:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     ae5:	e8 00 00 00 00       	call   aea <_do_seekable+0x3da>
     aea:	89 74 24 04          	mov    %esi,0x4(%esp)
     aee:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     af5:	00 
     af6:	89 44 24 08          	mov    %eax,0x8(%esp)
     afa:	89 1c 24             	mov    %ebx,(%esp)
              G.zipfn));
            error_in_archive = PK_WARN;
     afd:	be 01 00 00 00       	mov    $0x1,%esi
#endif
    }

    if (!too_weird_to_continue) {  /* (relatively) normal zipfile:  go for it */
        if (error) {
            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybePakBug),
     b02:	ff d7                	call   *%edi
     b04:	83 ec 10             	sub    $0x10,%esp
              G.zipfn));
            error_in_archive = PK_WARN;
        }
#endif /* !SFX */
        if ((G.extra_bytes = G.real_ecrec_offset-G.expect_ecrec_offset) <
     b07:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
     b0d:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
     b13:	29 d0                	sub    %edx,%eax
     b15:	89 83 14 09 01 00    	mov    %eax,0x10914(%ebx)
     b1b:	85 c0                	test   %eax,%eax
     b1d:	0f 88 f4 03 00 00    	js     f17 <_do_seekable+0x807>
            (Z_OFF_T)0)
        {
            Info(slide, 0x401, ((char *)slide, LoadFarString(MissingBytes),
              G.zipfn, (long)(-G.extra_bytes)));
            error_in_archive = PK_ERR;
        } else if (G.extra_bytes > 0) {
     b23:	74 79                	je     b9e <_do_seekable+0x48e>
            if ((G.ecrec.offset_start_central_directory == 0) &&
     b25:	8b 8b 74 09 01 00    	mov    0x10974(%ebx),%ecx
     b2b:	85 c9                	test   %ecx,%ecx
     b2d:	75 0e                	jne    b3d <_do_seekable+0x42d>
     b2f:	8b 93 70 09 01 00    	mov    0x10970(%ebx),%edx
     b35:	85 d2                	test   %edx,%edx
     b37:	0f 85 71 04 00 00    	jne    fae <_do_seekable+0x89e>
                G.extra_bytes = 0;
                error_in_archive = PK_ERR;
            }
#ifndef SFX
            else {
                Info(slide, 0x401, ((char *)slide,
     b3d:	b9 32 01 00 00       	mov    $0x132,%ecx
     b42:	ba 2e 01 00 00       	mov    $0x12e,%edx
     b47:	83 f8 01             	cmp    $0x1,%eax
     b4a:	89 44 24 0c          	mov    %eax,0xc(%esp)
     b4e:	0f 45 d1             	cmovne %ecx,%edx
     b51:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     b57:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     b5d:	89 54 24 10          	mov    %edx,0x10(%esp)
     b61:	89 44 24 08          	mov    %eax,0x8(%esp)
     b65:	c7 44 24 04 20 04 00 	movl   $0x420,0x4(%esp)
     b6c:	00 
     b6d:	89 3c 24             	mov    %edi,(%esp)
     b70:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     b76:	e8 00 00 00 00       	call   b7b <_do_seekable+0x46b>
     b7b:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     b82:	00 
     b83:	89 44 24 08          	mov    %eax,0x8(%esp)
     b87:	89 7c 24 04          	mov    %edi,0x4(%esp)
     b8b:	89 1c 24             	mov    %ebx,(%esp)
     b8e:	ff d6                	call   *%esi
     b90:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
     b96:	83 ec 10             	sub    $0x10,%esp
                  LoadFarString(ExtraBytesAtStart), G.zipfn,
                  (long)G.extra_bytes, (G.extra_bytes == 1)? "":"s"));
                error_in_archive = PK_WARN;
     b99:	be 01 00 00 00       	mov    $0x1,%esi

    /*-----------------------------------------------------------------------
        Check for empty zipfile and exit now if so.
      -----------------------------------------------------------------------*/

        if (G.expect_ecrec_offset==0L && G.ecrec.size_central_directory==0) {
     b9e:	85 d2                	test   %edx,%edx
     ba0:	0f 85 4a 01 00 00    	jne    cf0 <_do_seekable+0x5e0>
     ba6:	8b 83 70 09 01 00    	mov    0x10970(%ebx),%eax
     bac:	85 c0                	test   %eax,%eax
     bae:	0f 85 3c 01 00 00    	jne    cf0 <_do_seekable+0x5e0>
            if (uO.zipinfo_mode)
     bb4:	8b 43 0c             	mov    0xc(%ebx),%eax
     bb7:	85 c0                	test   %eax,%eax
     bb9:	0f 84 ac 03 00 00    	je     f6b <_do_seekable+0x85b>
                Info(slide, 0, ((char *)slide, "%sEmpty zipfile.\n",
     bbf:	ba 2e 01 00 00       	mov    $0x12e,%edx
     bc4:	b8 34 01 00 00       	mov    $0x134,%eax
     bc9:	83 7b 28 09          	cmpl   $0x9,0x28(%ebx)
     bcd:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     bd3:	c7 44 24 04 38 01 00 	movl   $0x138,0x4(%esp)
     bda:	00 
     bdb:	0f 4e c2             	cmovle %edx,%eax
     bde:	89 44 24 08          	mov    %eax,0x8(%esp)
     be2:	89 2c 24             	mov    %ebp,(%esp)
     be5:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     beb:	e8 00 00 00 00       	call   bf0 <_do_seekable+0x4e0>
     bf0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     bf7:	00 
     bf8:	89 44 24 08          	mov    %eax,0x8(%esp)
     bfc:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     c00:	89 1c 24             	mov    %ebx,(%esp)
     c03:	ff d7                	call   *%edi
     c05:	83 ec 10             	sub    $0x10,%esp
                  uO.lflag>9? "\n  " : ""));
            else
                Info(slide, 0x401, ((char *)slide, LoadFarString(ZipfileEmpty),
                                    G.zipfn));
            CLOSE_INFILE();
     c08:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     c0e:	89 04 24             	mov    %eax,(%esp)
     c11:	e8 00 00 00 00       	call   c16 <_do_seekable+0x506>
            return (error_in_archive > PK_WARN)? error_in_archive : PK_WARN;
     c16:	b8 01 00 00 00       	mov    $0x1,%eax
     c1b:	85 f6                	test   %esi,%esi
     c1d:	0f 4f c6             	cmovg  %esi,%eax
     c20:	e9 d8 fb ff ff       	jmp    7fd <_do_seekable+0xed>
#endif
#endif /* !WINDLL && !SFX */

    if ((
#ifndef NO_ZIPINFO
         uO.zipinfo_mode &&
     c25:	8b 93 0c 09 01 00    	mov    0x1090c(%ebx),%edx
     c2b:	89 d8                	mov    %ebx,%eax
     c2d:	e8 ce f3 ff ff       	call   0 <_find_ecrec>
     c32:	89 c6                	mov    %eax,%esi
     c34:	85 c0                	test   %eax,%eax
     c36:	0f 85 59 fc ff ff    	jne    895 <_do_seekable+0x185>
          ((error_in_archive = find_ecrec(__G__ G.ziplen)) != 0 ||
     c3c:	89 1c 24             	mov    %ebx,(%esp)
     c3f:	e8 00 00 00 00       	call   c44 <_do_seekable+0x534>
     c44:	89 c6                	mov    %eax,%esi
     c46:	83 f8 01             	cmp    $0x1,%eax
     c49:	0f 8f 46 fc ff ff    	jg     895 <_do_seekable+0x185>
          (error_in_archive = zi_end_central(__G)) > PK_WARN))
        || (!uO.zipinfo_mode &&
     c4f:	8b 43 0c             	mov    0xc(%ebx),%eax
     c52:	85 c0                	test   %eax,%eax
     c54:	0f 85 74 fd ff ff    	jne    9ce <_do_seekable+0x2be>
     c5a:	e9 0f fc ff ff       	jmp    86e <_do_seekable+0x15e>
     c5f:	90                   	nop
#ifndef SFX
            long tmp = G.extra_bytes;
#endif

            G.extra_bytes = 0;
            error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
     c60:	8b 83 74 09 01 00    	mov    0x10974(%ebx),%eax
        if ((error != PK_OK) || (readbuf(__G__ G.sig, 4) == 0) ||
            strncmp(G.sig, central_hdr_sig, 4))
#endif
        {
#ifndef SFX
            long tmp = G.extra_bytes;
     c66:	8b bb 14 09 01 00    	mov    0x10914(%ebx),%edi
#endif

            G.extra_bytes = 0;
            error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
     c6c:	89 44 24 04          	mov    %eax,0x4(%esp)
        {
#ifndef SFX
            long tmp = G.extra_bytes;
#endif

            G.extra_bytes = 0;
     c70:	c7 83 14 09 01 00 00 	movl   $0x0,0x10914(%ebx)
     c77:	00 00 00 
            error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
     c7a:	89 1c 24             	mov    %ebx,(%esp)
     c7d:	e8 00 00 00 00       	call   c82 <_do_seekable+0x572>
     c82:	89 c6                	mov    %eax,%esi
            if ((error != PK_OK) || (readbuf(__G__ G.sig, 4) == 0) ||
     c84:	85 c0                	test   %eax,%eax
     c86:	0f 84 2d 01 00 00    	je     db9 <_do_seekable+0x6a9>
                strncmp(G.sig, central_hdr_sig, 4))
            {
                if (error != PK_BADERR)
     c8c:	83 f8 03             	cmp    $0x3,%eax
     c8f:	0f 84 a8 01 00 00    	je     e3d <_do_seekable+0x72d>
                  Info(slide, 0x401, ((char *)slide,
     c95:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     c9b:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     ca1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     ca8:	00 
     ca9:	89 44 24 08          	mov    %eax,0x8(%esp)
     cad:	c7 44 24 04 c0 02 00 	movl   $0x2c0,0x4(%esp)
     cb4:	00 
     cb5:	89 3c 24             	mov    %edi,(%esp)
     cb8:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
     cbe:	e8 00 00 00 00       	call   cc3 <_do_seekable+0x5b3>
     cc3:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     cca:	00 
     ccb:	89 44 24 08          	mov    %eax,0x8(%esp)
     ccf:	89 7c 24 04          	mov    %edi,0x4(%esp)
     cd3:	89 1c 24             	mov    %ebx,(%esp)
     cd6:	ff d5                	call   *%ebp
     cd8:	83 ec 10             	sub    $0x10,%esp
                    LoadFarString(CentDirStartNotFound), G.zipfn,
                    LoadFarStringSmall(ReportMsg)));
                CLOSE_INFILE();
     cdb:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     ce1:	89 04 24             	mov    %eax,(%esp)
     ce4:	e8 00 00 00 00       	call   ce9 <_do_seekable+0x5d9>
     ce9:	89 f0                	mov    %esi,%eax
     ceb:	e9 0d fb ff ff       	jmp    7fd <_do_seekable+0xed>
        of central directory should be.  If header not found, uncompensate
        and try again (necessary for at least some Atari archives created
        with STZip, as well as archives created by J.H. Holm's ZIPSPLIT 1.1).
      -----------------------------------------------------------------------*/

        error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
     cf0:	8b 83 74 09 01 00    	mov    0x10974(%ebx),%eax
     cf6:	89 1c 24             	mov    %ebx,(%esp)
     cf9:	89 44 24 04          	mov    %eax,0x4(%esp)
     cfd:	e8 00 00 00 00       	call   d02 <_do_seekable+0x5f2>
        if (error == PK_BADERR) {
     d02:	83 f8 03             	cmp    $0x3,%eax
     d05:	0f 84 32 01 00 00    	je     e3d <_do_seekable+0x72d>
            CLOSE_INFILE();
            return PK_ERR;  /* file may be locked, or possibly disk error(?) */
        }
        if (strncmp(G.sig, central_hdr_sig, 4))
#else
        if ((error != PK_OK) || (readbuf(__G__ G.sig, 4) == 0) ||
     d0b:	85 c0                	test   %eax,%eax
     d0d:	0f 85 4d ff ff ff    	jne    c60 <_do_seekable+0x550>
     d13:	8d bb c8 00 00 00    	lea    0xc8(%ebx),%edi
     d19:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     d20:	00 
     d21:	89 7c 24 04          	mov    %edi,0x4(%esp)
     d25:	89 1c 24             	mov    %ebx,(%esp)
     d28:	e8 00 00 00 00       	call   d2d <_do_seekable+0x61d>
     d2d:	85 c0                	test   %eax,%eax
     d2f:	0f 84 2b ff ff ff    	je     c60 <_do_seekable+0x550>
            strncmp(G.sig, central_hdr_sig, 4))
     d35:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     d3c:	00 
     d3d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     d44:	00 
     d45:	89 3c 24             	mov    %edi,(%esp)
     d48:	e8 00 00 00 00       	call   d4d <_do_seekable+0x63d>
            CLOSE_INFILE();
            return PK_ERR;  /* file may be locked, or possibly disk error(?) */
        }
        if (strncmp(G.sig, central_hdr_sig, 4))
#else
        if ((error != PK_OK) || (readbuf(__G__ G.sig, 4) == 0) ||
     d4d:	85 c0                	test   %eax,%eax
     d4f:	0f 85 0b ff ff ff    	jne    c60 <_do_seekable+0x550>
        Seek to the start of the central directory one last time, since we
        have just read the first entry's signature bytes; then list, extract
        or test member files as instructed, and close the zipfile.
      -----------------------------------------------------------------------*/

        error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
     d55:	8b 83 74 09 01 00    	mov    0x10974(%ebx),%eax
     d5b:	89 1c 24             	mov    %ebx,(%esp)
     d5e:	89 44 24 04          	mov    %eax,0x4(%esp)
     d62:	e8 00 00 00 00       	call   d67 <_do_seekable+0x657>
     d67:	89 c7                	mov    %eax,%edi
        if (error != PK_OK) {
     d69:	85 c0                	test   %eax,%eax
     d6b:	0f 85 a1 02 00 00    	jne    1012 <_do_seekable+0x902>
           entries in the archive are in good condition.  This is
           currently used only in the Windows DLLs for purposes of
           checking archives within an archive to determine whether
           or not to display the inner archives.
         */
        if (!G.fValidate)
     d71:	8b ab 98 00 00 00    	mov    0x98(%ebx),%ebp
     d77:	85 ed                	test   %ebp,%ebp
     d79:	75 34                	jne    daf <_do_seekable+0x69f>
#endif
        {
#ifndef NO_ZIPINFO
            if (uO.zipinfo_mode)
     d7b:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
     d7f:	0f 85 0f 03 00 00    	jne    1094 <_do_seekable+0x984>
                error = zipinfo(__G);                 /* ZIPINFO 'EM */
            else
#endif
#ifndef SFX
#ifdef TIMESTAMP
            if (uO.T_flag)
     d85:	83 7b 48 00          	cmpl   $0x0,0x48(%ebx)
     d89:	0f 85 e6 02 00 00    	jne    1075 <_do_seekable+0x965>
                error = get_time_stamp(__G__ &uxstamp, &nmember);
            else
#endif
            if (uO.vflag && !uO.tflag && !uO.cflag)
     d8f:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
     d93:	74 10                	je     da5 <_do_seekable+0x695>
     d95:	83 7b 44 00          	cmpl   $0x0,0x44(%ebx)
     d99:	75 0a                	jne    da5 <_do_seekable+0x695>
     d9b:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
     d9f:	0f 84 41 03 00 00    	je     10e6 <_do_seekable+0x9d6>
                error = list_files(__G);              /* LIST 'EM */
            else
#endif /* !SFX */
                error = extract_or_test_files(__G);   /* EXTRACT OR TEST 'EM */
     da5:	89 1c 24             	mov    %ebx,(%esp)
     da8:	e8 00 00 00 00       	call   dad <_do_seekable+0x69d>
     dad:	89 c7                	mov    %eax,%edi
     daf:	39 f7                	cmp    %esi,%edi
     db1:	0f 4d f7             	cmovge %edi,%esi
     db4:	e9 86 fc ff ff       	jmp    a3f <_do_seekable+0x32f>
            long tmp = G.extra_bytes;
#endif

            G.extra_bytes = 0;
            error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
            if ((error != PK_OK) || (readbuf(__G__ G.sig, 4) == 0) ||
     db9:	8d b3 c8 00 00 00    	lea    0xc8(%ebx),%esi
     dbf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     dc6:	00 
     dc7:	89 74 24 04          	mov    %esi,0x4(%esp)
     dcb:	89 1c 24             	mov    %ebx,(%esp)
     dce:	e8 00 00 00 00       	call   dd3 <_do_seekable+0x6c3>
     dd3:	85 c0                	test   %eax,%eax
     dd5:	74 20                	je     df7 <_do_seekable+0x6e7>
                strncmp(G.sig, central_hdr_sig, 4))
     dd7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
     dde:	00 
     ddf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     de6:	00 
     de7:	89 34 24             	mov    %esi,(%esp)
     dea:	e8 00 00 00 00       	call   def <_do_seekable+0x6df>
            long tmp = G.extra_bytes;
#endif

            G.extra_bytes = 0;
            error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
            if ((error != PK_OK) || (readbuf(__G__ G.sig, 4) == 0) ||
     def:	85 c0                	test   %eax,%eax
     df1:	0f 84 30 02 00 00    	je     1027 <_do_seekable+0x917>
                strncmp(G.sig, central_hdr_sig, 4))
            {
                if (error != PK_BADERR)
                  Info(slide, 0x401, ((char *)slide,
     df7:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     dfd:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     e03:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     e0a:	00 
     e0b:	89 44 24 08          	mov    %eax,0x8(%esp)
     e0f:	c7 44 24 04 c0 02 00 	movl   $0x2c0,0x4(%esp)
     e16:	00 
     e17:	89 34 24             	mov    %esi,(%esp)
     e1a:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     e20:	e8 00 00 00 00       	call   e25 <_do_seekable+0x715>
     e25:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     e2c:	00 
     e2d:	89 44 24 08          	mov    %eax,0x8(%esp)
     e31:	89 74 24 04          	mov    %esi,0x4(%esp)
     e35:	89 1c 24             	mov    %ebx,(%esp)
     e38:	ff d7                	call   *%edi
     e3a:	83 ec 10             	sub    $0x10,%esp
                    LoadFarString(CentDirStartNotFound), G.zipfn,
                    LoadFarStringSmall(ReportMsg)));
                CLOSE_INFILE();
     e3d:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     e43:	89 04 24             	mov    %eax,(%esp)
     e46:	e8 00 00 00 00       	call   e4b <_do_seekable+0x73b>
                return (error != PK_OK ? error : PK_BADERR);
     e4b:	b8 03 00 00 00       	mov    $0x3,%eax
     e50:	e9 a8 f9 ff ff       	jmp    7fd <_do_seekable+0xed>
#ifdef SFX
        ++lastchance;   /* avoid picky compiler warnings */
        return error_in_archive;
#else
        if (maybe_exe)
            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybeExe),
     e55:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
     e5b:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     e61:	89 44 24 2c          	mov    %eax,0x2c(%esp)
     e65:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     e6b:	89 44 24 08          	mov    %eax,0x8(%esp)
     e6f:	c7 44 24 04 20 07 00 	movl   $0x720,0x4(%esp)
     e76:	00 
     e77:	89 2c 24             	mov    %ebp,(%esp)
     e7a:	e8 00 00 00 00       	call   e7f <_do_seekable+0x76f>
     e7f:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     e86:	00 
     e87:	89 44 24 08          	mov    %eax,0x8(%esp)
     e8b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     e8f:	89 1c 24             	mov    %ebx,(%esp)
     e92:	ff 54 24 2c          	call   *0x2c(%esp)
     e96:	83 ec 10             	sub    $0x10,%esp
     e99:	e9 0e fa ff ff       	jmp    8ac <_do_seekable+0x19c>
              LoadFarString(CentDirNotInZipMsg), G.zipfn,
              G.ecrec.number_this_disk, G.ecrec.num_disk_start_cdir));
            error_in_archive = PK_FIND;
            too_weird_to_continue = TRUE;
        } else {
            Info(slide, 0x401, ((char *)slide,
     e9e:	31 d2                	xor    %edx,%edx
     ea0:	c7 44 24 04 c0 05 00 	movl   $0x5c0,0x4(%esp)
     ea7:	00 
     ea8:	66 89 c2             	mov    %ax,%dx
     eab:	31 c0                	xor    %eax,%eax
     ead:	66 89 c8             	mov    %cx,%ax
     eb0:	89 54 24 10          	mov    %edx,0x10(%esp)
     eb4:	89 44 24 0c          	mov    %eax,0xc(%esp)
     eb8:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     ebe:	89 44 24 08          	mov    %eax,0x8(%esp)
     ec2:	89 3c 24             	mov    %edi,(%esp)
     ec5:	e8 00 00 00 00       	call   eca <_do_seekable+0x7ba>
     eca:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     ed1:	00 
     ed2:	89 44 24 08          	mov    %eax,0x8(%esp)
     ed6:	89 7c 24 04          	mov    %edi,0x4(%esp)
     eda:	89 1c 24             	mov    %ebx,(%esp)
     edd:	ff d6                	call   *%esi
              LoadFarString(EndCentDirBogus), G.zipfn,
              G.ecrec.number_this_disk, G.ecrec.num_disk_start_cdir));
            error_in_archive = PK_WARN;
     edf:	be 01 00 00 00       	mov    $0x1,%esi
              LoadFarString(CentDirNotInZipMsg), G.zipfn,
              G.ecrec.number_this_disk, G.ecrec.num_disk_start_cdir));
            error_in_archive = PK_FIND;
            too_weird_to_continue = TRUE;
        } else {
            Info(slide, 0x401, ((char *)slide,
     ee4:	83 ec 10             	sub    $0x10,%esp
     ee7:	e9 1b fc ff ff       	jmp    b07 <_do_seekable+0x3f7>
    a debugging tool, search the whole zipfile if zipinfo_mode is true.
  ---------------------------------------------------------------------------*/

    /* initialize the CRC table pointer (once) */
    if (CRC_32_TAB == NULL) {
        if ((CRC_32_TAB = get_crc_table()) == NULL) {
     eec:	e8 00 00 00 00       	call   ef1 <_do_seekable+0x7e1>
     ef1:	89 83 dc 08 01 00    	mov    %eax,0x108dc(%ebx)
     ef7:	85 c0                	test   %eax,%eax
     ef9:	0f 85 39 f9 ff ff    	jne    838 <_do_seekable+0x128>
            CLOSE_INFILE();
     eff:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
     f05:	89 04 24             	mov    %eax,(%esp)
     f08:	e8 00 00 00 00       	call   f0d <_do_seekable+0x7fd>
            return PK_MEM;
     f0d:	b8 04 00 00 00       	mov    $0x4,%eax
     f12:	e9 e6 f8 ff ff       	jmp    7fd <_do_seekable+0xed>
        }
#endif /* !SFX */
        if ((G.extra_bytes = G.real_ecrec_offset-G.expect_ecrec_offset) <
            (Z_OFF_T)0)
        {
            Info(slide, 0x401, ((char *)slide, LoadFarString(MissingBytes),
     f17:	f7 d8                	neg    %eax
     f19:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     f1f:	89 44 24 0c          	mov    %eax,0xc(%esp)
     f23:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     f29:	89 34 24             	mov    %esi,(%esp)
     f2c:	89 44 24 08          	mov    %eax,0x8(%esp)
     f30:	c7 44 24 04 c0 03 00 	movl   $0x3c0,0x4(%esp)
     f37:	00 
     f38:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     f3e:	e8 00 00 00 00       	call   f43 <_do_seekable+0x833>
     f43:	89 74 24 04          	mov    %esi,0x4(%esp)
     f47:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     f4e:	00 
     f4f:	89 44 24 08          	mov    %eax,0x8(%esp)
     f53:	89 1c 24             	mov    %ebx,(%esp)
     f56:	ff d7                	call   *%edi
              G.zipfn, (long)(-G.extra_bytes)));
            error_in_archive = PK_ERR;
     f58:	be 02 00 00 00       	mov    $0x2,%esi
        }
#endif /* !SFX */
        if ((G.extra_bytes = G.real_ecrec_offset-G.expect_ecrec_offset) <
            (Z_OFF_T)0)
        {
            Info(slide, 0x401, ((char *)slide, LoadFarString(MissingBytes),
     f5d:	83 ec 10             	sub    $0x10,%esp
     f60:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
     f66:	e9 33 fc ff ff       	jmp    b9e <_do_seekable+0x48e>
        if (G.expect_ecrec_offset==0L && G.ecrec.size_central_directory==0) {
            if (uO.zipinfo_mode)
                Info(slide, 0, ((char *)slide, "%sEmpty zipfile.\n",
                  uO.lflag>9? "\n  " : ""));
            else
                Info(slide, 0x401, ((char *)slide, LoadFarString(ZipfileEmpty),
     f6b:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     f71:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     f77:	89 44 24 08          	mov    %eax,0x8(%esp)
     f7b:	c7 44 24 04 20 03 00 	movl   $0x320,0x4(%esp)
     f82:	00 
     f83:	89 3c 24             	mov    %edi,(%esp)
     f86:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
     f8c:	e8 00 00 00 00       	call   f91 <_do_seekable+0x881>
     f91:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     f98:	00 
     f99:	89 44 24 08          	mov    %eax,0x8(%esp)
     f9d:	89 7c 24 04          	mov    %edi,0x4(%esp)
     fa1:	89 1c 24             	mov    %ebx,(%esp)
     fa4:	ff d5                	call   *%ebp
     fa6:	83 ec 10             	sub    $0x10,%esp
     fa9:	e9 5a fc ff ff       	jmp    c08 <_do_seekable+0x4f8>
            error_in_archive = PK_ERR;
        } else if (G.extra_bytes > 0) {
            if ((G.ecrec.offset_start_central_directory == 0) &&
                (G.ecrec.size_central_directory != 0))   /* zip 1.5 -go bug */
            {
                Info(slide, 0x401, ((char *)slide,
     fae:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     fb4:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
     fba:	89 34 24             	mov    %esi,(%esp)
     fbd:	89 44 24 08          	mov    %eax,0x8(%esp)
     fc1:	c7 44 24 04 60 03 00 	movl   $0x360,0x4(%esp)
     fc8:	00 
     fc9:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     fcf:	e8 00 00 00 00       	call   fd4 <_do_seekable+0x8c4>
     fd4:	89 74 24 04          	mov    %esi,0x4(%esp)
     fd8:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     fdf:	00 
     fe0:	89 44 24 08          	mov    %eax,0x8(%esp)
     fe4:	89 1c 24             	mov    %ebx,(%esp)
                  LoadFarString(NullCentDirOffset), G.zipfn));
                G.ecrec.offset_start_central_directory = G.extra_bytes;
                G.extra_bytes = 0;
                error_in_archive = PK_ERR;
     fe7:	be 02 00 00 00       	mov    $0x2,%esi
            error_in_archive = PK_ERR;
        } else if (G.extra_bytes > 0) {
            if ((G.ecrec.offset_start_central_directory == 0) &&
                (G.ecrec.size_central_directory != 0))   /* zip 1.5 -go bug */
            {
                Info(slide, 0x401, ((char *)slide,
     fec:	ff d7                	call   *%edi
                  LoadFarString(NullCentDirOffset), G.zipfn));
                G.ecrec.offset_start_central_directory = G.extra_bytes;
     fee:	8b 83 14 09 01 00    	mov    0x10914(%ebx),%eax
            error_in_archive = PK_ERR;
        } else if (G.extra_bytes > 0) {
            if ((G.ecrec.offset_start_central_directory == 0) &&
                (G.ecrec.size_central_directory != 0))   /* zip 1.5 -go bug */
            {
                Info(slide, 0x401, ((char *)slide,
     ff4:	83 ec 10             	sub    $0x10,%esp
                  LoadFarString(NullCentDirOffset), G.zipfn));
                G.ecrec.offset_start_central_directory = G.extra_bytes;
     ff7:	89 83 74 09 01 00    	mov    %eax,0x10974(%ebx)
                G.extra_bytes = 0;
     ffd:	c7 83 14 09 01 00 00 	movl   $0x0,0x10914(%ebx)
    1004:	00 00 00 
    1007:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
                error_in_archive = PK_ERR;
    100d:	e9 8c fb ff ff       	jmp    b9e <_do_seekable+0x48e>
        or test member files as instructed, and close the zipfile.
      -----------------------------------------------------------------------*/

        error = seek_zipf(__G__ G.ecrec.offset_start_central_directory);
        if (error != PK_OK) {
            CLOSE_INFILE();
    1012:	8b 83 08 09 01 00    	mov    0x10908(%ebx),%eax
    1018:	89 04 24             	mov    %eax,(%esp)
    101b:	e8 00 00 00 00       	call   1020 <_do_seekable+0x910>
            return error;
    1020:	89 f8                	mov    %edi,%eax
    1022:	e9 d6 f7 ff ff       	jmp    7fd <_do_seekable+0xed>
                    LoadFarStringSmall(ReportMsg)));
                CLOSE_INFILE();
                return (error != PK_OK ? error : PK_BADERR);
            }
#ifndef SFX
            Info(slide, 0x401, ((char *)slide, LoadFarString(CentDirTooLong),
    1027:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
    102d:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
    1033:	f7 df                	neg    %edi
    1035:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    1039:	89 44 24 08          	mov    %eax,0x8(%esp)
    103d:	c7 44 24 04 20 02 00 	movl   $0x220,0x4(%esp)
    1044:	00 
    1045:	89 2c 24             	mov    %ebp,(%esp)
    1048:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    104e:	e8 00 00 00 00       	call   1053 <_do_seekable+0x943>
    1053:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    105a:	00 
    105b:	89 44 24 08          	mov    %eax,0x8(%esp)
    105f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
    1063:	89 1c 24             	mov    %ebx,(%esp)
    1066:	ff d6                	call   *%esi
              G.zipfn, -tmp));
#endif
            error_in_archive = PK_ERR;
    1068:	be 02 00 00 00       	mov    $0x2,%esi
                    LoadFarStringSmall(ReportMsg)));
                CLOSE_INFILE();
                return (error != PK_OK ? error : PK_BADERR);
            }
#ifndef SFX
            Info(slide, 0x401, ((char *)slide, LoadFarString(CentDirTooLong),
    106d:	83 ec 10             	sub    $0x10,%esp
    1070:	e9 e0 fc ff ff       	jmp    d55 <_do_seekable+0x645>
            else
#endif
#ifndef SFX
#ifdef TIMESTAMP
            if (uO.T_flag)
                error = get_time_stamp(__G__ &uxstamp, &nmember);
    1075:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    1079:	89 1c 24             	mov    %ebx,(%esp)
    107c:	89 44 24 08          	mov    %eax,0x8(%esp)
    1080:	8d 44 24 38          	lea    0x38(%esp),%eax
    1084:	89 44 24 04          	mov    %eax,0x4(%esp)
    1088:	e8 00 00 00 00       	call   108d <_do_seekable+0x97d>
    108d:	89 c7                	mov    %eax,%edi
    108f:	e9 1b fd ff ff       	jmp    daf <_do_seekable+0x69f>
        if (!G.fValidate)
#endif
        {
#ifndef NO_ZIPINFO
            if (uO.zipinfo_mode)
                error = zipinfo(__G);                 /* ZIPINFO 'EM */
    1094:	89 1c 24             	mov    %ebx,(%esp)
    1097:	e8 00 00 00 00       	call   109c <_do_seekable+0x98c>
    109c:	89 c7                	mov    %eax,%edi
    109e:	e9 0c fd ff ff       	jmp    daf <_do_seekable+0x69f>
        if (stamp_file(__G__ G.zipfn, uxstamp)) {       /* TIME-STAMP 'EM */
# else
        if (stamp_file(G.zipfn, uxstamp)) {             /* TIME-STAMP 'EM */
# endif
            if (uO.qflag < 3)
                Info(slide, 0x201, ((char *)slide,
    10a3:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
    10a9:	8b 83 04 09 01 00    	mov    0x10904(%ebx),%eax
    10af:	89 44 24 08          	mov    %eax,0x8(%esp)
    10b3:	c7 44 24 04 4c 01 00 	movl   $0x14c,0x4(%esp)
    10ba:	00 
    10bb:	89 3c 24             	mov    %edi,(%esp)
    10be:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
    10c4:	e8 00 00 00 00       	call   10c9 <_do_seekable+0x9b9>
    10c9:	c7 44 24 0c 01 02 00 	movl   $0x201,0xc(%esp)
    10d0:	00 
    10d1:	89 44 24 08          	mov    %eax,0x8(%esp)
    10d5:	89 7c 24 04          	mov    %edi,0x4(%esp)
    10d9:	89 1c 24             	mov    %ebx,(%esp)
    10dc:	ff d5                	call   *%ebp
    10de:	83 ec 10             	sub    $0x10,%esp
    10e1:	e9 bb f9 ff ff       	jmp    aa1 <_do_seekable+0x391>
            if (uO.T_flag)
                error = get_time_stamp(__G__ &uxstamp, &nmember);
            else
#endif
            if (uO.vflag && !uO.tflag && !uO.cflag)
                error = list_files(__G);              /* LIST 'EM */
    10e6:	89 1c 24             	mov    %ebx,(%esp)
    10e9:	e8 00 00 00 00       	call   10ee <_do_seekable+0x9de>
    10ee:	89 c7                	mov    %eax,%edi
    10f0:	e9 ba fc ff ff       	jmp    daf <_do_seekable+0x69f>
    10f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    10f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001100 <_process_zipfiles>:
/* Function process_zipfiles() */
/*******************************/

int process_zipfiles(__G)    /* return PK-type error code */
    __GDEF
{
    1100:	55                   	push   %ebp
    1101:	57                   	push   %edi
    1102:	56                   	push   %esi
    1103:	53                   	push   %ebx
    1104:	83 ec 3c             	sub    $0x3c,%esp
/*---------------------------------------------------------------------------
    Start by allocating buffers and (re)constructing the various PK signature
    strings.
  ---------------------------------------------------------------------------*/

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    1107:	c7 04 24 04 20 00 00 	movl   $0x2004,(%esp)
/* Function process_zipfiles() */
/*******************************/

int process_zipfiles(__G)    /* return PK-type error code */
    __GDEF
{
    110e:	8b 5c 24 50          	mov    0x50(%esp),%ebx
/*---------------------------------------------------------------------------
    Start by allocating buffers and (re)constructing the various PK signature
    strings.
  ---------------------------------------------------------------------------*/

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    1112:	e8 00 00 00 00       	call   1117 <_process_zipfiles+0x17>
    1117:	89 83 e4 08 01 00    	mov    %eax,0x108e4(%ebx)
    G.outbuf = (uch *)malloc(OUTBUFSIZ + 1);  /* 1 extra for string term. */
    111d:	c7 04 24 01 00 02 00 	movl   $0x20001,(%esp)
/*---------------------------------------------------------------------------
    Start by allocating buffers and (re)constructing the various PK signature
    strings.
  ---------------------------------------------------------------------------*/

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    1124:	89 c6                	mov    %eax,%esi
    G.outbuf = (uch *)malloc(OUTBUFSIZ + 1);  /* 1 extra for string term. */
    1126:	e8 00 00 00 00       	call   112b <_process_zipfiles+0x2b>

    if ((G.inbuf == (uch *)NULL) || (G.outbuf == (uch *)NULL)) {
    112b:	85 f6                	test   %esi,%esi
    Start by allocating buffers and (re)constructing the various PK signature
    strings.
  ---------------------------------------------------------------------------*/

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    G.outbuf = (uch *)malloc(OUTBUFSIZ + 1);  /* 1 extra for string term. */
    112d:	89 83 cc 09 01 00    	mov    %eax,0x109cc(%ebx)

    if ((G.inbuf == (uch *)NULL) || (G.outbuf == (uch *)NULL)) {
    1133:	0f 84 7d 01 00 00    	je     12b6 <_process_zipfiles+0x1b6>
    1139:	85 c0                	test   %eax,%eax
    113b:	0f 84 75 01 00 00    	je     12b6 <_process_zipfiles+0x1b6>
        Info(slide, 0x401, ((char *)slide,
          LoadFarString(CannotAllocateBuffers)));
        return(PK_MEM);
    }
    G.hold = G.inbuf + INBUFSIZ;     /* to check for boundary-spanning sigs */
    1141:	81 c6 00 20 00 00    	add    $0x2000,%esi
    CRC_32_TAB = NULL;
#endif /* 0 */

    /* finish up initialization of magic signature strings */
    local_hdr_sig[0]  /* = extd_local_sig[0] */ =       /* ASCII 'P', */
      central_hdr_sig[0] = end_central_sig[0] = 0x50;   /* not EBCDIC */
    1147:	c6 05 00 00 00 00 50 	movb   $0x50,0x0
    if ((G.inbuf == (uch *)NULL) || (G.outbuf == (uch *)NULL)) {
        Info(slide, 0x401, ((char *)slide,
          LoadFarString(CannotAllocateBuffers)));
        return(PK_MEM);
    }
    G.hold = G.inbuf + INBUFSIZ;     /* to check for boundary-spanning sigs */
    114e:	89 b3 1c 09 01 00    	mov    %esi,0x1091c(%ebx)

#if (defined(WIN32) && defined(USE_EF_UT_TIME))
    /* For the Win32 environment, we may have to "prepare" the environment
       prior to the tzset() call, to work around tzset() implementation bugs.
     */
    iz_w32_prepareTZenv();
    1154:	c7 04 24 7a 01 00 00 	movl   $0x17a,(%esp)
    CRC_32_TAB = NULL;
#endif /* 0 */

    /* finish up initialization of magic signature strings */
    local_hdr_sig[0]  /* = extd_local_sig[0] */ =       /* ASCII 'P', */
      central_hdr_sig[0] = end_central_sig[0] = 0x50;   /* not EBCDIC */
    115b:	c6 05 00 00 00 00 50 	movb   $0x50,0x0
    /* allocate the CRC table only later when we know we have a zipfile */
    CRC_32_TAB = NULL;
#endif /* 0 */

    /* finish up initialization of magic signature strings */
    local_hdr_sig[0]  /* = extd_local_sig[0] */ =       /* ASCII 'P', */
    1162:	c6 05 00 00 00 00 50 	movb   $0x50,0x0
      central_hdr_sig[0] = end_central_sig[0] = 0x50;   /* not EBCDIC */

    local_hdr_sig[1]  /* = extd_local_sig[1] */ =       /* ASCII 'K', */
      central_hdr_sig[1] = end_central_sig[1] = 0x4B;   /* not EBCDIC */
    1169:	c6 05 01 00 00 00 4b 	movb   $0x4b,0x1
    1170:	c6 05 01 00 00 00 4b 	movb   $0x4b,0x1

    /* finish up initialization of magic signature strings */
    local_hdr_sig[0]  /* = extd_local_sig[0] */ =       /* ASCII 'P', */
      central_hdr_sig[0] = end_central_sig[0] = 0x50;   /* not EBCDIC */

    local_hdr_sig[1]  /* = extd_local_sig[1] */ =       /* ASCII 'K', */
    1177:	c6 05 01 00 00 00 4b 	movb   $0x4b,0x1

#if (defined(WIN32) && defined(USE_EF_UT_TIME))
    /* For the Win32 environment, we may have to "prepare" the environment
       prior to the tzset() call, to work around tzset() implementation bugs.
     */
    iz_w32_prepareTZenv();
    117e:	e8 00 00 00 00       	call   1183 <_process_zipfiles+0x83>
/* For systems that do not have tzset() but supply this function using another
   name (_tzset() or something similar), an appropiate "#define tzset ..."
   should be added to the system specifc configuration section.  */
#if (!defined(T20_VMS) && !defined(MACOS) && !defined(RISCOS) && !defined(QDOS))
#if (!defined(BSD) && !defined(MTS) && !defined(CMS_MVS) && !defined(TANDEM))
    tzset();
    1183:	e8 00 00 00 00       	call   1188 <_process_zipfiles+0x88>
    processing archive files.  Such a change should not affect the option
    settings as passed through the DLL calling interface.
    In case of conflicting options, the 'safer' flag uO.overwrite_none takes
    precedence.
  ---------------------------------------------------------------------------*/
    G.overwrite_mode = (uO.overwrite_none ? OVERWRT_NEVER :
    1188:	8b 4b 30             	mov    0x30(%ebx),%ecx
    118b:	b8 02 00 00 00       	mov    $0x2,%eax
    1190:	85 c9                	test   %ecx,%ecx
    1192:	0f 84 a8 01 00 00    	je     1340 <_process_zipfiles+0x240>
    1198:	89 43 78             	mov    %eax,0x78(%ebx)
#ifndef SFX
    char *lastzipfn = (char *)NULL;
    int NumWinFiles, NumLoseFiles, NumWarnFiles;
    int NumMissDirs, NumMissFiles;
#endif
    int error=0, error_in_archive=0;
    119b:	31 ed                	xor    %ebp,%ebp
    119d:	31 ff                	xor    %edi,%edi
    }
#endif /* CHEAP_SFX_AUTORUN */

#else /* !SFX */
    NumWinFiles = NumLoseFiles = NumWarnFiles = 0;
    NumMissDirs = NumMissFiles = 0;
    119f:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
    11a6:	00 
    11a7:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    11ae:	00 
            Info(slide, 1, ((char *)slide, LoadFarString(NotAutoRunning)));
    }
#endif /* CHEAP_SFX_AUTORUN */

#else /* !SFX */
    NumWinFiles = NumLoseFiles = NumWarnFiles = 0;
    11af:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    11b6:	00 
    11b7:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    11be:	00 
    11bf:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
    11c6:	00 

int process_zipfiles(__G)    /* return PK-type error code */
    __GDEF
{
#ifndef SFX
    char *lastzipfn = (char *)NULL;
    11c7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    11ce:	00 

#else /* !SFX */
    NumWinFiles = NumLoseFiles = NumWarnFiles = 0;
    NumMissDirs = NumMissFiles = 0;

    while ((G.zipfn = do_wild(__G__ G.wildzipfn)) != (char *)NULL) {
    11cf:	eb 35                	jmp    1206 <_process_zipfiles+0x106>
            && (NumWinFiles+NumLoseFiles+NumWarnFiles+NumMissFiles) > 0)
            (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

        if ((error = do_seekable(__G__ 0)) == PK_WARN)
            ++NumWarnFiles;
        else if (error == IZ_DIR)
    11d1:	83 f8 4c             	cmp    $0x4c,%eax
    11d4:	0f 84 76 01 00 00    	je     1350 <_process_zipfiles+0x250>
            ++NumMissDirs;
        else if (error == PK_NOZIP)
    11da:	83 f8 09             	cmp    $0x9,%eax
    11dd:	0f 84 8d 01 00 00    	je     1370 <_process_zipfiles+0x270>
            ++NumMissFiles;
        else if (error)
    11e3:	85 c0                	test   %eax,%eax
    11e5:	0f 84 75 01 00 00    	je     1360 <_process_zipfiles+0x260>
            ++NumLoseFiles;
    11eb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    11ef:	40                   	inc    %eax
    11f0:	39 fd                	cmp    %edi,%ebp
    11f2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    11f6:	0f 4c ef             	cmovl  %edi,%ebp

        Trace((stderr, "do_seekable(0) returns %d\n", error));
        if (error != IZ_DIR && error > error_in_archive)
            error_in_archive = error;
#ifdef WINDLL
        if (error == IZ_CTRLC) {
    11f9:	83 ff 50             	cmp    $0x50,%edi
    11fc:	0f 84 ee 04 00 00    	je     16f0 <_process_zipfiles+0x5f0>
    1202:	89 74 24 14          	mov    %esi,0x14(%esp)

#else /* !SFX */
    NumWinFiles = NumLoseFiles = NumWarnFiles = 0;
    NumMissDirs = NumMissFiles = 0;

    while ((G.zipfn = do_wild(__G__ G.wildzipfn)) != (char *)NULL) {
    1206:	8b 83 00 09 01 00    	mov    0x10900(%ebx),%eax
    120c:	89 1c 24             	mov    %ebx,(%esp)
    120f:	89 44 24 04          	mov    %eax,0x4(%esp)
    1213:	e8 00 00 00 00       	call   1218 <_process_zipfiles+0x118>
    1218:	89 c6                	mov    %eax,%esi
    121a:	89 83 04 09 01 00    	mov    %eax,0x10904(%ebx)
    1220:	85 c0                	test   %eax,%eax
    1222:	0f 84 58 01 00 00    	je     1380 <_process_zipfiles+0x280>
        Trace((stderr, "do_wild( %s ) returns %s\n", G.wildzipfn, G.zipfn));

        lastzipfn = G.zipfn;

        /* print a blank line between the output of different zipfiles */
        if (!uO.qflag  &&  error != PK_NOZIP  &&  error != IZ_DIR
    1228:	8b 43 38             	mov    0x38(%ebx),%eax
    122b:	85 c0                	test   %eax,%eax
    122d:	75 52                	jne    1281 <_process_zipfiles+0x181>
    122f:	83 ff 09             	cmp    $0x9,%edi
    1232:	74 4d                	je     1281 <_process_zipfiles+0x181>
    1234:	83 ff 4c             	cmp    $0x4c,%edi
    1237:	74 48                	je     1281 <_process_zipfiles+0x181>
#ifdef TIMESTAMP
            && (!uO.T_flag || uO.zipinfo_mode)
    1239:	8b 43 48             	mov    0x48(%ebx),%eax
    123c:	85 c0                	test   %eax,%eax
    123e:	74 07                	je     1247 <_process_zipfiles+0x147>
    1240:	8b 7b 0c             	mov    0xc(%ebx),%edi
    1243:	85 ff                	test   %edi,%edi
    1245:	74 3a                	je     1281 <_process_zipfiles+0x181>
#endif
            && (NumWinFiles+NumLoseFiles+NumWarnFiles+NumMissFiles) > 0)
    1247:	8b 44 24 20          	mov    0x20(%esp),%eax
    124b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    124f:	01 d0                	add    %edx,%eax
    1251:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1255:	01 c8                	add    %ecx,%eax
    1257:	03 44 24 24          	add    0x24(%esp),%eax
    125b:	74 24                	je     1281 <_process_zipfiles+0x181>
            (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);
    125d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1264:	00 
    1265:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    126c:	00 
    126d:	c7 44 24 04 7e 01 00 	movl   $0x17e,0x4(%esp)
    1274:	00 
    1275:	89 1c 24             	mov    %ebx,(%esp)
    1278:	ff 93 44 0b 01 00    	call   *0x10b44(%ebx)
    127e:	83 ec 10             	sub    $0x10,%esp

        if ((error = do_seekable(__G__ 0)) == PK_WARN)
    1281:	31 d2                	xor    %edx,%edx
    1283:	89 d8                	mov    %ebx,%eax
    1285:	e8 86 f4 ff ff       	call   710 <_do_seekable>
    128a:	89 c7                	mov    %eax,%edi
    128c:	83 f8 01             	cmp    $0x1,%eax
    128f:	0f 85 3c ff ff ff    	jne    11d1 <_process_zipfiles+0xd1>
            ++NumWarnFiles;
    1295:	8b 44 24 18          	mov    0x18(%esp),%eax
    1299:	40                   	inc    %eax
    129a:	89 44 24 18          	mov    %eax,0x18(%esp)
            ++NumLoseFiles;
        else
            ++NumWinFiles;

        Trace((stderr, "do_seekable(0) returns %d\n", error));
        if (error != IZ_DIR && error > error_in_archive)
    129e:	39 ef                	cmp    %ebp,%edi
    12a0:	0f 8e 53 ff ff ff    	jle    11f9 <_process_zipfiles+0xf9>
    12a6:	83 ff 4c             	cmp    $0x4c,%edi
    12a9:	0f 84 4a ff ff ff    	je     11f9 <_process_zipfiles+0xf9>
    12af:	89 fd                	mov    %edi,%ebp
    12b1:	e9 4c ff ff ff       	jmp    1202 <_process_zipfiles+0x102>

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    G.outbuf = (uch *)malloc(OUTBUFSIZ + 1);  /* 1 extra for string term. */

    if ((G.inbuf == (uch *)NULL) || (G.outbuf == (uch *)NULL)) {
        Info(slide, 0x401, ((char *)slide,
    12b6:	8d 93 dc 08 00 00    	lea    0x8dc(%ebx),%edx
    12bc:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
    12c2:	89 d7                	mov    %edx,%edi
    12c4:	be 80 01 00 00       	mov    $0x180,%esi
    12c9:	b8 27 00 00 00       	mov    $0x27,%eax
    12ce:	f6 c2 01             	test   $0x1,%dl
    12d1:	0f 85 2e 04 00 00    	jne    1705 <_process_zipfiles+0x605>
    12d7:	f7 c7 02 00 00 00    	test   $0x2,%edi
    12dd:	0f 85 42 04 00 00    	jne    1725 <_process_zipfiles+0x625>
    12e3:	89 c1                	mov    %eax,%ecx
    12e5:	c1 e9 02             	shr    $0x2,%ecx
    12e8:	a8 02                	test   $0x2,%al
    12ea:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    12ec:	75 3a                	jne    1328 <_process_zipfiles+0x228>
    12ee:	a8 01                	test   $0x1,%al
    12f0:	75 2e                	jne    1320 <_process_zipfiles+0x220>
    12f2:	89 1c 24             	mov    %ebx,(%esp)
    12f5:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    12fc:	00 
    12fd:	c7 44 24 08 26 00 00 	movl   $0x26,0x8(%esp)
    1304:	00 
    1305:	89 54 24 04          	mov    %edx,0x4(%esp)
    1309:	ff d5                	call   *%ebp
          LoadFarString(CannotAllocateBuffers)));
        return(PK_MEM);
    130b:	b8 04 00 00 00       	mov    $0x4,%eax

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    G.outbuf = (uch *)malloc(OUTBUFSIZ + 1);  /* 1 extra for string term. */

    if ((G.inbuf == (uch *)NULL) || (G.outbuf == (uch *)NULL)) {
        Info(slide, 0x401, ((char *)slide,
    1310:	83 ec 10             	sub    $0x10,%esp
    /* free allocated memory */
    free_G_buffers(__G);

    return error_in_archive;

} /* end function process_zipfiles() */
    1313:	83 c4 3c             	add    $0x3c,%esp
    1316:	5b                   	pop    %ebx
    1317:	5e                   	pop    %esi
    1318:	5f                   	pop    %edi
    1319:	5d                   	pop    %ebp
    131a:	c3                   	ret    
    131b:	90                   	nop
    131c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    G.outbuf = (uch *)malloc(OUTBUFSIZ + 1);  /* 1 extra for string term. */

    if ((G.inbuf == (uch *)NULL) || (G.outbuf == (uch *)NULL)) {
        Info(slide, 0x401, ((char *)slide,
    1320:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    1323:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    1326:	eb ca                	jmp    12f2 <_process_zipfiles+0x1f2>
    1328:	66 8b 0e             	mov    (%esi),%cx
    132b:	a8 01                	test   $0x1,%al
    132d:	66 89 0f             	mov    %cx,(%edi)
    1330:	b9 02 00 00 00       	mov    $0x2,%ecx
    1335:	74 bb                	je     12f2 <_process_zipfiles+0x1f2>
    1337:	eb e7                	jmp    1320 <_process_zipfiles+0x220>
    1339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    processing archive files.  Such a change should not affect the option
    settings as passed through the DLL calling interface.
    In case of conflicting options, the 'safer' flag uO.overwrite_none takes
    precedence.
  ---------------------------------------------------------------------------*/
    G.overwrite_mode = (uO.overwrite_none ? OVERWRT_NEVER :
    1340:	31 c0                	xor    %eax,%eax
    1342:	8b 53 34             	mov    0x34(%ebx),%edx
    1345:	85 d2                	test   %edx,%edx
    1347:	0f 95 c0             	setne  %al
    134a:	e9 49 fe ff ff       	jmp    1198 <_process_zipfiles+0x98>
    134f:	90                   	nop
            (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

        if ((error = do_seekable(__G__ 0)) == PK_WARN)
            ++NumWarnFiles;
        else if (error == IZ_DIR)
            ++NumMissDirs;
    1350:	8b 44 24 28          	mov    0x28(%esp),%eax
    1354:	40                   	inc    %eax
    1355:	89 44 24 28          	mov    %eax,0x28(%esp)
    1359:	e9 a4 fe ff ff       	jmp    1202 <_process_zipfiles+0x102>
    135e:	66 90                	xchg   %ax,%ax
        else if (error == PK_NOZIP)
            ++NumMissFiles;
        else if (error)
            ++NumLoseFiles;
        else
            ++NumWinFiles;
    1360:	8b 44 24 20          	mov    0x20(%esp),%eax
    1364:	40                   	inc    %eax
    1365:	89 44 24 20          	mov    %eax,0x20(%esp)
    1369:	e9 30 ff ff ff       	jmp    129e <_process_zipfiles+0x19e>
    136e:	66 90                	xchg   %ax,%ax
        if ((error = do_seekable(__G__ 0)) == PK_WARN)
            ++NumWarnFiles;
        else if (error == IZ_DIR)
            ++NumMissDirs;
        else if (error == PK_NOZIP)
            ++NumMissFiles;
    1370:	8b 44 24 24          	mov    0x24(%esp),%eax
    1374:	40                   	inc    %eax
    1375:	89 44 24 24          	mov    %eax,0x24(%esp)
    1379:	e9 20 ff ff ff       	jmp    129e <_process_zipfiles+0x19e>
    137e:	66 90                	xchg   %ax,%ax
    1380:	8b 44 24 24          	mov    0x24(%esp),%eax
    1384:	8b 74 24 20          	mov    0x20(%esp),%esi
    1388:	89 c2                	mov    %eax,%edx
    138a:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    138e:	8b 44 24 28          	mov    0x28(%esp),%eax
    1392:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    1396:	89 c7                	mov    %eax,%edi
    1398:	8b 44 24 18          	mov    0x18(%esp),%eax
    139c:	89 44 24 24          	mov    %eax,0x24(%esp)
        }
#endif

    } /* end while-loop (wildcard zipfiles) */

    if ((NumWinFiles + NumWarnFiles + NumLoseFiles) == 0  &&
    13a0:	01 f0                	add    %esi,%eax
    13a2:	89 74 24 18          	mov    %esi,0x18(%esp)
    13a6:	01 c8                	add    %ecx,%eax
    13a8:	0f 85 a2 00 00 00    	jne    1450 <_process_zipfiles+0x350>
        (NumMissDirs + NumMissFiles) == 1  &&  lastzipfn != (char *)NULL)
    13ae:	89 d0                	mov    %edx,%eax
    13b0:	01 f8                	add    %edi,%eax
    13b2:	48                   	dec    %eax
    13b3:	0f 85 97 00 00 00    	jne    1450 <_process_zipfiles+0x350>
    13b9:	8b 44 24 14          	mov    0x14(%esp),%eax
    13bd:	85 c0                	test   %eax,%eax
    13bf:	0f 84 8b 00 00 00    	je     1450 <_process_zipfiles+0x350>
    {
#if (!defined(UNIX) && !defined(AMIGA)) /* filenames with wildcard characters */
        if (iswild(G.wildzipfn)) {
    13c5:	8b 83 00 09 01 00    	mov    0x10900(%ebx),%eax
    13cb:	89 04 24             	mov    %eax,(%esp)
    13ce:	e8 00 00 00 00       	call   13d3 <_process_zipfiles+0x2d3>
    13d3:	85 c0                	test   %eax,%eax
    13d5:	0f 85 5f 03 00 00    	jne    173a <_process_zipfiles+0x63a>
                  G.wildzipfn));
            }
        } else
#endif
        {
            char *p = lastzipfn + strlen(lastzipfn);
    13db:	8b 74 24 14          	mov    0x14(%esp),%esi
    13df:	89 34 24             	mov    %esi,(%esp)
    13e2:	e8 00 00 00 00       	call   13e7 <_process_zipfiles+0x2e7>

            G.zipfn = lastzipfn;
    13e7:	89 b3 04 09 01 00    	mov    %esi,0x10904(%ebx)
                    ++NumMissDirs;
                strcpy(p, ALT_ZSUFX);
                error = do_seekable(__G__ 1);
            }
#else
            error = do_seekable(__G__ 1);
    13ed:	ba 01 00 00 00       	mov    $0x1,%edx
                  G.wildzipfn));
            }
        } else
#endif
        {
            char *p = lastzipfn + strlen(lastzipfn);
    13f2:	8d 34 06             	lea    (%esi,%eax,1),%esi
                    ++NumMissDirs;
                strcpy(p, ALT_ZSUFX);
                error = do_seekable(__G__ 1);
            }
#else
            error = do_seekable(__G__ 1);
    13f5:	89 d8                	mov    %ebx,%eax
#endif
        {
            char *p = lastzipfn + strlen(lastzipfn);

            G.zipfn = lastzipfn;
            strcpy(p, ZSUFX);
    13f7:	c7 06 2e 7a 69 70    	movl   $0x70697a2e,(%esi)
    13fd:	c6 46 04 00          	movb   $0x0,0x4(%esi)
                    ++NumMissDirs;
                strcpy(p, ALT_ZSUFX);
                error = do_seekable(__G__ 1);
            }
#else
            error = do_seekable(__G__ 1);
    1401:	e8 0a f3 ff ff       	call   710 <_do_seekable>
    1406:	89 c5                	mov    %eax,%ebp
#endif
            Trace((stderr, "do_seekable(1) returns %d\n", error));
            switch (error) {
    1408:	83 f8 09             	cmp    $0x9,%eax
    140b:	0f 84 a2 04 00 00    	je     18b3 <_process_zipfiles+0x7b3>
    1411:	83 f8 4c             	cmp    $0x4c,%eax
    1414:	0f 84 8a 04 00 00    	je     18a4 <_process_zipfiles+0x7a4>
    141a:	83 f8 01             	cmp    $0x1,%eax
    141d:	0f 84 63 04 00 00    	je     1886 <_process_zipfiles+0x786>
                /* increment again => bug:
                   "1 file had no zipfile directory." */
                /* ++NumMissFiles */ ;
                break;
              default:
                if (error)
    1423:	85 c0                	test   %eax,%eax
    1425:	0f 84 92 04 00 00    	je     18bd <_process_zipfiles+0x7bd>
                    ++NumLoseFiles;
    142b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    142f:	46                   	inc    %esi
                else
                    ++NumWinFiles;
                break;
            }

            if (error > error_in_archive)
    1430:	85 c0                	test   %eax,%eax
                   "1 file had no zipfile directory." */
                /* ++NumMissFiles */ ;
                break;
              default:
                if (error)
                    ++NumLoseFiles;
    1432:	89 74 24 1c          	mov    %esi,0x1c(%esp)
                else
                    ++NumWinFiles;
                break;
            }

            if (error > error_in_archive)
    1436:	0f 8f 9c 02 00 00    	jg     16d8 <_process_zipfiles+0x5d8>
        (NumMissDirs + NumMissFiles) == 1  &&  lastzipfn != (char *)NULL)
    {
#if (!defined(UNIX) && !defined(AMIGA)) /* filenames with wildcard characters */
        if (iswild(G.wildzipfn)) {
            if (iswild(lastzipfn)) {
                NumMissDirs = NumMissFiles = 0;
    143c:	31 ed                	xor    %ebp,%ebp
            char *p = lastzipfn + strlen(lastzipfn);

            G.zipfn = lastzipfn;
            strcpy(p, ZSUFX);

            NumMissDirs = NumMissFiles = 0;
    143e:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
    1445:	00 
    1446:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    144d:	00 
    144e:	66 90                	xchg   %ax,%ax
    Print summary of all zipfiles, assuming zipfile spec was a wildcard (no
    need for a summary if just one zipfile).
  ---------------------------------------------------------------------------*/

#ifndef SFX
    if (iswild(G.wildzipfn) && uO.qflag < 3
    1450:	8b 83 00 09 01 00    	mov    0x10900(%ebx),%eax
    1456:	89 04 24             	mov    %eax,(%esp)
    1459:	e8 00 00 00 00       	call   145e <_process_zipfiles+0x35e>
    145e:	85 c0                	test   %eax,%eax
    1460:	0f 84 60 02 00 00    	je     16c6 <_process_zipfiles+0x5c6>
    1466:	8b 43 38             	mov    0x38(%ebx),%eax
    1469:	83 f8 02             	cmp    $0x2,%eax
    146c:	0f 8f 54 02 00 00    	jg     16c6 <_process_zipfiles+0x5c6>
#ifdef TIMESTAMP
        && !(uO.T_flag && uO.qflag && !uO.zipinfo_mode)
    1472:	8b 53 48             	mov    0x48(%ebx),%edx
    1475:	85 d2                	test   %edx,%edx
    1477:	0f 94 c2             	sete   %dl
    147a:	74 0f                	je     148b <_process_zipfiles+0x38b>
    147c:	85 c0                	test   %eax,%eax
    147e:	74 0b                	je     148b <_process_zipfiles+0x38b>
    1480:	8b 7b 0c             	mov    0xc(%ebx),%edi
    1483:	85 ff                	test   %edi,%edi
    1485:	0f 84 3b 02 00 00    	je     16c6 <_process_zipfiles+0x5c6>
#endif
                                                    )
    {
        if ((NumMissFiles + NumLoseFiles + NumWarnFiles > 0 || NumWinFiles != 1)
    148b:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    148f:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    1493:	01 f1                	add    %esi,%ecx
    1495:	03 4c 24 24          	add    0x24(%esp),%ecx
    1499:	75 0b                	jne    14a6 <_process_zipfiles+0x3a6>
    149b:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    14a0:	0f 84 42 03 00 00    	je     17e8 <_process_zipfiles+0x6e8>
#ifdef TIMESTAMP
            && !(uO.T_flag && !uO.zipinfo_mode)
    14a6:	84 d2                	test   %dl,%dl
    14a8:	75 07                	jne    14b1 <_process_zipfiles+0x3b1>
    14aa:	8b 7b 0c             	mov    0xc(%ebx),%edi
    14ad:	85 ff                	test   %edi,%edi
    14af:	74 14                	je     14c5 <_process_zipfiles+0x3c5>
#endif
            && !(uO.tflag && uO.qflag > 1))
    14b1:	8b 73 44             	mov    0x44(%ebx),%esi
    14b4:	85 f6                	test   %esi,%esi
    14b6:	0f 84 fd 02 00 00    	je     17b9 <_process_zipfiles+0x6b9>
    14bc:	83 f8 02             	cmp    $0x2,%eax
    14bf:	0f 85 f4 02 00 00    	jne    17b9 <_process_zipfiles+0x6b9>
            (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0x401);
        if ((NumWinFiles > 1) || (NumWinFiles == 1 &&
    14c5:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)
    14ca:	0f 8e 12 03 00 00    	jle    17e2 <_process_zipfiles+0x6e2>
            NumMissDirs + NumMissFiles + NumLoseFiles + NumWarnFiles > 0))
            Info(slide, 0x401, ((char *)slide, LoadFarString(FilesProcessOK),
    14d0:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    14d6:	b8 73 01 00 00       	mov    $0x173,%eax
    14db:	89 44 24 0c          	mov    %eax,0xc(%esp)
    14df:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
    14e5:	8b 44 24 18          	mov    0x18(%esp),%eax
    14e9:	c7 44 24 04 40 09 00 	movl   $0x940,0x4(%esp)
    14f0:	00 
    14f1:	89 44 24 08          	mov    %eax,0x8(%esp)
    14f5:	89 3c 24             	mov    %edi,(%esp)
    14f8:	e8 00 00 00 00       	call   14fd <_process_zipfiles+0x3fd>
    14fd:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1504:	00 
    1505:	89 44 24 08          	mov    %eax,0x8(%esp)
    1509:	89 7c 24 04          	mov    %edi,0x4(%esp)
    150d:	89 1c 24             	mov    %ebx,(%esp)
    1510:	ff d6                	call   *%esi
    1512:	83 ec 10             	sub    $0x10,%esp
              NumWinFiles, (NumWinFiles == 1)? " was" : "s were"));
        if (NumWarnFiles > 0)
    1515:	8b 4c 24 24          	mov    0x24(%esp),%ecx
    1519:	89 c8                	mov    %ecx,%eax
    151b:	85 c9                	test   %ecx,%ecx
    151d:	74 4a                	je     1569 <_process_zipfiles+0x469>
            Info(slide, 0x401, ((char *)slide, LoadFarString(ArchiveWarning),
    151f:	48                   	dec    %eax
    1520:	ba 32 01 00 00       	mov    $0x132,%edx
    1525:	b8 2e 01 00 00       	mov    $0x12e,%eax
    152a:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
    1530:	0f 45 c2             	cmovne %edx,%eax
    1533:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    1539:	89 44 24 0c          	mov    %eax,0xc(%esp)
    153d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    1541:	c7 44 24 04 00 09 00 	movl   $0x900,0x4(%esp)
    1548:	00 
    1549:	89 3c 24             	mov    %edi,(%esp)
    154c:	e8 00 00 00 00       	call   1551 <_process_zipfiles+0x451>
    1551:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1558:	00 
    1559:	89 44 24 08          	mov    %eax,0x8(%esp)
    155d:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1561:	89 1c 24             	mov    %ebx,(%esp)
    1564:	ff d6                	call   *%esi
    1566:	83 ec 10             	sub    $0x10,%esp
              NumWarnFiles, (NumWarnFiles == 1)? "" : "s"));
        if (NumLoseFiles > 0)
    1569:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    156d:	89 c8                	mov    %ecx,%eax
    156f:	85 c9                	test   %ecx,%ecx
    1571:	74 4a                	je     15bd <_process_zipfiles+0x4bd>
            Info(slide, 0x401, ((char *)slide, LoadFarString(ArchiveFatalError),
    1573:	48                   	dec    %eax
    1574:	ba 32 01 00 00       	mov    $0x132,%edx
    1579:	b8 2e 01 00 00       	mov    $0x12e,%eax
    157e:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
    1584:	0f 45 c2             	cmovne %edx,%eax
    1587:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    158d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1591:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    1595:	c7 44 24 04 e0 08 00 	movl   $0x8e0,0x4(%esp)
    159c:	00 
    159d:	89 3c 24             	mov    %edi,(%esp)
    15a0:	e8 00 00 00 00       	call   15a5 <_process_zipfiles+0x4a5>
    15a5:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    15ac:	00 
    15ad:	89 44 24 08          	mov    %eax,0x8(%esp)
    15b1:	89 7c 24 04          	mov    %edi,0x4(%esp)
    15b5:	89 1c 24             	mov    %ebx,(%esp)
    15b8:	ff d6                	call   *%esi
    15ba:	83 ec 10             	sub    $0x10,%esp
              NumLoseFiles, (NumLoseFiles == 1)? "" : "s"));
        if (NumMissFiles > 0)
    15bd:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    15c1:	89 c8                	mov    %ecx,%eax
    15c3:	85 c9                	test   %ecx,%ecx
    15c5:	74 4a                	je     1611 <_process_zipfiles+0x511>
            Info(slide, 0x401, ((char *)slide,
    15c7:	48                   	dec    %eax
    15c8:	ba 32 01 00 00       	mov    $0x132,%edx
    15cd:	b8 2e 01 00 00       	mov    $0x12e,%eax
    15d2:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
    15d8:	0f 45 c2             	cmovne %edx,%eax
    15db:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    15e1:	89 44 24 0c          	mov    %eax,0xc(%esp)
    15e5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    15e9:	c7 44 24 04 a0 08 00 	movl   $0x8a0,0x4(%esp)
    15f0:	00 
    15f1:	89 3c 24             	mov    %edi,(%esp)
    15f4:	e8 00 00 00 00       	call   15f9 <_process_zipfiles+0x4f9>
    15f9:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1600:	00 
    1601:	89 44 24 08          	mov    %eax,0x8(%esp)
    1605:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1609:	89 1c 24             	mov    %ebx,(%esp)
    160c:	ff d6                	call   *%esi
    160e:	83 ec 10             	sub    $0x10,%esp
              LoadFarString(FileHadNoZipfileDir), NumMissFiles,
              (NumMissFiles == 1)? "" : "s"));
        if (NumMissDirs == 1)
    1611:	83 7c 24 28 01       	cmpl   $0x1,0x28(%esp)
    1616:	0f 84 f6 01 00 00    	je     1812 <_process_zipfiles+0x712>
            Info(slide, 0x401, ((char *)slide, LoadFarString(ZipfileWasDir)));
        else if (NumMissDirs > 0)
    161c:	8b 44 24 28          	mov    0x28(%esp),%eax
    1620:	85 c0                	test   %eax,%eax
    1622:	74 38                	je     165c <_process_zipfiles+0x55c>
            Info(slide, 0x401, ((char *)slide,
    1624:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
    162a:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    1630:	89 44 24 08          	mov    %eax,0x8(%esp)
    1634:	c7 44 24 04 60 08 00 	movl   $0x860,0x4(%esp)
    163b:	00 
    163c:	89 3c 24             	mov    %edi,(%esp)
    163f:	e8 00 00 00 00       	call   1644 <_process_zipfiles+0x544>
    1644:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    164b:	00 
    164c:	89 44 24 08          	mov    %eax,0x8(%esp)
    1650:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1654:	89 1c 24             	mov    %ebx,(%esp)
    1657:	ff d6                	call   *%esi
    1659:	83 ec 10             	sub    $0x10,%esp
              LoadFarString(ManyZipfilesWereDir), NumMissDirs));
        if (NumWinFiles + NumLoseFiles + NumWarnFiles == 0)
    165c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    1660:	8b 7c 24 18          	mov    0x18(%esp),%edi
    1664:	01 c7                	add    %eax,%edi
    1666:	8b 44 24 24          	mov    0x24(%esp),%eax
    166a:	01 f8                	add    %edi,%eax
    166c:	75 58                	jne    16c6 <_process_zipfiles+0x5c6>
            Info(slide, 0x401, ((char *)slide, LoadFarString(NoZipfileFound)));
    166e:	8d 83 dc 08 00 00    	lea    0x8dc(%ebx),%eax
    1674:	c7 83 dc 08 00 00 4e 	movl   $0x7a206f4e,0x8dc(%ebx)
    167b:	6f 20 7a 
    167e:	c7 83 e0 08 00 00 69 	movl   $0x69667069,0x8e0(%ebx)
    1685:	70 66 69 
    1688:	c7 83 e4 08 00 00 6c 	movl   $0x2073656c,0x8e4(%ebx)
    168f:	65 73 20 
    1692:	c7 83 e8 08 00 00 66 	movl   $0x6e756f66,0x8e8(%ebx)
    1699:	6f 75 6e 
    169c:	c7 83 ec 08 00 00 64 	movl   $0xa2e64,0x8ec(%ebx)
    16a3:	2e 0a 00 
    16a6:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    16ad:	00 
    16ae:	c7 44 24 08 13 00 00 	movl   $0x13,0x8(%esp)
    16b5:	00 
    16b6:	89 44 24 04          	mov    %eax,0x4(%esp)
    16ba:	89 1c 24             	mov    %ebx,(%esp)
    16bd:	ff 93 44 0b 01 00    	call   *0x10b44(%ebx)
    16c3:	83 ec 10             	sub    $0x10,%esp
    }
#endif /* !SFX */

    /* free allocated memory */
    free_G_buffers(__G);
    16c6:	89 1c 24             	mov    %ebx,(%esp)
    16c9:	e8 32 ee ff ff       	call   500 <_free_G_buffers>

    return error_in_archive;

} /* end function process_zipfiles() */
    16ce:	83 c4 3c             	add    $0x3c,%esp
#endif /* !SFX */

    /* free allocated memory */
    free_G_buffers(__G);

    return error_in_archive;
    16d1:	89 e8                	mov    %ebp,%eax

} /* end function process_zipfiles() */
    16d3:	5b                   	pop    %ebx
    16d4:	5e                   	pop    %esi
    16d5:	5f                   	pop    %edi
    16d6:	5d                   	pop    %ebp
    16d7:	c3                   	ret    
            char *p = lastzipfn + strlen(lastzipfn);

            G.zipfn = lastzipfn;
            strcpy(p, ZSUFX);

            NumMissDirs = NumMissFiles = 0;
    16d8:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    16df:	00 
            }

            if (error > error_in_archive)
                error_in_archive = error;
#ifdef WINDLL
            if (error == IZ_CTRLC) {
    16e0:	83 f8 50             	cmp    $0x50,%eax
    16e3:	0f 85 ae 01 00 00    	jne    1897 <_process_zipfiles+0x797>
    16e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        Trace((stderr, "do_seekable(0) returns %d\n", error));
        if (error != IZ_DIR && error > error_in_archive)
            error_in_archive = error;
#ifdef WINDLL
        if (error == IZ_CTRLC) {
            free_G_buffers(__G);
    16f0:	89 1c 24             	mov    %ebx,(%esp)
    16f3:	e8 08 ee ff ff       	call   500 <_free_G_buffers>
    /* free allocated memory */
    free_G_buffers(__G);

    return error_in_archive;

} /* end function process_zipfiles() */
    16f8:	83 c4 3c             	add    $0x3c,%esp
        if (error != IZ_DIR && error > error_in_archive)
            error_in_archive = error;
#ifdef WINDLL
        if (error == IZ_CTRLC) {
            free_G_buffers(__G);
            return error;
    16fb:	b8 50 00 00 00       	mov    $0x50,%eax
    /* free allocated memory */
    free_G_buffers(__G);

    return error_in_archive;

} /* end function process_zipfiles() */
    1700:	5b                   	pop    %ebx
    1701:	5e                   	pop    %esi
    1702:	5f                   	pop    %edi
    1703:	5d                   	pop    %ebp
    1704:	c3                   	ret    

    G.inbuf = (uch *)malloc(INBUFSIZ + 4);    /* 4 extra for hold[] (below) */
    G.outbuf = (uch *)malloc(OUTBUFSIZ + 1);  /* 1 extra for string term. */

    if ((G.inbuf == (uch *)NULL) || (G.outbuf == (uch *)NULL)) {
        Info(slide, 0x401, ((char *)slide,
    1705:	a0 80 01 00 00       	mov    0x180,%al
    170a:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    1710:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    1716:	be 81 01 00 00       	mov    $0x181,%esi
    171b:	b8 26 00 00 00       	mov    $0x26,%eax
    1720:	e9 b2 fb ff ff       	jmp    12d7 <_process_zipfiles+0x1d7>
    1725:	66 8b 0e             	mov    (%esi),%cx
    1728:	83 c7 02             	add    $0x2,%edi
    172b:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    172f:	83 c6 02             	add    $0x2,%esi
    1732:	83 e8 02             	sub    $0x2,%eax
    1735:	e9 a9 fb ff ff       	jmp    12e3 <_process_zipfiles+0x1e3>
    if ((NumWinFiles + NumWarnFiles + NumLoseFiles) == 0  &&
        (NumMissDirs + NumMissFiles) == 1  &&  lastzipfn != (char *)NULL)
    {
#if (!defined(UNIX) && !defined(AMIGA)) /* filenames with wildcard characters */
        if (iswild(G.wildzipfn)) {
            if (iswild(lastzipfn)) {
    173a:	8b 44 24 14          	mov    0x14(%esp),%eax
    173e:	89 04 24             	mov    %eax,(%esp)
    1741:	e8 00 00 00 00       	call   1746 <_process_zipfiles+0x646>
    1746:	85 c0                	test   %eax,%eax
    1748:	0f 84 02 fd ff ff    	je     1450 <_process_zipfiles+0x350>
                NumMissDirs = NumMissFiles = 0;
                error_in_archive = PK_COOL;
                Info(slide, 0x401, ((char *)slide,
    174e:	8b 6b 0c             	mov    0xc(%ebx),%ebp
    1751:	b9 58 07 00 00       	mov    $0x758,%ecx
    1756:	b8 00 00 00 00       	mov    $0x0,%eax
    175b:	8b 93 00 09 01 00    	mov    0x10900(%ebx),%edx
    1761:	85 ed                	test   %ebp,%ebp
    1763:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
    1769:	0f 44 c1             	cmove  %ecx,%eax
    176c:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    1772:	89 54 24 0c          	mov    %edx,0xc(%esp)
    1776:	89 44 24 08          	mov    %eax,0x8(%esp)
    177a:	c7 44 24 04 20 08 00 	movl   $0x820,0x4(%esp)
    1781:	00 
    1782:	89 3c 24             	mov    %edi,(%esp)
    {
#if (!defined(UNIX) && !defined(AMIGA)) /* filenames with wildcard characters */
        if (iswild(G.wildzipfn)) {
            if (iswild(lastzipfn)) {
                NumMissDirs = NumMissFiles = 0;
                error_in_archive = PK_COOL;
    1785:	31 ed                	xor    %ebp,%ebp
                Info(slide, 0x401, ((char *)slide,
    1787:	e8 00 00 00 00       	call   178c <_process_zipfiles+0x68c>
    178c:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    1793:	00 
    1794:	89 44 24 08          	mov    %eax,0x8(%esp)
    1798:	89 7c 24 04          	mov    %edi,0x4(%esp)
    179c:	89 1c 24             	mov    %ebx,(%esp)
    179f:	ff d6                	call   *%esi
    17a1:	83 ec 10             	sub    $0x10,%esp
        (NumMissDirs + NumMissFiles) == 1  &&  lastzipfn != (char *)NULL)
    {
#if (!defined(UNIX) && !defined(AMIGA)) /* filenames with wildcard characters */
        if (iswild(G.wildzipfn)) {
            if (iswild(lastzipfn)) {
                NumMissDirs = NumMissFiles = 0;
    17a4:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
    17ab:	00 
    17ac:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    17b3:	00 
    17b4:	e9 97 fc ff ff       	jmp    1450 <_process_zipfiles+0x350>
        if ((NumMissFiles + NumLoseFiles + NumWarnFiles > 0 || NumWinFiles != 1)
#ifdef TIMESTAMP
            && !(uO.T_flag && !uO.zipinfo_mode)
#endif
            && !(uO.tflag && uO.qflag > 1))
            (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0x401);
    17b9:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    17c0:	00 
    17c1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    17c8:	00 
    17c9:	c7 44 24 04 7e 01 00 	movl   $0x17e,0x4(%esp)
    17d0:	00 
    17d1:	89 1c 24             	mov    %ebx,(%esp)
    17d4:	ff 93 44 0b 01 00    	call   *0x10b44(%ebx)
    17da:	83 ec 10             	sub    $0x10,%esp
    17dd:	e9 e3 fc ff ff       	jmp    14c5 <_process_zipfiles+0x3c5>
        if ((NumWinFiles > 1) || (NumWinFiles == 1 &&
    17e2:	0f 85 2d fd ff ff    	jne    1515 <_process_zipfiles+0x415>
            NumMissDirs + NumMissFiles + NumLoseFiles + NumWarnFiles > 0))
    17e8:	8b 44 24 28          	mov    0x28(%esp),%eax
    17ec:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    17f0:	01 d0                	add    %edx,%eax
    17f2:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    17f6:	01 c8                	add    %ecx,%eax
#ifdef TIMESTAMP
            && !(uO.T_flag && !uO.zipinfo_mode)
#endif
            && !(uO.tflag && uO.qflag > 1))
            (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0x401);
        if ((NumWinFiles > 1) || (NumWinFiles == 1 &&
    17f8:	03 44 24 24          	add    0x24(%esp),%eax
    17fc:	0f 84 13 fd ff ff    	je     1515 <_process_zipfiles+0x415>
            NumMissDirs + NumMissFiles + NumLoseFiles + NumWarnFiles > 0))
            Info(slide, 0x401, ((char *)slide, LoadFarString(FilesProcessOK),
    1802:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
    1808:	b8 6e 01 00 00       	mov    $0x16e,%eax
    180d:	e9 c9 fc ff ff       	jmp    14db <_process_zipfiles+0x3db>
        if (NumMissFiles > 0)
            Info(slide, 0x401, ((char *)slide,
              LoadFarString(FileHadNoZipfileDir), NumMissFiles,
              (NumMissFiles == 1)? "" : "s"));
        if (NumMissDirs == 1)
            Info(slide, 0x401, ((char *)slide, LoadFarString(ZipfileWasDir)));
    1812:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
    1818:	8d 93 dc 08 00 00    	lea    0x8dc(%ebx),%edx
    181e:	89 44 24 14          	mov    %eax,0x14(%esp)
    1822:	89 d7                	mov    %edx,%edi
    1824:	be a7 01 00 00       	mov    $0x1a7,%esi
    1829:	b8 1e 00 00 00       	mov    $0x1e,%eax
    182e:	f6 c2 01             	test   $0x1,%dl
    1831:	0f 85 a9 00 00 00    	jne    18e0 <_process_zipfiles+0x7e0>
    1837:	f7 c7 02 00 00 00    	test   $0x2,%edi
    183d:	0f 85 88 00 00 00    	jne    18cb <_process_zipfiles+0x7cb>
    1843:	89 c1                	mov    %eax,%ecx
    1845:	c1 e9 02             	shr    $0x2,%ecx
    1848:	a8 02                	test   $0x2,%al
    184a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    184c:	74 0b                	je     1859 <_process_zipfiles+0x759>
    184e:	66 8b 0e             	mov    (%esi),%cx
    1851:	66 89 0f             	mov    %cx,(%edi)
    1854:	b9 02 00 00 00       	mov    $0x2,%ecx
    1859:	a8 01                	test   $0x1,%al
    185b:	74 06                	je     1863 <_process_zipfiles+0x763>
    185d:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    1860:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    1863:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    186a:	00 
    186b:	c7 44 24 08 1d 00 00 	movl   $0x1d,0x8(%esp)
    1872:	00 
    1873:	89 54 24 04          	mov    %edx,0x4(%esp)
    1877:	89 1c 24             	mov    %ebx,(%esp)
    187a:	ff 54 24 14          	call   *0x14(%esp)
    187e:	83 ec 10             	sub    $0x10,%esp
    1881:	e9 d6 fd ff ff       	jmp    165c <_process_zipfiles+0x55c>
            error = do_seekable(__G__ 1);
#endif
            Trace((stderr, "do_seekable(1) returns %d\n", error));
            switch (error) {
              case PK_WARN:
                ++NumWarnFiles;
    1886:	8b 7c 24 24          	mov    0x24(%esp),%edi
            char *p = lastzipfn + strlen(lastzipfn);

            G.zipfn = lastzipfn;
            strcpy(p, ZSUFX);

            NumMissDirs = NumMissFiles = 0;
    188a:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    1891:	00 
            error = do_seekable(__G__ 1);
#endif
            Trace((stderr, "do_seekable(1) returns %d\n", error));
            switch (error) {
              case PK_WARN:
                ++NumWarnFiles;
    1892:	47                   	inc    %edi
    1893:	89 7c 24 24          	mov    %edi,0x24(%esp)
            char *p = lastzipfn + strlen(lastzipfn);

            G.zipfn = lastzipfn;
            strcpy(p, ZSUFX);

            NumMissDirs = NumMissFiles = 0;
    1897:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
    189e:	00 
    189f:	e9 ac fb ff ff       	jmp    1450 <_process_zipfiles+0x350>
              case PK_WARN:
                ++NumWarnFiles;
                break;
              case IZ_DIR:
                ++NumMissDirs;
                error = PK_NOZIP;
    18a4:	bd 09 00 00 00       	mov    $0x9,%ebp
            switch (error) {
              case PK_WARN:
                ++NumWarnFiles;
                break;
              case IZ_DIR:
                ++NumMissDirs;
    18a9:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
    18b0:	00 
    18b1:	eb e4                	jmp    1897 <_process_zipfiles+0x797>
            char *p = lastzipfn + strlen(lastzipfn);

            G.zipfn = lastzipfn;
            strcpy(p, ZSUFX);

            NumMissDirs = NumMissFiles = 0;
    18b3:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    18ba:	00 
    18bb:	eb da                	jmp    1897 <_process_zipfiles+0x797>
                break;
              default:
                if (error)
                    ++NumLoseFiles;
                else
                    ++NumWinFiles;
    18bd:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    18c1:	41                   	inc    %ecx
    18c2:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    18c6:	e9 71 fb ff ff       	jmp    143c <_process_zipfiles+0x33c>
        if (NumMissFiles > 0)
            Info(slide, 0x401, ((char *)slide,
              LoadFarString(FileHadNoZipfileDir), NumMissFiles,
              (NumMissFiles == 1)? "" : "s"));
        if (NumMissDirs == 1)
            Info(slide, 0x401, ((char *)slide, LoadFarString(ZipfileWasDir)));
    18cb:	66 8b 0e             	mov    (%esi),%cx
    18ce:	83 c7 02             	add    $0x2,%edi
    18d1:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    18d5:	83 c6 02             	add    $0x2,%esi
    18d8:	83 e8 02             	sub    $0x2,%eax
    18db:	e9 63 ff ff ff       	jmp    1843 <_process_zipfiles+0x743>
    18e0:	a0 a7 01 00 00       	mov    0x1a7,%al
    18e5:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    18eb:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    18f1:	be a8 01 00 00       	mov    $0x1a8,%esi
    18f6:	b8 1d 00 00 00       	mov    $0x1d,%eax
    18fb:	e9 37 ff ff ff       	jmp    1837 <_process_zipfiles+0x737>

00001900 <_get_cdir_ent>:
/* Function get_cdir_ent() */
/***************************/

int get_cdir_ent(__G)   /* return PK-type error code */
    __GDEF
{
    1900:	53                   	push   %ebx
    1901:	83 ec 48             	sub    $0x48,%esp
    1904:	8b 5c 24 50          	mov    0x50(%esp),%ebx
    conversions (byte ordering, structure padding compensation--do so by
    copying the data from the array into which it was read (byterec) to the
    usable struct (crec)).
  ---------------------------------------------------------------------------*/

    if (readbuf(__G__ (char *)byterec, CREC_SIZE) == 0)
    1908:	8d 44 24 16          	lea    0x16(%esp),%eax
    190c:	c7 44 24 08 2a 00 00 	movl   $0x2a,0x8(%esp)
    1913:	00 
    1914:	89 44 24 04          	mov    %eax,0x4(%esp)
    1918:	89 1c 24             	mov    %ebx,(%esp)
    191b:	e8 00 00 00 00       	call   1920 <_get_cdir_ent+0x20>
        return PK_EOF;
    1920:	ba 33 00 00 00       	mov    $0x33,%edx
    conversions (byte ordering, structure padding compensation--do so by
    copying the data from the array into which it was read (byterec) to the
    usable struct (crec)).
  ---------------------------------------------------------------------------*/

    if (readbuf(__G__ (char *)byterec, CREC_SIZE) == 0)
    1925:	85 c0                	test   %eax,%eax
    1927:	75 07                	jne    1930 <_get_cdir_ent+0x30>
    G.crec.relative_offset_local_header =
      makelong(&byterec[C_RELATIVE_OFFSET_LOCAL_HEADER]);

    return PK_COOL;

} /* end function get_cdir_ent() */
    1929:	83 c4 48             	add    $0x48,%esp
    192c:	89 d0                	mov    %edx,%eax
    192e:	5b                   	pop    %ebx
    192f:	c3                   	ret    
  ---------------------------------------------------------------------------*/

    if (readbuf(__G__ (char *)byterec, CREC_SIZE) == 0)
        return PK_EOF;

    G.crec.version_made_by[0] = byterec[C_VERSION_MADE_BY_0];
    1930:	8a 44 24 16          	mov    0x16(%esp),%al
    1934:	88 83 3c 09 01 00    	mov    %al,0x1093c(%ebx)
    G.crec.version_made_by[1] = byterec[C_VERSION_MADE_BY_1];
    193a:	8a 44 24 17          	mov    0x17(%esp),%al
    193e:	88 83 3d 09 01 00    	mov    %al,0x1093d(%ebx)
    G.crec.version_needed_to_extract[0] =
    1944:	8a 44 24 18          	mov    0x18(%esp),%al
    1948:	88 83 3e 09 01 00    	mov    %al,0x1093e(%ebx)
      byterec[C_VERSION_NEEDED_TO_EXTRACT_0];
    G.crec.version_needed_to_extract[1] =
    194e:	8a 44 24 19          	mov    0x19(%esp),%al
    1952:	88 83 3f 09 01 00    	mov    %al,0x1093f(%ebx)
      byterec[C_VERSION_NEEDED_TO_EXTRACT_1];

    G.crec.general_purpose_bit_flag =
      makeword(&byterec[C_GENERAL_PURPOSE_BIT_FLAG]);
    1958:	8d 44 24 1a          	lea    0x1a(%esp),%eax
    195c:	89 04 24             	mov    %eax,(%esp)
    195f:	e8 00 00 00 00       	call   1964 <_get_cdir_ent+0x64>
    G.crec.version_needed_to_extract[0] =
      byterec[C_VERSION_NEEDED_TO_EXTRACT_0];
    G.crec.version_needed_to_extract[1] =
      byterec[C_VERSION_NEEDED_TO_EXTRACT_1];

    G.crec.general_purpose_bit_flag =
    1964:	66 89 83 40 09 01 00 	mov    %ax,0x10940(%ebx)
      makeword(&byterec[C_GENERAL_PURPOSE_BIT_FLAG]);
    G.crec.compression_method =
      makeword(&byterec[C_COMPRESSION_METHOD]);
    196b:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    196f:	89 04 24             	mov    %eax,(%esp)
    1972:	e8 00 00 00 00       	call   1977 <_get_cdir_ent+0x77>
    G.crec.version_needed_to_extract[1] =
      byterec[C_VERSION_NEEDED_TO_EXTRACT_1];

    G.crec.general_purpose_bit_flag =
      makeword(&byterec[C_GENERAL_PURPOSE_BIT_FLAG]);
    G.crec.compression_method =
    1977:	66 89 83 42 09 01 00 	mov    %ax,0x10942(%ebx)
      makeword(&byterec[C_COMPRESSION_METHOD]);
    G.crec.last_mod_dos_datetime =
      makelong(&byterec[C_LAST_MOD_DOS_DATETIME]);
    197e:	8d 44 24 1e          	lea    0x1e(%esp),%eax
    1982:	89 04 24             	mov    %eax,(%esp)
    1985:	e8 00 00 00 00       	call   198a <_get_cdir_ent+0x8a>

    G.crec.general_purpose_bit_flag =
      makeword(&byterec[C_GENERAL_PURPOSE_BIT_FLAG]);
    G.crec.compression_method =
      makeword(&byterec[C_COMPRESSION_METHOD]);
    G.crec.last_mod_dos_datetime =
    198a:	89 83 44 09 01 00    	mov    %eax,0x10944(%ebx)
      makelong(&byterec[C_LAST_MOD_DOS_DATETIME]);
    G.crec.crc32 =
      makelong(&byterec[C_CRC32]);
    1990:	8d 44 24 22          	lea    0x22(%esp),%eax
    1994:	89 04 24             	mov    %eax,(%esp)
    1997:	e8 00 00 00 00       	call   199c <_get_cdir_ent+0x9c>
      makeword(&byterec[C_GENERAL_PURPOSE_BIT_FLAG]);
    G.crec.compression_method =
      makeword(&byterec[C_COMPRESSION_METHOD]);
    G.crec.last_mod_dos_datetime =
      makelong(&byterec[C_LAST_MOD_DOS_DATETIME]);
    G.crec.crc32 =
    199c:	89 83 48 09 01 00    	mov    %eax,0x10948(%ebx)
      makelong(&byterec[C_CRC32]);
    G.crec.csize =
      makelong(&byterec[C_COMPRESSED_SIZE]);
    19a2:	8d 44 24 26          	lea    0x26(%esp),%eax
    19a6:	89 04 24             	mov    %eax,(%esp)
    19a9:	e8 00 00 00 00       	call   19ae <_get_cdir_ent+0xae>
      makeword(&byterec[C_COMPRESSION_METHOD]);
    G.crec.last_mod_dos_datetime =
      makelong(&byterec[C_LAST_MOD_DOS_DATETIME]);
    G.crec.crc32 =
      makelong(&byterec[C_CRC32]);
    G.crec.csize =
    19ae:	89 83 4c 09 01 00    	mov    %eax,0x1094c(%ebx)
      makelong(&byterec[C_COMPRESSED_SIZE]);
    G.crec.ucsize =
      makelong(&byterec[C_UNCOMPRESSED_SIZE]);
    19b4:	8d 44 24 2a          	lea    0x2a(%esp),%eax
    19b8:	89 04 24             	mov    %eax,(%esp)
    19bb:	e8 00 00 00 00       	call   19c0 <_get_cdir_ent+0xc0>
      makelong(&byterec[C_LAST_MOD_DOS_DATETIME]);
    G.crec.crc32 =
      makelong(&byterec[C_CRC32]);
    G.crec.csize =
      makelong(&byterec[C_COMPRESSED_SIZE]);
    G.crec.ucsize =
    19c0:	89 83 50 09 01 00    	mov    %eax,0x10950(%ebx)
      makelong(&byterec[C_UNCOMPRESSED_SIZE]);
    G.crec.filename_length =
      makeword(&byterec[C_FILENAME_LENGTH]);
    19c6:	8d 44 24 2e          	lea    0x2e(%esp),%eax
    19ca:	89 04 24             	mov    %eax,(%esp)
    19cd:	e8 00 00 00 00       	call   19d2 <_get_cdir_ent+0xd2>
      makelong(&byterec[C_CRC32]);
    G.crec.csize =
      makelong(&byterec[C_COMPRESSED_SIZE]);
    G.crec.ucsize =
      makelong(&byterec[C_UNCOMPRESSED_SIZE]);
    G.crec.filename_length =
    19d2:	66 89 83 54 09 01 00 	mov    %ax,0x10954(%ebx)
      makeword(&byterec[C_FILENAME_LENGTH]);
    G.crec.extra_field_length =
      makeword(&byterec[C_EXTRA_FIELD_LENGTH]);
    19d9:	8d 44 24 30          	lea    0x30(%esp),%eax
    19dd:	89 04 24             	mov    %eax,(%esp)
    19e0:	e8 00 00 00 00       	call   19e5 <_get_cdir_ent+0xe5>
      makelong(&byterec[C_COMPRESSED_SIZE]);
    G.crec.ucsize =
      makelong(&byterec[C_UNCOMPRESSED_SIZE]);
    G.crec.filename_length =
      makeword(&byterec[C_FILENAME_LENGTH]);
    G.crec.extra_field_length =
    19e5:	66 89 83 56 09 01 00 	mov    %ax,0x10956(%ebx)
      makeword(&byterec[C_EXTRA_FIELD_LENGTH]);
    G.crec.file_comment_length =
      makeword(&byterec[C_FILE_COMMENT_LENGTH]);
    19ec:	8d 44 24 32          	lea    0x32(%esp),%eax
    19f0:	89 04 24             	mov    %eax,(%esp)
    19f3:	e8 00 00 00 00       	call   19f8 <_get_cdir_ent+0xf8>
      makelong(&byterec[C_UNCOMPRESSED_SIZE]);
    G.crec.filename_length =
      makeword(&byterec[C_FILENAME_LENGTH]);
    G.crec.extra_field_length =
      makeword(&byterec[C_EXTRA_FIELD_LENGTH]);
    G.crec.file_comment_length =
    19f8:	66 89 83 58 09 01 00 	mov    %ax,0x10958(%ebx)
      makeword(&byterec[C_FILE_COMMENT_LENGTH]);
    G.crec.disk_number_start =
      makeword(&byterec[C_DISK_NUMBER_START]);
    19ff:	8d 44 24 34          	lea    0x34(%esp),%eax
    1a03:	89 04 24             	mov    %eax,(%esp)
    1a06:	e8 00 00 00 00       	call   1a0b <_get_cdir_ent+0x10b>
      makeword(&byterec[C_FILENAME_LENGTH]);
    G.crec.extra_field_length =
      makeword(&byterec[C_EXTRA_FIELD_LENGTH]);
    G.crec.file_comment_length =
      makeword(&byterec[C_FILE_COMMENT_LENGTH]);
    G.crec.disk_number_start =
    1a0b:	66 89 83 5a 09 01 00 	mov    %ax,0x1095a(%ebx)
      makeword(&byterec[C_DISK_NUMBER_START]);
    G.crec.internal_file_attributes =
      makeword(&byterec[C_INTERNAL_FILE_ATTRIBUTES]);
    1a12:	8d 44 24 36          	lea    0x36(%esp),%eax
    1a16:	89 04 24             	mov    %eax,(%esp)
    1a19:	e8 00 00 00 00       	call   1a1e <_get_cdir_ent+0x11e>
      makeword(&byterec[C_EXTRA_FIELD_LENGTH]);
    G.crec.file_comment_length =
      makeword(&byterec[C_FILE_COMMENT_LENGTH]);
    G.crec.disk_number_start =
      makeword(&byterec[C_DISK_NUMBER_START]);
    G.crec.internal_file_attributes =
    1a1e:	66 89 83 5c 09 01 00 	mov    %ax,0x1095c(%ebx)
      makeword(&byterec[C_INTERNAL_FILE_ATTRIBUTES]);
    G.crec.external_file_attributes =
      makelong(&byterec[C_EXTERNAL_FILE_ATTRIBUTES]);  /* LONG, not word! */
    1a25:	8d 44 24 38          	lea    0x38(%esp),%eax
    1a29:	89 04 24             	mov    %eax,(%esp)
    1a2c:	e8 00 00 00 00       	call   1a31 <_get_cdir_ent+0x131>
      makeword(&byterec[C_FILE_COMMENT_LENGTH]);
    G.crec.disk_number_start =
      makeword(&byterec[C_DISK_NUMBER_START]);
    G.crec.internal_file_attributes =
      makeword(&byterec[C_INTERNAL_FILE_ATTRIBUTES]);
    G.crec.external_file_attributes =
    1a31:	89 83 60 09 01 00    	mov    %eax,0x10960(%ebx)
      makelong(&byterec[C_EXTERNAL_FILE_ATTRIBUTES]);  /* LONG, not word! */
    G.crec.relative_offset_local_header =
      makelong(&byterec[C_RELATIVE_OFFSET_LOCAL_HEADER]);
    1a37:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    1a3b:	89 04 24             	mov    %eax,(%esp)
    1a3e:	e8 00 00 00 00       	call   1a43 <_get_cdir_ent+0x143>

    return PK_COOL;
    1a43:	31 d2                	xor    %edx,%edx
      makeword(&byterec[C_DISK_NUMBER_START]);
    G.crec.internal_file_attributes =
      makeword(&byterec[C_INTERNAL_FILE_ATTRIBUTES]);
    G.crec.external_file_attributes =
      makelong(&byterec[C_EXTERNAL_FILE_ATTRIBUTES]);  /* LONG, not word! */
    G.crec.relative_offset_local_header =
    1a45:	89 83 64 09 01 00    	mov    %eax,0x10964(%ebx)
      makelong(&byterec[C_RELATIVE_OFFSET_LOCAL_HEADER]);

    return PK_COOL;

} /* end function get_cdir_ent() */
    1a4b:	83 c4 48             	add    $0x48,%esp
    1a4e:	89 d0                	mov    %edx,%eax
    1a50:	5b                   	pop    %ebx
    1a51:	c3                   	ret    
    1a52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    1a59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001a60 <_process_cdir_file_hdr>:
/* Function process_cdir_file_hdr() */
/************************************/

int process_cdir_file_hdr(__G)    /* return PK-type error code */
    __GDEF
{
    1a60:	56                   	push   %esi
    1a61:	53                   	push   %ebx
    1a62:	83 ec 14             	sub    $0x14,%esp
    1a65:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    Get central directory info, save host and method numbers, and set flag
    for lowercase conversion of filename, depending on the OS from which the
    file is coming.
  ---------------------------------------------------------------------------*/

    if ((error = get_cdir_ent(__G)) != 0)
    1a69:	89 1c 24             	mov    %ebx,(%esp)
    1a6c:	e8 8f fe ff ff       	call   1900 <_get_cdir_ent>
    1a71:	85 c0                	test   %eax,%eax
    1a73:	0f 85 8f 00 00 00    	jne    1b08 <_process_cdir_file_hdr+0xa8>
        return error;

    G.pInfo->hostver = G.crec.version_made_by[0];
    1a79:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
    1a7f:	8a 8b 3c 09 01 00    	mov    0x1093c(%ebx),%cl
    1a85:	88 48 12             	mov    %cl,0x12(%eax)
    G.pInfo->hostnum = MIN(G.crec.version_made_by[1], NUM_HOSTS);
    1a88:	b1 1f                	mov    $0x1f,%cl
    1a8a:	8a 83 3d 09 01 00    	mov    0x1093d(%ebx),%al
    1a90:	8b 93 d8 08 00 00    	mov    0x8d8(%ebx),%edx
    1a96:	3c 1f                	cmp    $0x1f,%al
    1a98:	0f 47 c1             	cmova  %ecx,%eax
    1a9b:	88 42 13             	mov    %al,0x13(%edx)
/*  extnum = MIN(crec.version_needed_to_extract[1], NUM_HOSTS); */

    G.pInfo->lcflag = 0;
    1a9e:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
    1aa4:	80 60 18 ef          	andb   $0xef,0x18(%eax)
    if (uO.L_flag == 1)       /* name conversion for monocase systems */
    1aa8:	83 7b 2c 01          	cmpl   $0x1,0x2c(%ebx)
    1aac:	74 72                	je     1b20 <_process_cdir_file_hdr+0xc0>

            default:     /* AMIGA_, FS_HPFS_, FS_NTFS_, MAC_, UNIX_, ATARI_, */
                break;   /*  FS_VFAT_, ATHEOS_, BEOS_ (Z_SYSTEM_), THEOS_: */
                         /*  no conversion */
        }
    else if (uO.L_flag > 1)   /* let -LL force lower case for all names */
    1aae:	7e 0a                	jle    1aba <_process_cdir_file_hdr+0x5a>
        G.pInfo->lcflag = 1;
    1ab0:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
    1ab6:	80 48 18 10          	orb    $0x10,0x18(%eax)
    1aba:	8b b3 d8 08 00 00    	mov    0x8d8(%ebx),%esi

    /* do Amigas (AMIGA_) also have volume labels? */
    if (IS_VOLID(G.crec.external_file_attributes) &&
    1ac0:	f6 83 60 09 01 00 08 	testb  $0x8,0x10960(%ebx)
    1ac7:	74 18                	je     1ae1 <_process_cdir_file_hdr+0x81>
        (G.pInfo->hostnum == FS_FAT_ || G.pInfo->hostnum == FS_HPFS_ ||
    1ac9:	8a 46 13             	mov    0x13(%esi),%al
    1acc:	3c 0b                	cmp    $0xb,%al
    1ace:	0f 94 c1             	sete   %cl
    1ad1:	84 c0                	test   %al,%al
    1ad3:	0f 94 c2             	sete   %dl
         G.pInfo->hostnum == FS_NTFS_ || G.pInfo->hostnum == ATARI_))
    1ad6:	08 d1                	or     %dl,%cl
    1ad8:	75 36                	jne    1b10 <_process_cdir_file_hdr+0xb0>
    1ada:	83 e8 05             	sub    $0x5,%eax
    1add:	3c 01                	cmp    $0x1,%al
    1adf:	76 2f                	jbe    1b10 <_process_cdir_file_hdr+0xb0>
    {
        G.pInfo->vollabel = TRUE;
        G.pInfo->lcflag = 0;        /* preserve case of volume labels */
    } else
        G.pInfo->vollabel = FALSE;
    1ae1:	80 66 18 df          	andb   $0xdf,0x18(%esi)

    /* this flag is needed to detect archives made by "PKZIP for Unix" when
       deciding which kind of codepage conversion has to be applied to
       strings (see do_string() function in fileio.c) */
    G.pInfo->HasUxAtt = (G.crec.external_file_attributes & 0xffff0000L) != 0L;
    1ae5:	8b 8b d8 08 00 00    	mov    0x8d8(%ebx),%ecx
    1aeb:	f7 83 60 09 01 00 00 	testl  $0xffff0000,0x10960(%ebx)
    1af2:	00 ff ff 
    1af5:	8a 51 18             	mov    0x18(%ecx),%dl
    1af8:	0f 95 c0             	setne  %al
    1afb:	c1 e0 06             	shl    $0x6,%eax
    1afe:	83 e2 bf             	and    $0xffffffbf,%edx
    1b01:	09 d0                	or     %edx,%eax
    1b03:	88 41 18             	mov    %al,0x18(%ecx)

    return PK_COOL;
    1b06:	31 c0                	xor    %eax,%eax

} /* end function process_cdir_file_hdr() */
    1b08:	83 c4 14             	add    $0x14,%esp
    1b0b:	5b                   	pop    %ebx
    1b0c:	5e                   	pop    %esi
    1b0d:	c3                   	ret    
    1b0e:	66 90                	xchg   %ax,%ax
    /* do Amigas (AMIGA_) also have volume labels? */
    if (IS_VOLID(G.crec.external_file_attributes) &&
        (G.pInfo->hostnum == FS_FAT_ || G.pInfo->hostnum == FS_HPFS_ ||
         G.pInfo->hostnum == FS_NTFS_ || G.pInfo->hostnum == ATARI_))
    {
        G.pInfo->vollabel = TRUE;
    1b10:	80 4e 18 20          	orb    $0x20,0x18(%esi)
        G.pInfo->lcflag = 0;        /* preserve case of volume labels */
    1b14:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
    1b1a:	80 60 18 ef          	andb   $0xef,0x18(%eax)
    1b1e:	eb c5                	jmp    1ae5 <_process_cdir_file_hdr+0x85>
    G.pInfo->hostnum = MIN(G.crec.version_made_by[1], NUM_HOSTS);
/*  extnum = MIN(crec.version_needed_to_extract[1], NUM_HOSTS); */

    G.pInfo->lcflag = 0;
    if (uO.L_flag == 1)       /* name conversion for monocase systems */
        switch (G.pInfo->hostnum) {
    1b20:	8b b3 d8 08 00 00    	mov    0x8d8(%ebx),%esi
    1b26:	80 7e 13 11          	cmpb   $0x11,0x13(%esi)
    1b2a:	77 94                	ja     1ac0 <_process_cdir_file_hdr+0x60>
    1b2c:	31 c0                	xor    %eax,%eax
    1b2e:	8a 46 13             	mov    0x13(%esi),%al
    1b31:	ff 24 85 c8 01 00 00 	jmp    *0x1c8(,%eax,4)
            case TANDEM_:
            case TOPS20_:
            case VMS_:        /* our Zip uses lowercase, but ASi's doesn't */
        /*  case Z_SYSTEM_:   ? */
        /*  case QDOS_:       ? */
                G.pInfo->lcflag = 1;   /* convert filename to lowercase */
    1b38:	80 4e 18 10          	orb    $0x10,0x18(%esi)
    1b3c:	8b b3 d8 08 00 00    	mov    0x8d8(%ebx),%esi
                break;
    1b42:	e9 79 ff ff ff       	jmp    1ac0 <_process_cdir_file_hdr+0x60>
    1b47:	89 f6                	mov    %esi,%esi
    1b49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001b50 <_process_local_file_hdr>:
/* Function process_local_file_hdr() */
/*************************************/

int process_local_file_hdr(__G)    /* return PK-type error code */
    __GDEF
{
    1b50:	53                   	push   %ebx
    1b51:	83 ec 38             	sub    $0x38,%esp
    1b54:	8b 5c 24 40          	mov    0x40(%esp),%ebx
    versions (byte ordering, structure padding compensation--do so by copy-
    ing the data from the array into which it was read (byterec) to the
    usable struct (lrec)).
  ---------------------------------------------------------------------------*/

    if (readbuf(__G__ (char *)byterec, LREC_SIZE) == 0)
    1b58:	8d 44 24 16          	lea    0x16(%esp),%eax
    1b5c:	c7 44 24 08 1a 00 00 	movl   $0x1a,0x8(%esp)
    1b63:	00 
    1b64:	89 44 24 04          	mov    %eax,0x4(%esp)
    1b68:	89 1c 24             	mov    %ebx,(%esp)
    1b6b:	e8 00 00 00 00       	call   1b70 <_process_local_file_hdr+0x20>
        return PK_EOF;
    1b70:	ba 33 00 00 00       	mov    $0x33,%edx
    versions (byte ordering, structure padding compensation--do so by copy-
    ing the data from the array into which it was read (byterec) to the
    usable struct (lrec)).
  ---------------------------------------------------------------------------*/

    if (readbuf(__G__ (char *)byterec, LREC_SIZE) == 0)
    1b75:	85 c0                	test   %eax,%eax
    1b77:	75 07                	jne    1b80 <_process_local_file_hdr+0x30>

    G.csize = (long)G.lrec.csize;

    return PK_COOL;

} /* end function process_local_file_hdr() */
    1b79:	83 c4 38             	add    $0x38,%esp
    1b7c:	89 d0                	mov    %edx,%eax
    1b7e:	5b                   	pop    %ebx
    1b7f:	c3                   	ret    
  ---------------------------------------------------------------------------*/

    if (readbuf(__G__ (char *)byterec, LREC_SIZE) == 0)
        return PK_EOF;

    G.lrec.version_needed_to_extract[0] =
    1b80:	8a 44 24 16          	mov    0x16(%esp),%al
    1b84:	88 83 30 09 01 00    	mov    %al,0x10930(%ebx)
      byterec[L_VERSION_NEEDED_TO_EXTRACT_0];
    G.lrec.version_needed_to_extract[1] =
    1b8a:	8a 44 24 17          	mov    0x17(%esp),%al
    1b8e:	88 83 31 09 01 00    	mov    %al,0x10931(%ebx)
      byterec[L_VERSION_NEEDED_TO_EXTRACT_1];

    G.lrec.general_purpose_bit_flag =
      makeword(&byterec[L_GENERAL_PURPOSE_BIT_FLAG]);
    1b94:	8d 44 24 18          	lea    0x18(%esp),%eax
    1b98:	89 04 24             	mov    %eax,(%esp)
    1b9b:	e8 00 00 00 00       	call   1ba0 <_process_local_file_hdr+0x50>
    G.lrec.version_needed_to_extract[0] =
      byterec[L_VERSION_NEEDED_TO_EXTRACT_0];
    G.lrec.version_needed_to_extract[1] =
      byterec[L_VERSION_NEEDED_TO_EXTRACT_1];

    G.lrec.general_purpose_bit_flag =
    1ba0:	66 89 83 32 09 01 00 	mov    %ax,0x10932(%ebx)
      makeword(&byterec[L_GENERAL_PURPOSE_BIT_FLAG]);
    G.lrec.compression_method = makeword(&byterec[L_COMPRESSION_METHOD]);
    1ba7:	8d 44 24 1a          	lea    0x1a(%esp),%eax
    1bab:	89 04 24             	mov    %eax,(%esp)
    1bae:	e8 00 00 00 00       	call   1bb3 <_process_local_file_hdr+0x63>
    1bb3:	66 89 83 34 09 01 00 	mov    %ax,0x10934(%ebx)
    G.lrec.last_mod_dos_datetime = makelong(&byterec[L_LAST_MOD_DOS_DATETIME]);
    1bba:	8d 44 24 1c          	lea    0x1c(%esp),%eax
    1bbe:	89 04 24             	mov    %eax,(%esp)
    1bc1:	e8 00 00 00 00       	call   1bc6 <_process_local_file_hdr+0x76>
    1bc6:	89 83 28 09 01 00    	mov    %eax,0x10928(%ebx)
    G.lrec.crc32 = makelong(&byterec[L_CRC32]);
    1bcc:	8d 44 24 20          	lea    0x20(%esp),%eax
    1bd0:	89 04 24             	mov    %eax,(%esp)
    1bd3:	e8 00 00 00 00       	call   1bd8 <_process_local_file_hdr+0x88>
    1bd8:	89 83 2c 09 01 00    	mov    %eax,0x1092c(%ebx)
    G.lrec.csize = makelong(&byterec[L_COMPRESSED_SIZE]);
    1bde:	8d 44 24 24          	lea    0x24(%esp),%eax
    1be2:	89 04 24             	mov    %eax,(%esp)
    1be5:	e8 00 00 00 00       	call   1bea <_process_local_file_hdr+0x9a>
    1bea:	89 83 20 09 01 00    	mov    %eax,0x10920(%ebx)
    G.lrec.ucsize = makelong(&byterec[L_UNCOMPRESSED_SIZE]);
    1bf0:	8d 44 24 28          	lea    0x28(%esp),%eax
    1bf4:	89 04 24             	mov    %eax,(%esp)
    1bf7:	e8 00 00 00 00       	call   1bfc <_process_local_file_hdr+0xac>
    1bfc:	89 83 24 09 01 00    	mov    %eax,0x10924(%ebx)
    G.lrec.filename_length = makeword(&byterec[L_FILENAME_LENGTH]);
    1c02:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    1c06:	89 04 24             	mov    %eax,(%esp)
    1c09:	e8 00 00 00 00       	call   1c0e <_process_local_file_hdr+0xbe>
    1c0e:	66 89 83 36 09 01 00 	mov    %ax,0x10936(%ebx)
    G.lrec.extra_field_length = makeword(&byterec[L_EXTRA_FIELD_LENGTH]);
    1c15:	8d 44 24 2e          	lea    0x2e(%esp),%eax
    1c19:	89 04 24             	mov    %eax,(%esp)
    1c1c:	e8 00 00 00 00       	call   1c21 <_process_local_file_hdr+0xd1>

    if ((G.lrec.general_purpose_bit_flag & 8) != 0) {
    1c21:	f6 83 32 09 01 00 08 	testb  $0x8,0x10932(%ebx)
    G.lrec.last_mod_dos_datetime = makelong(&byterec[L_LAST_MOD_DOS_DATETIME]);
    G.lrec.crc32 = makelong(&byterec[L_CRC32]);
    G.lrec.csize = makelong(&byterec[L_COMPRESSED_SIZE]);
    G.lrec.ucsize = makelong(&byterec[L_UNCOMPRESSED_SIZE]);
    G.lrec.filename_length = makeword(&byterec[L_FILENAME_LENGTH]);
    G.lrec.extra_field_length = makeword(&byterec[L_EXTRA_FIELD_LENGTH]);
    1c28:	66 89 83 38 09 01 00 	mov    %ax,0x10938(%ebx)

    if ((G.lrec.general_purpose_bit_flag & 8) != 0) {
    1c2f:	75 15                	jne    1c46 <_process_local_file_hdr+0xf6>
    1c31:	8b 83 20 09 01 00    	mov    0x10920(%ebx),%eax
        G.lrec.crc32 = G.pInfo->crc;
        G.lrec.csize = G.pInfo->compr_size;
        G.lrec.ucsize = G.pInfo->uncompr_size;
    }

    G.csize = (long)G.lrec.csize;
    1c37:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    return PK_COOL;

} /* end function process_local_file_hdr() */
    1c3d:	83 c4 38             	add    $0x38,%esp
        G.lrec.ucsize = G.pInfo->uncompr_size;
    }

    G.csize = (long)G.lrec.csize;

    return PK_COOL;
    1c40:	31 d2                	xor    %edx,%edx

} /* end function process_local_file_hdr() */
    1c42:	89 d0                	mov    %edx,%eax
    1c44:	5b                   	pop    %ebx
    1c45:	c3                   	ret    
    G.lrec.filename_length = makeword(&byterec[L_FILENAME_LENGTH]);
    G.lrec.extra_field_length = makeword(&byterec[L_EXTRA_FIELD_LENGTH]);

    if ((G.lrec.general_purpose_bit_flag & 8) != 0) {
        /* can't trust local header, use central directory: */
        G.lrec.crc32 = G.pInfo->crc;
    1c46:	8b 93 d8 08 00 00    	mov    0x8d8(%ebx),%edx
    1c4c:	8b 42 0c             	mov    0xc(%edx),%eax
    1c4f:	89 83 2c 09 01 00    	mov    %eax,0x1092c(%ebx)
        G.lrec.csize = G.pInfo->compr_size;
    1c55:	8b 42 04             	mov    0x4(%edx),%eax
        G.lrec.ucsize = G.pInfo->uncompr_size;
    1c58:	8b 52 08             	mov    0x8(%edx),%edx
    G.lrec.extra_field_length = makeword(&byterec[L_EXTRA_FIELD_LENGTH]);

    if ((G.lrec.general_purpose_bit_flag & 8) != 0) {
        /* can't trust local header, use central directory: */
        G.lrec.crc32 = G.pInfo->crc;
        G.lrec.csize = G.pInfo->compr_size;
    1c5b:	89 83 20 09 01 00    	mov    %eax,0x10920(%ebx)
        G.lrec.ucsize = G.pInfo->uncompr_size;
    1c61:	89 93 24 09 01 00    	mov    %edx,0x10924(%ebx)
    1c67:	eb ce                	jmp    1c37 <_process_local_file_hdr+0xe7>
    1c69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001c70 <_ef_scan_for_izux>:
    unsigned ef_len;    /* total length of extra field */
    int ef_is_c;        /* flag indicating "is central extra field" */
    ulg dos_mdatetime;  /* last_mod_file_date_time in DOS format */
    iztimes *z_utim;    /* return storage: atime, mtime, ctime */
    ush *z_uidgid;      /* return storage: uid and gid */
{
    1c70:	55                   	push   %ebp
    1c71:	57                   	push   %edi
    1c72:	56                   	push   %esi
    1c73:	53                   	push   %ebx
    1c74:	83 ec 2c             	sub    $0x2c,%esp
    1c77:	8b 6c 24 44          	mov    0x44(%esp),%ebp
    1c7b:	8b 74 24 40          	mov    0x40(%esp),%esi
    The return value is a combination of the EF_TIME Flags field with an
    additional flag bit indicating the presence of valid UID/GID info,
    or 0 in case of failure.
  ---------------------------------------------------------------------------*/

    if (ef_len == 0 || ef_buf == NULL || (z_utim == 0 && z_uidgid == NULL))
    1c7f:	85 ed                	test   %ebp,%ebp
    1c81:	0f 84 bc 01 00 00    	je     1e43 <_ef_scan_for_izux+0x1d3>
    1c87:	85 f6                	test   %esi,%esi
    1c89:	0f 84 b4 01 00 00    	je     1e43 <_ef_scan_for_izux+0x1d3>
    1c8f:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1c93:	85 c9                	test   %ecx,%ecx
    1c95:	75 19                	jne    1cb0 <_ef_scan_for_izux+0x40>
    1c97:	8b 54 24 54          	mov    0x54(%esp),%edx
        return 0;
    1c9b:	31 c0                	xor    %eax,%eax
    The return value is a combination of the EF_TIME Flags field with an
    additional flag bit indicating the presence of valid UID/GID info,
    or 0 in case of failure.
  ---------------------------------------------------------------------------*/

    if (ef_len == 0 || ef_buf == NULL || (z_utim == 0 && z_uidgid == NULL))
    1c9d:	85 d2                	test   %edx,%edx
    1c9f:	75 0f                	jne    1cb0 <_ef_scan_for_izux+0x40>
        ef_buf += (eb_len + EB_HEADSIZE);
        ef_len -= (eb_len + EB_HEADSIZE);
    }

    return flags;
}
    1ca1:	83 c4 2c             	add    $0x2c,%esp
    1ca4:	5b                   	pop    %ebx
    1ca5:	5e                   	pop    %esi
    1ca6:	5f                   	pop    %edi
    1ca7:	5d                   	pop    %ebp
    1ca8:	c3                   	ret    
    1ca9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        return 0;

    TTrace((stderr,"\nef_scan_for_izux: scanning extra field of length %u\n",
      ef_len));

    while (ef_len >= EB_HEADSIZE) {
    1cb0:	83 fd 03             	cmp    $0x3,%ebp
    1cb3:	0f 86 94 01 00 00    	jbe    1e4d <_ef_scan_for_izux+0x1dd>
    1cb9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    1cc0:	00 
    1cc1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    1cc8:	00 
    1cc9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    1cd0:	00 
    1cd1:	eb 5c                	jmp    1d2f <_ef_scan_for_izux+0xbf>
              "ef_scan_for_izux: block length %u > rest ef_size %u\n", eb_len,
              ef_len - EB_HEADSIZE));
            break;
        }

        switch (eb_id) {
    1cd3:	0f 86 d7 00 00 00    	jbe    1db0 <_ef_scan_for_izux+0x140>
    1cd9:	66 81 ff 55 58       	cmp    $0x5855,%di
    1cde:	0f 84 d6 00 00 00    	je     1dba <_ef_scan_for_izux+0x14a>
    1ce4:	66 81 ff 55 78       	cmp    $0x7855,%di
    1ce9:	75 2e                	jne    1d19 <_ef_scan_for_izux+0xa9>
            }
            break;

          case EF_IZUNIX2:
            if (!have_new_type_eb) {
                flags &= ~0x0ff;        /* ignore any previous IZUNIX field */
    1ceb:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    1cef:	8b 54 24 18          	mov    0x18(%esp),%edx
    1cf3:	89 c8                	mov    %ecx,%eax
    1cf5:	30 c0                	xor    %al,%al
    1cf7:	85 d2                	test   %edx,%edx
    1cf9:	0f 45 c1             	cmovne %ecx,%eax
    1cfc:	89 44 24 14          	mov    %eax,0x14(%esp)
                have_new_type_eb = TRUE;
            }
            if (eb_len >= EB_UX2_MINLEN && z_uidgid != NULL) {
    1d00:	83 fb 03             	cmp    $0x3,%ebx
    1d03:	76 0c                	jbe    1d11 <_ef_scan_for_izux+0xa1>
    1d05:	8b 7c 24 54          	mov    0x54(%esp),%edi
    1d09:	85 ff                	test   %edi,%edi
    1d0b:	0f 85 50 01 00 00    	jne    1e61 <_ef_scan_for_izux+0x1f1>
    1d11:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    1d18:	00 
    1d19:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
          default:
            break;
        }

        /* Skip this extra field block */
        ef_buf += (eb_len + EB_HEADSIZE);
    1d1e:	8d 74 1e 04          	lea    0x4(%esi,%ebx,1),%esi
    1d22:	29 d8                	sub    %ebx,%eax
        ef_len -= (eb_len + EB_HEADSIZE);
    1d24:	01 c5                	add    %eax,%ebp
        return 0;

    TTrace((stderr,"\nef_scan_for_izux: scanning extra field of length %u\n",
      ef_len));

    while (ef_len >= EB_HEADSIZE) {
    1d26:	83 fd 03             	cmp    $0x3,%ebp
    1d29:	0f 86 26 01 00 00    	jbe    1e55 <_ef_scan_for_izux+0x1e5>
        eb_id = makeword(EB_ID + ef_buf);
    1d2f:	89 34 24             	mov    %esi,(%esp)
        eb_len = makeword(EB_LEN + ef_buf);
    1d32:	31 db                	xor    %ebx,%ebx

    TTrace((stderr,"\nef_scan_for_izux: scanning extra field of length %u\n",
      ef_len));

    while (ef_len >= EB_HEADSIZE) {
        eb_id = makeword(EB_ID + ef_buf);
    1d34:	e8 00 00 00 00       	call   1d39 <_ef_scan_for_izux+0xc9>
    1d39:	89 c7                	mov    %eax,%edi
        eb_len = makeword(EB_LEN + ef_buf);
    1d3b:	8d 46 02             	lea    0x2(%esi),%eax
    1d3e:	89 04 24             	mov    %eax,(%esp)
    1d41:	e8 00 00 00 00       	call   1d46 <_ef_scan_for_izux+0xd6>
    1d46:	66 89 c3             	mov    %ax,%bx

        if (eb_len > (ef_len - EB_HEADSIZE)) {
    1d49:	8d 45 fc             	lea    -0x4(%ebp),%eax
    1d4c:	39 c3                	cmp    %eax,%ebx
    1d4e:	0f 87 01 01 00 00    	ja     1e55 <_ef_scan_for_izux+0x1e5>
              "ef_scan_for_izux: block length %u > rest ef_size %u\n", eb_len,
              ef_len - EB_HEADSIZE));
            break;
        }

        switch (eb_id) {
    1d54:	66 81 ff 55 54       	cmp    $0x5455,%di
    1d59:	0f 85 74 ff ff ff    	jne    1cd3 <_ef_scan_for_izux+0x63>
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
    1d5f:	8b 44 24 14          	mov    0x14(%esp),%eax
            have_new_type_eb = TRUE;
            if ( eb_len >= EB_UT_MINLEN && z_utim != NULL) {
    1d63:	85 db                	test   %ebx,%ebx
            break;
        }

        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
    1d65:	b0 00                	mov    $0x0,%al
    1d67:	89 44 24 14          	mov    %eax,0x14(%esp)
    1d6b:	8b 54 24 14          	mov    0x14(%esp),%edx
            have_new_type_eb = TRUE;
            if ( eb_len >= EB_UT_MINLEN && z_utim != NULL) {
    1d6f:	74 a0                	je     1d11 <_ef_scan_for_izux+0xa1>
    1d71:	8b 44 24 50          	mov    0x50(%esp),%eax
    1d75:	85 c0                	test   %eax,%eax
    1d77:	74 98                	je     1d11 <_ef_scan_for_izux+0xa1>
                unsigned eb_idx = EB_UT_TIME1;
                TTrace((stderr,"ef_scan_for_izux: found TIME extra field\n"));
                flags |= (ef_buf[EB_HEADSIZE+EB_UT_FLAGS] & 0x0ff);
    1d79:	31 c0                	xor    %eax,%eax
    1d7b:	8a 46 04             	mov    0x4(%esi),%al
    1d7e:	09 c2                	or     %eax,%edx
    1d80:	89 54 24 14          	mov    %edx,0x14(%esp)
                if ((flags & EB_UT_FL_MTIME)) {
    1d84:	83 e2 01             	and    $0x1,%edx
    1d87:	0f 84 13 01 00 00    	je     1ea0 <_ef_scan_for_izux+0x230>
                    if ((eb_idx+4) <= eb_len) {
    1d8d:	83 fb 04             	cmp    $0x4,%ebx
    1d90:	0f 87 ba 01 00 00    	ja     1f50 <_ef_scan_for_izux+0x2e0>
                            ut_zip_unzip_compatible = FALSE;
                        }
                        z_utim->mtime = (time_t)i_time;
#endif /* ?TIME_T_TYPE_DOUBLE */
                    } else {
                        flags &= ~EB_UT_FL_MTIME;
    1d96:	8b 44 24 14          	mov    0x14(%esp),%eax
        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
            have_new_type_eb = TRUE;
            if ( eb_len >= EB_UT_MINLEN && z_utim != NULL) {
                unsigned eb_idx = EB_UT_TIME1;
    1d9a:	b9 01 00 00 00       	mov    $0x1,%ecx
                            ut_zip_unzip_compatible = FALSE;
                        }
                        z_utim->mtime = (time_t)i_time;
#endif /* ?TIME_T_TYPE_DOUBLE */
                    } else {
                        flags &= ~EB_UT_FL_MTIME;
    1d9f:	83 e0 fe             	and    $0xfffffffe,%eax
    1da2:	89 44 24 14          	mov    %eax,0x14(%esp)
    1da6:	e9 fa 00 00 00       	jmp    1ea5 <_ef_scan_for_izux+0x235>
    1dab:	90                   	nop
    1dac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
              "ef_scan_for_izux: block length %u > rest ef_size %u\n", eb_len,
              ef_len - EB_HEADSIZE));
            break;
        }

        switch (eb_id) {
    1db0:	66 83 ff 0d          	cmp    $0xd,%di
    1db4:	0f 85 5f ff ff ff    	jne    1d19 <_ef_scan_for_izux+0xa9>
          case EF_IZUNIX:
          case EF_PKUNIX:       /* PKUNIX e.f. layout is identical to IZUNIX */
            if (eb_len >= EB_UX_MINLEN) {
                TTrace((stderr,"ef_scan_for_izux: found %s extra field\n",
                        (eb_id == EF_IZUNIX ? "IZUNIX" : "PKUNIX")));
                if (have_new_type_eb) {
    1dba:	83 fb 07             	cmp    $0x7,%ebx
    1dbd:	0f 86 56 ff ff ff    	jbe    1d19 <_ef_scan_for_izux+0xa9>
    1dc3:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1dc7:	85 c9                	test   %ecx,%ecx
    1dc9:	0f 85 4a ff ff ff    	jne    1d19 <_ef_scan_for_izux+0xa9>
                    break;      /* Ignore IZUNIX extra field block ! */
                }
                if (z_utim != NULL) {
    1dcf:	8b 54 24 50          	mov    0x50(%esp),%edx
    1dd3:	85 d2                	test   %edx,%edx
    1dd5:	74 4e                	je     1e25 <_ef_scan_for_izux+0x1b5>
                    flags |= (EB_UT_FL_MTIME | EB_UT_FL_ATIME);
    1dd7:	8b 44 24 14          	mov    0x14(%esp),%eax
    1ddb:	83 c8 03             	or     $0x3,%eax
    1dde:	89 c7                	mov    %eax,%edi
                    i_time = (long)makelong((EB_HEADSIZE+EB_UX_MTIME)+ef_buf);
    1de0:	8d 46 08             	lea    0x8(%esi),%eax
    1de3:	89 04 24             	mov    %eax,(%esp)
    1de6:	e8 00 00 00 00       	call   1deb <_ef_scan_for_izux+0x17b>
                        /* cannot determine, safe assumption is FALSE */
                        ut_in_archive_sgn = 0;
                        z_utim->mtime = (time_t)i_time;
                    }
#else /* !TIME_T_TYPE_DOUBLE */
                    if ((ulg)(i_time) & (ulg)(0x80000000L)) {
    1deb:	85 c0                	test   %eax,%eax
    1ded:	0f 88 e3 01 00 00    	js     1fd6 <_ef_scan_for_izux+0x366>
                        }
                    } else {
                        /* cannot determine, safe assumption is FALSE */
                        ut_zip_unzip_compatible = FALSE;
                    }
                    z_utim->mtime = (time_t)i_time;
    1df3:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1df7:	89 41 04             	mov    %eax,0x4(%ecx)
#endif /* ?TIME_T_TYPE_DOUBLE */
                    i_time = (long)makelong((EB_HEADSIZE+EB_UX_ATIME)+ef_buf);
    1dfa:	8d 46 04             	lea    0x4(%esi),%eax
    1dfd:	89 04 24             	mov    %eax,(%esp)
    1e00:	e8 00 00 00 00       	call   1e05 <_ef_scan_for_izux+0x195>
                        }
                    } else {
                        z_utim->atime = (time_t)i_time;
                    }
#else /* !TIME_T_TYPE_DOUBLE */
                    if (((ulg)(i_time) & (ulg)(0x80000000L)) &&
    1e05:	85 c0                	test   %eax,%eax
    1e07:	79 0a                	jns    1e13 <_ef_scan_for_izux+0x1a3>
                        !ut_zip_unzip_compatible && (flags & 0x0ff)) {
    1e09:	89 fa                	mov    %edi,%edx
    1e0b:	84 d2                	test   %dl,%dl
    1e0d:	0f 85 ad 01 00 00    	jne    1fc0 <_ef_scan_for_izux+0x350>
    1e13:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    1e1a:	00 
                        /* atime not in range of UnZip's time_t */
                        flags &= ~EB_UT_FL_ATIME;
                        TTrace((stderr,
                                "  UX access time range error: skip time!\n"));
                    } else {
                        z_utim->atime = (time_t)i_time;
    1e1b:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1e1f:	89 7c 24 14          	mov    %edi,0x14(%esp)
    1e23:	89 01                	mov    %eax,(%ecx)
                    }
#endif /* ?TIME_T_TYPE_DOUBLE */
                }
                if (eb_len >= EB_UX_FULLSIZE && z_uidgid != NULL) {
    1e25:	83 fb 0b             	cmp    $0xb,%ebx
    1e28:	76 0c                	jbe    1e36 <_ef_scan_for_izux+0x1c6>
    1e2a:	8b 44 24 54          	mov    0x54(%esp),%eax
    1e2e:	85 c0                	test   %eax,%eax
    1e30:	0f 85 4a 01 00 00    	jne    1f80 <_ef_scan_for_izux+0x310>
    1e36:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    1e3d:	00 
    1e3e:	e9 d6 fe ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
        ef_buf += (eb_len + EB_HEADSIZE);
        ef_len -= (eb_len + EB_HEADSIZE);
    }

    return flags;
}
    1e43:	83 c4 2c             	add    $0x2c,%esp
    additional flag bit indicating the presence of valid UID/GID info,
    or 0 in case of failure.
  ---------------------------------------------------------------------------*/

    if (ef_len == 0 || ef_buf == NULL || (z_utim == 0 && z_uidgid == NULL))
        return 0;
    1e46:	31 c0                	xor    %eax,%eax
        ef_buf += (eb_len + EB_HEADSIZE);
        ef_len -= (eb_len + EB_HEADSIZE);
    }

    return flags;
}
    1e48:	5b                   	pop    %ebx
    1e49:	5e                   	pop    %esi
    1e4a:	5f                   	pop    %edi
    1e4b:	5d                   	pop    %ebp
    1e4c:	c3                   	ret    
        return 0;

    TTrace((stderr,"\nef_scan_for_izux: scanning extra field of length %u\n",
      ef_len));

    while (ef_len >= EB_HEADSIZE) {
    1e4d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    1e54:	00 
        /* Skip this extra field block */
        ef_buf += (eb_len + EB_HEADSIZE);
        ef_len -= (eb_len + EB_HEADSIZE);
    }

    return flags;
    1e55:	8b 44 24 14          	mov    0x14(%esp),%eax
}
    1e59:	83 c4 2c             	add    $0x2c,%esp
    1e5c:	5b                   	pop    %ebx
    1e5d:	5e                   	pop    %esi
    1e5e:	5f                   	pop    %edi
    1e5f:	5d                   	pop    %ebp
    1e60:	c3                   	ret    
            if (!have_new_type_eb) {
                flags &= ~0x0ff;        /* ignore any previous IZUNIX field */
                have_new_type_eb = TRUE;
            }
            if (eb_len >= EB_UX2_MINLEN && z_uidgid != NULL) {
                z_uidgid[0] = makeword((EB_HEADSIZE+EB_UX2_UID) + ef_buf);
    1e61:	8d 46 04             	lea    0x4(%esi),%eax
    1e64:	89 04 24             	mov    %eax,(%esp)
    1e67:	e8 00 00 00 00       	call   1e6c <_ef_scan_for_izux+0x1fc>
    1e6c:	8b 4c 24 54          	mov    0x54(%esp),%ecx
    1e70:	66 89 01             	mov    %ax,(%ecx)
                z_uidgid[1] = makeword((EB_HEADSIZE+EB_UX2_GID) + ef_buf);
    1e73:	8d 46 06             	lea    0x6(%esi),%eax
    1e76:	89 04 24             	mov    %eax,(%esp)
    1e79:	e8 00 00 00 00       	call   1e7e <_ef_scan_for_izux+0x20e>
    1e7e:	8b 4c 24 54          	mov    0x54(%esp),%ecx
                flags |= EB_UX2_VALID;   /* signal success */
    1e82:	81 4c 24 14 00 01 00 	orl    $0x100,0x14(%esp)
    1e89:	00 
                flags &= ~0x0ff;        /* ignore any previous IZUNIX field */
                have_new_type_eb = TRUE;
            }
            if (eb_len >= EB_UX2_MINLEN && z_uidgid != NULL) {
                z_uidgid[0] = makeword((EB_HEADSIZE+EB_UX2_UID) + ef_buf);
                z_uidgid[1] = makeword((EB_HEADSIZE+EB_UX2_GID) + ef_buf);
    1e8a:	66 89 41 02          	mov    %ax,0x2(%ecx)
                flags |= EB_UX2_VALID;   /* signal success */
    1e8e:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    1e95:	00 
    1e96:	e9 7e fe ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
    1e9b:	90                   	nop
    1e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
            have_new_type_eb = TRUE;
            if ( eb_len >= EB_UT_MINLEN && z_utim != NULL) {
                unsigned eb_idx = EB_UT_TIME1;
    1ea0:	b9 01 00 00 00       	mov    $0x1,%ecx
                    } else {
                        flags &= ~EB_UT_FL_MTIME;
                        TTrace((stderr,"  UT e.f. truncated; no modtime\n"));
                    }
                }
                if (ef_is_c) {
    1ea5:	8b 7c 24 48          	mov    0x48(%esp),%edi
        }

        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
            have_new_type_eb = TRUE;
    1ea9:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    1eb0:	00 
                    } else {
                        flags &= ~EB_UT_FL_MTIME;
                        TTrace((stderr,"  UT e.f. truncated; no modtime\n"));
                    }
                }
                if (ef_is_c) {
    1eb1:	85 ff                	test   %edi,%edi
    1eb3:	0f 85 60 fe ff ff    	jne    1d19 <_ef_scan_for_izux+0xa9>
                    break;      /* central version of TIME field ends here */
                }

                if (flags & EB_UT_FL_ATIME) {
    1eb9:	f6 44 24 14 02       	testb  $0x2,0x14(%esp)
    1ebe:	74 53                	je     1f13 <_ef_scan_for_izux+0x2a3>
                    if ((eb_idx+4) <= eb_len) {
    1ec0:	83 c1 04             	add    $0x4,%ecx
    1ec3:	39 cb                	cmp    %ecx,%ebx
    1ec5:	73 17                	jae    1ede <_ef_scan_for_izux+0x26e>
                        } else {
                            z_utim->atime = (time_t)i_time;
                        }
#endif /* ?TIME_T_TYPE_DOUBLE */
                    } else {
                        flags &= ~EB_UT_FL_ATIME;
    1ec7:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    1ecb:	89 c8                	mov    %ecx,%eax
    1ecd:	83 e0 fd             	and    $0xfffffffd,%eax
                    }
                }
                if (flags & EB_UT_FL_CTIME) {
    1ed0:	83 e1 04             	and    $0x4,%ecx
                        } else {
                            z_utim->atime = (time_t)i_time;
                        }
#endif /* ?TIME_T_TYPE_DOUBLE */
                    } else {
                        flags &= ~EB_UT_FL_ATIME;
    1ed3:	89 44 24 14          	mov    %eax,0x14(%esp)
                    }
                }
                if (flags & EB_UT_FL_CTIME) {
    1ed7:	75 58                	jne    1f31 <_ef_scan_for_izux+0x2c1>
    1ed9:	e9 3b fe ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
                    break;      /* central version of TIME field ends here */
                }

                if (flags & EB_UT_FL_ATIME) {
                    if ((eb_idx+4) <= eb_len) {
                        i_time = (long)makelong((EB_HEADSIZE+eb_idx) + ef_buf);
    1ede:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
    1ee1:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    1ee5:	89 04 24             	mov    %eax,(%esp)
    1ee8:	e8 00 00 00 00       	call   1eed <_ef_scan_for_izux+0x27d>
                            }
                        } else {
                            z_utim->atime = (time_t)i_time;
                        }
#else /* !TIME_T_TYPE_DOUBLE */
                        if (((ulg)(i_time) & (ulg)(0x80000000L)) &&
    1eed:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    1ef1:	89 c2                	mov    %eax,%edx
    1ef3:	c1 ea 1f             	shr    $0x1f,%edx
    1ef6:	0f 84 76 01 00 00    	je     2072 <_ef_scan_for_izux+0x402>
    1efc:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    1f00:	85 d2                	test   %edx,%edx
    1f02:	0f 85 6a 01 00 00    	jne    2072 <_ef_scan_for_izux+0x402>
                            !ut_zip_unzip_compatible) {
                            flags &= ~EB_UT_FL_ATIME;
    1f08:	8b 7c 24 14          	mov    0x14(%esp),%edi
    1f0c:	83 e7 fd             	and    $0xfffffffd,%edi
    1f0f:	89 7c 24 14          	mov    %edi,0x14(%esp)
        }

        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
            have_new_type_eb = TRUE;
    1f13:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    1f1a:	00 
#endif /* ?TIME_T_TYPE_DOUBLE */
                    } else {
                        flags &= ~EB_UT_FL_ATIME;
                    }
                }
                if (flags & EB_UT_FL_CTIME) {
    1f1b:	f6 44 24 14 04       	testb  $0x4,0x14(%esp)
    1f20:	0f 84 f3 fd ff ff    	je     1d19 <_ef_scan_for_izux+0xa9>
                    if ((eb_idx+4) <= eb_len) {
    1f26:	83 c1 04             	add    $0x4,%ecx
    1f29:	39 cb                	cmp    %ecx,%ebx
    1f2b:	0f 83 bc 00 00 00    	jae    1fed <_ef_scan_for_izux+0x37d>
                        } else {
                            z_utim->ctime = (time_t)i_time;
                        }
#endif /* ?TIME_T_TYPE_DOUBLE */
                    } else {
                        flags &= ~EB_UT_FL_CTIME;
    1f31:	8b 4c 24 14          	mov    0x14(%esp),%ecx
        }

        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
            have_new_type_eb = TRUE;
    1f35:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    1f3c:	00 
                        } else {
                            z_utim->ctime = (time_t)i_time;
                        }
#endif /* ?TIME_T_TYPE_DOUBLE */
                    } else {
                        flags &= ~EB_UT_FL_CTIME;
    1f3d:	83 e1 fb             	and    $0xfffffffb,%ecx
    1f40:	89 4c 24 14          	mov    %ecx,0x14(%esp)
    1f44:	e9 d0 fd ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
    1f49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                unsigned eb_idx = EB_UT_TIME1;
                TTrace((stderr,"ef_scan_for_izux: found TIME extra field\n"));
                flags |= (ef_buf[EB_HEADSIZE+EB_UT_FLAGS] & 0x0ff);
                if ((flags & EB_UT_FL_MTIME)) {
                    if ((eb_idx+4) <= eb_len) {
                        i_time = (long)makelong((EB_HEADSIZE+eb_idx) + ef_buf);
    1f50:	8d 46 05             	lea    0x5(%esi),%eax
    1f53:	89 04 24             	mov    %eax,(%esp)
    1f56:	e8 00 00 00 00       	call   1f5b <_ef_scan_for_izux+0x2eb>
                                "  UT modtime range error; ignore e.f.!\n"));
                              break;            /* stop scanning this field */
                            }
                        } else {
                            /* cannot determine, safe assumption is FALSE */
                            ut_zip_unzip_compatible = FALSE;
    1f5b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    1f62:	00 
                            /* cannot determine, safe assumption is FALSE */
                            ut_in_archive_sgn = 0;
                            z_utim->mtime = (time_t)i_time;
                        }
#else /* !TIME_T_TYPE_DOUBLE */
                        if ((ulg)(i_time) & (ulg)(0x80000000L)) {
    1f63:	85 c0                	test   %eax,%eax
    1f65:	0f 88 d2 00 00 00    	js     203d <_ef_scan_for_izux+0x3cd>
                            }
                        } else {
                            /* cannot determine, safe assumption is FALSE */
                            ut_zip_unzip_compatible = FALSE;
                        }
                        z_utim->mtime = (time_t)i_time;
    1f6b:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1f6f:	89 41 04             	mov    %eax,0x4(%ecx)
                TTrace((stderr,"ef_scan_for_izux: found TIME extra field\n"));
                flags |= (ef_buf[EB_HEADSIZE+EB_UT_FLAGS] & 0x0ff);
                if ((flags & EB_UT_FL_MTIME)) {
                    if ((eb_idx+4) <= eb_len) {
                        i_time = (long)makelong((EB_HEADSIZE+eb_idx) + ef_buf);
                        eb_idx += 4;
    1f72:	b9 05 00 00 00       	mov    $0x5,%ecx
    1f77:	e9 29 ff ff ff       	jmp    1ea5 <_ef_scan_for_izux+0x235>
    1f7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                        z_utim->atime = (time_t)i_time;
                    }
#endif /* ?TIME_T_TYPE_DOUBLE */
                }
                if (eb_len >= EB_UX_FULLSIZE && z_uidgid != NULL) {
                    z_uidgid[0] = makeword((EB_HEADSIZE+EB_UX_UID) + ef_buf);
    1f80:	8d 46 0c             	lea    0xc(%esi),%eax
    1f83:	89 04 24             	mov    %eax,(%esp)
    1f86:	e8 00 00 00 00       	call   1f8b <_ef_scan_for_izux+0x31b>
    1f8b:	8b 4c 24 54          	mov    0x54(%esp),%ecx
    1f8f:	66 89 01             	mov    %ax,(%ecx)
                    z_uidgid[1] = makeword((EB_HEADSIZE+EB_UX_GID) + ef_buf);
    1f92:	8d 46 0e             	lea    0xe(%esi),%eax
    1f95:	89 04 24             	mov    %eax,(%esp)
    1f98:	e8 00 00 00 00       	call   1f9d <_ef_scan_for_izux+0x32d>
    1f9d:	8b 54 24 54          	mov    0x54(%esp),%edx
                    flags |= EB_UX2_VALID;
    1fa1:	81 4c 24 14 00 01 00 	orl    $0x100,0x14(%esp)
    1fa8:	00 
                    }
#endif /* ?TIME_T_TYPE_DOUBLE */
                }
                if (eb_len >= EB_UX_FULLSIZE && z_uidgid != NULL) {
                    z_uidgid[0] = makeword((EB_HEADSIZE+EB_UX_UID) + ef_buf);
                    z_uidgid[1] = makeword((EB_HEADSIZE+EB_UX_GID) + ef_buf);
    1fa9:	66 89 42 02          	mov    %ax,0x2(%edx)
                    flags |= EB_UX2_VALID;
    1fad:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    1fb4:	00 
    1fb5:	e9 5f fd ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
    1fba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                    }
#else /* !TIME_T_TYPE_DOUBLE */
                    if (((ulg)(i_time) & (ulg)(0x80000000L)) &&
                        !ut_zip_unzip_compatible && (flags & 0x0ff)) {
                        /* atime not in range of UnZip's time_t */
                        flags &= ~EB_UT_FL_ATIME;
    1fc0:	89 f8                	mov    %edi,%eax
    1fc2:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    1fc9:	00 
    1fca:	83 e0 fd             	and    $0xfffffffd,%eax
    1fcd:	89 44 24 14          	mov    %eax,0x14(%esp)
    1fd1:	e9 4f fe ff ff       	jmp    1e25 <_ef_scan_for_izux+0x1b5>
                    if ((ulg)(i_time) & (ulg)(0x80000000L)) {
                        ut_zip_unzip_compatible =
                          ((time_t)0x80000000L < (time_t)0L)
                          ? (dos_mdatetime == DOSTIME_MINIMUM)
                          : (dos_mdatetime >= DOSTIME_2038_01_18);
                        if (!ut_zip_unzip_compatible) {
    1fd6:	81 7c 24 4c 00 00 21 	cmpl   $0x210000,0x4c(%esp)
    1fdd:	00 
    1fde:	74 3e                	je     201e <_ef_scan_for_izux+0x3ae>
                            /* UnZip interpretes mtime differently than Zip;
                               without modtime: ignore complete UT field */
                            flags &= ~0x0ff;    /* no time_t times available */
    1fe0:	8b 54 24 14          	mov    0x14(%esp),%edx
    1fe4:	30 d2                	xor    %dl,%dl
    1fe6:	89 d7                	mov    %edx,%edi
    1fe8:	e9 06 fe ff ff       	jmp    1df3 <_ef_scan_for_izux+0x183>
                        flags &= ~EB_UT_FL_ATIME;
                    }
                }
                if (flags & EB_UT_FL_CTIME) {
                    if ((eb_idx+4) <= eb_len) {
                        i_time = (long)makelong((EB_HEADSIZE+eb_idx) + ef_buf);
    1fed:	01 f1                	add    %esi,%ecx
    1fef:	89 0c 24             	mov    %ecx,(%esp)
    1ff2:	e8 00 00 00 00       	call   1ff7 <_ef_scan_for_izux+0x387>
                            }
                        } else {
                            z_utim->ctime = (time_t)i_time;
                        }
#else /* !TIME_T_TYPE_DOUBLE */
                        if (((ulg)(i_time) & (ulg)(0x80000000L)) &&
    1ff7:	89 c1                	mov    %eax,%ecx
    1ff9:	c1 e9 1f             	shr    $0x1f,%ecx
    1ffc:	74 60                	je     205e <_ef_scan_for_izux+0x3ee>
    1ffe:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    2002:	85 d2                	test   %edx,%edx
    2004:	75 58                	jne    205e <_ef_scan_for_izux+0x3ee>
                            !ut_zip_unzip_compatible) {
                            flags &= ~EB_UT_FL_CTIME;
    2006:	8b 7c 24 14          	mov    0x14(%esp),%edi
    200a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
    2011:	00 
    2012:	83 e7 fb             	and    $0xfffffffb,%edi
    2015:	89 7c 24 14          	mov    %edi,0x14(%esp)
    2019:	e9 fb fc ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
                        }
                    } else {
                        /* cannot determine, safe assumption is FALSE */
                        ut_zip_unzip_compatible = FALSE;
                    }
                    z_utim->mtime = (time_t)i_time;
    201e:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    2022:	89 41 04             	mov    %eax,0x4(%ecx)
#endif /* ?TIME_T_TYPE_DOUBLE */
                    i_time = (long)makelong((EB_HEADSIZE+EB_UX_ATIME)+ef_buf);
    2025:	8d 46 04             	lea    0x4(%esi),%eax
    2028:	89 04 24             	mov    %eax,(%esp)
    202b:	e8 00 00 00 00       	call   2030 <_ef_scan_for_izux+0x3c0>
    2030:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
    2037:	00 
    2038:	e9 de fd ff ff       	jmp    1e1b <_ef_scan_for_izux+0x1ab>
                        if ((ulg)(i_time) & (ulg)(0x80000000L)) {
                            ut_zip_unzip_compatible =
                              ((time_t)0x80000000L < (time_t)0L)
                              ? (dos_mdatetime == DOSTIME_MINIMUM)
                              : (dos_mdatetime >= DOSTIME_2038_01_18);
                            if (!ut_zip_unzip_compatible) {
    203d:	81 7c 24 4c 00 00 21 	cmpl   $0x210000,0x4c(%esp)
    2044:	00 
    2045:	74 36                	je     207d <_ef_scan_for_izux+0x40d>
                              /* UnZip interprets mtime differently than Zip;
                                 without modtime: ignore complete UT field */
                              flags &= ~0x0ff;  /* no time_t times available */
    2047:	8b 44 24 14          	mov    0x14(%esp),%eax
        }

        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
            have_new_type_eb = TRUE;
    204b:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    2052:	00 
                              ? (dos_mdatetime == DOSTIME_MINIMUM)
                              : (dos_mdatetime >= DOSTIME_2038_01_18);
                            if (!ut_zip_unzip_compatible) {
                              /* UnZip interprets mtime differently than Zip;
                                 without modtime: ignore complete UT field */
                              flags &= ~0x0ff;  /* no time_t times available */
    2053:	b0 00                	mov    $0x0,%al
    2055:	89 44 24 14          	mov    %eax,0x14(%esp)
                              TTrace((stderr,
                                "  UT modtime range error; ignore e.f.!\n"));
                              break;            /* stop scanning this field */
    2059:	e9 bb fc ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
                            !ut_zip_unzip_compatible) {
                            flags &= ~EB_UT_FL_CTIME;
                            TTrace((stderr,
                              "  UT creation time range error: skip time!\n"));
                        } else {
                            z_utim->ctime = (time_t)i_time;
    205e:	8b 4c 24 50          	mov    0x50(%esp),%ecx
        }

        switch (eb_id) {
          case EF_TIME:
            flags &= ~0x0ff;    /* ignore previous IZUNIX or EF_TIME fields */
            have_new_type_eb = TRUE;
    2062:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
    2069:	00 
                            !ut_zip_unzip_compatible) {
                            flags &= ~EB_UT_FL_CTIME;
                            TTrace((stderr,
                              "  UT creation time range error: skip time!\n"));
                        } else {
                            z_utim->ctime = (time_t)i_time;
    206a:	89 41 08             	mov    %eax,0x8(%ecx)
    206d:	e9 a7 fc ff ff       	jmp    1d19 <_ef_scan_for_izux+0xa9>
                            !ut_zip_unzip_compatible) {
                            flags &= ~EB_UT_FL_ATIME;
                            TTrace((stderr,
                              "  UT access time range error: skip time!\n"));
                        } else {
                            z_utim->atime = (time_t)i_time;
    2072:	8b 54 24 50          	mov    0x50(%esp),%edx
    2076:	89 02                	mov    %eax,(%edx)
    2078:	e9 96 fe ff ff       	jmp    1f13 <_ef_scan_for_izux+0x2a3>
    207d:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
    2084:	00 
    2085:	e9 e1 fe ff ff       	jmp    1f6b <_ef_scan_for_izux+0x2fb>
    208a:	90                   	nop
    208b:	90                   	nop
    208c:	90                   	nop
    208d:	90                   	nop
    208e:	90                   	nop
    208f:	90                   	nop

unreduce.o:     file format pe-i386


unshrink.o:     file format pe-i386


Disassembly of section .text:

00000000 <_unshrink>:
/* Function unshrink() */
/***********************/

int unshrink(__G)
     __GDEF
{
   0:	55                   	push   %ebp
   1:	57                   	push   %edi
   2:	56                   	push   %esi
   3:	53                   	push   %ebx
   4:	83 ec 4c             	sub    $0x4c,%esp
   7:	8b 5c 24 60          	mov    0x60(%esp),%ebx
    int offset = (HSIZE - 1);
    uch *stacktop = stack + offset;
   b:	8d 83 db c8 00 00    	lea    0xc8db(%ebx),%eax
  11:	89 44 24 28          	mov    %eax,0x28(%esp)
#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
    /* Normally realbuf and outbuf will be the same.  However, if the data
     * are redirected to a large memory buffer, realbuf will point to the
     * new location while outbuf will remain pointing to the malloc'd
     * memory buffer. */
    uch *realbuf = G.outbuf;
  15:	8b 83 cc 09 01 00    	mov    0x109cc(%ebx),%eax
  1b:	89 44 24 1c          	mov    %eax,0x1c(%esp)

#ifndef VMS     /* VMS uses its own buffer scheme for textmode flush(). */
#ifndef SMALL_MEM
    /* non-memory-limited machines:  allocate second (large) buffer for
     * textmode conversion in flush(), but only if needed */
    if (G.pInfo->textmode && !G.outbuf2 &&
  1f:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
  25:	f6 40 18 08          	testb  $0x8,0x18(%eax)
  29:	74 0e                	je     39 <_unshrink+0x39>
  2b:	8b 83 d4 09 01 00    	mov    0x109d4(%ebx),%eax
  31:	85 c0                	test   %eax,%eax
  33:	0f 84 a4 05 00 00    	je     5dd <_unshrink+0x5dd>
/* Function unshrink() */
/***********************/

int unshrink(__G)
     __GDEF
{
  39:	31 c0                	xor    %eax,%eax
  3b:	90                   	nop
  3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return PK_MEM3;
#endif
#endif /* !VMS */

    for (code = 0;  code < BOGUSCODE;  ++code) {
        Value[code] = (uch)code;
  40:	88 84 03 dc 88 00 00 	mov    %al,0x88dc(%ebx,%eax,1)
        parent[code] = BOGUSCODE;
  47:	c7 84 83 dc 08 00 00 	movl   $0x100,0x8dc(%ebx,%eax,4)
  4e:	00 01 00 00 
        (G.outbuf2 = (uch *)malloc(TRANSBUFSIZ)) == (uch *)NULL)
        return PK_MEM3;
#endif
#endif /* !VMS */

    for (code = 0;  code < BOGUSCODE;  ++code) {
  52:	40                   	inc    %eax
  53:	3d 00 01 00 00       	cmp    $0x100,%eax
  58:	75 e6                	jne    40 <_unshrink+0x40>
  5a:	8d 8b dc 88 00 00    	lea    0x88dc(%ebx),%ecx
  60:	8d 83 e0 0c 00 00    	lea    0xce0(%ebx),%eax
  66:	89 44 24 38          	mov    %eax,0x38(%esp)
  6a:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
  6e:	89 ca                	mov    %ecx,%edx
        Value[code] = (uch)code;
        parent[code] = BOGUSCODE;
    }
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code)
        parent[code] = FREE_CODE;
  70:	c7 00 00 20 00 00    	movl   $0x2000,(%eax)
  76:	83 c0 04             	add    $0x4,%eax

    for (code = 0;  code < BOGUSCODE;  ++code) {
        Value[code] = (uch)code;
        parent[code] = BOGUSCODE;
    }
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code)
  79:	39 d0                	cmp    %edx,%eax
  7b:	75 f3                	jne    70 <_unshrink+0x70>
        parent[code] = FREE_CODE;

#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
    if (G.redirect_slide) { /* use normal outbuf unless we're a DLL routine */
  7d:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
#else
    if (G.pInfo->textmode)
#endif
        outbufsiz = RAWBUFSIZ;
    else
        outbufsiz = OUTBUFSIZ;
  83:	c7 44 24 34 00 00 02 	movl   $0x20000,0x34(%esp)
  8a:	00 
    }
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code)
        parent[code] = FREE_CODE;

#if (defined(DLL) && !defined(NO_SLIDE_REDIR))
    if (G.redirect_slide) { /* use normal outbuf unless we're a DLL routine */
  8b:	85 c0                	test   %eax,%eax
  8d:	74 14                	je     a3 <_unshrink+0xa3>
        realbuf = G.redirect_buffer;
  8f:	8b 83 b4 00 00 00    	mov    0xb4(%ebx),%eax
  95:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        outbufsiz = (unsigned)G.redirect_size;
  99:	8b 83 b0 00 00 00    	mov    0xb0(%ebx),%eax
  9f:	89 44 24 34          	mov    %eax,0x34(%esp)
    if (G.pInfo->textmode)
#endif
        outbufsiz = RAWBUFSIZ;
    else
        outbufsiz = OUTBUFSIZ;
    G.outptr = realbuf;
  a3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    G.outcnt = 0L;
  a7:	c7 83 dc 09 01 00 00 	movl   $0x0,0x109dc(%ebx)
  ae:	00 00 00 
    if (G.pInfo->textmode)
#endif
        outbufsiz = RAWBUFSIZ;
    else
        outbufsiz = OUTBUFSIZ;
    G.outptr = realbuf;
  b1:	89 83 d8 09 01 00    	mov    %eax,0x109d8(%ebx)

/*---------------------------------------------------------------------------
    Get and output first code, then loop over remaining ones.
  ---------------------------------------------------------------------------*/

    READBITS(codesize, oldcode)
  b7:	8b 83 f4 08 01 00    	mov    0x108f4(%ebx),%eax
  bd:	89 c1                	mov    %eax,%ecx
  bf:	83 f8 08             	cmp    $0x8,%eax
  c2:	0f 8f 80 00 00 00    	jg     148 <_unshrink+0x148>
  c8:	c7 83 f8 08 01 00 01 	movl   $0x1,0x108f8(%ebx)
  cf:	00 00 00 
  d2:	eb 48                	jmp    11c <_unshrink+0x11c>
  d4:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
  da:	8d 50 01             	lea    0x1(%eax),%edx
  dd:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
  e3:	0f b6 30             	movzbl (%eax),%esi
  e6:	81 e6 ff 00 00 00    	and    $0xff,%esi
  ec:	89 f0                	mov    %esi,%eax
  ee:	d3 e0                	shl    %cl,%eax
  f0:	8b ab f0 08 01 00    	mov    0x108f0(%ebx),%ebp
  f6:	89 ca                	mov    %ecx,%edx
  f8:	09 e8                	or     %ebp,%eax
  fa:	83 c1 08             	add    $0x8,%ecx
  fd:	89 83 f0 08 01 00    	mov    %eax,0x108f0(%ebx)
 103:	89 8b f4 08 01 00    	mov    %ecx,0x108f4(%ebx)
 109:	c7 83 f8 08 01 00 00 	movl   $0x0,0x108f8(%ebx)
 110:	00 00 00 
 113:	83 f9 18             	cmp    $0x18,%ecx
 116:	0f 8f 3f 04 00 00    	jg     55b <_unshrink+0x55b>
 11c:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
 122:	85 c0                	test   %eax,%eax
 124:	8d 50 ff             	lea    -0x1(%eax),%edx
 127:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
 12d:	7f a5                	jg     d4 <_unshrink+0xd4>
 12f:	89 1c 24             	mov    %ebx,(%esp)
 132:	e8 00 00 00 00       	call   137 <_unshrink+0x137>
 137:	83 f8 ff             	cmp    $0xffffffff,%eax
 13a:	0f 84 6d 04 00 00    	je     5ad <_unshrink+0x5ad>
 140:	8b 8b f4 08 01 00    	mov    0x108f4(%ebx),%ecx
 146:	eb a6                	jmp    ee <_unshrink+0xee>
 148:	8b 93 f0 08 01 00    	mov    0x108f0(%ebx),%edx
 14e:	8b 8b f8 08 01 00    	mov    0x108f8(%ebx),%ecx
 154:	89 d7                	mov    %edx,%edi
 156:	8b 35 24 00 00 00    	mov    0x24,%esi
 15c:	21 f7                	and    %esi,%edi
 15e:	83 e8 09             	sub    $0x9,%eax
 161:	c1 ea 09             	shr    $0x9,%edx
 164:	89 7c 24 24          	mov    %edi,0x24(%esp)
 168:	89 93 f0 08 01 00    	mov    %edx,0x108f0(%ebx)
 16e:	89 83 f4 08 01 00    	mov    %eax,0x108f4(%ebx)
    if (!G.zipeof) {
 174:	85 c9                	test   %ecx,%ecx
 176:	0f 84 fd 03 00 00    	je     579 <_unshrink+0x579>
        (G.outbuf2 = (uch *)malloc(TRANSBUFSIZ)) == (uch *)NULL)
        return PK_MEM3;
#endif
#endif /* !VMS */

    for (code = 0;  code < BOGUSCODE;  ++code) {
 17c:	c7 44 24 18 09 00 00 	movl   $0x9,0x18(%esp)
 183:	00 
 184:	89 f5                	mov    %esi,%ebp
 186:	bf 00 01 00 00       	mov    $0x100,%edi
        OUTDBG((uch)oldcode)
        ++G.outcnt;
    }

    do {
        READBITS(codesize, code)
 18b:	39 44 24 18          	cmp    %eax,0x18(%esp)
 18f:	0f 8f 85 01 00 00    	jg     31a <_unshrink+0x31a>
 195:	8b 93 f0 08 01 00    	mov    0x108f0(%ebx),%edx
 19b:	8b b3 f8 08 01 00    	mov    0x108f8(%ebx),%esi
 1a1:	89 d1                	mov    %edx,%ecx
 1a3:	21 e9                	and    %ebp,%ecx
 1a5:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 1a9:	8a 4c 24 18          	mov    0x18(%esp),%cl
 1ad:	d3 ea                	shr    %cl,%edx
 1af:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 1b3:	89 93 f0 08 01 00    	mov    %edx,0x108f0(%ebx)
 1b9:	29 c8                	sub    %ecx,%eax
        if (G.zipeof)
 1bb:	85 f6                	test   %esi,%esi
        OUTDBG((uch)oldcode)
        ++G.outcnt;
    }

    do {
        READBITS(codesize, code)
 1bd:	89 83 f4 08 01 00    	mov    %eax,0x108f4(%ebx)
        if (G.zipeof)
 1c3:	0f 85 1b 03 00 00    	jne    4e4 <_unshrink+0x4e4>
            break;
        if (code == BOGUSCODE) {   /* possible to have consecutive escapes? */
 1c9:	81 7c 24 20 00 01 00 	cmpl   $0x100,0x20(%esp)
 1d0:	00 
 1d1:	0f 84 dc 01 00 00    	je     3b3 <_unshrink+0x3b3>
      -----------------------------------------------------------------------*/

        newstr = stacktop;
        curcode = code;

        if (parent[curcode] == FREE_CODE) {
 1d7:	8b 44 24 20          	mov    0x20(%esp),%eax
 1db:	81 bc 83 dc 08 00 00 	cmpl   $0x2000,0x8dc(%ebx,%eax,4)
 1e2:	00 20 00 00 
 1e6:	0f 84 4d 03 00 00    	je     539 <_unshrink+0x539>
 1ec:	8b 44 24 20          	mov    0x20(%esp),%eax

    /*-----------------------------------------------------------------------
        Translate code:  traverse tree from leaf back to root.
      -----------------------------------------------------------------------*/

        newstr = stacktop;
 1f0:	8b 74 24 28          	mov    0x28(%esp),%esi
            Trace((stderr, " (found a KwKwK code %d; oldcode = %d)\n", code,
              oldcode));
            --newstr;   /* last character will be same as first character */
            curcode = oldcode;
        } else
            KwKwK = FALSE;
 1f4:	31 ed                	xor    %ebp,%ebp
 1f6:	eb 02                	jmp    1fa <_unshrink+0x1fa>
 1f8:	89 d6                	mov    %edx,%esi

        do {
            *newstr-- = Value[curcode];
 1fa:	8d 56 ff             	lea    -0x1(%esi),%edx
 1fd:	8a 8c 03 dc 88 00 00 	mov    0x88dc(%ebx,%eax,1),%cl
 204:	88 4a 01             	mov    %cl,0x1(%edx)
            curcode = (shrint)(parent[curcode] & CODE_MASK);
 207:	8b 84 83 dc 08 00 00 	mov    0x8dc(%ebx,%eax,4),%eax
 20e:	25 ff 1f 00 00       	and    $0x1fff,%eax
        } while (curcode != BOGUSCODE);
 213:	3d 00 01 00 00       	cmp    $0x100,%eax
 218:	75 de                	jne    1f8 <_unshrink+0x1f8>

        len = (int)(stacktop - newstr++);
 21a:	8b 44 24 28          	mov    0x28(%esp),%eax
 21e:	89 74 24 2c          	mov    %esi,0x2c(%esp)
 222:	29 d0                	sub    %edx,%eax
        if (KwKwK)
 224:	85 ed                	test   %ebp,%ebp
 226:	74 06                	je     22e <_unshrink+0x22e>
            *stacktop = *newstr;
 228:	88 8b db c8 00 00    	mov    %cl,0xc8db(%ebx)
          oldcode, (int)(*newstr), (*newstr<32 || *newstr>=127)? ' ':*newstr));

        {
            register uch *p;

            for (p = newstr;  p < newstr+len;  ++p) {
 22e:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
 231:	39 f5                	cmp    %esi,%ebp
 233:	76 76                	jbe    2ab <_unshrink+0x2ab>
 235:	89 7c 24 30          	mov    %edi,0x30(%esp)
 239:	89 ef                	mov    %ebp,%edi
 23b:	8b 6c 24 34          	mov    0x34(%esp),%ebp
 23f:	eb 05                	jmp    246 <_unshrink+0x246>
 241:	46                   	inc    %esi
 242:	39 fe                	cmp    %edi,%esi
 244:	74 61                	je     2a7 <_unshrink+0x2a7>
                *G.outptr++ = *p;
 246:	8b 83 d8 09 01 00    	mov    0x109d8(%ebx),%eax
 24c:	8d 48 01             	lea    0x1(%eax),%ecx
 24f:	89 8b d8 09 01 00    	mov    %ecx,0x109d8(%ebx)
 255:	8a 16                	mov    (%esi),%dl
 257:	88 10                	mov    %dl,(%eax)
                OUTDBG(*p)
                if (++G.outcnt == outbufsiz) {
 259:	8b 83 dc 09 01 00    	mov    0x109dc(%ebx),%eax
 25f:	40                   	inc    %eax
 260:	89 83 dc 09 01 00    	mov    %eax,0x109dc(%ebx)
 266:	39 c5                	cmp    %eax,%ebp
 268:	75 d7                	jne    241 <_unshrink+0x241>
                    Trace((stderr, "doing flush(), outcnt = %lu\n", G.outcnt));
                    if ((error = flush(__G__ realbuf, G.outcnt, TRUE)) != 0) {
 26a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 26e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 275:	00 
 276:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 27a:	89 44 24 04          	mov    %eax,0x4(%esp)
 27e:	89 1c 24             	mov    %ebx,(%esp)
 281:	e8 00 00 00 00       	call   286 <_unshrink+0x286>
 286:	85 c0                	test   %eax,%eax
 288:	0f 85 7c 02 00 00    	jne    50a <_unshrink+0x50a>
                        Trace((stderr, "unshrink:  flush() error (%d)\n",
                          error));
                        return error;
                    }
                    G.outptr = realbuf;
 28e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
          oldcode, (int)(*newstr), (*newstr<32 || *newstr>=127)? ' ':*newstr));

        {
            register uch *p;

            for (p = newstr;  p < newstr+len;  ++p) {
 292:	46                   	inc    %esi
                    if ((error = flush(__G__ realbuf, G.outcnt, TRUE)) != 0) {
                        Trace((stderr, "unshrink:  flush() error (%d)\n",
                          error));
                        return error;
                    }
                    G.outptr = realbuf;
 293:	89 83 d8 09 01 00    	mov    %eax,0x109d8(%ebx)
                    G.outcnt = 0L;
 299:	c7 83 dc 09 01 00 00 	movl   $0x0,0x109dc(%ebx)
 2a0:	00 00 00 
          oldcode, (int)(*newstr), (*newstr<32 || *newstr>=127)? ' ':*newstr));

        {
            register uch *p;

            for (p = newstr;  p < newstr+len;  ++p) {
 2a3:	39 fe                	cmp    %edi,%esi
 2a5:	75 9f                	jne    246 <_unshrink+0x246>
 2a7:	8b 7c 24 30          	mov    0x30(%esp),%edi
    /*-----------------------------------------------------------------------
        Add new leaf (first character of newstr) to tree as child of oldcode.
      -----------------------------------------------------------------------*/

        /* search for freecode */
        freecode = (shrint)(lastfreecode + 1);
 2ab:	47                   	inc    %edi
        /* add if-test before loop for speed? */
        while (parent[freecode] != FREE_CODE)
 2ac:	8d 87 34 02 00 00    	lea    0x234(%edi),%eax
 2b2:	81 7c 83 0c 00 20 00 	cmpl   $0x2000,0xc(%ebx,%eax,4)
 2b9:	00 
 2ba:	74 18                	je     2d4 <_unshrink+0x2d4>
 2bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            ++freecode;
 2c0:	47                   	inc    %edi
      -----------------------------------------------------------------------*/

        /* search for freecode */
        freecode = (shrint)(lastfreecode + 1);
        /* add if-test before loop for speed? */
        while (parent[freecode] != FREE_CODE)
 2c1:	81 bc bb dc 08 00 00 	cmpl   $0x2000,0x8dc(%ebx,%edi,4)
 2c8:	00 20 00 00 
 2cc:	75 f2                	jne    2c0 <_unshrink+0x2c0>
 2ce:	8d 87 34 02 00 00    	lea    0x234(%edi),%eax
            ++freecode;
        lastfreecode = freecode;
        Trace((stderr, "]; newcode %d\n", freecode));

        Value[freecode] = *newstr;
 2d4:	8b 74 24 2c          	mov    0x2c(%esp),%esi
 2d8:	8a 0e                	mov    (%esi),%cl
        parent[freecode] = oldcode;
 2da:	8b 74 24 24          	mov    0x24(%esp),%esi
        while (parent[freecode] != FREE_CODE)
            ++freecode;
        lastfreecode = freecode;
        Trace((stderr, "]; newcode %d\n", freecode));

        Value[freecode] = *newstr;
 2de:	88 8c 3b dc 88 00 00 	mov    %cl,0x88dc(%ebx,%edi,1)
        parent[freecode] = oldcode;
 2e5:	89 74 83 0c          	mov    %esi,0xc(%ebx,%eax,4)
 2e9:	8b 44 24 20          	mov    0x20(%esp),%eax
 2ed:	89 44 24 24          	mov    %eax,0x24(%esp)
        oldcode = code;

    } while (!G.zipeof);
 2f1:	8b 83 f8 08 01 00    	mov    0x108f8(%ebx),%eax
 2f7:	85 c0                	test   %eax,%eax
 2f9:	0f 85 e5 01 00 00    	jne    4e4 <_unshrink+0x4e4>
 2ff:	8b 74 24 18          	mov    0x18(%esp),%esi
 303:	8b 83 f4 08 01 00    	mov    0x108f4(%ebx),%eax
        OUTDBG((uch)oldcode)
        ++G.outcnt;
    }

    do {
        READBITS(codesize, code)
 309:	39 44 24 18          	cmp    %eax,0x18(%esp)
 30d:	8b 2c b5 00 00 00 00 	mov    0x0(,%esi,4),%ebp
 314:	0f 8e 7b fe ff ff    	jle    195 <_unshrink+0x195>
 31a:	c7 83 f8 08 01 00 01 	movl   $0x1,0x108f8(%ebx)
 321:	00 00 00 
 324:	83 f8 18             	cmp    $0x18,%eax
 327:	7e 53                	jle    37c <_unshrink+0x37c>
 329:	e9 96 02 00 00       	jmp    5c4 <_unshrink+0x5c4>
 32e:	66 90                	xchg   %ax,%ax
 330:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
 336:	8d 50 01             	lea    0x1(%eax),%edx
 339:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
 33f:	0f b6 30             	movzbl (%eax),%esi
 342:	81 e6 ff 00 00 00    	and    $0xff,%esi
 348:	89 f0                	mov    %esi,%eax
 34a:	8b 8b f4 08 01 00    	mov    0x108f4(%ebx),%ecx
 350:	8b b3 f0 08 01 00    	mov    0x108f0(%ebx),%esi
 356:	d3 e0                	shl    %cl,%eax
 358:	09 f0                	or     %esi,%eax
 35a:	83 c1 08             	add    $0x8,%ecx
 35d:	89 83 f0 08 01 00    	mov    %eax,0x108f0(%ebx)
 363:	89 8b f4 08 01 00    	mov    %ecx,0x108f4(%ebx)
 369:	c7 83 f8 08 01 00 00 	movl   $0x0,0x108f8(%ebx)
 370:	00 00 00 
 373:	83 f9 18             	cmp    $0x18,%ecx
 376:	0f 8f 96 01 00 00    	jg     512 <_unshrink+0x512>
 37c:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
 382:	85 c0                	test   %eax,%eax
 384:	8d 50 ff             	lea    -0x1(%eax),%edx
 387:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
 38d:	7f a1                	jg     330 <_unshrink+0x330>
 38f:	89 1c 24             	mov    %ebx,(%esp)
 392:	e8 00 00 00 00       	call   397 <_unshrink+0x397>
 397:	83 f8 ff             	cmp    $0xffffffff,%eax
 39a:	75 ae                	jne    34a <_unshrink+0x34a>
 39c:	8b 93 f0 08 01 00    	mov    0x108f0(%ebx),%edx
 3a2:	8b 83 f4 08 01 00    	mov    0x108f4(%ebx),%eax
 3a8:	8b b3 f8 08 01 00    	mov    0x108f8(%ebx),%esi
 3ae:	e9 ee fd ff ff       	jmp    1a1 <_unshrink+0x1a1>
        if (G.zipeof)
            break;
        if (code == BOGUSCODE) {   /* possible to have consecutive escapes? */
            READBITS(codesize, code)
 3b3:	39 44 24 18          	cmp    %eax,0x18(%esp)
 3b7:	0f 8e 8b 00 00 00    	jle    448 <_unshrink+0x448>
 3bd:	c7 83 f8 08 01 00 01 	movl   $0x1,0x108f8(%ebx)
 3c4:	00 00 00 
 3c7:	83 f8 18             	cmp    $0x18,%eax
 3ca:	7e 50                	jle    41c <_unshrink+0x41c>
 3cc:	eb 7a                	jmp    448 <_unshrink+0x448>
 3ce:	66 90                	xchg   %ax,%ax
 3d0:	8b 83 e8 08 01 00    	mov    0x108e8(%ebx),%eax
 3d6:	8d 50 01             	lea    0x1(%eax),%edx
 3d9:	89 93 e8 08 01 00    	mov    %edx,0x108e8(%ebx)
 3df:	0f b6 30             	movzbl (%eax),%esi
 3e2:	81 e6 ff 00 00 00    	and    $0xff,%esi
 3e8:	89 f0                	mov    %esi,%eax
 3ea:	8b 8b f4 08 01 00    	mov    0x108f4(%ebx),%ecx
 3f0:	8b b3 f0 08 01 00    	mov    0x108f0(%ebx),%esi
 3f6:	d3 e0                	shl    %cl,%eax
 3f8:	09 f0                	or     %esi,%eax
 3fa:	83 c1 08             	add    $0x8,%ecx
 3fd:	89 83 f0 08 01 00    	mov    %eax,0x108f0(%ebx)
 403:	89 8b f4 08 01 00    	mov    %ecx,0x108f4(%ebx)
 409:	c7 83 f8 08 01 00 00 	movl   $0x0,0x108f8(%ebx)
 410:	00 00 00 
 413:	83 f9 18             	cmp    $0x18,%ecx
 416:	0f 8f 88 01 00 00    	jg     5a4 <_unshrink+0x5a4>
 41c:	8b 83 ec 08 01 00    	mov    0x108ec(%ebx),%eax
 422:	85 c0                	test   %eax,%eax
 424:	8d 50 ff             	lea    -0x1(%eax),%edx
 427:	89 93 ec 08 01 00    	mov    %edx,0x108ec(%ebx)
 42d:	7f a1                	jg     3d0 <_unshrink+0x3d0>
 42f:	89 1c 24             	mov    %ebx,(%esp)
 432:	e8 00 00 00 00       	call   437 <_unshrink+0x437>
 437:	83 f8 ff             	cmp    $0xffffffff,%eax
 43a:	75 ae                	jne    3ea <_unshrink+0x3ea>
 43c:	8b 93 f0 08 01 00    	mov    0x108f0(%ebx),%edx
 442:	8b 83 f4 08 01 00    	mov    0x108f4(%ebx),%eax
 448:	8b 74 24 18          	mov    0x18(%esp),%esi
 44c:	21 d5                	and    %edx,%ebp
 44e:	89 f1                	mov    %esi,%ecx
 450:	29 f0                	sub    %esi,%eax
 452:	d3 ea                	shr    %cl,%edx
 454:	89 93 f0 08 01 00    	mov    %edx,0x108f0(%ebx)
 45a:	89 83 f4 08 01 00    	mov    %eax,0x108f4(%ebx)
            if (code == 1) {
 460:	83 fd 01             	cmp    $0x1,%ebp
 463:	0f 84 e4 00 00 00    	je     54d <_unshrink+0x54d>
                ++codesize;
                Trace((stderr, " (codesize now %d bits)\n", codesize));
            } else if (code == 2) {
 469:	83 fd 02             	cmp    $0x2,%ebp
 46c:	0f 85 7f fe ff ff    	jne    2f1 <_unshrink+0x2f1>
 472:	8b 54 24 38          	mov    0x38(%esp),%edx
 476:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
 47a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

    /* clear all nodes which have no children (i.e., leaf nodes only) */

    /* first loop:  mark each parent as such */
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code) {
        register shrint cparent = (shrint)(parent[code] & CODE_MASK);
 480:	8b 02                	mov    (%edx),%eax
 482:	25 ff 1f 00 00       	and    $0x1fff,%eax

        if (cparent > BOGUSCODE && cparent != FREE_CODE)
 487:	3d 00 01 00 00       	cmp    $0x100,%eax
 48c:	7e 0b                	jle    499 <_unshrink+0x499>
            FLAG_BITS[cparent] |= HAS_CHILD;   /* set parent's child-bit */
 48e:	81 8c 83 dc 08 00 00 	orl    $0x4000,0x8dc(%ebx,%eax,4)
 495:	00 40 00 00 
 499:	83 c2 04             	add    $0x4,%edx
    register shrint code;

    /* clear all nodes which have no children (i.e., leaf nodes only) */

    /* first loop:  mark each parent as such */
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code) {
 49c:	39 ca                	cmp    %ecx,%edx
 49e:	75 e0                	jne    480 <_unshrink+0x480>
 4a0:	8b 44 24 38          	mov    0x38(%esp),%eax
 4a4:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
 4a8:	eb 13                	jmp    4bd <_unshrink+0x4bd>
 4aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    }

    /* second loop:  clear all nodes *not* marked as parents; reset flag bits */
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code) {
        if (FLAG_BITS[code] & HAS_CHILD)    /* just clear child-bit */
            FLAG_BITS[code] &= ~HAS_CHILD;
 4b0:	80 e6 bf             	and    $0xbf,%dh
 4b3:	83 c0 04             	add    $0x4,%eax
 4b6:	89 50 fc             	mov    %edx,-0x4(%eax)
        if (cparent > BOGUSCODE && cparent != FREE_CODE)
            FLAG_BITS[cparent] |= HAS_CHILD;   /* set parent's child-bit */
    }

    /* second loop:  clear all nodes *not* marked as parents; reset flag bits */
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code) {
 4b9:	39 c8                	cmp    %ecx,%eax
 4bb:	74 14                	je     4d1 <_unshrink+0x4d1>
        if (FLAG_BITS[code] & HAS_CHILD)    /* just clear child-bit */
 4bd:	8b 10                	mov    (%eax),%edx
 4bf:	f6 c6 40             	test   $0x40,%dh
 4c2:	75 ec                	jne    4b0 <_unshrink+0x4b0>
            FLAG_BITS[code] &= ~HAS_CHILD;
        else {                              /* leaf:  lose it */
            Trace((stderr, "%d\n", code));
            parent[code] = FREE_CODE;
 4c4:	c7 00 00 20 00 00    	movl   $0x2000,(%eax)
 4ca:	83 c0 04             	add    $0x4,%eax
        if (cparent > BOGUSCODE && cparent != FREE_CODE)
            FLAG_BITS[cparent] |= HAS_CHILD;   /* set parent's child-bit */
    }

    /* second loop:  clear all nodes *not* marked as parents; reset flag bits */
    for (code = BOGUSCODE+1;  code < HSIZE;  ++code) {
 4cd:	39 c8                	cmp    %ecx,%eax
 4cf:	75 ec                	jne    4bd <_unshrink+0x4bd>

        Value[freecode] = *newstr;
        parent[freecode] = oldcode;
        oldcode = code;

    } while (!G.zipeof);
 4d1:	8b 83 f8 08 01 00    	mov    0x108f8(%ebx),%eax
                Trace((stderr, " (codesize now %d bits)\n", codesize));
            } else if (code == 2) {
                Trace((stderr, " (partial clear code)\n"));
                partial_clear(__G);   /* clear leafs (nodes with no children) */
                Trace((stderr, " (done with partial clear)\n"));
                lastfreecode = BOGUSCODE;  /* reset start of free-node search */
 4d7:	bf 00 01 00 00       	mov    $0x100,%edi

        Value[freecode] = *newstr;
        parent[freecode] = oldcode;
        oldcode = code;

    } while (!G.zipeof);
 4dc:	85 c0                	test   %eax,%eax
 4de:	0f 84 1b fe ff ff    	je     2ff <_unshrink+0x2ff>

/*---------------------------------------------------------------------------
    Flush any remaining data and return to sender...
  ---------------------------------------------------------------------------*/

    if (G.outcnt > 0L) {
 4e4:	8b 83 dc 09 01 00    	mov    0x109dc(%ebx),%eax
 4ea:	85 c0                	test   %eax,%eax
 4ec:	74 1c                	je     50a <_unshrink+0x50a>
        Trace((stderr, "doing final flush(), outcnt = %lu\n", G.outcnt));
        if ((error = flush(__G__ realbuf, G.outcnt, TRUE)) != 0) {
 4ee:	89 44 24 08          	mov    %eax,0x8(%esp)
 4f2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 4f6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 4fd:	00 
 4fe:	89 44 24 04          	mov    %eax,0x4(%esp)
 502:	89 1c 24             	mov    %ebx,(%esp)
 505:	e8 00 00 00 00       	call   50a <_unshrink+0x50a>
        Trace((stderr, "done with flush()\n"));
    }

    return PK_OK;

} /* end function unshrink() */
 50a:	83 c4 4c             	add    $0x4c,%esp
 50d:	5b                   	pop    %ebx
 50e:	5e                   	pop    %esi
 50f:	5f                   	pop    %edi
 510:	5d                   	pop    %ebp
 511:	c3                   	ret    
 512:	89 c2                	mov    %eax,%edx
 514:	89 c8                	mov    %ecx,%eax
        OUTDBG((uch)oldcode)
        ++G.outcnt;
    }

    do {
        READBITS(codesize, code)
 516:	89 d6                	mov    %edx,%esi
 518:	21 ee                	and    %ebp,%esi
 51a:	89 74 24 20          	mov    %esi,0x20(%esp)
 51e:	8b 74 24 18          	mov    0x18(%esp),%esi
 522:	89 f1                	mov    %esi,%ecx
 524:	29 f0                	sub    %esi,%eax
 526:	d3 ea                	shr    %cl,%edx
 528:	89 93 f0 08 01 00    	mov    %edx,0x108f0(%ebx)
 52e:	89 83 f4 08 01 00    	mov    %eax,0x108f4(%ebx)
 534:	e9 90 fc ff ff       	jmp    1c9 <_unshrink+0x1c9>
        if (parent[curcode] == FREE_CODE) {
            /* or (FLAG_BITS[curcode] & FREE_CODE)? */
            KwKwK = TRUE;
            Trace((stderr, " (found a KwKwK code %d; oldcode = %d)\n", code,
              oldcode));
            --newstr;   /* last character will be same as first character */
 539:	8d b3 da c8 00 00    	lea    0xc8da(%ebx),%esi
            curcode = oldcode;
 53f:	8b 44 24 24          	mov    0x24(%esp),%eax
        newstr = stacktop;
        curcode = code;

        if (parent[curcode] == FREE_CODE) {
            /* or (FLAG_BITS[curcode] & FREE_CODE)? */
            KwKwK = TRUE;
 543:	bd 01 00 00 00       	mov    $0x1,%ebp
 548:	e9 ad fc ff ff       	jmp    1fa <_unshrink+0x1fa>
        if (G.zipeof)
            break;
        if (code == BOGUSCODE) {   /* possible to have consecutive escapes? */
            READBITS(codesize, code)
            if (code == 1) {
                ++codesize;
 54d:	8b 54 24 18          	mov    0x18(%esp),%edx
 551:	42                   	inc    %edx
 552:	89 54 24 18          	mov    %edx,0x18(%esp)
 556:	e9 96 fd ff ff       	jmp    2f1 <_unshrink+0x2f1>

/*---------------------------------------------------------------------------
    Get and output first code, then loop over remaining ones.
  ---------------------------------------------------------------------------*/

    READBITS(codesize, oldcode)
 55b:	89 c7                	mov    %eax,%edi
 55d:	8b 35 24 00 00 00    	mov    0x24,%esi
 563:	21 f7                	and    %esi,%edi
 565:	4a                   	dec    %edx
 566:	c1 e8 09             	shr    $0x9,%eax
 569:	89 7c 24 24          	mov    %edi,0x24(%esp)
 56d:	89 83 f0 08 01 00    	mov    %eax,0x108f0(%ebx)
 573:	89 93 f4 08 01 00    	mov    %edx,0x108f4(%ebx)
    if (!G.zipeof) {
        *G.outptr++ = (uch)oldcode;
 579:	8b 83 d8 09 01 00    	mov    0x109d8(%ebx),%eax
 57f:	89 f9                	mov    %edi,%ecx
 581:	8d 50 01             	lea    0x1(%eax),%edx
 584:	89 93 d8 09 01 00    	mov    %edx,0x109d8(%ebx)
 58a:	88 08                	mov    %cl,(%eax)
        OUTDBG((uch)oldcode)
        ++G.outcnt;
 58c:	8b bb dc 09 01 00    	mov    0x109dc(%ebx),%edi
 592:	8b 83 f4 08 01 00    	mov    0x108f4(%ebx),%eax
 598:	47                   	inc    %edi
 599:	89 bb dc 09 01 00    	mov    %edi,0x109dc(%ebx)
 59f:	e9 d8 fb ff ff       	jmp    17c <_unshrink+0x17c>
 5a4:	89 c2                	mov    %eax,%edx
 5a6:	89 c8                	mov    %ecx,%eax
 5a8:	e9 9b fe ff ff       	jmp    448 <_unshrink+0x448>
 5ad:	8b 93 f0 08 01 00    	mov    0x108f0(%ebx),%edx
 5b3:	8b 83 f4 08 01 00    	mov    0x108f4(%ebx),%eax
 5b9:	8b 8b f8 08 01 00    	mov    0x108f8(%ebx),%ecx
 5bf:	e9 90 fb ff ff       	jmp    154 <_unshrink+0x154>
    }

    do {
        READBITS(codesize, code)
 5c4:	8b 74 24 18          	mov    0x18(%esp),%esi
 5c8:	89 f1                	mov    %esi,%ecx
 5ca:	29 f0                	sub    %esi,%eax
 5cc:	d3 ab f0 08 01 00    	shrl   %cl,0x108f0(%ebx)
 5d2:	89 83 f4 08 01 00    	mov    %eax,0x108f4(%ebx)
 5d8:	e9 07 ff ff ff       	jmp    4e4 <_unshrink+0x4e4>
#ifndef VMS     /* VMS uses its own buffer scheme for textmode flush(). */
#ifndef SMALL_MEM
    /* non-memory-limited machines:  allocate second (large) buffer for
     * textmode conversion in flush(), but only if needed */
    if (G.pInfo->textmode && !G.outbuf2 &&
        (G.outbuf2 = (uch *)malloc(TRANSBUFSIZ)) == (uch *)NULL)
 5dd:	c7 04 24 00 00 04 00 	movl   $0x40000,(%esp)
 5e4:	e8 00 00 00 00       	call   5e9 <_unshrink+0x5e9>
 5e9:	89 83 d4 09 01 00    	mov    %eax,0x109d4(%ebx)

#ifndef VMS     /* VMS uses its own buffer scheme for textmode flush(). */
#ifndef SMALL_MEM
    /* non-memory-limited machines:  allocate second (large) buffer for
     * textmode conversion in flush(), but only if needed */
    if (G.pInfo->textmode && !G.outbuf2 &&
 5ef:	85 c0                	test   %eax,%eax
 5f1:	0f 85 42 fa ff ff    	jne    39 <_unshrink+0x39>
        (G.outbuf2 = (uch *)malloc(TRANSBUFSIZ)) == (uch *)NULL)
        return PK_MEM3;
 5f7:	b8 06 00 00 00       	mov    $0x6,%eax
 5fc:	e9 09 ff ff ff       	jmp    50a <_unshrink+0x50a>
 601:	90                   	nop
 602:	90                   	nop
 603:	90                   	nop
 604:	90                   	nop
 605:	90                   	nop
 606:	90                   	nop
 607:	90                   	nop
 608:	90                   	nop
 609:	90                   	nop
 60a:	90                   	nop
 60b:	90                   	nop
 60c:	90                   	nop
 60d:	90                   	nop
 60e:	90                   	nop
 60f:	90                   	nop

win32.o:     file format pe-i386


Disassembly of section .text:

00000000 <_NTQueryVolInfo>:
 *        can support long filenames (LFN) on FAT filesystems.  Check the
 *        filesystem maximum component length field to detect LFN support.
 */

static int NTQueryVolInfo(__GPRO__ const char *name)
{
       0:	55                   	push   %ebp
       1:	57                   	push   %edi
       2:	56                   	push   %esi
       3:	53                   	push   %ebx
       4:	81 ec 5c 02 00 00    	sub    $0x25c,%esp

    INTERN_TO_ISO(name, ansi_name);
    name = ansi_name;
#endif

    if ((!strncmp(name, "//", 2) || !strncmp(name,"\\\\", 2)) &&
       a:	bf 00 00 00 00       	mov    $0x0,%edi
       f:	b9 02 00 00 00       	mov    $0x2,%ecx
      14:	89 d6                	mov    %edx,%esi
      16:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
      18:	74 10                	je     2a <_NTQueryVolInfo+0x2a>
      1a:	bf 03 00 00 00       	mov    $0x3,%edi
      1f:	b9 02 00 00 00       	mov    $0x2,%ecx
      24:	89 d6                	mov    %edx,%esi
      26:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
      28:	75 28                	jne    52 <_NTQueryVolInfo+0x52>
        (name[2] != '\0' && name[2] != '/' && name[2] != '\\')) {
      2a:	8a 4a 02             	mov    0x2(%edx),%cl
      2d:	80 f9 2f             	cmp    $0x2f,%cl
      30:	0f 95 c3             	setne  %bl
      33:	84 c9                	test   %cl,%cl
      35:	0f 95 44 24 2f       	setne  0x2f(%esp)
      3a:	84 5c 24 2f          	test   %bl,0x2f(%esp)
      3e:	74 12                	je     52 <_NTQueryVolInfo+0x52>
      40:	80 f9 5c             	cmp    $0x5c,%cl
      43:	74 0d                	je     52 <_NTQueryVolInfo+0x52>
        /* GetFullPathname() and GetVolumeInformation() do not work
         * on UNC names. For now, we return "error".
         * **FIXME**: check if UNC name is mapped to a drive letter
         *            and use mapped drive for volume info query.
         */
        return FALSE;
      45:	31 c0                	xor    %eax,%eax
                          !strncmp(tmp2, "FAT", 3);
    }

    return TRUE;

} /* end function NTQueryVolInfo() */
      47:	81 c4 5c 02 00 00    	add    $0x25c,%esp
      4d:	5b                   	pop    %ebx
      4e:	5e                   	pop    %esi
      4f:	5f                   	pop    %edi
      50:	5d                   	pop    %ebp
      51:	c3                   	ret    
	|| defined (__STRICT_ANSI__))

/* use  simple lookup if SB locale, else  _isctype()  */
#define __ISCTYPE(c, mask)  (MB_CUR_MAX == 1 ? (_pctype[c] & mask) : _isctype(c, mask))
__CRT_INLINE int __cdecl __MINGW_NOTHROW isalnum(int c) {return __ISCTYPE(c, (_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isalpha(int c) {return __ISCTYPE(c, _ALPHA);}
      52:	8b 0d 00 00 00 00    	mov    0x0,%ecx
      58:	89 c3                	mov    %eax,%ebx
      5a:	89 d7                	mov    %edx,%edi
         * **FIXME**: check if UNC name is mapped to a drive letter
         *            and use mapped drive for volume info query.
         */
        return FALSE;
    }
    if (isalpha((uch)name[0]) && (name[1] == ':'))
      5c:	8a 02                	mov    (%edx),%al
      5e:	83 39 01             	cmpl   $0x1,(%ecx)
      61:	0f 84 f9 00 00 00    	je     160 <_NTQueryVolInfo+0x160>
      67:	25 ff 00 00 00       	and    $0xff,%eax
      6c:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
      73:	00 
      74:	89 04 24             	mov    %eax,(%esp)
      77:	e8 00 00 00 00       	call   7c <_NTQueryVolInfo+0x7c>
      7c:	85 c0                	test   %eax,%eax
      7e:	74 0a                	je     8a <_NTQueryVolInfo+0x8a>
      80:	80 7f 01 3a          	cmpb   $0x3a,0x1(%edi)
      84:	0f 84 66 01 00 00    	je     1f0 <_NTQueryVolInfo+0x1f0>
        tmp0 = (char *)name;
    else
    {
        if (!GetFullPathName(name, MAX_PATH, tmp1, &tmp0))
      8a:	8d 44 24 38          	lea    0x38(%esp),%eax
      8e:	8d 74 24 48          	lea    0x48(%esp),%esi
      92:	89 44 24 0c          	mov    %eax,0xc(%esp)
      96:	89 74 24 08          	mov    %esi,0x8(%esp)
      9a:	c7 44 24 04 04 01 00 	movl   $0x104,0x4(%esp)
      a1:	00 
      a2:	89 3c 24             	mov    %edi,(%esp)
      a5:	e8 00 00 00 00       	call   aa <_NTQueryVolInfo+0xaa>
      aa:	83 ec 10             	sub    $0x10,%esp
      ad:	85 c0                	test   %eax,%eax
      af:	74 94                	je     45 <_NTQueryVolInfo+0x45>
            return FALSE;
        tmp0 = &tmp1[0];
      b1:	89 74 24 38          	mov    %esi,0x38(%esp)
    }
    if (strncmp(G.lastRootPath, tmp0, 2) != 0) {
      b5:	8d bb 80 0b 01 00    	lea    0x10b80(%ebx),%edi
      bb:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
      c2:	00 
      c3:	89 74 24 04          	mov    %esi,0x4(%esp)
      c7:	89 3c 24             	mov    %edi,(%esp)
      ca:	e8 00 00 00 00       	call   cf <_NTQueryVolInfo+0xcf>
      cf:	89 c2                	mov    %eax,%edx
        G.lastVolLocTim = !strncmp(strupr(tmp2), "VFAT", 4) ||
                          !strncmp(tmp2, "HPFS", 4) ||
                          !strncmp(tmp2, "FAT", 3);
    }

    return TRUE;
      d1:	b8 01 00 00 00       	mov    $0x1,%eax
    {
        if (!GetFullPathName(name, MAX_PATH, tmp1, &tmp0))
            return FALSE;
        tmp0 = &tmp1[0];
    }
    if (strncmp(G.lastRootPath, tmp0, 2) != 0) {
      d6:	85 d2                	test   %edx,%edx
      d8:	0f 84 69 ff ff ff    	je     47 <_NTQueryVolInfo+0x47>
        /* For speed, we skip repeated queries for the same device */
        strncpy(G.lastRootPath, tmp0, 2);   /* Build the root path name, */
      de:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
      e5:	00 
      e6:	89 74 24 04          	mov    %esi,0x4(%esp)
      ea:	89 3c 24             	mov    %edi,(%esp)
        G.lastRootPath[2] = '/';            /* e.g. "A:/"                */
        G.lastRootPath[3] = '\0';

        if (!GetVolumeInformation((LPCTSTR)G.lastRootPath,
      ed:	8d ac 24 4c 01 00 00 	lea    0x14c(%esp),%ebp
            return FALSE;
        tmp0 = &tmp1[0];
    }
    if (strncmp(G.lastRootPath, tmp0, 2) != 0) {
        /* For speed, we skip repeated queries for the same device */
        strncpy(G.lastRootPath, tmp0, 2);   /* Build the root path name, */
      f4:	e8 00 00 00 00       	call   f9 <_NTQueryVolInfo+0xf9>
        G.lastRootPath[2] = '/';            /* e.g. "A:/"                */
        G.lastRootPath[3] = '\0';

        if (!GetVolumeInformation((LPCTSTR)G.lastRootPath,
      f9:	8d 44 24 44          	lea    0x44(%esp),%eax
        tmp0 = &tmp1[0];
    }
    if (strncmp(G.lastRootPath, tmp0, 2) != 0) {
        /* For speed, we skip repeated queries for the same device */
        strncpy(G.lastRootPath, tmp0, 2);   /* Build the root path name, */
        G.lastRootPath[2] = '/';            /* e.g. "A:/"                */
      fd:	c6 83 82 0b 01 00 2f 	movb   $0x2f,0x10b82(%ebx)
        G.lastRootPath[3] = '\0';
     104:	c6 83 83 0b 01 00 00 	movb   $0x0,0x10b83(%ebx)

        if (!GetVolumeInformation((LPCTSTR)G.lastRootPath,
     10b:	89 44 24 14          	mov    %eax,0x14(%esp)
     10f:	8d 44 24 40          	lea    0x40(%esp),%eax
     113:	89 44 24 10          	mov    %eax,0x10(%esp)
     117:	8d 44 24 3c          	lea    0x3c(%esp),%eax
     11b:	89 44 24 0c          	mov    %eax,0xc(%esp)
     11f:	8d 44 24 48          	lea    0x48(%esp),%eax
     123:	c7 44 24 1c 04 01 00 	movl   $0x104,0x1c(%esp)
     12a:	00 
     12b:	89 6c 24 18          	mov    %ebp,0x18(%esp)
     12f:	c7 44 24 08 04 01 00 	movl   $0x104,0x8(%esp)
     136:	00 
     137:	89 44 24 04          	mov    %eax,0x4(%esp)
     13b:	89 3c 24             	mov    %edi,(%esp)
     13e:	e8 00 00 00 00       	call   143 <_NTQueryVolInfo+0x143>
     143:	83 ec 20             	sub    $0x20,%esp
     146:	85 c0                	test   %eax,%eax
     148:	75 36                	jne    180 <_NTQueryVolInfo+0x180>
              (LPTSTR)tmp1, (DWORD)MAX_PATH,
              &volSerNo, &maxCompLen, &fileSysFlags,
              (LPTSTR)tmp2, (DWORD)MAX_PATH)) {
            G.lastRootPath[0] = '\0';
     14a:	c6 83 80 0b 01 00 00 	movb   $0x0,0x10b80(%ebx)
                          !strncmp(tmp2, "FAT", 3);
    }

    return TRUE;

} /* end function NTQueryVolInfo() */
     151:	81 c4 5c 02 00 00    	add    $0x25c,%esp
     157:	5b                   	pop    %ebx
     158:	5e                   	pop    %esi
     159:	5f                   	pop    %edi
     15a:	5d                   	pop    %ebp
     15b:	c3                   	ret    
     15c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     160:	8b 0d 00 00 00 00    	mov    0x0,%ecx
     166:	25 ff 00 00 00       	and    $0xff,%eax
     16b:	8b 09                	mov    (%ecx),%ecx
     16d:	66 8b 04 41          	mov    (%ecx,%eax,2),%ax
     171:	25 03 01 00 00       	and    $0x103,%eax
     176:	e9 01 ff ff ff       	jmp    7c <_NTQueryVolInfo+0x7c>
     17b:	90                   	nop
     17c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            G.lastRootPath[0] = '\0';
            return FALSE;
        }

        /*  LFNs are available if the component length is > 12 */
        G.lastVolOldFAT = (maxCompLen <= 12);
     180:	31 c0                	xor    %eax,%eax
/*      G.lastVolOldFAT = !strncmp(strupr(tmp2), "FAT", 3);   old version */

        /* Volumes in (V)FAT and (OS/2) HPFS format store file timestamps in
         * local time!
         */
        G.lastVolLocTim = !strncmp(strupr(tmp2), "VFAT", 4) ||
     182:	bf 06 00 00 00       	mov    $0x6,%edi
            G.lastRootPath[0] = '\0';
            return FALSE;
        }

        /*  LFNs are available if the component length is > 12 */
        G.lastVolOldFAT = (maxCompLen <= 12);
     187:	83 7c 24 40 0c       	cmpl   $0xc,0x40(%esp)
     18c:	0f 96 c0             	setbe  %al
     18f:	89 83 84 0b 01 00    	mov    %eax,0x10b84(%ebx)
/*      G.lastVolOldFAT = !strncmp(strupr(tmp2), "FAT", 3);   old version */

        /* Volumes in (V)FAT and (OS/2) HPFS format store file timestamps in
         * local time!
         */
        G.lastVolLocTim = !strncmp(strupr(tmp2), "VFAT", 4) ||
     195:	89 2c 24             	mov    %ebp,(%esp)
     198:	e8 00 00 00 00       	call   19d <_NTQueryVolInfo+0x19d>
     19d:	b9 04 00 00 00       	mov    $0x4,%ecx
     1a2:	89 c6                	mov    %eax,%esi
                          !strncmp(tmp2, "HPFS", 4) ||
     1a4:	b8 01 00 00 00       	mov    $0x1,%eax
/*      G.lastVolOldFAT = !strncmp(strupr(tmp2), "FAT", 3);   old version */

        /* Volumes in (V)FAT and (OS/2) HPFS format store file timestamps in
         * local time!
         */
        G.lastVolLocTim = !strncmp(strupr(tmp2), "VFAT", 4) ||
     1a9:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
     1ab:	0f 97 c2             	seta   %dl
     1ae:	0f 92 c1             	setb   %cl
                          !strncmp(tmp2, "HPFS", 4) ||
     1b1:	38 ca                	cmp    %cl,%dl
     1b3:	74 26                	je     1db <_NTQueryVolInfo+0x1db>
     1b5:	bf 0b 00 00 00       	mov    $0xb,%edi
     1ba:	b9 04 00 00 00       	mov    $0x4,%ecx
     1bf:	89 ee                	mov    %ebp,%esi
/*      G.lastVolOldFAT = !strncmp(strupr(tmp2), "FAT", 3);   old version */

        /* Volumes in (V)FAT and (OS/2) HPFS format store file timestamps in
         * local time!
         */
        G.lastVolLocTim = !strncmp(strupr(tmp2), "VFAT", 4) ||
     1c1:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
     1c3:	74 16                	je     1db <_NTQueryVolInfo+0x1db>
                          !strncmp(tmp2, "HPFS", 4) ||
                          !strncmp(tmp2, "FAT", 3);
     1c5:	bf 10 00 00 00       	mov    $0x10,%edi
     1ca:	b9 03 00 00 00       	mov    $0x3,%ecx
     1cf:	89 ee                	mov    %ebp,%esi

        /* Volumes in (V)FAT and (OS/2) HPFS format store file timestamps in
         * local time!
         */
        G.lastVolLocTim = !strncmp(strupr(tmp2), "VFAT", 4) ||
                          !strncmp(tmp2, "HPFS", 4) ||
     1d1:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
     1d3:	0f 94 c0             	sete   %al
     1d6:	25 ff 00 00 00       	and    $0xff,%eax
/*      G.lastVolOldFAT = !strncmp(strupr(tmp2), "FAT", 3);   old version */

        /* Volumes in (V)FAT and (OS/2) HPFS format store file timestamps in
         * local time!
         */
        G.lastVolLocTim = !strncmp(strupr(tmp2), "VFAT", 4) ||
     1db:	89 83 88 0b 01 00    	mov    %eax,0x10b88(%ebx)
                          !strncmp(tmp2, "HPFS", 4) ||
                          !strncmp(tmp2, "FAT", 3);
    }

    return TRUE;
     1e1:	b8 01 00 00 00       	mov    $0x1,%eax
     1e6:	e9 5c fe ff ff       	jmp    47 <_NTQueryVolInfo+0x47>
     1eb:	90                   	nop
     1ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
         *            and use mapped drive for volume info query.
         */
        return FALSE;
    }
    if (isalpha((uch)name[0]) && (name[1] == ':'))
        tmp0 = (char *)name;
     1f0:	89 7c 24 38          	mov    %edi,0x38(%esp)
     1f4:	89 fe                	mov    %edi,%esi
     1f6:	e9 ba fe ff ff       	jmp    b5 <_NTQueryVolInfo+0xb5>
     1fb:	90                   	nop
     1fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000200 <_SetSD>:
    __GDEF
    char *path;
    unsigned fperms;
    uch *eb_ptr;
    unsigned eb_len;
{
     200:	55                   	push   %ebp
     201:	57                   	push   %edi
     202:	56                   	push   %esi
     203:	53                   	push   %ebx
     204:	81 ec 5c 01 00 00    	sub    $0x15c,%esp
     20a:	89 c6                	mov    %eax,%esi
     20c:	89 d7                	mov    %edx,%edi
     20e:	89 cd                	mov    %ecx,%ebp
    ulg ntsd_ucSize;
    VOLUMECAPS VolumeCaps;
    uch *security_data;
    int error;

    ntsd_ucSize = makelong(eb_ptr + (EB_HEADSIZE+EB_UCSIZE_P));
     210:	8b 84 24 70 01 00 00 	mov    0x170(%esp),%eax
     217:	83 c0 04             	add    $0x4,%eax
     21a:	89 04 24             	mov    %eax,(%esp)
     21d:	e8 00 00 00 00       	call   222 <_SetSD+0x22>
     222:	89 c3                	mov    %eax,%ebx
    if (ntsd_ucSize > 0L && eb_len <= (EB_NTSD_L_LEN + EB_CMPRHEADLEN))
     224:	85 c0                	test   %eax,%eax
     226:	74 1a                	je     242 <_SetSD+0x42>
        return IZ_EF_TRUNC;               /* no compressed data! */
     228:	b8 4f 00 00 00       	mov    $0x4f,%eax
    VOLUMECAPS VolumeCaps;
    uch *security_data;
    int error;

    ntsd_ucSize = makelong(eb_ptr + (EB_HEADSIZE+EB_UCSIZE_P));
    if (ntsd_ucSize > 0L && eb_len <= (EB_NTSD_L_LEN + EB_CMPRHEADLEN))
     22d:	83 bc 24 74 01 00 00 	cmpl   $0xb,0x174(%esp)
     234:	0b 
     235:	77 0b                	ja     242 <_SetSD+0x42>
        }
    }

    free(security_data);
    return error;
}
     237:	81 c4 5c 01 00 00    	add    $0x15c,%esp
     23d:	5b                   	pop    %ebx
     23e:	5e                   	pop    %esi
     23f:	5f                   	pop    %edi
     240:	5d                   	pop    %ebp
     241:	c3                   	ret    
    if (ntsd_ucSize > 0L && eb_len <= (EB_NTSD_L_LEN + EB_CMPRHEADLEN))
        return IZ_EF_TRUNC;               /* no compressed data! */

    /* provide useful input */
    VolumeCaps.dwFileAttributes = fperms;
    VolumeCaps.bUsePrivileges = (uO.X_flag > 1);
     242:	31 c0                	xor    %eax,%eax
    ntsd_ucSize = makelong(eb_ptr + (EB_HEADSIZE+EB_UCSIZE_P));
    if (ntsd_ucSize > 0L && eb_len <= (EB_NTSD_L_LEN + EB_CMPRHEADLEN))
        return IZ_EF_TRUNC;               /* no compressed data! */

    /* provide useful input */
    VolumeCaps.dwFileAttributes = fperms;
     244:	89 6c 24 44          	mov    %ebp,0x44(%esp)
    VolumeCaps.bUsePrivileges = (uO.X_flag > 1);
     248:	83 7e 5c 01          	cmpl   $0x1,0x5c(%esi)
     24c:	0f 9f c0             	setg   %al
     24f:	89 44 24 34          	mov    %eax,0x34(%esp)

    /* check target volume capabilities - just fall through
     * and try if fail */
    if (GetVolumeCaps(G.rootpath, path, &VolumeCaps) &&
     253:	8d 6c 24 30          	lea    0x30(%esp),%ebp
     257:	8b 86 8c 0b 01 00    	mov    0x10b8c(%esi),%eax
     25d:	89 6c 24 08          	mov    %ebp,0x8(%esp)
     261:	89 7c 24 04          	mov    %edi,0x4(%esp)
     265:	89 04 24             	mov    %eax,(%esp)
     268:	e8 00 00 00 00       	call   26d <_SetSD+0x6d>
     26d:	85 c0                	test   %eax,%eax
     26f:	74 09                	je     27a <_SetSD+0x7a>
        !(VolumeCaps.dwFileSystemFlags & FS_PERSISTENT_ACLS))
        return PK_OK;
     271:	31 c0                	xor    %eax,%eax
    VolumeCaps.dwFileAttributes = fperms;
    VolumeCaps.bUsePrivileges = (uO.X_flag > 1);

    /* check target volume capabilities - just fall through
     * and try if fail */
    if (GetVolumeCaps(G.rootpath, path, &VolumeCaps) &&
     273:	f6 44 24 38 08       	testb  $0x8,0x38(%esp)
     278:	74 bd                	je     237 <_SetSD+0x37>
        !(VolumeCaps.dwFileSystemFlags & FS_PERSISTENT_ACLS))
        return PK_OK;

    /* allocate storage for uncompressed data */
    security_data = (uch *)malloc((extent)ntsd_ucSize);
     27a:	89 1c 24             	mov    %ebx,(%esp)
     27d:	e8 00 00 00 00       	call   282 <_SetSD+0x82>
     282:	89 c2                	mov    %eax,%edx
    if (security_data == (uch *)NULL)
        return PK_MEM4;
     284:	b8 07 00 00 00       	mov    $0x7,%eax
        !(VolumeCaps.dwFileSystemFlags & FS_PERSISTENT_ACLS))
        return PK_OK;

    /* allocate storage for uncompressed data */
    security_data = (uch *)malloc((extent)ntsd_ucSize);
    if (security_data == (uch *)NULL)
     289:	85 d2                	test   %edx,%edx
     28b:	74 aa                	je     237 <_SetSD+0x37>
        return PK_MEM4;

    error = memextract(__G__ security_data, ntsd_ucSize,
      (eb_ptr + (EB_HEADSIZE+EB_NTSD_L_LEN)), (ulg)(eb_len - EB_NTSD_L_LEN));
     28d:	8b 84 24 74 01 00 00 	mov    0x174(%esp),%eax
    /* allocate storage for uncompressed data */
    security_data = (uch *)malloc((extent)ntsd_ucSize);
    if (security_data == (uch *)NULL)
        return PK_MEM4;

    error = memextract(__G__ security_data, ntsd_ucSize,
     294:	89 54 24 04          	mov    %edx,0x4(%esp)
      (eb_ptr + (EB_HEADSIZE+EB_NTSD_L_LEN)), (ulg)(eb_len - EB_NTSD_L_LEN));
     298:	83 e8 05             	sub    $0x5,%eax
    /* allocate storage for uncompressed data */
    security_data = (uch *)malloc((extent)ntsd_ucSize);
    if (security_data == (uch *)NULL)
        return PK_MEM4;

    error = memextract(__G__ security_data, ntsd_ucSize,
     29b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     29f:	89 44 24 10          	mov    %eax,0x10(%esp)
     2a3:	8b 84 24 70 01 00 00 	mov    0x170(%esp),%eax
     2aa:	83 c0 09             	add    $0x9,%eax
     2ad:	89 34 24             	mov    %esi,(%esp)
     2b0:	89 44 24 0c          	mov    %eax,0xc(%esp)
     2b4:	89 54 24 2c          	mov    %edx,0x2c(%esp)
     2b8:	e8 00 00 00 00       	call   2bd <_SetSD+0xbd>
      (eb_ptr + (EB_HEADSIZE+EB_NTSD_L_LEN)), (ulg)(eb_len - EB_NTSD_L_LEN));

    if (error == PK_OK) {
     2bd:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    /* allocate storage for uncompressed data */
    security_data = (uch *)malloc((extent)ntsd_ucSize);
    if (security_data == (uch *)NULL)
        return PK_MEM4;

    error = memextract(__G__ security_data, ntsd_ucSize,
     2c1:	89 44 24 28          	mov    %eax,0x28(%esp)
      (eb_ptr + (EB_HEADSIZE+EB_NTSD_L_LEN)), (ulg)(eb_len - EB_NTSD_L_LEN));

    if (error == PK_OK) {
     2c5:	85 c0                	test   %eax,%eax
     2c7:	74 17                	je     2e0 <_SetSD+0xe0>
                Info(slide, 0, ((char *)slide, " (%ld bytes security)",
                  ntsd_ucSize));
        }
    }

    free(security_data);
     2c9:	89 14 24             	mov    %edx,(%esp)
     2cc:	e8 00 00 00 00       	call   2d1 <_SetSD+0xd1>
    return error;
     2d1:	8b 44 24 28          	mov    0x28(%esp),%eax
     2d5:	e9 5d ff ff ff       	jmp    237 <_SetSD+0x37>
     2da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

    error = memextract(__G__ security_data, ntsd_ucSize,
      (eb_ptr + (EB_HEADSIZE+EB_NTSD_L_LEN)), (ulg)(eb_len - EB_NTSD_L_LEN));

    if (error == PK_OK) {
        if (SecuritySet(path, &VolumeCaps, security_data)) {
     2e0:	89 54 24 08          	mov    %edx,0x8(%esp)
     2e4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     2e8:	89 3c 24             	mov    %edi,(%esp)
     2eb:	e8 00 00 00 00       	call   2f0 <_SetSD+0xf0>
     2f0:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     2f4:	85 c0                	test   %eax,%eax
     2f6:	74 d1                	je     2c9 <_SetSD+0xc9>
            error = PK_COOL;
            if (!uO.tflag && QCOND2)
     2f8:	8b 4e 44             	mov    0x44(%esi),%ecx
     2fb:	85 c9                	test   %ecx,%ecx
     2fd:	75 ca                	jne    2c9 <_SetSD+0xc9>
     2ff:	8b 46 38             	mov    0x38(%esi),%eax
     302:	85 c0                	test   %eax,%eax
     304:	75 c3                	jne    2c9 <_SetSD+0xc9>
                Info(slide, 0, ((char *)slide, " (%ld bytes security)",
     306:	8d ae dc 08 00 00    	lea    0x8dc(%esi),%ebp
     30c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     310:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
     317:	00 
     318:	89 2c 24             	mov    %ebp,(%esp)
     31b:	8b be 44 0b 01 00    	mov    0x10b44(%esi),%edi
     321:	e8 00 00 00 00       	call   326 <_SetSD+0x126>
     326:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     32d:	00 
     32e:	89 44 24 08          	mov    %eax,0x8(%esp)
     332:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     336:	89 34 24             	mov    %esi,(%esp)
     339:	ff d7                	call   *%edi
     33b:	83 ec 10             	sub    $0x10,%esp
     33e:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     342:	eb 85                	jmp    2c9 <_SetSD+0xc9>
     344:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     34a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000350 <_map2fat>:
/* Function map2fat() */        /* Not quite identical to OS/2 version */
/**********************/

static void map2fat(pathcomp, pEndFAT)
    char *pathcomp, **pEndFAT;
{
     350:	55                   	push   %ebp
     351:	57                   	push   %edi
     352:	56                   	push   %esi
     353:	53                   	push   %ebx
     354:	83 ec 2c             	sub    $0x2c,%esp
     357:	89 d7                	mov    %edx,%edi
    char *ppc = pathcomp;       /* variable pointer to pathcomp */
    char *pEnd = *pEndFAT;      /* variable pointer to buildpathFAT */
     359:	8b 32                	mov    (%edx),%esi
     35b:	8a 10                	mov    (%eax),%dl
     35d:	89 74 24 1c          	mov    %esi,0x1c(%esp)
     361:	89 f3                	mov    %esi,%ebx
    char *pBegin = *pEndFAT;    /* constant pointer to start of this comp. */
    char *last_dot = NULL;      /* last dot not converted to underscore */
     363:	31 ed                	xor    %ebp,%ebp

    /* Only need check those characters which are legal in NTFS but not
     * in FAT:  to get here, must already have passed through mapname.
     * Also must truncate path component to ensure 8.3 compliance.
     */
    while ((workch = (uch)*ppc++) != 0) {
     365:	8d 70 01             	lea    0x1(%eax),%esi
     368:	84 d2                	test   %dl,%dl
     36a:	74 31                	je     39d <_map2fat+0x4d>
     36c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        switch (workch) {
     370:	8d 4a d5             	lea    -0x2b(%edx),%ecx
     373:	80 f9 32             	cmp    $0x32,%cl
     376:	77 7a                	ja     3f2 <_map2fat+0xa2>
     378:	81 e1 ff 00 00 00    	and    $0xff,%ecx
     37e:	ff 24 8d 2c 00 00 00 	jmp    *0x2c(,%ecx,4)
            case '=':
                *pEnd++ = '_';      /* convert brackets to underscores */
                break;

            case '.':
                if (pEnd == *pEndFAT) {   /* nothing appended yet... */
     385:	8b 0f                	mov    (%edi),%ecx
     387:	39 d9                	cmp    %ebx,%ecx
     389:	74 75                	je     400 <_map2fat+0xb0>
                    } else {              /* FAT doesn't allow null filename */
                        *pEnd++ = '_';    /*  bodies, so map .exrc -> _exrc */
                    }                     /*  (_.exr would keep max 3 chars) */
                } else {                  /* found dot within path component */
                    last_dot = pEnd;      /*  point at last dot so far... */
                    *pEnd++ = '_';        /*  convert to underscore for now */
     38b:	c6 03 5f             	movb   $0x5f,(%ebx)
     38e:	89 dd                	mov    %ebx,%ebp
     390:	8a 50 01             	mov    0x1(%eax),%dl
     393:	43                   	inc    %ebx
     394:	89 f0                	mov    %esi,%eax

    /* Only need check those characters which are legal in NTFS but not
     * in FAT:  to get here, must already have passed through mapname.
     * Also must truncate path component to ensure 8.3 compliance.
     */
    while ((workch = (uch)*ppc++) != 0) {
     396:	8d 70 01             	lea    0x1(%eax),%esi
     399:	84 d2                	test   %dl,%dl
     39b:	75 d3                	jne    370 <_map2fat+0x20>
     39d:	89 e8                	mov    %ebp,%eax
     39f:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
     3a3:	29 c8                	sub    %ecx,%eax
                *pEnd++ = (char)workch;

        } /* end switch */
    } /* end while loop */

    *pEnd = '\0';                 /* terminate buildpathFAT */
     3a5:	c6 03 00             	movb   $0x0,(%ebx)
     * if there are no dots already, the name either gets truncated
     * at 8 characters or the last underscore is converted to a dot
     * (only if more characters are saved that way).  In no case is
     * a dot inserted between existing characters.
     */
    if (last_dot == NULL) {       /* no dots:  check for underscores... */
     3a8:	85 ed                	test   %ebp,%ebp
     3aa:	0f 84 c8 00 00 00    	je     478 <_map2fat+0x128>
        } else
            *pEndFAT = pEnd;      /* whole thing fits into 8 chars or less */
    }

    if (last_dot != NULL) {       /* one dot is OK: */
        *last_dot = '.';          /* put it back in */
     3b0:	c6 45 00 2e          	movb   $0x2e,0x0(%ebp)

        if ((last_dot - pBegin) > 8) {
     3b4:	83 f8 08             	cmp    $0x8,%eax
     3b7:	7f 67                	jg     420 <_map2fat+0xd0>
            q = last_dot = pBegin + 8;
            for (i = 0;  (i < 4) && *p;  ++i)  /* too many chars in basename: */
                *q++ = *p++;                   /*  shift .ext left and trun- */
            *q = '\0';                         /*  cate/terminate it */
            *pEndFAT = q;
        } else if ((pEnd - last_dot) > 4) {    /* too many chars in extension */
     3b9:	89 da                	mov    %ebx,%edx
     3bb:	29 ea                	sub    %ebp,%edx
     3bd:	83 fa 04             	cmp    $0x4,%edx
     3c0:	0f 8e 8c 00 00 00    	jle    452 <_map2fat+0x102>
            *pEndFAT = last_dot + 4;
     3c6:	8d 55 04             	lea    0x4(%ebp),%edx
     3c9:	89 e9                	mov    %ebp,%ecx
     3cb:	89 17                	mov    %edx,(%edi)
            **pEndFAT = '\0';
     3cd:	c6 45 04 00          	movb   $0x0,0x4(%ebp)
        } else
            *pEndFAT = pEnd;   /* filename is fine; point at terminating zero */

        if ((last_dot - pBegin) > 0 && last_dot[-1] == ' ')
     3d1:	85 c0                	test   %eax,%eax
     3d3:	7e 0a                	jle    3df <_map2fat+0x8f>
     3d5:	80 79 ff 20          	cmpb   $0x20,-0x1(%ecx)
     3d9:	75 04                	jne    3df <_map2fat+0x8f>
            last_dot[-1] = '_';                /* NO blank in front of '.'! */
     3db:	c6 41 ff 5f          	movb   $0x5f,-0x1(%ecx)
    }
} /* end function map2fat() */
     3df:	83 c4 2c             	add    $0x2c,%esp
     3e2:	5b                   	pop    %ebx
     3e3:	5e                   	pop    %esi
     3e4:	5f                   	pop    %edi
     3e5:	5d                   	pop    %ebp
     3e6:	c3                   	ret    
            case ']':
            case '+':
            case ',':
            case ';':
            case '=':
                *pEnd++ = '_';      /* convert brackets to underscores */
     3e7:	c6 03 5f             	movb   $0x5f,(%ebx)
     3ea:	43                   	inc    %ebx
     3eb:	8a 50 01             	mov    0x1(%eax),%dl
                    } else {              /* FAT doesn't allow null filename */
                        *pEnd++ = '_';    /*  bodies, so map .exrc -> _exrc */
                    }                     /*  (_.exr would keep max 3 chars) */
                } else {                  /* found dot within path component */
                    last_dot = pEnd;      /*  point at last dot so far... */
                    *pEnd++ = '_';        /*  convert to underscore for now */
     3ee:	89 f0                	mov    %esi,%eax
     3f0:	eb a4                	jmp    396 <_map2fat+0x46>
                }
                break;

            default:
                *pEnd++ = (char)workch;
     3f2:	88 13                	mov    %dl,(%ebx)
     3f4:	43                   	inc    %ebx
     3f5:	8a 50 01             	mov    0x1(%eax),%dl
                    } else {              /* FAT doesn't allow null filename */
                        *pEnd++ = '_';    /*  bodies, so map .exrc -> _exrc */
                    }                     /*  (_.exr would keep max 3 chars) */
                } else {                  /* found dot within path component */
                    last_dot = pEnd;      /*  point at last dot so far... */
                    *pEnd++ = '_';        /*  convert to underscore for now */
     3f8:	89 f0                	mov    %esi,%eax
     3fa:	eb 9a                	jmp    396 <_map2fat+0x46>
     3fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                *pEnd++ = '_';      /* convert brackets to underscores */
                break;

            case '.':
                if (pEnd == *pEndFAT) {   /* nothing appended yet... */
                    if (*ppc == '\0')     /* don't bother appending a */
     400:	8a 50 01             	mov    0x1(%eax),%dl
     403:	84 d2                	test   %dl,%dl
     405:	74 8d                	je     394 <_map2fat+0x44>
                        break;            /*  "./" component to the path */
                    else if (*ppc == '.' && ppc[1] == '\0') {   /* "../" */
     407:	80 fa 2e             	cmp    $0x2e,%dl
     40a:	74 4f                	je     45b <_map2fat+0x10b>
                        *pEnd++ = '.';    /*  add first dot, */
                        *pEnd++ = '.';    /*  add second dot, and */
                        ++ppc;            /*  skip over to pathcomp's end */
                    } else {              /* FAT doesn't allow null filename */
                        *pEnd++ = '_';    /*  bodies, so map .exrc -> _exrc */
     40c:	c6 01 5f             	movb   $0x5f,(%ecx)
     40f:	8d 59 01             	lea    0x1(%ecx),%ebx
     412:	8a 50 01             	mov    0x1(%eax),%dl
                    }                     /*  (_.exr would keep max 3 chars) */
                } else {                  /* found dot within path component */
                    last_dot = pEnd;      /*  point at last dot so far... */
                    *pEnd++ = '_';        /*  convert to underscore for now */
     415:	89 f0                	mov    %esi,%eax
     417:	e9 7a ff ff ff       	jmp    396 <_map2fat+0x46>
     41c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if ((last_dot - pBegin) > 8) {
            char *p, *q;
            int i;

            p = last_dot;
            q = last_dot = pBegin + 8;
     420:	8b 44 24 1c          	mov    0x1c(%esp),%eax
            for (i = 0;  (i < 4) && *p;  ++i)  /* too many chars in basename: */
     424:	b2 2e                	mov    $0x2e,%dl
        if ((last_dot - pBegin) > 8) {
            char *p, *q;
            int i;

            p = last_dot;
            q = last_dot = pBegin + 8;
     426:	8d 48 08             	lea    0x8(%eax),%ecx
     429:	8d 58 0c             	lea    0xc(%eax),%ebx
     42c:	89 c8                	mov    %ecx,%eax
            for (i = 0;  (i < 4) && *p;  ++i)  /* too many chars in basename: */
                *q++ = *p++;                   /*  shift .ext left and trun- */
     42e:	40                   	inc    %eax
     42f:	88 50 ff             	mov    %dl,-0x1(%eax)
            char *p, *q;
            int i;

            p = last_dot;
            q = last_dot = pBegin + 8;
            for (i = 0;  (i < 4) && *p;  ++i)  /* too many chars in basename: */
     432:	39 d8                	cmp    %ebx,%eax
     434:	74 0a                	je     440 <_map2fat+0xf0>
                *q++ = *p++;                   /*  shift .ext left and trun- */
     436:	45                   	inc    %ebp
            char *p, *q;
            int i;

            p = last_dot;
            q = last_dot = pBegin + 8;
            for (i = 0;  (i < 4) && *p;  ++i)  /* too many chars in basename: */
     437:	8a 55 00             	mov    0x0(%ebp),%dl
     43a:	84 d2                	test   %dl,%dl
     43c:	75 f0                	jne    42e <_map2fat+0xde>
     43e:	89 c3                	mov    %eax,%ebx
     440:	89 c8                	mov    %ecx,%eax
     442:	8b 54 24 1c          	mov    0x1c(%esp),%edx
                *q++ = *p++;                   /*  shift .ext left and trun- */
            *q = '\0';                         /*  cate/terminate it */
     446:	c6 03 00             	movb   $0x0,(%ebx)
     449:	29 d0                	sub    %edx,%eax
            *pEndFAT = q;
     44b:	89 1f                	mov    %ebx,(%edi)
     44d:	e9 7f ff ff ff       	jmp    3d1 <_map2fat+0x81>
        } else if ((pEnd - last_dot) > 4) {    /* too many chars in extension */
            *pEndFAT = last_dot + 4;
            **pEndFAT = '\0';
        } else
            *pEndFAT = pEnd;   /* filename is fine; point at terminating zero */
     452:	89 1f                	mov    %ebx,(%edi)
     454:	89 e9                	mov    %ebp,%ecx
     456:	e9 76 ff ff ff       	jmp    3d1 <_map2fat+0x81>

            case '.':
                if (pEnd == *pEndFAT) {   /* nothing appended yet... */
                    if (*ppc == '\0')     /* don't bother appending a */
                        break;            /*  "./" component to the path */
                    else if (*ppc == '.' && ppc[1] == '\0') {   /* "../" */
     45b:	80 78 02 00          	cmpb   $0x0,0x2(%eax)
     45f:	75 ab                	jne    40c <_map2fat+0xbc>
                        *pEnd++ = '.';    /*  add first dot, */
     461:	c6 03 2e             	movb   $0x2e,(%ebx)
                        *pEnd++ = '.';    /*  add second dot, and */
                        ++ppc;            /*  skip over to pathcomp's end */
     464:	8d 70 02             	lea    0x2(%eax),%esi
                if (pEnd == *pEndFAT) {   /* nothing appended yet... */
                    if (*ppc == '\0')     /* don't bother appending a */
                        break;            /*  "./" component to the path */
                    else if (*ppc == '.' && ppc[1] == '\0') {   /* "../" */
                        *pEnd++ = '.';    /*  add first dot, */
                        *pEnd++ = '.';    /*  add second dot, and */
     467:	c6 41 01 2e          	movb   $0x2e,0x1(%ecx)
     46b:	83 c3 02             	add    $0x2,%ebx
     46e:	8a 50 02             	mov    0x2(%eax),%dl
                    } else {              /* FAT doesn't allow null filename */
                        *pEnd++ = '_';    /*  bodies, so map .exrc -> _exrc */
                    }                     /*  (_.exr would keep max 3 chars) */
                } else {                  /* found dot within path component */
                    last_dot = pEnd;      /*  point at last dot so far... */
                    *pEnd++ = '_';        /*  convert to underscore for now */
     471:	89 f0                	mov    %esi,%eax
     473:	e9 1e ff ff ff       	jmp    396 <_map2fat+0x46>
     * at 8 characters or the last underscore is converted to a dot
     * (only if more characters are saved that way).  In no case is
     * a dot inserted between existing characters.
     */
    if (last_dot == NULL) {       /* no dots:  check for underscores... */
        char *plu = MBSRCHR(pBegin, '_');   /* pointer to last underscore */
     478:	8b 74 24 1c          	mov    0x1c(%esp),%esi
     47c:	c7 44 24 04 5f 00 00 	movl   $0x5f,0x4(%esp)
     483:	00 
     484:	89 34 24             	mov    %esi,(%esp)
     487:	e8 00 00 00 00       	call   48c <_map2fat+0x13c>
     48c:	89 c5                	mov    %eax,%ebp

        if ((plu != NULL) &&      /* found underscore: convert to dot? */
     48e:	85 c0                	test   %eax,%eax
     490:	74 2a                	je     4bc <_map2fat+0x16c>
            (MIN(plu - pBegin, 8) + MIN(pEnd - plu - 1, 3) > 8)) {
     492:	29 f0                	sub    %esi,%eax
     494:	89 d9                	mov    %ebx,%ecx
     496:	be 08 00 00 00       	mov    $0x8,%esi
     49b:	83 f8 08             	cmp    $0x8,%eax
     49e:	0f 4e f0             	cmovle %eax,%esi
     4a1:	29 e9                	sub    %ebp,%ecx
     4a3:	83 f9 03             	cmp    $0x3,%ecx
     4a6:	8d 51 ff             	lea    -0x1(%ecx),%edx
     4a9:	b9 03 00 00 00       	mov    $0x3,%ecx
     4ae:	0f 4f d1             	cmovg  %ecx,%edx
     4b1:	01 d6                	add    %edx,%esi
     * a dot inserted between existing characters.
     */
    if (last_dot == NULL) {       /* no dots:  check for underscores... */
        char *plu = MBSRCHR(pBegin, '_');   /* pointer to last underscore */

        if ((plu != NULL) &&      /* found underscore: convert to dot? */
     4b3:	83 fe 08             	cmp    $0x8,%esi
     4b6:	0f 8f f4 fe ff ff    	jg     3b0 <_map2fat+0x60>
            (MIN(plu - pBegin, 8) + MIN(pEnd - plu - 1, 3) > 8)) {
            last_dot = plu;       /* be lazy:  drop through to next if-blk */
        } else if ((pEnd - *pEndFAT) > 8) {
     4bc:	8b 07                	mov    (%edi),%eax
     4be:	89 da                	mov    %ebx,%edx
     4c0:	29 c2                	sub    %eax,%edx
     4c2:	83 fa 08             	cmp    $0x8,%edx
     4c5:	7e 0e                	jle    4d5 <_map2fat+0x185>
            /* no underscore; or converting underscore to dot would save less
               chars than leaving everything in the basename */
            *pEndFAT += 8;        /* truncate at 8 chars */
     4c7:	8d 50 08             	lea    0x8(%eax),%edx
     4ca:	89 17                	mov    %edx,(%edi)
            **pEndFAT = '\0';
     4cc:	c6 40 08 00          	movb   $0x0,0x8(%eax)
     4d0:	e9 0a ff ff ff       	jmp    3df <_map2fat+0x8f>
        } else
            *pEndFAT = pEnd;      /* whole thing fits into 8 chars or less */
     4d5:	89 1f                	mov    %ebx,(%edi)
     4d7:	e9 03 ff ff ff       	jmp    3df <_map2fat+0x8f>
     4dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000004e0 <_Opendir>:
/* Function Opendir() */        /* Difference: no special handling for      */
/**********************/        /*             hidden or system files.      */

static zDIR *Opendir(n)
    const char *n;          /* directory to open */
{
     4e0:	55                   	push   %ebp
     4e1:	57                   	push   %edi
     4e2:	56                   	push   %esi
     4e3:	53                   	push   %ebx
     4e4:	81 ec 5c 01 00 00    	sub    $0x15c,%esp
     4ea:	89 c5                	mov    %eax,%ebp
    zDIR *d;                /* malloc'd return value */
    char *p;                /* malloc'd temporary string */
    WIN32_FIND_DATA fd;
    extent len = strlen(n);
     4ec:	89 04 24             	mov    %eax,(%esp)
     4ef:	e8 00 00 00 00       	call   4f4 <_Opendir+0x14>

    /* Start searching for files in directory n */

    if ((d = (zDIR *)malloc(sizeof(zDIR))) == NULL ||
     4f4:	c7 04 24 2c 01 00 00 	movl   $0x12c,(%esp)
    const char *n;          /* directory to open */
{
    zDIR *d;                /* malloc'd return value */
    char *p;                /* malloc'd temporary string */
    WIN32_FIND_DATA fd;
    extent len = strlen(n);
     4fb:	89 c7                	mov    %eax,%edi

    /* Start searching for files in directory n */

    if ((d = (zDIR *)malloc(sizeof(zDIR))) == NULL ||
     4fd:	e8 00 00 00 00       	call   502 <_Opendir+0x22>
     502:	89 c3                	mov    %eax,%ebx
     504:	85 c0                	test   %eax,%eax
     506:	0f 84 ac 00 00 00    	je     5b8 <_Opendir+0xd8>
        (p = malloc(strlen(n) + 5)) == NULL)
     50c:	8d 47 05             	lea    0x5(%edi),%eax
    WIN32_FIND_DATA fd;
    extent len = strlen(n);

    /* Start searching for files in directory n */

    if ((d = (zDIR *)malloc(sizeof(zDIR))) == NULL ||
     50f:	89 04 24             	mov    %eax,(%esp)
     512:	e8 00 00 00 00       	call   517 <_Opendir+0x37>
     517:	89 c6                	mov    %eax,%esi
     519:	85 c0                	test   %eax,%eax
     51b:	0f 84 8f 00 00 00    	je     5b0 <_Opendir+0xd0>
    {
        if (d != (zDIR *)NULL)
            free((void *)d);
        return (zDIR *)NULL;
    }
    INTERN_TO_ISO(n, p);
     521:	39 c5                	cmp    %eax,%ebp
     523:	74 13                	je     538 <_Opendir+0x58>
     525:	8d 47 01             	lea    0x1(%edi),%eax
     528:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     52c:	89 44 24 08          	mov    %eax,0x8(%esp)
     530:	89 34 24             	mov    %esi,(%esp)
     533:	e8 00 00 00 00       	call   538 <_Opendir+0x58>
     538:	89 f2                	mov    %esi,%edx
    if (len > 0) {
     53a:	85 ff                	test   %edi,%edi
     53c:	75 56                	jne    594 <_Opendir+0xb4>
        else if (p[len-1] == '/' || p[len-1] == '\\')
            --len;              /* foo/ => foo */
    }
    strcpy(p+len, "/*");

    if (INVALID_HANDLE_VALUE == (d->d_hFindFile = FindFirstFile(p, &fd))) {
     53e:	8d 44 24 10          	lea    0x10(%esp),%eax
        if (p[len-1] == ':')
            p[len++] = '.';     /* x: => x:. */
        else if (p[len-1] == '/' || p[len-1] == '\\')
            --len;              /* foo/ => foo */
    }
    strcpy(p+len, "/*");
     542:	66 c7 02 2f 2a       	movw   $0x2a2f,(%edx)
     547:	c6 42 02 00          	movb   $0x0,0x2(%edx)

    if (INVALID_HANDLE_VALUE == (d->d_hFindFile = FindFirstFile(p, &fd))) {
     54b:	89 44 24 04          	mov    %eax,0x4(%esp)
     54f:	89 34 24             	mov    %esi,(%esp)
     552:	e8 00 00 00 00       	call   557 <_Opendir+0x77>
     557:	89 83 28 01 00 00    	mov    %eax,0x128(%ebx)
     55d:	40                   	inc    %eax
     55e:	52                   	push   %edx
     55f:	52                   	push   %edx
     560:	74 70                	je     5d2 <_Opendir+0xf2>
        free((zvoid *)d);
        free((zvoid *)p);
        return NULL;
    }
    strcpy(d->d_name, fd.cFileName);
     562:	8d 44 24 3c          	lea    0x3c(%esp),%eax
     566:	89 44 24 04          	mov    %eax,0x4(%esp)
     56a:	8d 43 20             	lea    0x20(%ebx),%eax
     56d:	89 04 24             	mov    %eax,(%esp)
     570:	e8 00 00 00 00       	call   575 <_Opendir+0x95>

    free((zvoid *)p);
     575:	89 34 24             	mov    %esi,(%esp)
     578:	e8 00 00 00 00       	call   57d <_Opendir+0x9d>
    d->d_first = 1;
     57d:	c7 83 24 01 00 00 01 	movl   $0x1,0x124(%ebx)
     584:	00 00 00 
    return d;
     587:	89 d8                	mov    %ebx,%eax

} /* end of function Opendir() */
     589:	81 c4 5c 01 00 00    	add    $0x15c,%esp
     58f:	5b                   	pop    %ebx
     590:	5e                   	pop    %esi
     591:	5f                   	pop    %edi
     592:	5d                   	pop    %ebp
     593:	c3                   	ret    
            free((void *)d);
        return (zDIR *)NULL;
    }
    INTERN_TO_ISO(n, p);
    if (len > 0) {
        if (p[len-1] == ':')
     594:	8d 54 3e ff          	lea    -0x1(%esi,%edi,1),%edx
     598:	8a 02                	mov    (%edx),%al
     59a:	3c 3a                	cmp    $0x3a,%al
     59c:	74 27                	je     5c5 <_Opendir+0xe5>
            p[len++] = '.';     /* x: => x:. */
        else if (p[len-1] == '/' || p[len-1] == '\\')
     59e:	3c 5c                	cmp    $0x5c,%al
     5a0:	74 9c                	je     53e <_Opendir+0x5e>
     5a2:	3c 2f                	cmp    $0x2f,%al
     5a4:	0f 94 c0             	sete   %al
     5a7:	01 f7                	add    %esi,%edi
     5a9:	84 c0                	test   %al,%al
     5ab:	0f 44 d7             	cmove  %edi,%edx
     5ae:	eb 8e                	jmp    53e <_Opendir+0x5e>

    if ((d = (zDIR *)malloc(sizeof(zDIR))) == NULL ||
        (p = malloc(strlen(n) + 5)) == NULL)
    {
        if (d != (zDIR *)NULL)
            free((void *)d);
     5b0:	89 1c 24             	mov    %ebx,(%esp)
     5b3:	e8 00 00 00 00       	call   5b8 <_Opendir+0xd8>

    free((zvoid *)p);
    d->d_first = 1;
    return d;

} /* end of function Opendir() */
     5b8:	81 c4 5c 01 00 00    	add    $0x15c,%esp
    if ((d = (zDIR *)malloc(sizeof(zDIR))) == NULL ||
        (p = malloc(strlen(n) + 5)) == NULL)
    {
        if (d != (zDIR *)NULL)
            free((void *)d);
        return (zDIR *)NULL;
     5be:	31 c0                	xor    %eax,%eax

    free((zvoid *)p);
    d->d_first = 1;
    return d;

} /* end of function Opendir() */
     5c0:	5b                   	pop    %ebx
     5c1:	5e                   	pop    %esi
     5c2:	5f                   	pop    %edi
     5c3:	5d                   	pop    %ebp
     5c4:	c3                   	ret    
        return (zDIR *)NULL;
    }
    INTERN_TO_ISO(n, p);
    if (len > 0) {
        if (p[len-1] == ':')
            p[len++] = '.';     /* x: => x:. */
     5c5:	c6 04 3e 2e          	movb   $0x2e,(%esi,%edi,1)
     5c9:	8d 54 3e 01          	lea    0x1(%esi,%edi,1),%edx
     5cd:	e9 6c ff ff ff       	jmp    53e <_Opendir+0x5e>
            --len;              /* foo/ => foo */
    }
    strcpy(p+len, "/*");

    if (INVALID_HANDLE_VALUE == (d->d_hFindFile = FindFirstFile(p, &fd))) {
        free((zvoid *)d);
     5d2:	89 1c 24             	mov    %ebx,(%esp)
     5d5:	e8 00 00 00 00       	call   5da <_Opendir+0xfa>
        free((zvoid *)p);
     5da:	89 34 24             	mov    %esi,(%esp)
     5dd:	e8 00 00 00 00       	call   5e2 <_Opendir+0x102>
        return NULL;
     5e2:	31 c0                	xor    %eax,%eax
     5e4:	eb a3                	jmp    589 <_Opendir+0xa9>
     5e6:	8d 76 00             	lea    0x0(%esi),%esi
     5e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000005f0 <_Readdir>:
static struct zdirent *Readdir(d)
    zDIR *d;                    /* directory stream from which to read */
{
    /* Return pointer to first or next directory entry, or NULL if end. */

    if ( d->d_first )
     5f0:	8b 88 24 01 00 00    	mov    0x124(%eax),%ecx
     5f6:	85 c9                	test   %ecx,%ecx
     5f8:	74 0b                	je     605 <_Readdir+0x15>
        d->d_first = 0;
     5fa:	c7 80 24 01 00 00 00 	movl   $0x0,0x124(%eax)
     601:	00 00 00 

        ISO_TO_INTERN(fd.cFileName, d->d_name);
    }
    return (struct zdirent *)d;

} /* end of function Readdir() */
     604:	c3                   	ret    
/* Function Readdir() */        /* Difference: no special handling for      */
/**********************/        /*             hidden or system files.      */

static struct zdirent *Readdir(d)
    zDIR *d;                    /* directory stream from which to read */
{
     605:	53                   	push   %ebx
     606:	89 c3                	mov    %eax,%ebx
     608:	81 ec 58 01 00 00    	sub    $0x158,%esp
        d->d_first = 0;
    else
    {
        WIN32_FIND_DATA fd;

        if ( !FindNextFile(d->d_hFindFile, &fd) )
     60e:	8d 44 24 10          	lea    0x10(%esp),%eax
     612:	89 44 24 04          	mov    %eax,0x4(%esp)
     616:	8b 83 28 01 00 00    	mov    0x128(%ebx),%eax
     61c:	89 04 24             	mov    %eax,(%esp)
     61f:	e8 00 00 00 00       	call   624 <_Readdir+0x34>
     624:	85 c0                	test   %eax,%eax
     626:	52                   	push   %edx
     627:	52                   	push   %edx
     628:	74 19                	je     643 <_Readdir+0x53>
            return NULL;

        ISO_TO_INTERN(fd.cFileName, d->d_name);
     62a:	8d 43 20             	lea    0x20(%ebx),%eax
     62d:	8d 54 24 3c          	lea    0x3c(%esp),%edx
     631:	39 d0                	cmp    %edx,%eax
     633:	74 0c                	je     641 <_Readdir+0x51>
     635:	89 54 24 04          	mov    %edx,0x4(%esp)
     639:	89 04 24             	mov    %eax,(%esp)
     63c:	e8 00 00 00 00       	call   641 <_Readdir+0x51>
     641:	89 d8                	mov    %ebx,%eax
    }
    return (struct zdirent *)d;

} /* end of function Readdir() */
     643:	81 c4 58 01 00 00    	add    $0x158,%esp
     649:	5b                   	pop    %ebx
     64a:	c3                   	ret    
     64b:	90                   	nop
     64c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000650 <_maskDOSdevice>:
/****************************/

static void maskDOSdevice(__G__ pathcomp)
    __GDEF
    char *pathcomp;
{
     650:	56                   	push   %esi
     651:	53                   	push   %ebx
     652:	83 ec 14             	sub    $0x14,%esp
     655:	89 c6                	mov    %eax,%esi
    } else {
        Trace((stderr, "maskDOSdevice() stat(\"%s\", buf) failed\n",
               FnFilter1(pathcomp)));
    }
#endif
    if (stat(pathcomp, &G.statbuf) == 0 && S_ISCHR(G.statbuf.st_mode)) {
     657:	8d 80 7c 09 01 00    	lea    0x1097c(%eax),%eax
/****************************/

static void maskDOSdevice(__G__ pathcomp)
    __GDEF
    char *pathcomp;
{
     65d:	89 d3                	mov    %edx,%ebx
    } else {
        Trace((stderr, "maskDOSdevice() stat(\"%s\", buf) failed\n",
               FnFilter1(pathcomp)));
    }
#endif
    if (stat(pathcomp, &G.statbuf) == 0 && S_ISCHR(G.statbuf.st_mode)) {
     65f:	89 44 24 04          	mov    %eax,0x4(%esp)
     663:	89 14 24             	mov    %edx,(%esp)
     666:	e8 00 00 00 00       	call   66b <_maskDOSdevice+0x1b>
     66b:	85 c0                	test   %eax,%eax
     66d:	75 12                	jne    681 <_maskDOSdevice+0x31>
     66f:	66 8b 86 82 09 01 00 	mov    0x10982(%esi),%ax
     676:	25 00 f0 ff ff       	and    $0xfffff000,%eax
     67b:	66 3d 00 20          	cmp    $0x2000,%ax
     67f:	74 06                	je     687 <_maskDOSdevice+0x37>
         */
        for (i = strlen(pathcomp) + 1; i > 0; --i)
            pathcomp[i] = pathcomp[i - 1];
        pathcomp[0] = '_';
    }
} /* end function maskDOSdevice() */
     681:	83 c4 14             	add    $0x14,%esp
     684:	5b                   	pop    %ebx
     685:	5e                   	pop    %esi
     686:	c3                   	ret    

        /* pathcomp contains a name of a DOS character device (builtin or
         * installed device driver).
         * Prepend a '_' to allow creation of the item in the file system.
         */
        for (i = strlen(pathcomp) + 1; i > 0; --i)
     687:	89 1c 24             	mov    %ebx,(%esp)
     68a:	e8 00 00 00 00       	call   68f <_maskDOSdevice+0x3f>
     68f:	8d 53 ff             	lea    -0x1(%ebx),%edx
     692:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
     695:	40                   	inc    %eax
     696:	74 0a                	je     6a2 <_maskDOSdevice+0x52>
            pathcomp[i] = pathcomp[i - 1];
     698:	8a 01                	mov    (%ecx),%al
     69a:	49                   	dec    %ecx
     69b:	88 41 02             	mov    %al,0x2(%ecx)

        /* pathcomp contains a name of a DOS character device (builtin or
         * installed device driver).
         * Prepend a '_' to allow creation of the item in the file system.
         */
        for (i = strlen(pathcomp) + 1; i > 0; --i)
     69e:	39 d1                	cmp    %edx,%ecx
     6a0:	75 f6                	jne    698 <_maskDOSdevice+0x48>
            pathcomp[i] = pathcomp[i - 1];
        pathcomp[0] = '_';
     6a2:	c6 03 5f             	movb   $0x5f,(%ebx)
    }
} /* end function maskDOSdevice() */
     6a5:	83 c4 14             	add    $0x14,%esp
     6a8:	5b                   	pop    %ebx
     6a9:	5e                   	pop    %esi
     6aa:	c3                   	ret    
     6ab:	90                   	nop
     6ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000006b0 <_VFatFileTime2utime>:
/*********************************/
/* Function VFatFileTime2utime() */
/*********************************/

static int VFatFileTime2utime(const FILETIME *pft, time_t *ut)
{
     6b0:	56                   	push   %esi
     6b1:	53                   	push   %ebx
     6b2:	83 ec 24             	sub    $0x24,%esp
     6b5:	89 d6                	mov    %edx,%esi
#else
    SYSTEMTIME w32tm;
    struct tm ltm;
#endif

    if (!FileTimeToLocalFileTime(pft, &lft)) {
     6b7:	8d 5c 24 18          	lea    0x18(%esp),%ebx
     6bb:	89 04 24             	mov    %eax,(%esp)
     6be:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     6c2:	e8 00 00 00 00       	call   6c7 <_VFatFileTime2utime+0x17>
     6c7:	85 c0                	test   %eax,%eax
     6c9:	51                   	push   %ecx
     6ca:	51                   	push   %ecx
     6cb:	74 48                	je     715 <_VFatFileTime2utime+0x65>
    /* This version of the FILETIME-to-UNIXTIME conversion function
     * uses DOS-DATE-TIME format as intermediate stage. For modification
     * and access times, this is no problem. But, the extra fine resolution
     * of the VFAT-stored creation time gets lost.
     */
    if (!FileTimeToDosDateTime(&lft, &wDOSDate, &wDOSTime)) {
     6cd:	8d 44 24 16          	lea    0x16(%esp),%eax
     6d1:	89 1c 24             	mov    %ebx,(%esp)
     6d4:	89 44 24 08          	mov    %eax,0x8(%esp)
     6d8:	8d 44 24 14          	lea    0x14(%esp),%eax
     6dc:	89 44 24 04          	mov    %eax,0x4(%esp)
     6e0:	e8 00 00 00 00       	call   6e5 <_VFatFileTime2utime+0x35>
     6e5:	83 ec 0c             	sub    $0xc,%esp
     6e8:	85 c0                	test   %eax,%eax
     6ea:	74 3b                	je     727 <_VFatFileTime2utime+0x77>
     6ec:	31 c0                	xor    %eax,%eax
     6ee:	31 d2                	xor    %edx,%edx
     6f0:	66 8b 44 24 14       	mov    0x14(%esp),%ax
     6f5:	66 8b 54 24 16       	mov    0x16(%esp),%dx
     6fa:	c1 e0 10             	shl    $0x10,%eax
     6fd:	09 d0                	or     %edx,%eax
    }
    TTrace((stdout,"DosDateTime is %04u-%02u-%02u %02u:%02u:%02u\n",
      (unsigned)((wDOSDate>>9)&0x7f)+1980,(unsigned)((wDOSDate>>5)&0x0f),
      (unsigned)(wDOSDate&0x1f),(unsigned)((wDOSTime>>11)&0x1f),
      (unsigned)((wDOSTime>>5)&0x3f),(unsigned)((wDOSTime<<1)&0x3e)));
    *ut = dos_to_unix_time(((ulg)wDOSDate << 16) | (ulg)wDOSTime);
     6ff:	89 04 24             	mov    %eax,(%esp)
     702:	e8 00 00 00 00       	call   707 <_VFatFileTime2utime+0x57>
     707:	89 06                	mov    %eax,(%esi)
     * (The only known exception is creation time on VFAT partitions.)
     */
    return (*ut != (time_t)-1L);
#endif /* ?HAVE_MKTIME */

} /* end function VFatFileTime2utime() */
     709:	83 c4 24             	add    $0x24,%esp

    /* a cheap error check: dos_to_unix_time() only returns an odd time
     * when clipping at maximum time_t value. DOS_DATE_TIME values have
     * a resolution of 2 seconds and are therefore even numbers.
     */
    return (((*ut)&1) == (time_t)0);
     70c:	83 e0 01             	and    $0x1,%eax
     70f:	83 f0 01             	xor    $0x1,%eax
     * (The only known exception is creation time on VFAT partitions.)
     */
    return (*ut != (time_t)-1L);
#endif /* ?HAVE_MKTIME */

} /* end function VFatFileTime2utime() */
     712:	5b                   	pop    %ebx
     713:	5e                   	pop    %esi
     714:	c3                   	ret    
    struct tm ltm;
#endif

    if (!FileTimeToLocalFileTime(pft, &lft)) {
        /* if pft cannot be converted to local time, return current time */
        return (int)time(NULL);
     715:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     71c:	e8 00 00 00 00       	call   721 <_VFatFileTime2utime+0x71>
     * (The only known exception is creation time on VFAT partitions.)
     */
    return (*ut != (time_t)-1L);
#endif /* ?HAVE_MKTIME */

} /* end function VFatFileTime2utime() */
     721:	83 c4 24             	add    $0x24,%esp
     724:	5b                   	pop    %ebx
     725:	5e                   	pop    %esi
     726:	c3                   	ret    
     * of the VFAT-stored creation time gets lost.
     */
    if (!FileTimeToDosDateTime(&lft, &wDOSDate, &wDOSTime)) {
        static const FILETIME dosmin_ft =
                {DOSTIME_MIN_FT_LO, DOSTIME_MIN_FT_HI};
        if (CompareFileTime(&lft, &dosmin_ft) <= 0) {
     727:	c7 44 24 04 10 06 00 	movl   $0x610,0x4(%esp)
     72e:	00 
     72f:	89 1c 24             	mov    %ebx,(%esp)
     732:	e8 00 00 00 00       	call   737 <_VFatFileTime2utime+0x87>
     737:	85 c0                	test   %eax,%eax
     739:	52                   	push   %edx
     73a:	52                   	push   %edx
     73b:	7e 15                	jle    752 <_VFatFileTime2utime+0xa2>
            /* underflow -> set to minimum DOS time */
            wDOSDate = (WORD)((DWORD)DOSTIME_MINIMUM >> 16);
            wDOSTime = (WORD)DOSTIME_MINIMUM;
        } else {
            /* overflow -> set to maximum DOS time */
            wDOSDate = (WORD)0xFF9F;    /* 2107-12-31 */
     73d:	66 c7 44 24 14 9f ff 	movw   $0xff9f,0x14(%esp)
            wDOSTime = (WORD)0xBF7D;    /* 23:59:58 */
     744:	66 c7 44 24 16 7d bf 	movw   $0xbf7d,0x16(%esp)
     74b:	b8 7d bf 9f ff       	mov    $0xff9fbf7d,%eax
     750:	eb ad                	jmp    6ff <_VFatFileTime2utime+0x4f>
    if (!FileTimeToDosDateTime(&lft, &wDOSDate, &wDOSTime)) {
        static const FILETIME dosmin_ft =
                {DOSTIME_MIN_FT_LO, DOSTIME_MIN_FT_HI};
        if (CompareFileTime(&lft, &dosmin_ft) <= 0) {
            /* underflow -> set to minimum DOS time */
            wDOSDate = (WORD)((DWORD)DOSTIME_MINIMUM >> 16);
     752:	66 c7 44 24 14 21 00 	movw   $0x21,0x14(%esp)
            wDOSTime = (WORD)DOSTIME_MINIMUM;
     759:	66 c7 44 24 16 00 00 	movw   $0x0,0x16(%esp)
     760:	b8 00 00 21 00       	mov    $0x210000,%eax
     765:	eb 98                	jmp    6ff <_VFatFileTime2utime+0x4f>
     767:	89 f6                	mov    %esi,%esi
     769:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000770 <_utime2VFatFileTime.constprop.5>:

/*********************************/
/* Function utime2VFatFileTime() */ /* convert Unix time_t format into the */
/*********************************/ /* form used by SetFileTime() in NT/9x */

static void utime2VFatFileTime(time_t ut, FILETIME *pft, int clipDosMin)
     770:	57                   	push   %edi
     771:	56                   	push   %esi
     772:	53                   	push   %ebx
     773:	89 d6                	mov    %edx,%esi
     775:	83 ec 30             	sub    $0x30,%esp
     778:	89 c3                	mov    %eax,%ebx

#ifdef __BORLANDC__   /* Borland C++ 5.x crashes when trying to reference tm */
    if (utc < UTIME_1980_JAN_01_00_00)
        utc = UTIME_1980_JAN_01_00_00;
#endif
    ltm = localtime(&utc);
     77a:	8d 7c 24 14          	lea    0x14(%esp),%edi
/* Function utime2VFatFileTime() */ /* convert Unix time_t format into the */
/*********************************/ /* form used by SetFileTime() in NT/9x */

static void utime2VFatFileTime(time_t ut, FILETIME *pft, int clipDosMin)
{
    time_t utc = ut;
     77e:	89 44 24 14          	mov    %eax,0x14(%esp)

#ifdef __BORLANDC__   /* Borland C++ 5.x crashes when trying to reference tm */
    if (utc < UTIME_1980_JAN_01_00_00)
        utc = UTIME_1980_JAN_01_00_00;
#endif
    ltm = localtime(&utc);
     782:	89 3c 24             	mov    %edi,(%esp)
     785:	e8 00 00 00 00       	call   78a <_utime2VFatFileTime.constprop.5+0x1a>
     78a:	89 c1                	mov    %eax,%ecx
    if (ltm == (struct tm *)NULL)
     78c:	85 c0                	test   %eax,%eax
     78e:	74 65                	je     7f5 <_utime2VFatFileTime.constprop.5+0x85>
            w32tm.wSecond = 0;
        } else {
            /* as a last resort, use the current system time */
            GetLocalTime(&w32tm);
        }
    } else if (clipDosMin && (ltm->tm_year < 80)) {
     790:	8b 41 14             	mov    0x14(%ecx),%eax
     793:	83 f8 4f             	cmp    $0x4f,%eax
     796:	7e 73                	jle    80b <_utime2VFatFileTime.constprop.5+0x9b>
        w32tm.wDay = 1;
        w32tm.wHour = 0;
        w32tm.wMinute = 0;
        w32tm.wSecond = 0;
    } else {
        w32tm.wYear = ltm->tm_year + 1900; /* year + 1900 -> year */
     798:	05 6c 07 00 00       	add    $0x76c,%eax
     79d:	8d 7c 24 20          	lea    0x20(%esp),%edi
     7a1:	66 89 44 24 20       	mov    %ax,0x20(%esp)
        w32tm.wMonth = ltm->tm_mon + 1;    /* 0..11 -> 1..12 */
     7a6:	8b 41 10             	mov    0x10(%ecx),%eax
     7a9:	40                   	inc    %eax
     7aa:	66 89 44 24 22       	mov    %ax,0x22(%esp)
        w32tm.wDay = ltm->tm_mday;         /* 1..31 */
     7af:	8b 41 0c             	mov    0xc(%ecx),%eax
     7b2:	66 89 44 24 26       	mov    %ax,0x26(%esp)
        w32tm.wHour = ltm->tm_hour;        /* 0..23 */
     7b7:	8b 41 08             	mov    0x8(%ecx),%eax
     7ba:	66 89 44 24 28       	mov    %ax,0x28(%esp)
        w32tm.wMinute = ltm->tm_min;       /* 0..59 */
     7bf:	8b 41 04             	mov    0x4(%ecx),%eax
     7c2:	66 89 44 24 2a       	mov    %ax,0x2a(%esp)
        w32tm.wSecond = ltm->tm_sec;       /* 0..61 in ANSI C */
     7c7:	8b 01                	mov    (%ecx),%eax
     7c9:	66 89 44 24 2c       	mov    %ax,0x2c(%esp)
    }

    SystemTimeToFileTime(&w32tm, &lft);
     7ce:	8d 5c 24 18          	lea    0x18(%esp),%ebx
     7d2:	89 3c 24             	mov    %edi,(%esp)
     7d5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     7d9:	e8 00 00 00 00       	call   7de <_utime2VFatFileTime.constprop.5+0x6e>
     7de:	50                   	push   %eax
     7df:	50                   	push   %eax
    LocalFileTimeToFileTime(&lft, pft);
     7e0:	89 74 24 04          	mov    %esi,0x4(%esp)
     7e4:	89 1c 24             	mov    %ebx,(%esp)
     7e7:	e8 00 00 00 00       	call   7ec <_utime2VFatFileTime.constprop.5+0x7c>
     7ec:	52                   	push   %edx
     7ed:	52                   	push   %edx

} /* end function utime2VFatFileTime() */
     7ee:	83 c4 30             	add    $0x30,%esp
     7f1:	5b                   	pop    %ebx
     7f2:	5e                   	pop    %esi
     7f3:	5f                   	pop    %edi
     7f4:	c3                   	ret    
#endif
    ltm = localtime(&utc);
    if (ltm == (struct tm *)NULL)
        /* localtime() did not accept given utc time value; try to use
           the UTC value */
        ltm = gmtime(&utc);
     7f5:	89 3c 24             	mov    %edi,(%esp)
     7f8:	e8 00 00 00 00       	call   7fd <_utime2VFatFileTime.constprop.5+0x8d>
     7fd:	89 c1                	mov    %eax,%ecx
    if (ltm == (struct tm *)NULL) {
     7ff:	85 c0                	test   %eax,%eax
     801:	75 8d                	jne    790 <_utime2VFatFileTime.constprop.5+0x20>
        if (ut <= (UTIME_1980_JAN_01_00_00 + 86400)) {
     803:	81 fb 80 f7 cf 12    	cmp    $0x12cff780,%ebx
     809:	7f 35                	jg     840 <_utime2VFatFileTime.constprop.5+0xd0>
            /* use DOSTIME_MINIMUM date instead of "early" failure dates */
            w32tm.wYear = 1980;
     80b:	66 c7 44 24 20 bc 07 	movw   $0x7bc,0x20(%esp)
            w32tm.wMonth = 1;
     812:	66 c7 44 24 22 01 00 	movw   $0x1,0x22(%esp)
            w32tm.wDay = 1;
     819:	66 c7 44 24 26 01 00 	movw   $0x1,0x26(%esp)
            w32tm.wHour = 0;
     820:	66 c7 44 24 28 00 00 	movw   $0x0,0x28(%esp)
            w32tm.wMinute = 0;
     827:	66 c7 44 24 2a 00 00 	movw   $0x0,0x2a(%esp)
            w32tm.wSecond = 0;
     82e:	66 c7 44 24 2c 00 00 	movw   $0x0,0x2c(%esp)
     835:	8d 7c 24 20          	lea    0x20(%esp),%edi
     839:	eb 93                	jmp    7ce <_utime2VFatFileTime.constprop.5+0x5e>
     83b:	90                   	nop
     83c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        } else {
            /* as a last resort, use the current system time */
            GetLocalTime(&w32tm);
     840:	8d 7c 24 20          	lea    0x20(%esp),%edi
     844:	89 3c 24             	mov    %edi,(%esp)
     847:	e8 00 00 00 00       	call   84c <_utime2VFatFileTime.constprop.5+0xdc>
     84c:	51                   	push   %ecx
     84d:	e9 7c ff ff ff       	jmp    7ce <_utime2VFatFileTime.constprop.5+0x5e>
     852:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     859:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000860 <_getNTfiletime>:
static int getNTfiletime(__G__ pModFT, pAccFT, pCreFT)
    __GDEF
    FILETIME *pModFT;
    FILETIME *pAccFT;
    FILETIME *pCreFT;
{
     860:	55                   	push   %ebp
     861:	57                   	push   %edi
     862:	56                   	push   %esi
     863:	53                   	push   %ebx
     864:	83 ec 5c             	sub    $0x5c,%esp
     867:	89 d6                	mov    %edx,%esi
#ifdef USE_EF_UT_TIME
    unsigned eb_izux_flg;
    iztimes z_utime;   /* struct for Unix-style actime & modtime, + creatime */
#endif
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);
     869:	8d 90 e0 09 01 00    	lea    0x109e0(%eax),%edx
static int getNTfiletime(__G__ pModFT, pAccFT, pCreFT)
    __GDEF
    FILETIME *pModFT;
    FILETIME *pAccFT;
    FILETIME *pCreFT;
{
     86f:	89 c3                	mov    %eax,%ebx
     871:	89 cf                	mov    %ecx,%edi
/* Function FStampIsLocTime() */
/******************************/

static int FStampIsLocTime(__GPRO__ const char *path)
{
    return (NTQueryVolInfo(__G__ path) ? G.lastVolLocTim : FALSE);
     873:	e8 88 f7 ff ff       	call   0 <_NTQueryVolInfo>
     878:	85 c0                	test   %eax,%eax
     87a:	0f 84 92 00 00 00    	je     912 <_getNTfiletime+0xb2>
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);

    /* Copy and/or convert time and date variables, if necessary;
     * return a flag indicating which time stamps are available. */
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
     880:	8b 83 18 09 01 00    	mov    0x10918(%ebx),%eax
/* Function FStampIsLocTime() */
/******************************/

static int FStampIsLocTime(__GPRO__ const char *path)
{
    return (NTQueryVolInfo(__G__ path) ? G.lastVolLocTim : FALSE);
     886:	8b 93 88 0b 01 00    	mov    0x10b88(%ebx),%edx
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);

    /* Copy and/or convert time and date variables, if necessary;
     * return a flag indicating which time stamps are available. */
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
     88c:	85 c0                	test   %eax,%eax
     88e:	74 49                	je     8d9 <_getNTfiletime+0x79>
     890:	8d 4c 24 44          	lea    0x44(%esp),%ecx
     894:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
     89b:	00 
     89c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     8a0:	89 54 24 2c          	mov    %edx,0x2c(%esp)
     8a4:	8b 8b 28 09 01 00    	mov    0x10928(%ebx),%ecx
     8aa:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     8b1:	00 
     8b2:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
#ifdef IZ_CHECK_TZ
        G.tz_is_valid &&
#endif
        ((eb_izux_flg = ef_scan_for_izux(G.extra_field,
     8b6:	31 c9                	xor    %ecx,%ecx
     8b8:	66 8b 8b 38 09 01 00 	mov    0x10938(%ebx),%cx
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);

    /* Copy and/or convert time and date variables, if necessary;
     * return a flag indicating which time stamps are available. */
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
     8bf:	89 04 24             	mov    %eax,(%esp)
#ifdef IZ_CHECK_TZ
        G.tz_is_valid &&
#endif
        ((eb_izux_flg = ef_scan_for_izux(G.extra_field,
     8c2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);

    /* Copy and/or convert time and date variables, if necessary;
     * return a flag indicating which time stamps are available. */
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
     8c6:	e8 00 00 00 00       	call   8cb <_getNTfiletime+0x6b>
     8cb:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     8cf:	89 c5                	mov    %eax,%ebp
     8d1:	a8 01                	test   $0x1,%al
     8d3:	0f 85 be 00 00 00    	jne    997 <_getNTfiletime+0x137>
        }
        return (int)eb_izux_flg;
    }
#endif /* USE_EF_UT_TIME */
#ifndef NO_W32TIMES_IZFIX
    if (!fs_uses_loctime) {
     8d9:	85 d2                	test   %edx,%edx
     8db:	74 7c                	je     959 <_getNTfiletime+0xf9>
#endif /* NO_W32TIMES_IZFIX */
    {
        FILETIME lft;

        DosDateTimeToFileTime((WORD)(G.lrec.last_mod_dos_datetime >> 16),
                              (WORD)(G.lrec.last_mod_dos_datetime & 0xFFFFL),
     8dd:	8b 83 28 09 01 00    	mov    0x10928(%ebx),%eax
     8e3:	31 d2                	xor    %edx,%edx
     8e5:	66 89 c2             	mov    %ax,%dx
    } else
#endif /* NO_W32TIMES_IZFIX */
    {
        FILETIME lft;

        DosDateTimeToFileTime((WORD)(G.lrec.last_mod_dos_datetime >> 16),
     8e8:	8d 5c 24 3c          	lea    0x3c(%esp),%ebx
     8ec:	c1 e8 10             	shr    $0x10,%eax
     8ef:	89 54 24 04          	mov    %edx,0x4(%esp)
     8f3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     8f7:	89 04 24             	mov    %eax,(%esp)
     8fa:	e8 00 00 00 00       	call   8ff <_getNTfiletime+0x9f>
     8ff:	83 ec 0c             	sub    $0xc,%esp
                              (WORD)(G.lrec.last_mod_dos_datetime & 0xFFFFL),
                              &lft);
        LocalFileTimeToFileTime(&lft, pModFT);
     902:	89 74 24 04          	mov    %esi,0x4(%esp)
     906:	89 1c 24             	mov    %ebx,(%esp)
     909:	e8 00 00 00 00       	call   90e <_getNTfiletime+0xae>
     90e:	50                   	push   %eax
     90f:	50                   	push   %eax
     910:	eb 6e                	jmp    980 <_getNTfiletime+0x120>
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);

    /* Copy and/or convert time and date variables, if necessary;
     * return a flag indicating which time stamps are available. */
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
     912:	8b 83 18 09 01 00    	mov    0x10918(%ebx),%eax
     918:	85 c0                	test   %eax,%eax
     91a:	74 3d                	je     959 <_getNTfiletime+0xf9>
     91c:	8d 54 24 44          	lea    0x44(%esp),%edx
     920:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
     927:	00 
     928:	89 54 24 10          	mov    %edx,0x10(%esp)
     92c:	8b 93 28 09 01 00    	mov    0x10928(%ebx),%edx
     932:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     939:	00 
     93a:	89 54 24 0c          	mov    %edx,0xc(%esp)
#ifdef IZ_CHECK_TZ
        G.tz_is_valid &&
#endif
        ((eb_izux_flg = ef_scan_for_izux(G.extra_field,
     93e:	31 d2                	xor    %edx,%edx
     940:	66 8b 93 38 09 01 00 	mov    0x10938(%ebx),%dx
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);

    /* Copy and/or convert time and date variables, if necessary;
     * return a flag indicating which time stamps are available. */
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
     947:	89 04 24             	mov    %eax,(%esp)
#ifdef IZ_CHECK_TZ
        G.tz_is_valid &&
#endif
        ((eb_izux_flg = ef_scan_for_izux(G.extra_field,
     94a:	89 54 24 04          	mov    %edx,0x4(%esp)
    int fs_uses_loctime = FStampIsLocTime(__G__ G.filename);

    /* Copy and/or convert time and date variables, if necessary;
     * return a flag indicating which time stamps are available. */
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
     94e:	e8 00 00 00 00       	call   953 <_getNTfiletime+0xf3>
     953:	89 c5                	mov    %eax,%ebp
     955:	a8 01                	test   $0x1,%al
     957:	75 42                	jne    99b <_getNTfiletime+0x13b>
#endif /* USE_EF_UT_TIME */
#ifndef NO_W32TIMES_IZFIX
    if (!fs_uses_loctime) {
        time_t ux_modtime;

        ux_modtime = dos_to_unix_time(G.lrec.last_mod_dos_datetime);
     959:	8b 83 28 09 01 00    	mov    0x10928(%ebx),%eax
     95f:	89 04 24             	mov    %eax,(%esp)
     962:	e8 00 00 00 00       	call   967 <_getNTfiletime+0x107>
     967:	89 c2                	mov    %eax,%edx
    ULLNG64 NTtime;

    /* NT_QUANTA_PER_UNIX is small enough so that "ut * NT_QUANTA_PER_UNIX"
     * cannot overflow in 64-bit signed calculation, regardless whether "ut"
     * is signed or unsigned.  */
    NTtime = ((LLONG64)ut * NT_QUANTA_PER_UNIX) +
     969:	b8 80 96 98 00       	mov    $0x989680,%eax
     96e:	f7 ea                	imul   %edx
     970:	05 00 80 3e d5       	add    $0xd53e8000,%eax
     975:	81 d2 de b1 9d 01    	adc    $0x19db1de,%edx
             ((ULLNG64)UNIX_TIME_ZERO_LO + ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    pft->dwLowDateTime = (DWORD)NTtime;
     97b:	89 06                	mov    %eax,(%esi)
    pft->dwHighDateTime = (DWORD)(NTtime >> 32);
     97d:	89 56 04             	mov    %edx,0x4(%esi)
        DosDateTimeToFileTime((WORD)(G.lrec.last_mod_dos_datetime >> 16),
                              (WORD)(G.lrec.last_mod_dos_datetime & 0xFFFFL),
                              &lft);
        LocalFileTimeToFileTime(&lft, pModFT);
    }
    *pAccFT = *pModFT;
     980:	8b 06                	mov    (%esi),%eax
     982:	8b 56 04             	mov    0x4(%esi),%edx
     985:	89 57 04             	mov    %edx,0x4(%edi)
     988:	89 07                	mov    %eax,(%edi)
    return (EB_UT_FL_MTIME | EB_UT_FL_ATIME);

} /* end function getNTfiletime() */
     98a:	83 c4 5c             	add    $0x5c,%esp
                              (WORD)(G.lrec.last_mod_dos_datetime & 0xFFFFL),
                              &lft);
        LocalFileTimeToFileTime(&lft, pModFT);
    }
    *pAccFT = *pModFT;
    return (EB_UT_FL_MTIME | EB_UT_FL_ATIME);
     98d:	b8 03 00 00 00       	mov    $0x3,%eax

} /* end function getNTfiletime() */
     992:	5b                   	pop    %ebx
     993:	5e                   	pop    %esi
     994:	5f                   	pop    %edi
     995:	5d                   	pop    %ebp
     996:	c3                   	ret    
          G.lrec.extra_field_length, 0, G.lrec.last_mod_dos_datetime,
          &z_utime, NULL)) & EB_UT_FL_MTIME))
    {
        TTrace((stderr, "getNTfiletime:  Unix e.f. modif. time = %lu\n",
          z_utime.mtime));
        UTIME_2_IZFILETIME(z_utime.mtime, pModFT)
     997:	85 d2                	test   %edx,%edx
     999:	75 75                	jne    a10 <_getNTfiletime+0x1b0>
    ULLNG64 NTtime;

    /* NT_QUANTA_PER_UNIX is small enough so that "ut * NT_QUANTA_PER_UNIX"
     * cannot overflow in 64-bit signed calculation, regardless whether "ut"
     * is signed or unsigned.  */
    NTtime = ((LLONG64)ut * NT_QUANTA_PER_UNIX) +
     99b:	b9 80 96 98 00       	mov    $0x989680,%ecx
     9a0:	89 c8                	mov    %ecx,%eax
     9a2:	f7 6c 24 48          	imull  0x48(%esp)
     9a6:	05 00 80 3e d5       	add    $0xd53e8000,%eax
     9ab:	81 d2 de b1 9d 01    	adc    $0x19db1de,%edx
             ((ULLNG64)UNIX_TIME_ZERO_LO + ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    pft->dwLowDateTime = (DWORD)NTtime;
     9b1:	89 06                	mov    %eax,(%esi)
    pft->dwHighDateTime = (DWORD)(NTtime >> 32);
     9b3:	89 56 04             	mov    %edx,0x4(%esi)
          &z_utime, NULL)) & EB_UT_FL_MTIME))
    {
        TTrace((stderr, "getNTfiletime:  Unix e.f. modif. time = %lu\n",
          z_utime.mtime));
        UTIME_2_IZFILETIME(z_utime.mtime, pModFT)
        if (eb_izux_flg & EB_UT_FL_ATIME) {
     9b6:	f7 c5 02 00 00 00    	test   $0x2,%ebp
     9bc:	74 45                	je     a03 <_getNTfiletime+0x1a3>
    ULLNG64 NTtime;

    /* NT_QUANTA_PER_UNIX is small enough so that "ut * NT_QUANTA_PER_UNIX"
     * cannot overflow in 64-bit signed calculation, regardless whether "ut"
     * is signed or unsigned.  */
    NTtime = ((LLONG64)ut * NT_QUANTA_PER_UNIX) +
     9be:	89 c8                	mov    %ecx,%eax
     9c0:	f7 6c 24 44          	imull  0x44(%esp)
     9c4:	05 00 80 3e d5       	add    $0xd53e8000,%eax
     9c9:	81 d2 de b1 9d 01    	adc    $0x19db1de,%edx
             ((ULLNG64)UNIX_TIME_ZERO_LO + ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    pft->dwLowDateTime = (DWORD)NTtime;
     9cf:	89 07                	mov    %eax,(%edi)
    pft->dwHighDateTime = (DWORD)(NTtime >> 32);
     9d1:	89 57 04             	mov    %edx,0x4(%edi)
          z_utime.mtime));
        UTIME_2_IZFILETIME(z_utime.mtime, pModFT)
        if (eb_izux_flg & EB_UT_FL_ATIME) {
            UTIME_2_IZFILETIME(z_utime.atime, pAccFT)
        }
        if (eb_izux_flg & EB_UT_FL_CTIME) {
     9d4:	f7 c5 04 00 00 00    	test   $0x4,%ebp
     9da:	74 1d                	je     9f9 <_getNTfiletime+0x199>
    ULLNG64 NTtime;

    /* NT_QUANTA_PER_UNIX is small enough so that "ut * NT_QUANTA_PER_UNIX"
     * cannot overflow in 64-bit signed calculation, regardless whether "ut"
     * is signed or unsigned.  */
    NTtime = ((LLONG64)ut * NT_QUANTA_PER_UNIX) +
     9dc:	b8 80 96 98 00       	mov    $0x989680,%eax
             ((ULLNG64)UNIX_TIME_ZERO_LO + ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    pft->dwLowDateTime = (DWORD)NTtime;
     9e1:	8b 7c 24 70          	mov    0x70(%esp),%edi
    ULLNG64 NTtime;

    /* NT_QUANTA_PER_UNIX is small enough so that "ut * NT_QUANTA_PER_UNIX"
     * cannot overflow in 64-bit signed calculation, regardless whether "ut"
     * is signed or unsigned.  */
    NTtime = ((LLONG64)ut * NT_QUANTA_PER_UNIX) +
     9e5:	f7 6c 24 4c          	imull  0x4c(%esp)
     9e9:	05 00 80 3e d5       	add    $0xd53e8000,%eax
     9ee:	81 d2 de b1 9d 01    	adc    $0x19db1de,%edx
             ((ULLNG64)UNIX_TIME_ZERO_LO + ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    pft->dwLowDateTime = (DWORD)NTtime;
     9f4:	89 07                	mov    %eax,(%edi)
    pft->dwHighDateTime = (DWORD)(NTtime >> 32);
     9f6:	89 57 04             	mov    %edx,0x4(%edi)
            UTIME_2_IZFILETIME(z_utime.atime, pAccFT)
        }
        if (eb_izux_flg & EB_UT_FL_CTIME) {
            UTIME_2_IZFILETIME(z_utime.ctime, pCreFT)
        }
        return (int)eb_izux_flg;
     9f9:	89 e8                	mov    %ebp,%eax
        LocalFileTimeToFileTime(&lft, pModFT);
    }
    *pAccFT = *pModFT;
    return (EB_UT_FL_MTIME | EB_UT_FL_ATIME);

} /* end function getNTfiletime() */
     9fb:	83 c4 5c             	add    $0x5c,%esp
     9fe:	5b                   	pop    %ebx
     9ff:	5e                   	pop    %esi
     a00:	5f                   	pop    %edi
     a01:	5d                   	pop    %ebp
     a02:	c3                   	ret    
          z_utime.mtime));
        UTIME_2_IZFILETIME(z_utime.mtime, pModFT)
        if (eb_izux_flg & EB_UT_FL_ATIME) {
            UTIME_2_IZFILETIME(z_utime.atime, pAccFT)
        }
        if (eb_izux_flg & EB_UT_FL_CTIME) {
     a03:	f7 c5 04 00 00 00    	test   $0x4,%ebp
     a09:	75 d1                	jne    9dc <_getNTfiletime+0x17c>
     a0b:	eb ec                	jmp    9f9 <_getNTfiletime+0x199>
     a0d:	8d 76 00             	lea    0x0(%esi),%esi
          G.lrec.extra_field_length, 0, G.lrec.last_mod_dos_datetime,
          &z_utime, NULL)) & EB_UT_FL_MTIME))
    {
        TTrace((stderr, "getNTfiletime:  Unix e.f. modif. time = %lu\n",
          z_utime.mtime));
        UTIME_2_IZFILETIME(z_utime.mtime, pModFT)
     a10:	89 f2                	mov    %esi,%edx
     a12:	8b 44 24 48          	mov    0x48(%esp),%eax
     a16:	e8 55 fd ff ff       	call   770 <_utime2VFatFileTime.constprop.5>
        if (eb_izux_flg & EB_UT_FL_ATIME) {
     a1b:	f7 c5 02 00 00 00    	test   $0x2,%ebp
     a21:	75 1d                	jne    a40 <_getNTfiletime+0x1e0>
            UTIME_2_IZFILETIME(z_utime.atime, pAccFT)
        }
        if (eb_izux_flg & EB_UT_FL_CTIME) {
     a23:	f7 c5 04 00 00 00    	test   $0x4,%ebp
     a29:	74 ce                	je     9f9 <_getNTfiletime+0x199>
            UTIME_2_IZFILETIME(z_utime.ctime, pCreFT)
     a2b:	8b 44 24 4c          	mov    0x4c(%esp),%eax
     a2f:	8b 54 24 70          	mov    0x70(%esp),%edx
     a33:	e8 38 fd ff ff       	call   770 <_utime2VFatFileTime.constprop.5>
        }
        return (int)eb_izux_flg;
     a38:	89 e8                	mov    %ebp,%eax
     a3a:	eb bf                	jmp    9fb <_getNTfiletime+0x19b>
     a3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    {
        TTrace((stderr, "getNTfiletime:  Unix e.f. modif. time = %lu\n",
          z_utime.mtime));
        UTIME_2_IZFILETIME(z_utime.mtime, pModFT)
        if (eb_izux_flg & EB_UT_FL_ATIME) {
            UTIME_2_IZFILETIME(z_utime.atime, pAccFT)
     a40:	89 fa                	mov    %edi,%edx
     a42:	8b 44 24 44          	mov    0x44(%esp),%eax
     a46:	e8 25 fd ff ff       	call   770 <_utime2VFatFileTime.constprop.5>
        }
        if (eb_izux_flg & EB_UT_FL_CTIME) {
     a4b:	f7 c5 04 00 00 00    	test   $0x4,%ebp
     a51:	75 d8                	jne    a2b <_getNTfiletime+0x1cb>
            UTIME_2_IZFILETIME(z_utime.ctime, pCreFT)
        }
        return (int)eb_izux_flg;
     a53:	89 e8                	mov    %ebp,%eax
     a55:	eb a4                	jmp    9fb <_getNTfiletime+0x19b>
     a57:	89 f6                	mov    %esi,%esi
     a59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000a60 <_test_NTSD>:
    __GDEF
    uch *eb;
    unsigned eb_size;
    uch *eb_ucptr;
    ulg eb_ucsize;
{
     a60:	83 ec 1c             	sub    $0x1c,%esp
    return (ValidateSecurity(eb_ucptr) ? PK_OK : PK_WARN);
     a63:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     a67:	89 04 24             	mov    %eax,(%esp)
     a6a:	e8 00 00 00 00       	call   a6f <_test_NTSD+0xf>
     a6f:	85 c0                	test   %eax,%eax
     a71:	0f 94 c0             	sete   %al
     a74:	25 ff 00 00 00       	and    $0xff,%eax
} /* end function test_NTSD() */
     a79:	83 c4 1c             	add    $0x1c,%esp
     a7c:	c3                   	ret    
     a7d:	8d 76 00             	lea    0x0(%esi),%esi

00000a80 <_IsWinNT>:

int IsWinNT(void)       /* returns TRUE if real NT, FALSE if Win9x or Win32s */
{
    static DWORD g_PlatformId = 0xFFFFFFFF; /* saved platform indicator */

    if (g_PlatformId == 0xFFFFFFFF) {
     a80:	a1 00 00 00 00       	mov    0x0,%eax
     a85:	83 f8 ff             	cmp    $0xffffffff,%eax
     a88:	74 06                	je     a90 <_IsWinNT+0x10>
            g_PlatformId = TRUE;
        else
            g_PlatformId = FALSE;
    }
    return (int)g_PlatformId;
}
     a8a:	c3                   	ret    
     a8b:	90                   	nop
     a8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
/**********************/
/* Function IsWinNT() */
/**********************/

int IsWinNT(void)       /* returns TRUE if real NT, FALSE if Win9x or Win32s */
{
     a90:	83 ec 0c             	sub    $0xc,%esp
    static DWORD g_PlatformId = 0xFFFFFFFF; /* saved platform indicator */

    if (g_PlatformId == 0xFFFFFFFF) {
        /* note: GetVersionEx() doesn't exist on WinNT 3.1 */
        if (GetVersion() < 0x80000000)
     a93:	e8 00 00 00 00       	call   a98 <_IsWinNT+0x18>
     a98:	85 c0                	test   %eax,%eax
     a9a:	78 14                	js     ab0 <_IsWinNT+0x30>
            g_PlatformId = TRUE;
     a9c:	c7 05 00 00 00 00 01 	movl   $0x1,0x0
     aa3:	00 00 00 
     aa6:	b8 01 00 00 00       	mov    $0x1,%eax
        else
            g_PlatformId = FALSE;
    }
    return (int)g_PlatformId;
}
     aab:	83 c4 0c             	add    $0xc,%esp
     aae:	c3                   	ret    
     aaf:	90                   	nop
    if (g_PlatformId == 0xFFFFFFFF) {
        /* note: GetVersionEx() doesn't exist on WinNT 3.1 */
        if (GetVersion() < 0x80000000)
            g_PlatformId = TRUE;
        else
            g_PlatformId = FALSE;
     ab0:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     ab7:	00 00 00 
     aba:	31 c0                	xor    %eax,%eax
     abc:	eb ed                	jmp    aab <_IsWinNT+0x2b>
     abe:	66 90                	xchg   %ax,%ax

00000ac0 <_FindSDExtraField.isra.2.part.3>:
 * Address and size of the NTSD e.f. block are passed up to the caller.
 * In case of more than one valid NTSD block in the e.f., the last block
 * found is passed up.
 * Returns FALSE and leaves the content of the ebSD_ptr and ebSD_len
 * parameters untouched when no valid NTFS SD block is found. */
static int FindSDExtraField(__GPRO__
     ac0:	55                   	push   %ebp
     ac1:	57                   	push   %edi
     ac2:	56                   	push   %esi
     ac3:	53                   	push   %ebx
     ac4:	83 ec 2c             	sub    $0x2c,%esp
     ac7:	89 d5                	mov    %edx,%ebp

    if (!uO.X_flag)
        return FALSE;  /* user said don't process ACLs; for now, no other
                          extra block types are handled here */

    while (ef_len >= EB_HEADSIZE)
     ac9:	83 fa 03             	cmp    $0x3,%edx
 * Address and size of the NTSD e.f. block are passed up to the caller.
 * In case of more than one valid NTSD block in the e.f., the last block
 * found is passed up.
 * Returns FALSE and leaves the content of the ebSD_ptr and ebSD_len
 * parameters untouched when no valid NTFS SD block is found. */
static int FindSDExtraField(__GPRO__
     acc:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)

    if (!uO.X_flag)
        return FALSE;  /* user said don't process ACLs; for now, no other
                          extra block types are handled here */

    while (ef_len >= EB_HEADSIZE)
     ad0:	0f 86 96 00 00 00    	jbe    b6c <_FindSDExtraField.isra.2.part.3+0xac>
     ad6:	89 c3                	mov    %eax,%ebx
     ad8:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
     adf:	00 
     ae0:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
     ae5:	eb 0f                	jmp    af6 <_FindSDExtraField.isra.2.part.3+0x36>
     ae7:	89 f8                	mov    %edi,%eax
                  "FindSDExtraField: unknown extra field block, ID=%u\n",
                  eb_id));
                break;
        }

        ef_ptr += (eb_len + EB_HEADSIZE);
     ae9:	8d 5c 13 04          	lea    0x4(%ebx,%edx,1),%ebx
     aed:	29 d0                	sub    %edx,%eax
        ef_len -= (eb_len + EB_HEADSIZE);
     aef:	01 c5                	add    %eax,%ebp

    if (!uO.X_flag)
        return FALSE;  /* user said don't process ACLs; for now, no other
                          extra block types are handled here */

    while (ef_len >= EB_HEADSIZE)
     af1:	83 fd 03             	cmp    $0x3,%ebp
     af4:	76 6a                	jbe    b60 <_FindSDExtraField.isra.2.part.3+0xa0>
    {
        unsigned eb_id = makeword(EB_ID + ef_ptr);
     af6:	89 1c 24             	mov    %ebx,(%esp)
     af9:	e8 00 00 00 00       	call   afe <_FindSDExtraField.isra.2.part.3+0x3e>
     afe:	89 c6                	mov    %eax,%esi
        unsigned eb_len = makeword(EB_LEN + ef_ptr);
     b00:	8d 43 02             	lea    0x2(%ebx),%eax
     b03:	89 04 24             	mov    %eax,(%esp)
     b06:	e8 00 00 00 00       	call   b0b <_FindSDExtraField.isra.2.part.3+0x4b>
     b0b:	31 d2                	xor    %edx,%edx
     b0d:	66 89 c2             	mov    %ax,%dx

        if (eb_len > (ef_len - EB_HEADSIZE)) {
     b10:	8d 45 fc             	lea    -0x4(%ebp),%eax
     b13:	39 c2                	cmp    %eax,%edx
     b15:	77 49                	ja     b60 <_FindSDExtraField.isra.2.part.3+0xa0>
              "FindSDExtraField: block length %u > rest ef_size %u\n", eb_len,
              ef_len - EB_HEADSIZE));
            break;
        }

        switch (eb_id)
     b17:	66 81 fe 53 44       	cmp    $0x4453,%si
     b1c:	75 c9                	jne    ae7 <_FindSDExtraField.isra.2.part.3+0x27>
     b1e:	89 54 24 14          	mov    %edx,0x14(%esp)
                 Target local/remote drive supports acls AND
                 Target file is not a directory (else we defer processing
                   until later)
             */
            case EF_NTSD:
                if (!IsWinNT())
     b22:	e8 59 ff ff ff       	call   a80 <_IsWinNT>
                    break; /* OS not capable of handling NTFS attributes */

                if (eb_len < EB_NTSD_L_LEN)
     b27:	8b 54 24 14          	mov    0x14(%esp),%edx
     b2b:	85 c0                	test   %eax,%eax
     b2d:	74 b8                	je     ae7 <_FindSDExtraField.isra.2.part.3+0x27>
     b2f:	83 fa 04             	cmp    $0x4,%edx
     b32:	76 b3                	jbe    ae7 <_FindSDExtraField.isra.2.part.3+0x27>
                    break; /* not a valid NTSD extra field */

                /* check if we know how to handle this version */
                if (*(ef_ptr + (EB_HEADSIZE+EB_NTSD_VERSION))
     b34:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
     b38:	75 ad                	jne    ae7 <_FindSDExtraField.isra.2.part.3+0x27>
                    > (uch)EB_NTSD_MAX_VER)
                    break;

                *p_ebSD_ptr = ef_ptr;
     b3a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
                *p_ebSD_len = eb_len;
                rc = TRUE;
     b3e:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
     b45:	00 
                /* check if we know how to handle this version */
                if (*(ef_ptr + (EB_HEADSIZE+EB_NTSD_VERSION))
                    > (uch)EB_NTSD_MAX_VER)
                    break;

                *p_ebSD_ptr = ef_ptr;
     b46:	89 18                	mov    %ebx,(%eax)
                *p_ebSD_len = eb_len;
     b48:	8b 44 24 40          	mov    0x40(%esp),%eax
                  "FindSDExtraField: unknown extra field block, ID=%u\n",
                  eb_id));
                break;
        }

        ef_ptr += (eb_len + EB_HEADSIZE);
     b4c:	8d 5c 13 04          	lea    0x4(%ebx,%edx,1),%ebx
                if (*(ef_ptr + (EB_HEADSIZE+EB_NTSD_VERSION))
                    > (uch)EB_NTSD_MAX_VER)
                    break;

                *p_ebSD_ptr = ef_ptr;
                *p_ebSD_len = eb_len;
     b50:	89 10                	mov    %edx,(%eax)
     b52:	89 f8                	mov    %edi,%eax
     b54:	29 d0                	sub    %edx,%eax
                  eb_id));
                break;
        }

        ef_ptr += (eb_len + EB_HEADSIZE);
        ef_len -= (eb_len + EB_HEADSIZE);
     b56:	01 c5                	add    %eax,%ebp

    if (!uO.X_flag)
        return FALSE;  /* user said don't process ACLs; for now, no other
                          extra block types are handled here */

    while (ef_len >= EB_HEADSIZE)
     b58:	83 fd 03             	cmp    $0x3,%ebp
     b5b:	77 99                	ja     af6 <_FindSDExtraField.isra.2.part.3+0x36>
     b5d:	8d 76 00             	lea    0x0(%esi),%esi
        ef_ptr += (eb_len + EB_HEADSIZE);
        ef_len -= (eb_len + EB_HEADSIZE);
    }

    return rc;
}
     b60:	8b 44 24 18          	mov    0x18(%esp),%eax
     b64:	83 c4 2c             	add    $0x2c,%esp
     b67:	5b                   	pop    %ebx
     b68:	5e                   	pop    %esi
     b69:	5f                   	pop    %edi
     b6a:	5d                   	pop    %ebp
     b6b:	c3                   	ret    

    if (!uO.X_flag)
        return FALSE;  /* user said don't process ACLs; for now, no other
                          extra block types are handled here */

    while (ef_len >= EB_HEADSIZE)
     b6c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
     b73:	00 
     b74:	eb ea                	jmp    b60 <_FindSDExtraField.isra.2.part.3+0xa0>
     b76:	8d 76 00             	lea    0x0(%esi),%esi
     b79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000b80 <_SetFileSize>:
/**************************/
/* Function SetFileSize() */
/**************************/

int SetFileSize(FILE *file, ulg filesize)
{
     b80:	53                   	push   %ebx
     b81:	83 ec 18             	sub    $0x18,%esp
     */
    HANDLE os_fh;

    /* Win9x supports FAT file system, only; presetting file size does
       not help to prevent fragmentation. */
    if (!IsWinNT()) return 0;
     b84:	e8 f7 fe ff ff       	call   a80 <_IsWinNT>
     b89:	85 c0                	test   %eax,%eax
     b8b:	75 05                	jne    b92 <_SetFileSize+0x12>
    if (SetEndOfFile(os_fh) == 0)
        return -1;
    /* move file position pointer back to the start of the file! */
    return (SetFilePointer(os_fh, 0, 0, FILE_BEGIN) == 0xFFFFFFFF) ? -1 : 0;
#endif /* ?__RSXNT__ */
} /* end function SetFileSize() */
     b8d:	83 c4 18             	add    $0x18,%esp
     b90:	5b                   	pop    %ebx
     b91:	c3                   	ret    
       The interface function used to retrieve the Win32 handle for
       a file opened by the C rtl is non-standard and may not be
       available for every Win32 compiler environment.
       (see also win32/win32.c of the Zip distribution)
     */
    os_fh = (HANDLE)_get_osfhandle(fileno(file));
     b92:	8b 44 24 20          	mov    0x20(%esp),%eax
     b96:	8b 40 10             	mov    0x10(%eax),%eax
     b99:	89 04 24             	mov    %eax,(%esp)
     b9c:	e8 00 00 00 00       	call   ba1 <_SetFileSize+0x21>
    /* move file pointer behind the last byte of the expected file size */
    if (SetFilePointer(os_fh, filesize, 0, FILE_BEGIN) == 0xFFFFFFFF)
     ba1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     ba8:	00 
       The interface function used to retrieve the Win32 handle for
       a file opened by the C rtl is non-standard and may not be
       available for every Win32 compiler environment.
       (see also win32/win32.c of the Zip distribution)
     */
    os_fh = (HANDLE)_get_osfhandle(fileno(file));
     ba9:	89 c3                	mov    %eax,%ebx
    /* move file pointer behind the last byte of the expected file size */
    if (SetFilePointer(os_fh, filesize, 0, FILE_BEGIN) == 0xFFFFFFFF)
     bab:	8b 44 24 24          	mov    0x24(%esp),%eax
     baf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     bb6:	00 
     bb7:	89 44 24 04          	mov    %eax,0x4(%esp)
     bbb:	89 1c 24             	mov    %ebx,(%esp)
     bbe:	e8 00 00 00 00       	call   bc3 <_SetFileSize+0x43>
     bc3:	83 ec 10             	sub    $0x10,%esp
     bc6:	40                   	inc    %eax
     bc7:	74 47                	je     c10 <_SetFileSize+0x90>
        return -1;
    /* extend/truncate file to the current position */
    if (SetEndOfFile(os_fh) == 0)
     bc9:	89 1c 24             	mov    %ebx,(%esp)
     bcc:	e8 00 00 00 00       	call   bd1 <_SetFileSize+0x51>
     bd1:	85 c0                	test   %eax,%eax
     bd3:	52                   	push   %edx
     bd4:	74 3a                	je     c10 <_SetFileSize+0x90>
        return -1;
    /* move file position pointer back to the start of the file! */
    return (SetFilePointer(os_fh, 0, 0, FILE_BEGIN) == 0xFFFFFFFF) ? -1 : 0;
     bd6:	89 1c 24             	mov    %ebx,(%esp)
     bd9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     be0:	00 
     be1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     be8:	00 
     be9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     bf0:	00 
     bf1:	e8 00 00 00 00       	call   bf6 <_SetFileSize+0x76>
     bf6:	83 ec 10             	sub    $0x10,%esp
     bf9:	40                   	inc    %eax
     bfa:	0f 94 c0             	sete   %al
#endif /* ?__RSXNT__ */
} /* end function SetFileSize() */
     bfd:	83 c4 18             	add    $0x18,%esp
        return -1;
    /* extend/truncate file to the current position */
    if (SetEndOfFile(os_fh) == 0)
        return -1;
    /* move file position pointer back to the start of the file! */
    return (SetFilePointer(os_fh, 0, 0, FILE_BEGIN) == 0xFFFFFFFF) ? -1 : 0;
     c00:	25 ff 00 00 00       	and    $0xff,%eax
     c05:	f7 d8                	neg    %eax
#endif /* ?__RSXNT__ */
} /* end function SetFileSize() */
     c07:	5b                   	pop    %ebx
     c08:	c3                   	ret    
     c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
       (see also win32/win32.c of the Zip distribution)
     */
    os_fh = (HANDLE)_get_osfhandle(fileno(file));
    /* move file pointer behind the last byte of the expected file size */
    if (SetFilePointer(os_fh, filesize, 0, FILE_BEGIN) == 0xFFFFFFFF)
        return -1;
     c10:	83 c8 ff             	or     $0xffffffff,%eax
     c13:	e9 75 ff ff ff       	jmp    b8d <_SetFileSize+0xd>
     c18:	90                   	nop
     c19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000c20 <_close_outfile>:
/* Function close_outfile() */
/****************************/

void close_outfile(__G)
    __GDEF
{
     c20:	55                   	push   %ebp
     c21:	57                   	push   %edi
     c22:	56                   	push   %esi
     c23:	53                   	push   %ebx
     c24:	83 ec 5c             	sub    $0x5c,%esp
     c27:	8b 5c 24 70          	mov    0x70(%esp),%ebx

    /* Close the file and then re-open it using the Win32
     * CreateFile call, so that the file can be created
     * with GENERIC_WRITE access, otherwise the SetFileTime
     * call will fail. */
    fclose(G.outfile);
     c2b:	8b 83 c8 09 01 00    	mov    0x109c8(%ebx),%eax
     c31:	89 04 24             	mov    %eax,(%esp)
     c34:	e8 00 00 00 00       	call   c39 <_close_outfile+0x19>

    /* don't set the time stamp and attributes on standard output */
    if (uO.cflag)
     c39:	8b 4b 14             	mov    0x14(%ebx),%ecx
     c3c:	85 c9                	test   %ecx,%ecx
     c3e:	74 08                	je     c48 <_close_outfile+0x28>

    return;

#undef Ansi_Fname

} /* end function close_outfile() */
     c40:	83 c4 5c             	add    $0x5c,%esp
     c43:	5b                   	pop    %ebx
     c44:	5e                   	pop    %esi
     c45:	5f                   	pop    %edi
     c46:	5d                   	pop    %ebp
     c47:	c3                   	ret    

    /* don't set the time stamp and attributes on standard output */
    if (uO.cflag)
        return;

    gotTime = getNTfiletime(__G__ &Modft, &Accft, &Creft);
     c48:	8d 44 24 48          	lea    0x48(%esp),%eax
     c4c:	8d 4c 24 40          	lea    0x40(%esp),%ecx
     c50:	89 04 24             	mov    %eax,(%esp)
     c53:	8d 54 24 38          	lea    0x38(%esp),%edx
     c57:	89 d8                	mov    %ebx,%eax

    /* open a handle to the file before processing extra fields;
       we do this in case new security on file prevents us from updating
       time stamps */
    hFile = CreateFile(Ansi_Fname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
     c59:	8d ab e0 09 01 00    	lea    0x109e0(%ebx),%ebp

    /* don't set the time stamp and attributes on standard output */
    if (uO.cflag)
        return;

    gotTime = getNTfiletime(__G__ &Modft, &Accft, &Creft);
     c5f:	e8 fc fb ff ff       	call   860 <_getNTfiletime>

    /* open a handle to the file before processing extra fields;
       we do this in case new security on file prevents us from updating
       time stamps */
    hFile = CreateFile(Ansi_Fname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
     c64:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
     c6b:	00 
     c6c:	c7 44 24 14 80 00 00 	movl   $0x80,0x14(%esp)
     c73:	00 
     c74:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
     c7b:	00 
     c7c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     c83:	00 
     c84:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
     c8b:	00 
     c8c:	c7 44 24 04 00 00 00 	movl   $0x40000000,0x4(%esp)
     c93:	40 
     c94:	89 2c 24             	mov    %ebp,(%esp)

    /* don't set the time stamp and attributes on standard output */
    if (uO.cflag)
        return;

    gotTime = getNTfiletime(__G__ &Modft, &Accft, &Creft);
     c97:	89 c7                	mov    %eax,%edi

    /* open a handle to the file before processing extra fields;
       we do this in case new security on file prevents us from updating
       time stamps */
    hFile = CreateFile(Ansi_Fname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
     c99:	e8 00 00 00 00       	call   c9e <_close_outfile+0x7e>
     c9e:	89 c6                	mov    %eax,%esi
       from succeeding otherwise.  Also, since most files don't have
       any interesting attributes, only change them if something other than
       FILE_ATTRIBUTE_ARCHIVE appears in the attributes.  This works well
       as an optimization because FILE_ATTRIBUTE_ARCHIVE gets applied to the
       file anyway, when it's created new. */
    if((G.pInfo->file_attr & 0x7F) & ~FILE_ATTRIBUTE_ARCHIVE) {
     ca0:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
    gotTime = getNTfiletime(__G__ &Modft, &Accft, &Creft);

    /* open a handle to the file before processing extra fields;
       we do this in case new security on file prevents us from updating
       time stamps */
    hFile = CreateFile(Ansi_Fname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
     ca6:	83 ec 1c             	sub    $0x1c,%esp
       from succeeding otherwise.  Also, since most files don't have
       any interesting attributes, only change them if something other than
       FILE_ATTRIBUTE_ARCHIVE appears in the attributes.  This works well
       as an optimization because FILE_ATTRIBUTE_ARCHIVE gets applied to the
       file anyway, when it's created new. */
    if((G.pInfo->file_attr & 0x7F) & ~FILE_ATTRIBUTE_ARCHIVE) {
     ca9:	8b 40 14             	mov    0x14(%eax),%eax
     cac:	a8 5f                	test   $0x5f,%al
     cae:	0f 85 bd 00 00 00    	jne    d71 <_close_outfile+0x151>
              (int)GetLastError()));
    }

#ifdef NTSD_EAS
    /* set NTFS SD extra fields */
    if (G.extra_field &&    /* zipfile extra field may have extended attribs */
     cb4:	8b 83 18 09 01 00    	mov    0x10918(%ebx),%eax
     cba:	85 c0                	test   %eax,%eax
     cbc:	74 11                	je     ccf <_close_outfile+0xaf>
                            uch *ef_ptr, unsigned ef_len,
                            uch **p_ebSD_ptr, unsigned *p_ebSD_len)
{
    int rc = FALSE;

    if (!uO.X_flag)
     cbe:	8b 4b 5c             	mov    0x5c(%ebx),%ecx
    }

#ifdef NTSD_EAS
    /* set NTFS SD extra fields */
    if (G.extra_field &&    /* zipfile extra field may have extended attribs */
        FindSDExtraField(__G__ G.extra_field, G.lrec.extra_field_length,
     cc1:	8b 93 38 09 01 00    	mov    0x10938(%ebx),%edx
                            uch *ef_ptr, unsigned ef_len,
                            uch **p_ebSD_ptr, unsigned *p_ebSD_len)
{
    int rc = FALSE;

    if (!uO.X_flag)
     cc7:	85 c9                	test   %ecx,%ecx
     cc9:	0f 85 11 01 00 00    	jne    de0 <_close_outfile+0x1c0>
              ebSDlen-(EB_NTSD_L_LEN+EB_CMPRHEADLEN), uO.qflag? "\n":""));
        }
    }
#endif /* NTSD_EAS */

    if ( hFile == INVALID_HANDLE_VALUE )
     ccf:	83 fe ff             	cmp    $0xffffffff,%esi
     cd2:	0f 84 ae 01 00 00    	je     e86 <_close_outfile+0x266>
        Info(slide, 1, ((char *)slide,
          "\nCreateFile() error %d when trying set file time\n",
          (int)GetLastError()));
    else {
        if (gotTime) {
     cd8:	85 ff                	test   %edi,%edi
     cda:	0f 84 80 00 00 00    	je     d60 <_close_outfile+0x140>
            FILETIME *pModft = (gotTime & EB_UT_FL_MTIME) ? &Modft : NULL;
     ce0:	31 c0                	xor    %eax,%eax
     ce2:	8d 4c 24 38          	lea    0x38(%esp),%ecx
            FILETIME *pAccft = (gotTime & EB_UT_FL_ATIME) ? &Accft : NULL;
     ce6:	8d 54 24 40          	lea    0x40(%esp),%edx
            FILETIME *pCreft = (gotTime & EB_UT_FL_CTIME) ? &Creft : NULL;

            if (!SetFileTime(hFile, pCreft, pAccft, pModft))
     cea:	89 34 24             	mov    %esi,(%esp)
        Info(slide, 1, ((char *)slide,
          "\nCreateFile() error %d when trying set file time\n",
          (int)GetLastError()));
    else {
        if (gotTime) {
            FILETIME *pModft = (gotTime & EB_UT_FL_MTIME) ? &Modft : NULL;
     ced:	f7 c7 01 00 00 00    	test   $0x1,%edi
     cf3:	0f 44 c8             	cmove  %eax,%ecx
            FILETIME *pAccft = (gotTime & EB_UT_FL_ATIME) ? &Accft : NULL;
     cf6:	f7 c7 02 00 00 00    	test   $0x2,%edi
     cfc:	0f 44 d0             	cmove  %eax,%edx
            FILETIME *pCreft = (gotTime & EB_UT_FL_CTIME) ? &Creft : NULL;
     cff:	83 e7 04             	and    $0x4,%edi
     d02:	8d 7c 24 48          	lea    0x48(%esp),%edi
     d06:	0f 45 c7             	cmovne %edi,%eax

            if (!SetFileTime(hFile, pCreft, pAccft, pModft))
     d09:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     d0d:	89 54 24 08          	mov    %edx,0x8(%esp)
     d11:	89 44 24 04          	mov    %eax,0x4(%esp)
     d15:	e8 00 00 00 00       	call   d1a <_close_outfile+0xfa>
     d1a:	83 ec 10             	sub    $0x10,%esp
     d1d:	85 c0                	test   %eax,%eax
     d1f:	75 3f                	jne    d60 <_close_outfile+0x140>
                Info(slide, 0, ((char *)slide, "\nSetFileTime failed: %d\n",
     d21:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
     d27:	e8 00 00 00 00       	call   d2c <_close_outfile+0x10c>
     d2c:	8d bb dc 08 00 00    	lea    0x8dc(%ebx),%edi
     d32:	89 44 24 08          	mov    %eax,0x8(%esp)
     d36:	c7 44 24 04 66 01 00 	movl   $0x166,0x4(%esp)
     d3d:	00 
     d3e:	89 3c 24             	mov    %edi,(%esp)
     d41:	e8 00 00 00 00       	call   d46 <_close_outfile+0x126>
     d46:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     d4d:	00 
     d4e:	89 44 24 08          	mov    %eax,0x8(%esp)
     d52:	89 7c 24 04          	mov    %edi,0x4(%esp)
     d56:	89 1c 24             	mov    %ebx,(%esp)
     d59:	ff d5                	call   *%ebp
     d5b:	83 ec 10             	sub    $0x10,%esp
     d5e:	66 90                	xchg   %ax,%ax
                  (int)GetLastError()));
        }
        CloseHandle(hFile);
     d60:	89 34 24             	mov    %esi,(%esp)
     d63:	e8 00 00 00 00       	call   d68 <_close_outfile+0x148>
     d68:	50                   	push   %eax

    return;

#undef Ansi_Fname

} /* end function close_outfile() */
     d69:	83 c4 5c             	add    $0x5c,%esp
     d6c:	5b                   	pop    %ebx
     d6d:	5e                   	pop    %esi
     d6e:	5f                   	pop    %edi
     d6f:	5d                   	pop    %ebp
     d70:	c3                   	ret    
       any interesting attributes, only change them if something other than
       FILE_ATTRIBUTE_ARCHIVE appears in the attributes.  This works well
       as an optimization because FILE_ATTRIBUTE_ARCHIVE gets applied to the
       file anyway, when it's created new. */
    if((G.pInfo->file_attr & 0x7F) & ~FILE_ATTRIBUTE_ARCHIVE) {
        if (!SetFileAttributes(Ansi_Fname, G.pInfo->file_attr & 0x7F))
     d71:	83 e0 7f             	and    $0x7f,%eax
     d74:	89 2c 24             	mov    %ebp,(%esp)
     d77:	89 44 24 04          	mov    %eax,0x4(%esp)
     d7b:	e8 00 00 00 00       	call   d80 <_close_outfile+0x160>
     d80:	85 c0                	test   %eax,%eax
     d82:	52                   	push   %edx
     d83:	52                   	push   %edx
     d84:	0f 85 2a ff ff ff    	jne    cb4 <_close_outfile+0x94>
            Info(slide, 1, ((char *)slide,
     d8a:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
     d90:	89 44 24 28          	mov    %eax,0x28(%esp)
     d94:	e8 00 00 00 00       	call   d99 <_close_outfile+0x179>
     d99:	8d 93 dc 08 00 00    	lea    0x8dc(%ebx),%edx
     d9f:	89 44 24 08          	mov    %eax,0x8(%esp)
     da3:	89 14 24             	mov    %edx,(%esp)
     da6:	c7 44 24 04 fc 00 00 	movl   $0xfc,0x4(%esp)
     dad:	00 
     dae:	89 54 24 2c          	mov    %edx,0x2c(%esp)
     db2:	e8 00 00 00 00       	call   db7 <_close_outfile+0x197>
     db7:	8b 54 24 2c          	mov    0x2c(%esp),%edx
     dbb:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
     dc2:	00 
     dc3:	89 44 24 08          	mov    %eax,0x8(%esp)
     dc7:	89 54 24 04          	mov    %edx,0x4(%esp)
     dcb:	89 1c 24             	mov    %ebx,(%esp)
     dce:	ff 54 24 28          	call   *0x28(%esp)
     dd2:	83 ec 10             	sub    $0x10,%esp
     dd5:	e9 da fe ff ff       	jmp    cb4 <_close_outfile+0x94>
     dda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     de0:	8d 4c 24 34          	lea    0x34(%esp),%ecx
    }

#ifdef NTSD_EAS
    /* set NTFS SD extra fields */
    if (G.extra_field &&    /* zipfile extra field may have extended attribs */
        FindSDExtraField(__G__ G.extra_field, G.lrec.extra_field_length,
     de4:	81 e2 ff ff 00 00    	and    $0xffff,%edx
     dea:	89 0c 24             	mov    %ecx,(%esp)
     ded:	8d 4c 24 30          	lea    0x30(%esp),%ecx
     df1:	e8 ca fc ff ff       	call   ac0 <_FindSDExtraField.isra.2.part.3>
              (int)GetLastError()));
    }

#ifdef NTSD_EAS
    /* set NTFS SD extra fields */
    if (G.extra_field &&    /* zipfile extra field may have extended attribs */
     df6:	85 c0                	test   %eax,%eax
     df8:	0f 84 d1 fe ff ff    	je     ccf <_close_outfile+0xaf>
        FindSDExtraField(__G__ G.extra_field, G.lrec.extra_field_length,
                         &ebSDptr, &ebSDlen))
    {
        int err = SetSD(__G__ Ansi_Fname, G.pInfo->file_attr,
     dfe:	8b 83 d8 08 00 00    	mov    0x8d8(%ebx),%eax
     e04:	89 ea                	mov    %ebp,%edx
     e06:	8b 48 14             	mov    0x14(%eax),%ecx
     e09:	8b 44 24 34          	mov    0x34(%esp),%eax
     e0d:	89 44 24 04          	mov    %eax,0x4(%esp)
     e11:	8b 44 24 30          	mov    0x30(%esp),%eax
     e15:	89 04 24             	mov    %eax,(%esp)
     e18:	89 d8                	mov    %ebx,%eax
     e1a:	e8 e1 f3 ff ff       	call   200 <_SetSD>
                        ebSDptr, ebSDlen);

        if (err == IZ_EF_TRUNC) {
     e1f:	83 f8 4f             	cmp    $0x4f,%eax
     e22:	0f 85 a7 fe ff ff    	jne    ccf <_close_outfile+0xaf>
            if (uO.qflag)
     e28:	8b 4b 38             	mov    0x38(%ebx),%ecx
                Info(slide, 1, ((char *)slide, "%-22s ",
     e2b:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
    {
        int err = SetSD(__G__ Ansi_Fname, G.pInfo->file_attr,
                        ebSDptr, ebSDlen);

        if (err == IZ_EF_TRUNC) {
            if (uO.qflag)
     e31:	85 c9                	test   %ecx,%ecx
                Info(slide, 1, ((char *)slide, "%-22s ",
     e33:	89 44 24 28          	mov    %eax,0x28(%esp)
    {
        int err = SetSD(__G__ Ansi_Fname, G.pInfo->file_attr,
                        ebSDptr, ebSDlen);

        if (err == IZ_EF_TRUNC) {
            if (uO.qflag)
     e37:	0f 85 8b 00 00 00    	jne    ec8 <_close_outfile+0x2a8>
     e3d:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
                Info(slide, 1, ((char *)slide, "%-22s ",
                  FnFilter1(G.filename)));
            Info(slide, 1, ((char *)slide, LoadFarString(TruncNTSD),
     e43:	b8 fa 00 00 00       	mov    $0xfa,%eax
     e48:	89 44 24 0c          	mov    %eax,0xc(%esp)
     e4c:	8b 44 24 34          	mov    0x34(%esp),%eax
     e50:	83 e8 0b             	sub    $0xb,%eax
     e53:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     e5a:	00 
     e5b:	89 44 24 08          	mov    %eax,0x8(%esp)
     e5f:	89 2c 24             	mov    %ebp,(%esp)
     e62:	e8 00 00 00 00       	call   e67 <_close_outfile+0x247>
     e67:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
     e6e:	00 
     e6f:	89 44 24 08          	mov    %eax,0x8(%esp)
     e73:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     e77:	89 1c 24             	mov    %ebx,(%esp)
     e7a:	ff 54 24 28          	call   *0x28(%esp)
     e7e:	83 ec 10             	sub    $0x10,%esp
     e81:	e9 49 fe ff ff       	jmp    ccf <_close_outfile+0xaf>
        }
    }
#endif /* NTSD_EAS */

    if ( hFile == INVALID_HANDLE_VALUE )
        Info(slide, 1, ((char *)slide,
     e86:	8b bb 44 0b 01 00    	mov    0x10b44(%ebx),%edi
     e8c:	e8 00 00 00 00       	call   e91 <_close_outfile+0x271>
     e91:	8d b3 dc 08 00 00    	lea    0x8dc(%ebx),%esi
     e97:	89 44 24 08          	mov    %eax,0x8(%esp)
     e9b:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
     ea2:	00 
     ea3:	89 34 24             	mov    %esi,(%esp)
     ea6:	e8 00 00 00 00       	call   eab <_close_outfile+0x28b>
     eab:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
     eb2:	00 
     eb3:	89 44 24 08          	mov    %eax,0x8(%esp)
     eb7:	89 74 24 04          	mov    %esi,0x4(%esp)
     ebb:	89 1c 24             	mov    %ebx,(%esp)
     ebe:	ff d7                	call   *%edi
     ec0:	83 ec 10             	sub    $0x10,%esp
     ec3:	e9 78 fd ff ff       	jmp    c40 <_close_outfile+0x20>
        int err = SetSD(__G__ Ansi_Fname, G.pInfo->file_attr,
                        ebSDptr, ebSDlen);

        if (err == IZ_EF_TRUNC) {
            if (uO.qflag)
                Info(slide, 1, ((char *)slide, "%-22s ",
     ec8:	8d 83 dc 88 00 00    	lea    0x88dc(%ebx),%eax
     ece:	89 2c 24             	mov    %ebp,(%esp)
     ed1:	89 44 24 04          	mov    %eax,0x4(%esp)
     ed5:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     edb:	e8 00 00 00 00       	call   ee0 <_close_outfile+0x2c0>
     ee0:	c7 44 24 04 2a 01 00 	movl   $0x12a,0x4(%esp)
     ee7:	00 
     ee8:	89 44 24 08          	mov    %eax,0x8(%esp)
     eec:	89 2c 24             	mov    %ebp,(%esp)
     eef:	e8 00 00 00 00       	call   ef4 <_close_outfile+0x2d4>
     ef4:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
     efb:	00 
     efc:	89 44 24 08          	mov    %eax,0x8(%esp)
     f00:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     f04:	89 1c 24             	mov    %ebx,(%esp)
     f07:	ff 54 24 28          	call   *0x28(%esp)
                  FnFilter1(G.filename)));
            Info(slide, 1, ((char *)slide, LoadFarString(TruncNTSD),
     f0b:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
        int err = SetSD(__G__ Ansi_Fname, G.pInfo->file_attr,
                        ebSDptr, ebSDlen);

        if (err == IZ_EF_TRUNC) {
            if (uO.qflag)
                Info(slide, 1, ((char *)slide, "%-22s ",
     f11:	83 ec 10             	sub    $0x10,%esp
                  FnFilter1(G.filename)));
            Info(slide, 1, ((char *)slide, LoadFarString(TruncNTSD),
     f14:	8b 53 38             	mov    0x38(%ebx),%edx
     f17:	b9 fa 00 00 00       	mov    $0xfa,%ecx
     f1c:	85 d2                	test   %edx,%edx
     f1e:	89 44 24 28          	mov    %eax,0x28(%esp)
     f22:	b8 f8 00 00 00       	mov    $0xf8,%eax
     f27:	0f 44 c1             	cmove  %ecx,%eax
     f2a:	e9 19 ff ff ff       	jmp    e48 <_close_outfile+0x228>
     f2f:	90                   	nop

00000f30 <_defer_dir_attribs>:
#ifdef SET_DIR_ATTRIB

int defer_dir_attribs(__G__ pd)
    __GDEF
    direntry **pd;
{
     f30:	55                   	push   %ebp
     f31:	57                   	push   %edi
     f32:	56                   	push   %esi
     f33:	53                   	push   %ebx
     f34:	83 ec 2c             	sub    $0x2c,%esp
     f37:	8b 74 24 40          	mov    0x40(%esp),%esi
    uch *ebSDptr;
    unsigned ebSDlen;
#endif

    /* Win9x does not support setting directory time stamps. */
    if (!IsWinNT()) {
     f3b:	e8 40 fb ff ff       	call   a80 <_IsWinNT>
     f40:	85 c0                	test   %eax,%eax
     f42:	0f 84 90 00 00 00    	je     fd8 <_defer_dir_attribs+0xa8>
        return PK_OK;
    }

#ifdef NTSD_EAS
    /* set extended attributes from extra fields */
    if (G.extra_field &&  /* zipfile e.f. may have extended attribs */
     f48:	8b 86 18 09 01 00    	mov    0x10918(%esi),%eax
     f4e:	85 c0                	test   %eax,%eax
     f50:	74 11                	je     f63 <_defer_dir_attribs+0x33>
                            uch *ef_ptr, unsigned ef_len,
                            uch **p_ebSD_ptr, unsigned *p_ebSD_len)
{
    int rc = FALSE;

    if (!uO.X_flag)
     f52:	8b 4e 5c             	mov    0x5c(%esi),%ecx
    }

#ifdef NTSD_EAS
    /* set extended attributes from extra fields */
    if (G.extra_field &&  /* zipfile e.f. may have extended attribs */
        FindSDExtraField(__G__ G.extra_field, G.lrec.extra_field_length,
     f55:	8b 96 38 09 01 00    	mov    0x10938(%esi),%edx
                            uch *ef_ptr, unsigned ef_len,
                            uch **p_ebSD_ptr, unsigned *p_ebSD_len)
{
    int rc = FALSE;

    if (!uO.X_flag)
     f5b:	85 c9                	test   %ecx,%ecx
     f5d:	0f 85 8d 00 00 00    	jne    ff0 <_defer_dir_attribs+0xc0>

    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
     f63:	8d be e0 09 01 00    	lea    0x109e0(%esi),%edi
        /* ebSDlen contains the payload size of the e.f. block, but
           we store it including the e.b. header. */
        ebSDlen += EB_HEADSIZE;
    } else {
        /* no NTSD e.f. block -> no space needed to allocate */
        ebSDlen = 0;
     f69:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
     f70:	00 

    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
     f71:	89 3c 24             	mov    %edi,(%esp)
     f74:	e8 00 00 00 00       	call   f79 <_defer_dir_attribs+0x49>
        /* no NTSD e.f. block -> no space needed to allocate */
        ebSDlen = 0;
    }
#endif /* NTSD_EAS */

    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
     f79:	83 c0 30             	add    $0x30,%eax
     f7c:	89 04 24             	mov    %eax,(%esp)
     f7f:	e8 00 00 00 00       	call   f84 <_defer_dir_attribs+0x54>
     f84:	89 c3                	mov    %eax,%ebx
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
    *pd = (direntry *)d_entry;
     f86:	8b 44 24 44          	mov    0x44(%esp),%eax
    if (d_entry == (NTdirattr *)NULL) {
     f8a:	85 db                	test   %ebx,%ebx
    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
    *pd = (direntry *)d_entry;
     f8c:	89 18                	mov    %ebx,(%eax)
    if (d_entry == (NTdirattr *)NULL) {
     f8e:	0f 84 cf 00 00 00    	je     1063 <_defer_dir_attribs+0x133>

    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
     f94:	31 ed                	xor    %ebp,%ebp
    }
#ifdef NTSD_EAS
    if (ebSDlen > 0)
        memcpy(d_entry->buf, ebSDptr, ebSDlen);
    d_entry->SDlen = ebSDlen;
    d_entry->fn = d_entry->buf + ebSDlen;
     f96:	8d 44 2b 2c          	lea    0x2c(%ebx,%ebp,1),%eax
        return PK_MEM;
    }
#ifdef NTSD_EAS
    if (ebSDlen > 0)
        memcpy(d_entry->buf, ebSDptr, ebSDlen);
    d_entry->SDlen = ebSDlen;
     f9a:	89 6b 28             	mov    %ebp,0x28(%ebx)
    d_entry->fn = d_entry->buf + ebSDlen;
     f9d:	89 43 04             	mov    %eax,0x4(%ebx)
#else
    d_entry->fn = d_entry->buf;
#endif

    strcpy(d_entry->fn, G.filename);
     fa0:	89 7c 24 04          	mov    %edi,0x4(%esp)
     fa4:	89 04 24             	mov    %eax,(%esp)
     fa7:	e8 00 00 00 00       	call   fac <_defer_dir_attribs+0x7c>

    d_entry->perms = G.pInfo->file_attr;
     fac:	8b 86 d8 08 00 00    	mov    0x8d8(%esi),%eax
     fb2:	8b 40 14             	mov    0x14(%eax),%eax

    d_entry->gotTime = getNTfiletime(__G__ &(d_entry->Modft),
     fb5:	8d 4b 10             	lea    0x10(%ebx),%ecx
    d_entry->fn = d_entry->buf;
#endif

    strcpy(d_entry->fn, G.filename);

    d_entry->perms = G.pInfo->file_attr;
     fb8:	89 43 24             	mov    %eax,0x24(%ebx)

    d_entry->gotTime = getNTfiletime(__G__ &(d_entry->Modft),
     fbb:	8d 43 18             	lea    0x18(%ebx),%eax
     fbe:	89 04 24             	mov    %eax,(%esp)
     fc1:	8d 53 08             	lea    0x8(%ebx),%edx
     fc4:	89 f0                	mov    %esi,%eax
     fc6:	e8 95 f8 ff ff       	call   860 <_getNTfiletime>
     fcb:	89 43 20             	mov    %eax,0x20(%ebx)
                                     &(d_entry->Accft), &(d_entry->Creft));
    return PK_OK;
} /* end function defer_dir_attribs() */
     fce:	83 c4 2c             	add    $0x2c,%esp

    d_entry->perms = G.pInfo->file_attr;

    d_entry->gotTime = getNTfiletime(__G__ &(d_entry->Modft),
                                     &(d_entry->Accft), &(d_entry->Creft));
    return PK_OK;
     fd1:	31 c0                	xor    %eax,%eax
} /* end function defer_dir_attribs() */
     fd3:	5b                   	pop    %ebx
     fd4:	5e                   	pop    %esi
     fd5:	5f                   	pop    %edi
     fd6:	5d                   	pop    %ebp
     fd7:	c3                   	ret    
    unsigned ebSDlen;
#endif

    /* Win9x does not support setting directory time stamps. */
    if (!IsWinNT()) {
        *pd = (direntry *)NULL;
     fd8:	8b 7c 24 44          	mov    0x44(%esp),%edi
     fdc:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    d_entry->perms = G.pInfo->file_attr;

    d_entry->gotTime = getNTfiletime(__G__ &(d_entry->Modft),
                                     &(d_entry->Accft), &(d_entry->Creft));
    return PK_OK;
} /* end function defer_dir_attribs() */
     fe2:	83 c4 2c             	add    $0x2c,%esp
     fe5:	5b                   	pop    %ebx
     fe6:	5e                   	pop    %esi
     fe7:	5f                   	pop    %edi
     fe8:	5d                   	pop    %ebp
     fe9:	c3                   	ret    
     fea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     ff0:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
    }

#ifdef NTSD_EAS
    /* set extended attributes from extra fields */
    if (G.extra_field &&  /* zipfile e.f. may have extended attribs */
        FindSDExtraField(__G__ G.extra_field, G.lrec.extra_field_length,
     ff4:	81 e2 ff ff 00 00    	and    $0xffff,%edx
     ffa:	89 0c 24             	mov    %ecx,(%esp)
     ffd:	8d 4c 24 18          	lea    0x18(%esp),%ecx
    1001:	e8 ba fa ff ff       	call   ac0 <_FindSDExtraField.isra.2.part.3>
        return PK_OK;
    }

#ifdef NTSD_EAS
    /* set extended attributes from extra fields */
    if (G.extra_field &&  /* zipfile e.f. may have extended attribs */
    1006:	85 c0                	test   %eax,%eax
    1008:	0f 84 55 ff ff ff    	je     f63 <_defer_dir_attribs+0x33>
        FindSDExtraField(__G__ G.extra_field, G.lrec.extra_field_length,
                         &ebSDptr, &ebSDlen)) {
        /* ebSDlen contains the payload size of the e.f. block, but
           we store it including the e.b. header. */
        ebSDlen += EB_HEADSIZE;
    100e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx

    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
    1012:	8d be e0 09 01 00    	lea    0x109e0(%esi),%edi
    1018:	89 3c 24             	mov    %edi,(%esp)
    if (G.extra_field &&  /* zipfile e.f. may have extended attribs */
        FindSDExtraField(__G__ G.extra_field, G.lrec.extra_field_length,
                         &ebSDptr, &ebSDlen)) {
        /* ebSDlen contains the payload size of the e.f. block, but
           we store it including the e.b. header. */
        ebSDlen += EB_HEADSIZE;
    101b:	8d 6b 04             	lea    0x4(%ebx),%ebp
    101e:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)

    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
    1022:	e8 00 00 00 00       	call   1027 <_defer_dir_attribs+0xf7>
        /* no NTSD e.f. block -> no space needed to allocate */
        ebSDlen = 0;
    }
#endif /* NTSD_EAS */

    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
    1027:	8d 44 03 34          	lea    0x34(%ebx,%eax,1),%eax
    102b:	89 04 24             	mov    %eax,(%esp)
    102e:	e8 00 00 00 00       	call   1033 <_defer_dir_attribs+0x103>
    1033:	89 c3                	mov    %eax,%ebx
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
    *pd = (direntry *)d_entry;
    1035:	8b 44 24 44          	mov    0x44(%esp),%eax
    if (d_entry == (NTdirattr *)NULL) {
    1039:	85 db                	test   %ebx,%ebx
    d_entry = (NTdirattr *)malloc(sizeof(NTdirattr)
#ifdef NTSD_EAS
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
    *pd = (direntry *)d_entry;
    103b:	89 18                	mov    %ebx,(%eax)
    if (d_entry == (NTdirattr *)NULL) {
    103d:	74 24                	je     1063 <_defer_dir_attribs+0x133>
        return PK_MEM;
    }
#ifdef NTSD_EAS
    if (ebSDlen > 0)
    103f:	85 ed                	test   %ebp,%ebp
    1041:	0f 84 4f ff ff ff    	je     f96 <_defer_dir_attribs+0x66>
        memcpy(d_entry->buf, ebSDptr, ebSDlen);
    1047:	8d 43 2c             	lea    0x2c(%ebx),%eax
    104a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    104e:	89 6c 24 08          	mov    %ebp,0x8(%esp)
    1052:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    1056:	89 04 24             	mov    %eax,(%esp)
    1059:	e8 00 00 00 00       	call   105e <_defer_dir_attribs+0x12e>
    105e:	e9 33 ff ff ff       	jmp    f96 <_defer_dir_attribs+0x66>
    d_entry->perms = G.pInfo->file_attr;

    d_entry->gotTime = getNTfiletime(__G__ &(d_entry->Modft),
                                     &(d_entry->Accft), &(d_entry->Creft));
    return PK_OK;
} /* end function defer_dir_attribs() */
    1063:	83 c4 2c             	add    $0x2c,%esp
                                  + ebSDlen
#endif
                                  + strlen(G.filename));
    *pd = (direntry *)d_entry;
    if (d_entry == (NTdirattr *)NULL) {
        return PK_MEM;
    1066:	b8 04 00 00 00       	mov    $0x4,%eax
    d_entry->perms = G.pInfo->file_attr;

    d_entry->gotTime = getNTfiletime(__G__ &(d_entry->Modft),
                                     &(d_entry->Accft), &(d_entry->Creft));
    return PK_OK;
} /* end function defer_dir_attribs() */
    106b:	5b                   	pop    %ebx
    106c:	5e                   	pop    %esi
    106d:	5f                   	pop    %edi
    106e:	5d                   	pop    %ebp
    106f:	c3                   	ret    

00001070 <_set_direc_attribs>:


int set_direc_attribs(__G__ d)
    __GDEF
    direntry *d;
{
    1070:	55                   	push   %ebp
    1071:	57                   	push   %edi
    1072:	56                   	push   %esi
    1073:	53                   	push   %ebx
    1074:	83 ec 3c             	sub    $0x3c,%esp
    1077:	8b 74 24 54          	mov    0x54(%esp),%esi
#ifdef __RSXNT__
    char *ansi_name;
#endif

    /* Win9x does not support setting directory time stamps. */
    if (!IsWinNT())
    107b:	e8 00 fa ff ff       	call   a80 <_IsWinNT>
    1080:	85 c0                	test   %eax,%eax
    1082:	75 0c                	jne    1090 <_set_direc_attribs+0x20>
        }
        CloseHandle(hFile);
    }

    return errval;
} /* end function set_direc_attribs() */
    1084:	83 c4 3c             	add    $0x3c,%esp
    1087:	5b                   	pop    %ebx
    1088:	5e                   	pop    %esi
    1089:	5f                   	pop    %edi
    108a:	5d                   	pop    %ebp
    108b:	c3                   	ret    
    108c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
       access flag to create the handle for SetFileTime(), this is too
       demanding for directories with the "read-only" attribute bit set.
       So we use the more specific flag FILE_WRITE_ATTRIBUTES here to
       request the minimum required access rights. (This problem is a
       Windows bug that has been silently fixed in Windows XP SP2.) */
    hFile = CreateFile(Ansi_Dirname, FILE_WRITE_ATTRIBUTES,
    1090:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    1097:	00 
    1098:	c7 44 24 14 00 00 00 	movl   $0x2000000,0x14(%esp)
    109f:	02 
    10a0:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
    10a7:	00 
    10a8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    10af:	00 
    10b0:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    10b7:	00 
    10b8:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
    10bf:	00 
    10c0:	8b 46 04             	mov    0x4(%esi),%eax
    10c3:	89 04 24             	mov    %eax,(%esp)
    10c6:	e8 00 00 00 00       	call   10cb <_set_direc_attribs+0x5b>
    10cb:	89 c7                	mov    %eax,%edi
                       FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

#ifdef NTSD_EAS
    if (NtAtt(d)->SDlen > 0) {
    10cd:	8b 46 28             	mov    0x28(%esi),%eax
       access flag to create the handle for SetFileTime(), this is too
       demanding for directories with the "read-only" attribute bit set.
       So we use the more specific flag FILE_WRITE_ATTRIBUTES here to
       request the minimum required access rights. (This problem is a
       Windows bug that has been silently fixed in Windows XP SP2.) */
    hFile = CreateFile(Ansi_Dirname, FILE_WRITE_ATTRIBUTES,
    10d0:	83 ec 1c             	sub    $0x1c,%esp
                       FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

#ifdef NTSD_EAS
    if (NtAtt(d)->SDlen > 0) {
    10d3:	85 c0                	test   %eax,%eax
    10d5:	0f 84 b8 00 00 00    	je     1193 <_set_direc_attribs+0x123>
        int err;

        if (QCOND2) {
    10db:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    10df:	8b 59 38             	mov    0x38(%ecx),%ebx
    10e2:	85 db                	test   %ebx,%ebx
    10e4:	0f 84 86 01 00 00    	je     1270 <_set_direc_attribs+0x200>
            Info(slide, 1, ((char *)slide, " set attrib: %-22s  ",
              FnFilter1(d->fn)));
        }

        /* set NTFS SD extra fields */
        err = SetSD(__G__ Ansi_Dirname, NtAtt(d)->perms,
    10ea:	83 e8 04             	sub    $0x4,%eax
    10ed:	8b 4e 24             	mov    0x24(%esi),%ecx
    10f0:	8b 56 04             	mov    0x4(%esi),%edx
    10f3:	89 44 24 04          	mov    %eax,0x4(%esp)
                        NtAtt(d)->buf, NtAtt(d)->SDlen - EB_HEADSIZE);
    10f7:	8d 46 2c             	lea    0x2c(%esi),%eax
    10fa:	89 04 24             	mov    %eax,(%esp)
            Info(slide, 1, ((char *)slide, " set attrib: %-22s  ",
              FnFilter1(d->fn)));
        }

        /* set NTFS SD extra fields */
        err = SetSD(__G__ Ansi_Dirname, NtAtt(d)->perms,
    10fd:	8b 44 24 50          	mov    0x50(%esp),%eax
    1101:	e8 fa f0 ff ff       	call   200 <_SetSD>
    1106:	89 c3                	mov    %eax,%ebx
                        NtAtt(d)->buf, NtAtt(d)->SDlen - EB_HEADSIZE);
        if (err == IZ_EF_TRUNC) {
            if (!QCOND2)
    1108:	8b 44 24 50          	mov    0x50(%esp),%eax
        }

        /* set NTFS SD extra fields */
        err = SetSD(__G__ Ansi_Dirname, NtAtt(d)->perms,
                        NtAtt(d)->buf, NtAtt(d)->SDlen - EB_HEADSIZE);
        if (err == IZ_EF_TRUNC) {
    110c:	83 fb 4f             	cmp    $0x4f,%ebx
    110f:	0f 84 bb 01 00 00    	je     12d0 <_set_direc_attribs+0x260>
            if (!QCOND2)
                Info(slide, 1, ((char *)slide, "%-22s  ",
                  FnFilter1(d->fn)));
            Info(slide, 1, ((char *)slide, LoadFarString(TruncNTSD),
              NtAtt(d)->SDlen-(EB_NTSD_L_LEN+EB_CMPRHEADLEN), "\n"));
        } else if (QCOND2) {
    1115:	8b 50 38             	mov    0x38(%eax),%edx
    1118:	85 d2                	test   %edx,%edx
    111a:	0f 84 78 02 00 00    	je     1398 <_set_direc_attribs+0x328>
            Info(slide, 0, ((char *)slide, "\n"));
        }
        if (errval < err)
    1120:	85 db                	test   %ebx,%ebx
    1122:	7e 6f                	jle    1193 <_set_direc_attribs+0x123>
            errval = err;
    }
#endif /* NTSD_EAS */

    if (hFile == INVALID_HANDLE_VALUE) {
    1124:	83 ff ff             	cmp    $0xffffffff,%edi
    1127:	75 75                	jne    119e <_set_direc_attribs+0x12e>
        Info(slide, 1, ((char *)slide,
    1129:	8b 44 24 50          	mov    0x50(%esp),%eax
    112d:	05 dc 88 00 00       	add    $0x88dc,%eax
    1132:	8b b8 68 82 00 00    	mov    0x8268(%eax),%edi
    1138:	89 44 24 04          	mov    %eax,0x4(%esp)
    113c:	8b 46 04             	mov    0x4(%esi),%eax
    113f:	89 04 24             	mov    %eax,(%esp)
    1142:	e8 00 00 00 00       	call   1147 <_set_direc_attribs+0xd7>
    1147:	89 c5                	mov    %eax,%ebp
    1149:	e8 00 00 00 00       	call   114e <_set_direc_attribs+0xde>
    114e:	8b 54 24 50          	mov    0x50(%esp),%edx
    1152:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
    1156:	89 44 24 08          	mov    %eax,0x8(%esp)
    115a:	c7 44 24 04 c8 01 00 	movl   $0x1c8,0x4(%esp)
    1161:	00 
    1162:	8d b2 dc 08 00 00    	lea    0x8dc(%edx),%esi
    1168:	89 34 24             	mov    %esi,(%esp)
    116b:	e8 00 00 00 00       	call   1170 <_set_direc_attribs+0x100>
    1170:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    1177:	00 
    1178:	89 44 24 08          	mov    %eax,0x8(%esp)
    117c:	8b 44 24 50          	mov    0x50(%esp),%eax
    1180:	89 74 24 04          	mov    %esi,0x4(%esp)
    1184:	89 04 24             	mov    %eax,(%esp)
    1187:	ff d7                	call   *%edi
    1189:	89 d8                	mov    %ebx,%eax
    118b:	83 ec 10             	sub    $0x10,%esp
    118e:	e9 f1 fe ff ff       	jmp    1084 <_set_direc_attribs+0x14>
        if (errval < err)
            errval = err;
    }
#endif /* NTSD_EAS */

    if (hFile == INVALID_HANDLE_VALUE) {
    1193:	83 ff ff             	cmp    $0xffffffff,%edi
    1196:	0f 84 3f 02 00 00    	je     13db <_set_direc_attribs+0x36b>
    119c:	31 db                	xor    %ebx,%ebx
          "warning: CreateFile() error %d (set file times for %s)\n",
          (int)GetLastError(), FnFilter1(d->fn)));
        if (!errval)
            errval = PK_WARN;
    } else {
        if (NtAtt(d)->gotTime) {
    119e:	8b 46 20             	mov    0x20(%esi),%eax
    11a1:	85 c0                	test   %eax,%eax
    11a3:	0f 84 ad 00 00 00    	je     1256 <_set_direc_attribs+0x1e6>
            FILETIME *pModft = (NtAtt(d)->gotTime & EB_UT_FL_MTIME)
                              ? &(NtAtt(d)->Modft) : NULL;
    11a9:	31 ed                	xor    %ebp,%ebp
    11ab:	8d 56 08             	lea    0x8(%esi),%edx
    11ae:	a8 01                	test   $0x1,%al
            FILETIME *pAccft = (NtAtt(d)->gotTime & EB_UT_FL_ATIME)
                              ? &(NtAtt(d)->Accft) : NULL;
    11b0:	8d 4e 10             	lea    0x10(%esi),%ecx
        if (!errval)
            errval = PK_WARN;
    } else {
        if (NtAtt(d)->gotTime) {
            FILETIME *pModft = (NtAtt(d)->gotTime & EB_UT_FL_MTIME)
                              ? &(NtAtt(d)->Modft) : NULL;
    11b3:	0f 44 d5             	cmove  %ebp,%edx
    11b6:	89 54 24 0c          	mov    %edx,0xc(%esp)
            FILETIME *pAccft = (NtAtt(d)->gotTime & EB_UT_FL_ATIME)
                              ? &(NtAtt(d)->Accft) : NULL;
            FILETIME *pCreft = (NtAtt(d)->gotTime & EB_UT_FL_CTIME)
                              ? &(NtAtt(d)->Creft) : NULL;
    11ba:	8d 56 18             	lea    0x18(%esi),%edx
    } else {
        if (NtAtt(d)->gotTime) {
            FILETIME *pModft = (NtAtt(d)->gotTime & EB_UT_FL_MTIME)
                              ? &(NtAtt(d)->Modft) : NULL;
            FILETIME *pAccft = (NtAtt(d)->gotTime & EB_UT_FL_ATIME)
                              ? &(NtAtt(d)->Accft) : NULL;
    11bd:	a8 02                	test   $0x2,%al
            FILETIME *pCreft = (NtAtt(d)->gotTime & EB_UT_FL_CTIME)
                              ? &(NtAtt(d)->Creft) : NULL;

            if (!SetFileTime(hFile, pCreft, pAccft, pModft)) {
    11bf:	89 3c 24             	mov    %edi,(%esp)
    } else {
        if (NtAtt(d)->gotTime) {
            FILETIME *pModft = (NtAtt(d)->gotTime & EB_UT_FL_MTIME)
                              ? &(NtAtt(d)->Modft) : NULL;
            FILETIME *pAccft = (NtAtt(d)->gotTime & EB_UT_FL_ATIME)
                              ? &(NtAtt(d)->Accft) : NULL;
    11c2:	0f 44 cd             	cmove  %ebp,%ecx
            FILETIME *pCreft = (NtAtt(d)->gotTime & EB_UT_FL_CTIME)
                              ? &(NtAtt(d)->Creft) : NULL;
    11c5:	a8 04                	test   $0x4,%al

            if (!SetFileTime(hFile, pCreft, pAccft, pModft)) {
    11c7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
            FILETIME *pModft = (NtAtt(d)->gotTime & EB_UT_FL_MTIME)
                              ? &(NtAtt(d)->Modft) : NULL;
            FILETIME *pAccft = (NtAtt(d)->gotTime & EB_UT_FL_ATIME)
                              ? &(NtAtt(d)->Accft) : NULL;
            FILETIME *pCreft = (NtAtt(d)->gotTime & EB_UT_FL_CTIME)
                              ? &(NtAtt(d)->Creft) : NULL;
    11cb:	0f 44 d5             	cmove  %ebp,%edx

            if (!SetFileTime(hFile, pCreft, pAccft, pModft)) {
    11ce:	89 54 24 04          	mov    %edx,0x4(%esp)
    11d2:	e8 00 00 00 00       	call   11d7 <_set_direc_attribs+0x167>
    11d7:	83 ec 10             	sub    $0x10,%esp
    11da:	85 c0                	test   %eax,%eax
    11dc:	75 78                	jne    1256 <_set_direc_attribs+0x1e6>
                Info(slide, 0, ((char *)slide,
    11de:	8b 44 24 50          	mov    0x50(%esp),%eax
    11e2:	8b 80 44 0b 01 00    	mov    0x10b44(%eax),%eax
    11e8:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    11ec:	e8 00 00 00 00       	call   11f1 <_set_direc_attribs+0x181>
    11f1:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    11f5:	89 c5                	mov    %eax,%ebp
    11f7:	8d 81 dc 88 00 00    	lea    0x88dc(%ecx),%eax
    11fd:	89 44 24 04          	mov    %eax,0x4(%esp)
    1201:	8b 46 04             	mov    0x4(%esi),%eax
    1204:	89 04 24             	mov    %eax,(%esp)
    1207:	e8 00 00 00 00       	call   120c <_set_direc_attribs+0x19c>
    120c:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1210:	8d b1 dc 08 00 00    	lea    0x8dc(%ecx),%esi
    1216:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
    121a:	89 44 24 08          	mov    %eax,0x8(%esp)
    121e:	c7 44 24 04 9c 01 00 	movl   $0x19c,0x4(%esp)
    1225:	00 
    1226:	89 34 24             	mov    %esi,(%esp)
    1229:	e8 00 00 00 00       	call   122e <_set_direc_attribs+0x1be>
    122e:	8b 54 24 50          	mov    0x50(%esp),%edx
    1232:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1239:	00 
    123a:	89 44 24 08          	mov    %eax,0x8(%esp)
    123e:	89 74 24 04          	mov    %esi,0x4(%esp)
    1242:	89 14 24             	mov    %edx,(%esp)
    1245:	ff 54 24 2c          	call   *0x2c(%esp)
                  "warning:  SetFileTime() for %s error %d\n",
                  FnFilter1(d->fn), (int)GetLastError()));
                if (!errval)
                    errval = PK_WARN;
    1249:	b8 01 00 00 00       	mov    $0x1,%eax
                              ? &(NtAtt(d)->Accft) : NULL;
            FILETIME *pCreft = (NtAtt(d)->gotTime & EB_UT_FL_CTIME)
                              ? &(NtAtt(d)->Creft) : NULL;

            if (!SetFileTime(hFile, pCreft, pAccft, pModft)) {
                Info(slide, 0, ((char *)slide,
    124e:	83 ec 10             	sub    $0x10,%esp
                  "warning:  SetFileTime() for %s error %d\n",
                  FnFilter1(d->fn), (int)GetLastError()));
                if (!errval)
                    errval = PK_WARN;
    1251:	85 db                	test   %ebx,%ebx
    1253:	0f 44 d8             	cmove  %eax,%ebx
            }
        }
        CloseHandle(hFile);
    1256:	89 3c 24             	mov    %edi,(%esp)
    1259:	e8 00 00 00 00       	call   125e <_set_direc_attribs+0x1ee>
    125e:	50                   	push   %eax
    125f:	89 d8                	mov    %ebx,%eax
    }

    return errval;
} /* end function set_direc_attribs() */
    1261:	83 c4 3c             	add    $0x3c,%esp
    1264:	5b                   	pop    %ebx
    1265:	5e                   	pop    %esi
    1266:	5f                   	pop    %edi
    1267:	5d                   	pop    %ebp
    1268:	c3                   	ret    
    1269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#ifdef NTSD_EAS
    if (NtAtt(d)->SDlen > 0) {
        int err;

        if (QCOND2) {
            Info(slide, 1, ((char *)slide, " set attrib: %-22s  ",
    1270:	89 c8                	mov    %ecx,%eax
    1272:	8b 99 44 0b 01 00    	mov    0x10b44(%ecx),%ebx
    1278:	05 dc 88 00 00       	add    $0x88dc,%eax
    127d:	89 44 24 04          	mov    %eax,0x4(%esp)
    1281:	8b 46 04             	mov    0x4(%esi),%eax
    1284:	89 04 24             	mov    %eax,(%esp)
    1287:	e8 00 00 00 00       	call   128c <_set_direc_attribs+0x21c>
    128c:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1290:	8d a9 dc 08 00 00    	lea    0x8dc(%ecx),%ebp
    1296:	89 44 24 08          	mov    %eax,0x8(%esp)
    129a:	c7 44 24 04 7f 01 00 	movl   $0x17f,0x4(%esp)
    12a1:	00 
    12a2:	89 2c 24             	mov    %ebp,(%esp)
    12a5:	e8 00 00 00 00       	call   12aa <_set_direc_attribs+0x23a>
    12aa:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    12b1:	00 
    12b2:	89 44 24 08          	mov    %eax,0x8(%esp)
    12b6:	8b 44 24 50          	mov    0x50(%esp),%eax
    12ba:	89 6c 24 04          	mov    %ebp,0x4(%esp)
    12be:	89 04 24             	mov    %eax,(%esp)
    12c1:	ff d3                	call   *%ebx
    12c3:	8b 46 28             	mov    0x28(%esi),%eax
    12c6:	83 ec 10             	sub    $0x10,%esp
    12c9:	e9 1c fe ff ff       	jmp    10ea <_set_direc_attribs+0x7a>
    12ce:	66 90                	xchg   %ax,%ax

        /* set NTFS SD extra fields */
        err = SetSD(__G__ Ansi_Dirname, NtAtt(d)->perms,
                        NtAtt(d)->buf, NtAtt(d)->SDlen - EB_HEADSIZE);
        if (err == IZ_EF_TRUNC) {
            if (!QCOND2)
    12d0:	8b 48 38             	mov    0x38(%eax),%ecx
    12d3:	85 c9                	test   %ecx,%ecx
    12d5:	75 59                	jne    1330 <_set_direc_attribs+0x2c0>
    12d7:	8d a8 dc 08 00 00    	lea    0x8dc(%eax),%ebp
                Info(slide, 1, ((char *)slide, "%-22s  ",
                  FnFilter1(d->fn)));
            Info(slide, 1, ((char *)slide, LoadFarString(TruncNTSD),
    12dd:	8b 44 24 50          	mov    0x50(%esp),%eax
    12e1:	8b 80 44 0b 01 00    	mov    0x10b44(%eax),%eax
    12e7:	c7 44 24 0c f8 00 00 	movl   $0xf8,0xc(%esp)
    12ee:	00 
    12ef:	8b 4e 28             	mov    0x28(%esi),%ecx
    12f2:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    12f6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    12fd:	00 
    12fe:	89 2c 24             	mov    %ebp,(%esp)
    1301:	8d 41 f5             	lea    -0xb(%ecx),%eax
    1304:	89 44 24 08          	mov    %eax,0x8(%esp)
    1308:	e8 00 00 00 00       	call   130d <_set_direc_attribs+0x29d>
    130d:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1311:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    1318:	00 
    1319:	89 44 24 08          	mov    %eax,0x8(%esp)
    131d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
    1321:	89 0c 24             	mov    %ecx,(%esp)
    1324:	ff 54 24 2c          	call   *0x2c(%esp)
    1328:	83 ec 10             	sub    $0x10,%esp
    132b:	e9 f4 fd ff ff       	jmp    1124 <_set_direc_attribs+0xb4>
        /* set NTFS SD extra fields */
        err = SetSD(__G__ Ansi_Dirname, NtAtt(d)->perms,
                        NtAtt(d)->buf, NtAtt(d)->SDlen - EB_HEADSIZE);
        if (err == IZ_EF_TRUNC) {
            if (!QCOND2)
                Info(slide, 1, ((char *)slide, "%-22s  ",
    1330:	8b 44 24 50          	mov    0x50(%esp),%eax
    1334:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1338:	8b 80 44 0b 01 00    	mov    0x10b44(%eax),%eax
    133e:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    1342:	8d 81 dc 88 00 00    	lea    0x88dc(%ecx),%eax
    1348:	89 44 24 04          	mov    %eax,0x4(%esp)
    134c:	8b 46 04             	mov    0x4(%esi),%eax
    134f:	89 04 24             	mov    %eax,(%esp)
    1352:	e8 00 00 00 00       	call   1357 <_set_direc_attribs+0x2e7>
    1357:	8b 54 24 50          	mov    0x50(%esp),%edx
    135b:	8d aa dc 08 00 00    	lea    0x8dc(%edx),%ebp
    1361:	89 44 24 08          	mov    %eax,0x8(%esp)
    1365:	c7 44 24 04 94 01 00 	movl   $0x194,0x4(%esp)
    136c:	00 
    136d:	89 2c 24             	mov    %ebp,(%esp)
    1370:	e8 00 00 00 00       	call   1375 <_set_direc_attribs+0x305>
    1375:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    1379:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    1380:	00 
    1381:	89 44 24 08          	mov    %eax,0x8(%esp)
    1385:	89 6c 24 04          	mov    %ebp,0x4(%esp)
    1389:	89 0c 24             	mov    %ecx,(%esp)
    138c:	ff 54 24 2c          	call   *0x2c(%esp)
    1390:	83 ec 10             	sub    $0x10,%esp
    1393:	e9 45 ff ff ff       	jmp    12dd <_set_direc_attribs+0x26d>
                  FnFilter1(d->fn)));
            Info(slide, 1, ((char *)slide, LoadFarString(TruncNTSD),
              NtAtt(d)->SDlen-(EB_NTSD_L_LEN+EB_CMPRHEADLEN), "\n"));
        } else if (QCOND2) {
            Info(slide, 0, ((char *)slide, "\n"));
    1398:	8b 80 44 0b 01 00    	mov    0x10b44(%eax),%eax
    139e:	8b 4c 24 50          	mov    0x50(%esp),%ecx
    13a2:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    13a6:	8b 44 24 50          	mov    0x50(%esp),%eax
    13aa:	05 dc 08 00 00       	add    $0x8dc,%eax
    13af:	66 c7 81 dc 08 00 00 	movw   $0xa,0x8dc(%ecx)
    13b6:	0a 00 
    13b8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    13bf:	00 
    13c0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    13c7:	00 
    13c8:	89 44 24 04          	mov    %eax,0x4(%esp)
    13cc:	89 0c 24             	mov    %ecx,(%esp)
    13cf:	ff 54 24 2c          	call   *0x2c(%esp)
    13d3:	83 ec 10             	sub    $0x10,%esp
    13d6:	e9 45 fd ff ff       	jmp    1120 <_set_direc_attribs+0xb0>
            errval = err;
    }
#endif /* NTSD_EAS */

    if (hFile == INVALID_HANDLE_VALUE) {
        Info(slide, 1, ((char *)slide,
    13db:	8b 44 24 50          	mov    0x50(%esp),%eax
    13df:	05 dc 88 00 00       	add    $0x88dc,%eax
    13e4:	8b b8 68 82 00 00    	mov    0x8268(%eax),%edi
    13ea:	89 44 24 04          	mov    %eax,0x4(%esp)
    13ee:	8b 46 04             	mov    0x4(%esi),%eax
    13f1:	89 04 24             	mov    %eax,(%esp)
    13f4:	e8 00 00 00 00       	call   13f9 <_set_direc_attribs+0x389>
    13f9:	89 c6                	mov    %eax,%esi
    13fb:	e8 00 00 00 00       	call   1400 <_set_direc_attribs+0x390>
    1400:	8b 5c 24 50          	mov    0x50(%esp),%ebx
    1404:	89 74 24 0c          	mov    %esi,0xc(%esp)
    1408:	81 c3 dc 08 00 00    	add    $0x8dc,%ebx
    140e:	89 44 24 08          	mov    %eax,0x8(%esp)
    1412:	c7 44 24 04 c8 01 00 	movl   $0x1c8,0x4(%esp)
    1419:	00 
    141a:	89 1c 24             	mov    %ebx,(%esp)
    141d:	e8 00 00 00 00       	call   1422 <_set_direc_attribs+0x3b2>
    1422:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    1429:	00 
    142a:	89 44 24 08          	mov    %eax,0x8(%esp)
    142e:	8b 44 24 50          	mov    0x50(%esp),%eax
    1432:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1436:	89 04 24             	mov    %eax,(%esp)
    1439:	ff d7                	call   *%edi
          "warning: CreateFile() error %d (set file times for %s)\n",
          (int)GetLastError(), FnFilter1(d->fn)));
        if (!errval)
            errval = PK_WARN;
    143b:	b8 01 00 00 00       	mov    $0x1,%eax
            errval = err;
    }
#endif /* NTSD_EAS */

    if (hFile == INVALID_HANDLE_VALUE) {
        Info(slide, 1, ((char *)slide,
    1440:	83 ec 10             	sub    $0x10,%esp
    1443:	e9 3c fc ff ff       	jmp    1084 <_set_direc_attribs+0x14>
    1448:	90                   	nop
    1449:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001450 <_stamp_file>:
/*************************/
/* Function stamp_file() */
/*************************/

int stamp_file(__GPRO__ ZCONST char *fname, time_t modtime)
{
    1450:	56                   	push   %esi
    1451:	53                   	push   %ebx
    1452:	83 ec 34             	sub    $0x34,%esp
    1455:	8b 74 24 40          	mov    0x40(%esp),%esi
    1459:	8b 5c 24 44          	mov    0x44(%esp),%ebx
/* Function FStampIsLocTime() */
/******************************/

static int FStampIsLocTime(__GPRO__ const char *path)
{
    return (NTQueryVolInfo(__G__ path) ? G.lastVolLocTim : FALSE);
    145d:	89 da                	mov    %ebx,%edx
    145f:	89 f0                	mov    %esi,%eax
    1461:	e8 9a eb ff ff       	call   0 <_NTQueryVolInfo>
    1466:	85 c0                	test   %eax,%eax
    1468:	0f 84 b2 00 00 00    	je     1520 <_stamp_file+0xd0>
    146e:	8b b6 88 0b 01 00    	mov    0x10b88(%esi),%esi
#else
#   define Ansi_Fname  fname
#endif

    /* open a handle to the file to prepare setting the mod-time stamp */
    hFile = CreateFile(Ansi_Fname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
    1474:	89 1c 24             	mov    %ebx,(%esp)
    1477:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    147e:	00 
    147f:	c7 44 24 14 80 00 00 	movl   $0x80,0x14(%esp)
    1486:	00 
    1487:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
    148e:	00 
    148f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1496:	00 
    1497:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
    149e:	00 
    149f:	c7 44 24 04 00 00 00 	movl   $0x40000000,0x4(%esp)
    14a6:	40 
    14a7:	e8 00 00 00 00       	call   14ac <_stamp_file+0x5c>
    14ac:	83 ec 1c             	sub    $0x1c,%esp
    14af:	89 c3                	mov    %eax,%ebx
         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if ( hFile == INVALID_HANDLE_VALUE ) {
    14b1:	83 f8 ff             	cmp    $0xffffffff,%eax
    14b4:	0f 84 ac 00 00 00    	je     1566 <_stamp_file+0x116>
        errstat = -1;
    } else {
        /* convert time_t modtime into WIN32 native 64bit format */
        UTIME_2_IZFILETIME(modtime, &Modft)
    14ba:	85 f6                	test   %esi,%esi
    14bc:	0f 85 ae 00 00 00    	jne    1570 <_stamp_file+0x120>
    ULLNG64 NTtime;

    /* NT_QUANTA_PER_UNIX is small enough so that "ut * NT_QUANTA_PER_UNIX"
     * cannot overflow in 64-bit signed calculation, regardless whether "ut"
     * is signed or unsigned.  */
    NTtime = ((LLONG64)ut * NT_QUANTA_PER_UNIX) +
    14c2:	b8 80 96 98 00       	mov    $0x989680,%eax
    14c7:	8d 74 24 28          	lea    0x28(%esp),%esi
    14cb:	f7 6c 24 48          	imull  0x48(%esp)
    14cf:	05 00 80 3e d5       	add    $0xd53e8000,%eax
    14d4:	81 d2 de b1 9d 01    	adc    $0x19db1de,%edx
             ((ULLNG64)UNIX_TIME_ZERO_LO + ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    pft->dwLowDateTime = (DWORD)NTtime;
    14da:	89 44 24 28          	mov    %eax,0x28(%esp)
    pft->dwHighDateTime = (DWORD)(NTtime >> 32);
    14de:	89 54 24 2c          	mov    %edx,0x2c(%esp)
        errstat = -1;
    } else {
        /* convert time_t modtime into WIN32 native 64bit format */
        UTIME_2_IZFILETIME(modtime, &Modft)
        /* set Access and Modification times of the file to modtime */
        if (!SetFileTime(hFile, NULL, &Modft, &Modft)) {
    14e2:	89 74 24 0c          	mov    %esi,0xc(%esp)
    14e6:	89 74 24 08          	mov    %esi,0x8(%esp)
    14ea:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    14f1:	00 
    14f2:	89 1c 24             	mov    %ebx,(%esp)
    14f5:	e8 00 00 00 00       	call   14fa <_stamp_file+0xaa>
    14fa:	83 ec 10             	sub    $0x10,%esp
    14fd:	85 c0                	test   %eax,%eax
    14ff:	0f 94 c0             	sete   %al
    1502:	25 ff 00 00 00       	and    $0xff,%eax
            errstat = -1;
        }
        CloseHandle(hFile);
    1507:	89 1c 24             	mov    %ebx,(%esp)
        errstat = -1;
    } else {
        /* convert time_t modtime into WIN32 native 64bit format */
        UTIME_2_IZFILETIME(modtime, &Modft)
        /* set Access and Modification times of the file to modtime */
        if (!SetFileTime(hFile, NULL, &Modft, &Modft)) {
    150a:	f7 d8                	neg    %eax
    150c:	89 c6                	mov    %eax,%esi
            errstat = -1;
        }
        CloseHandle(hFile);
    150e:	e8 00 00 00 00       	call   1513 <_stamp_file+0xc3>
    1513:	50                   	push   %eax
    }

    return errstat;

#undef Ansi_Fname
} /* end function stamp_file() */
    1514:	83 c4 34             	add    $0x34,%esp
    1517:	89 f0                	mov    %esi,%eax
    1519:	5b                   	pop    %ebx
    151a:	5e                   	pop    %esi
    151b:	c3                   	ret    
    151c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#else
#   define Ansi_Fname  fname
#endif

    /* open a handle to the file to prepare setting the mod-time stamp */
    hFile = CreateFile(Ansi_Fname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
    1520:	89 1c 24             	mov    %ebx,(%esp)
    1523:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    152a:	00 
    152b:	c7 44 24 14 80 00 00 	movl   $0x80,0x14(%esp)
    1532:	00 
    1533:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
    153a:	00 
    153b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1542:	00 
    1543:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
    154a:	00 
    154b:	c7 44 24 04 00 00 00 	movl   $0x40000000,0x4(%esp)
    1552:	40 
    1553:	e8 00 00 00 00       	call   1558 <_stamp_file+0x108>
    1558:	83 ec 1c             	sub    $0x1c,%esp
    155b:	89 c3                	mov    %eax,%ebx
         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if ( hFile == INVALID_HANDLE_VALUE ) {
    155d:	83 f8 ff             	cmp    $0xffffffff,%eax
    1560:	0f 85 5c ff ff ff    	jne    14c2 <_stamp_file+0x72>
        errstat = -1;
    1566:	83 ce ff             	or     $0xffffffff,%esi
    1569:	eb a9                	jmp    1514 <_stamp_file+0xc4>
    156b:	90                   	nop
    156c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    } else {
        /* convert time_t modtime into WIN32 native 64bit format */
        UTIME_2_IZFILETIME(modtime, &Modft)
    1570:	8d 74 24 28          	lea    0x28(%esp),%esi
    1574:	8b 44 24 48          	mov    0x48(%esp),%eax
    1578:	89 f2                	mov    %esi,%edx
    157a:	e8 f1 f1 ff ff       	call   770 <_utime2VFatFileTime.constprop.5>
    157f:	e9 5e ff ff ff       	jmp    14e2 <_stamp_file+0x92>
    1584:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    158a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00001590 <_do_wild>:
/************************/

char *do_wild(__G__ wildspec)
    __GDEF
    ZCONST char *wildspec;  /* only used first time on a given dir */
{
    1590:	55                   	push   %ebp
    1591:	57                   	push   %edi
    1592:	56                   	push   %esi
    1593:	53                   	push   %ebx
    1594:	83 ec 2c             	sub    $0x2c,%esp
    1597:	8b 5c 24 40          	mov    0x40(%esp),%ebx

    /* Even when we're just returning wildspec, we *always* do so in
     * matchname[]--calling routine is allowed to append four characters
     * to the returned string, and wildspec may be a pointer to argv[].
     */
    if (!G.notfirstcall) {  /* first call:  must initialize everything */
    159b:	8b 83 b8 0c 01 00    	mov    0x10cb8(%ebx),%eax
    15a1:	85 c0                	test   %eax,%eax
    15a3:	0f 84 18 01 00 00    	je     16c1 <_do_wild+0x131>
        G.matchname[FILNAMSIZ-1] = '\0';
        return G.matchname;
    }

    /* last time through, might have failed opendir but returned raw wildspec */
    if (G.wild_dir == NULL) {
    15a9:	8b 83 bc 0c 01 00    	mov    0x10cbc(%ebx),%eax
    15af:	85 c0                	test   %eax,%eax
    15b1:	74 55                	je     1608 <_do_wild+0x78>

    /* If we've gotten this far, we've read and matched at least one entry
     * successfully (in a previous call), so dirname has been copied into
     * matchname already.
     */
    if (G.have_dirname) {
    15b3:	8b 8b b0 0c 01 00    	mov    0x10cb0(%ebx),%ecx
        /* strcpy(G.matchname, G.dirname); */
        fnamestart = G.matchname + G.dirnamelen;
    } else
        fnamestart = G.matchname;
    15b9:	8d b3 a8 0b 01 00    	lea    0x10ba8(%ebx),%esi

    /* If we've gotten this far, we've read and matched at least one entry
     * successfully (in a previous call), so dirname has been copied into
     * matchname already.
     */
    if (G.have_dirname) {
    15bf:	85 c9                	test   %ecx,%ecx
    15c1:	0f 84 9d 00 00 00    	je     1664 <_do_wild+0xd4>
        /* strcpy(G.matchname, G.dirname); */
        fnamestart = G.matchname + G.dirnamelen;
    15c7:	8b 93 b4 0c 01 00    	mov    0x10cb4(%ebx),%edx
    15cd:	8d b4 13 a8 0b 01 00 	lea    0x10ba8(%ebx,%edx,1),%esi
    } else
        fnamestart = G.matchname;
    while ((file = Readdir((zDIR *)G.wild_dir)) != NULL) {
    15d4:	e8 17 f0 ff ff       	call   5f0 <_Readdir>
    15d9:	85 c0                	test   %eax,%eax
    15db:	0f 85 90 00 00 00    	jne    1671 <_do_wild+0xe1>
                *fnamestart = '\0';
            return G.matchname;
        }
    }

    Closedir((zDIR *)G.wild_dir);  /* at least one entry read; nothing left */
    15e1:	8b b3 bc 0c 01 00    	mov    0x10cbc(%ebx),%esi
/***********************/

static void Closedir(d)
    zDIR *d;                    /* directory stream to close */
{
    FindClose(d->d_hFindFile);
    15e7:	8b 86 28 01 00 00    	mov    0x128(%esi),%eax
    15ed:	89 04 24             	mov    %eax,(%esp)
    15f0:	e8 00 00 00 00       	call   15f5 <_do_wild+0x65>
    15f5:	52                   	push   %edx
    free(d);
    15f6:	89 34 24             	mov    %esi,(%esp)
    15f9:	e8 00 00 00 00       	call   15fe <_do_wild+0x6e>
            return G.matchname;
        }
    }

    Closedir((zDIR *)G.wild_dir);  /* at least one entry read; nothing left */
    G.wild_dir = NULL;
    15fe:	c7 83 bc 0c 01 00 00 	movl   $0x0,0x10cbc(%ebx)
    1605:	00 00 00 
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    if (G.have_dirname)
    1608:	8b 83 b0 0c 01 00    	mov    0x10cb0(%ebx),%eax
        }
    }

    Closedir((zDIR *)G.wild_dir);  /* at least one entry read; nothing left */
    G.wild_dir = NULL;
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    160e:	c7 83 b8 0c 01 00 00 	movl   $0x0,0x10cb8(%ebx)
    1615:	00 00 00 
    if (G.have_dirname)
    1618:	85 c0                	test   %eax,%eax
    161a:	0f 85 f0 01 00 00    	jne    1810 <_do_wild+0x280>
        free(G.dirname);
    return (char *)NULL;
    1620:	31 c0                	xor    %eax,%eax

} /* end function do_wild() */
    1622:	83 c4 2c             	add    $0x2c,%esp
    1625:	5b                   	pop    %ebx
    1626:	5e                   	pop    %esi
    1627:	5f                   	pop    %edi
    1628:	5d                   	pop    %ebp
    1629:	c3                   	ret    
    162a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    while ((file = Readdir((zDIR *)G.wild_dir)) != NULL) {
        Trace((stderr, "do_wild:  readdir returns %s\n",
          FnFilter1(file->d_name)));
        strcpy(fnamestart, file->d_name);
        if (MBSRCHR(fnamestart, '.') == (char *)NULL)
            strcat(fnamestart, ".");
    1630:	89 34 24             	mov    %esi,(%esp)
    1633:	e8 00 00 00 00       	call   1638 <_do_wild+0xa8>
    1638:	66 c7 04 06 2e 00    	movw   $0x2e,(%esi,%eax,1)
    163e:	66 90                	xchg   %ax,%ax
        if (match(fnamestart, G.wildname, TRUE WISEP)) {
    1640:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    1647:	00 
    1648:	8b 83 a0 0b 01 00    	mov    0x10ba0(%ebx),%eax
    164e:	89 34 24             	mov    %esi,(%esp)
    1651:	89 44 24 04          	mov    %eax,0x4(%esp)
    1655:	e8 00 00 00 00       	call   165a <_do_wild+0xca>
    165a:	85 c0                	test   %eax,%eax
    165c:	75 38                	jne    1696 <_do_wild+0x106>
    165e:	8b 83 bc 0c 01 00    	mov    0x10cbc(%ebx),%eax
    if (G.have_dirname) {
        /* strcpy(G.matchname, G.dirname); */
        fnamestart = G.matchname + G.dirnamelen;
    } else
        fnamestart = G.matchname;
    while ((file = Readdir((zDIR *)G.wild_dir)) != NULL) {
    1664:	e8 87 ef ff ff       	call   5f0 <_Readdir>
    1669:	85 c0                	test   %eax,%eax
    166b:	0f 84 70 ff ff ff    	je     15e1 <_do_wild+0x51>
        Trace((stderr, "do_wild:  readdir returns %s\n",
          FnFilter1(file->d_name)));
        strcpy(fnamestart, file->d_name);
    1671:	83 c0 20             	add    $0x20,%eax
    1674:	89 34 24             	mov    %esi,(%esp)
    1677:	89 44 24 04          	mov    %eax,0x4(%esp)
    167b:	e8 00 00 00 00       	call   1680 <_do_wild+0xf0>
        if (MBSRCHR(fnamestart, '.') == (char *)NULL)
    1680:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
    1687:	00 
    1688:	89 34 24             	mov    %esi,(%esp)
    168b:	e8 00 00 00 00       	call   1690 <_do_wild+0x100>
    1690:	85 c0                	test   %eax,%eax
    1692:	75 ac                	jne    1640 <_do_wild+0xb0>
    1694:	eb 9a                	jmp    1630 <_do_wild+0xa0>
            strcat(fnamestart, ".");
        if (match(fnamestart, G.wildname, TRUE WISEP)) {
            Trace((stderr, "do_wild:  match() succeeds\n"));
            /* remove trailing dot */
            fnamestart = plastchar(fnamestart, strlen(fnamestart));
    1696:	89 34 24             	mov    %esi,(%esp)
    1699:	e8 00 00 00 00       	call   169e <_do_wild+0x10e>
    169e:	89 34 24             	mov    %esi,(%esp)
    16a1:	89 44 24 04          	mov    %eax,0x4(%esp)
    16a5:	e8 00 00 00 00       	call   16aa <_do_wild+0x11a>
            if (*fnamestart == '.')
    16aa:	80 38 2e             	cmpb   $0x2e,(%eax)
    16ad:	0f 84 b3 01 00 00    	je     1866 <_do_wild+0x2d6>
                *fnamestart = '\0';
            return G.matchname;
    16b3:	8d 83 a8 0b 01 00    	lea    0x10ba8(%ebx),%eax
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    if (G.have_dirname)
        free(G.dirname);
    return (char *)NULL;

} /* end function do_wild() */
    16b9:	83 c4 2c             	add    $0x2c,%esp
    16bc:	5b                   	pop    %ebx
    16bd:	5e                   	pop    %esi
    16be:	5f                   	pop    %edi
    16bf:	5d                   	pop    %ebp
    16c0:	c3                   	ret    
     * to the returned string, and wildspec may be a pointer to argv[].
     */
    if (!G.notfirstcall) {  /* first call:  must initialize everything */
        G.notfirstcall = TRUE;

        if (!iswild(wildspec)) {
    16c1:	8b 44 24 44          	mov    0x44(%esp),%eax
    /* Even when we're just returning wildspec, we *always* do so in
     * matchname[]--calling routine is allowed to append four characters
     * to the returned string, and wildspec may be a pointer to argv[].
     */
    if (!G.notfirstcall) {  /* first call:  must initialize everything */
        G.notfirstcall = TRUE;
    16c5:	c7 83 b8 0c 01 00 01 	movl   $0x1,0x10cb8(%ebx)
    16cc:	00 00 00 

        if (!iswild(wildspec)) {
    16cf:	89 04 24             	mov    %eax,(%esp)
    16d2:	e8 00 00 00 00       	call   16d7 <_do_wild+0x147>
    16d7:	85 c0                	test   %eax,%eax
    16d9:	0f 84 44 01 00 00    	je     1823 <_do_wild+0x293>
            G.wild_dir = NULL;
            return G.matchname;
        }

        /* break the wildspec into a directory part and a wildcard filename */
        if ((G.wildname = MBSRCHR(wildspec, '/')) == (ZCONST char *)NULL &&
    16df:	8b 44 24 44          	mov    0x44(%esp),%eax
    16e3:	c7 44 24 04 2f 00 00 	movl   $0x2f,0x4(%esp)
    16ea:	00 
    16eb:	89 04 24             	mov    %eax,(%esp)
    16ee:	e8 00 00 00 00       	call   16f3 <_do_wild+0x163>
    16f3:	89 83 a0 0b 01 00    	mov    %eax,0x10ba0(%ebx)
    16f9:	85 c0                	test   %eax,%eax
    16fb:	0f 84 22 02 00 00    	je     1923 <_do_wild+0x393>
            G.dirname = ".";
            G.dirnamelen = 1;
            G.have_dirname = FALSE;
            G.wildname = wildspec;
        } else {
            ++G.wildname;     /* point at character after '/' or ':' */
    1701:	8d 70 01             	lea    0x1(%eax),%esi
            G.dirnamelen = G.wildname - wildspec;
    1704:	8b 44 24 44          	mov    0x44(%esp),%eax
            G.dirname = ".";
            G.dirnamelen = 1;
            G.have_dirname = FALSE;
            G.wildname = wildspec;
        } else {
            ++G.wildname;     /* point at character after '/' or ':' */
    1708:	89 b3 a0 0b 01 00    	mov    %esi,0x10ba0(%ebx)
            G.dirnamelen = G.wildname - wildspec;
    170e:	29 c6                	sub    %eax,%esi
    1710:	89 b3 b4 0c 01 00    	mov    %esi,0x10cb4(%ebx)
            if ((G.dirname = (char *)malloc(G.dirnamelen+1)) == NULL) {
    1716:	8d 46 01             	lea    0x1(%esi),%eax
    1719:	89 04 24             	mov    %eax,(%esp)
    171c:	e8 00 00 00 00       	call   1721 <_do_wild+0x191>
    1721:	89 c7                	mov    %eax,%edi
    1723:	89 83 a4 0b 01 00    	mov    %eax,0x10ba4(%ebx)
    1729:	85 c0                	test   %eax,%eax
    172b:	0f 84 46 02 00 00    	je     1977 <_do_wild+0x3e7>
                  "warning:  cannot allocate wildcard buffers\n"));
                strncpy(G.matchname, wildspec, FILNAMSIZ);
                G.matchname[FILNAMSIZ-1] = '\0';
                return G.matchname; /* but maybe filespec was not a wildcard */
            }
            strncpy(G.dirname, wildspec, G.dirnamelen);
    1731:	8b 44 24 44          	mov    0x44(%esp),%eax
    1735:	89 74 24 08          	mov    %esi,0x8(%esp)
    1739:	89 44 24 04          	mov    %eax,0x4(%esp)
    173d:	89 3c 24             	mov    %edi,(%esp)
    1740:	e8 00 00 00 00       	call   1745 <_do_wild+0x1b5>
            G.dirname[G.dirnamelen] = '\0';   /* terminate for strcpy below */
    1745:	c6 04 37 00          	movb   $0x0,(%edi,%esi,1)
            G.have_dirname = TRUE;
    1749:	c7 83 b0 0c 01 00 01 	movl   $0x1,0x10cb0(%ebx)
    1750:	00 00 00 
    1753:	89 f8                	mov    %edi,%eax
        }
        Trace((stderr, "do_wild:  dirname = [%s]\n", FnFilter1(G.dirname)));

        if ((G.wild_dir = (zvoid *)Opendir(G.dirname)) != NULL) {
    1755:	e8 86 ed ff ff       	call   4e0 <_Opendir>
    175a:	89 83 bc 0c 01 00    	mov    %eax,0x10cbc(%ebx)
    1760:	85 c0                	test   %eax,%eax
    1762:	0f 84 a0 02 00 00    	je     1a08 <_do_wild+0x478>
            if (G.have_dirname) {
    1768:	8b ab b0 0c 01 00    	mov    0x10cb0(%ebx),%ebp
    176e:	85 ed                	test   %ebp,%ebp
    1770:	0f 85 52 01 00 00    	jne    18c8 <_do_wild+0x338>
                strcpy(G.matchname, G.dirname);
                fnamestart = G.matchname + G.dirnamelen;
            } else
                fnamestart = G.matchname;
    1776:	8d ab a8 0b 01 00    	lea    0x10ba8(%ebx),%ebp
    177c:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
    1780:	eb 48                	jmp    17ca <_do_wild+0x23a>
                Trace((stderr, "do_wild:  Readdir returns %s\n",
                  FnFilter1(file->d_name)));
                strcpy(fnamestart, file->d_name);
                if (MBSRCHR(fnamestart, '.') == (char *)NULL)
                    strcat(fnamestart, ".");
                if (match(fnamestart, G.wildname, TRUE WISEP) &&
    1782:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    1789:	00 
    178a:	8b 83 a0 0b 01 00    	mov    0x10ba0(%ebx),%eax
    1790:	89 2c 24             	mov    %ebp,(%esp)
    1793:	89 44 24 04          	mov    %eax,0x4(%esp)
    1797:	e8 00 00 00 00       	call   179c <_do_wild+0x20c>
    179c:	85 c0                	test   %eax,%eax
    179e:	74 24                	je     17c4 <_do_wild+0x234>
                    /* skip "." and ".." directory entries */
                    strcmp(fnamestart, ".") && strcmp(fnamestart, "..")) {
    17a0:	bf 00 02 00 00       	mov    $0x200,%edi
    17a5:	89 ee                	mov    %ebp,%esi
    17a7:	b9 02 00 00 00       	mov    $0x2,%ecx
                Trace((stderr, "do_wild:  Readdir returns %s\n",
                  FnFilter1(file->d_name)));
                strcpy(fnamestart, file->d_name);
                if (MBSRCHR(fnamestart, '.') == (char *)NULL)
                    strcat(fnamestart, ".");
                if (match(fnamestart, G.wildname, TRUE WISEP) &&
    17ac:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
    17ae:	74 14                	je     17c4 <_do_wild+0x234>
                    /* skip "." and ".." directory entries */
                    strcmp(fnamestart, ".") && strcmp(fnamestart, "..")) {
    17b0:	bf 30 02 00 00       	mov    $0x230,%edi
    17b5:	89 ee                	mov    %ebp,%esi
    17b7:	b9 03 00 00 00       	mov    $0x3,%ecx
    17bc:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
    17be:	0f 85 3a 01 00 00    	jne    18fe <_do_wild+0x36e>
    17c4:	8b 83 bc 0c 01 00    	mov    0x10cbc(%ebx),%eax
            if (G.have_dirname) {
                strcpy(G.matchname, G.dirname);
                fnamestart = G.matchname + G.dirnamelen;
            } else
                fnamestart = G.matchname;
            while ((file = Readdir((zDIR *)G.wild_dir)) != NULL) {
    17ca:	e8 21 ee ff ff       	call   5f0 <_Readdir>
    17cf:	85 c0                	test   %eax,%eax
    17d1:	0f 84 9d 00 00 00    	je     1874 <_do_wild+0x2e4>
                Trace((stderr, "do_wild:  Readdir returns %s\n",
                  FnFilter1(file->d_name)));
                strcpy(fnamestart, file->d_name);
    17d7:	83 c0 20             	add    $0x20,%eax
    17da:	89 2c 24             	mov    %ebp,(%esp)
    17dd:	89 44 24 04          	mov    %eax,0x4(%esp)
    17e1:	e8 00 00 00 00       	call   17e6 <_do_wild+0x256>
                if (MBSRCHR(fnamestart, '.') == (char *)NULL)
    17e6:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
    17ed:	00 
    17ee:	89 2c 24             	mov    %ebp,(%esp)
    17f1:	e8 00 00 00 00       	call   17f6 <_do_wild+0x266>
    17f6:	85 c0                	test   %eax,%eax
    17f8:	75 88                	jne    1782 <_do_wild+0x1f2>
                    strcat(fnamestart, ".");
    17fa:	89 2c 24             	mov    %ebp,(%esp)
    17fd:	e8 00 00 00 00       	call   1802 <_do_wild+0x272>
    1802:	66 c7 44 05 00 2e 00 	movw   $0x2e,0x0(%ebp,%eax,1)
    1809:	e9 74 ff ff ff       	jmp    1782 <_do_wild+0x1f2>
    180e:	66 90                	xchg   %ax,%ax

    Closedir((zDIR *)G.wild_dir);  /* at least one entry read; nothing left */
    G.wild_dir = NULL;
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    if (G.have_dirname)
        free(G.dirname);
    1810:	8b 83 a4 0b 01 00    	mov    0x10ba4(%ebx),%eax
    1816:	89 04 24             	mov    %eax,(%esp)
    1819:	e8 00 00 00 00       	call   181e <_do_wild+0x28e>
    181e:	e9 fd fd ff ff       	jmp    1620 <_do_wild+0x90>
     */
    if (!G.notfirstcall) {  /* first call:  must initialize everything */
        G.notfirstcall = TRUE;

        if (!iswild(wildspec)) {
            strncpy(G.matchname, wildspec, FILNAMSIZ);
    1823:	8d b3 a8 0b 01 00    	lea    0x10ba8(%ebx),%esi
    1829:	8b 44 24 44          	mov    0x44(%esp),%eax
    182d:	89 34 24             	mov    %esi,(%esp)
    1830:	c7 44 24 08 04 01 00 	movl   $0x104,0x8(%esp)
    1837:	00 
    1838:	89 44 24 04          	mov    %eax,0x4(%esp)
    183c:	e8 00 00 00 00       	call   1841 <_do_wild+0x2b1>
            G.matchname[FILNAMSIZ-1] = '\0';
    1841:	c6 83 ab 0c 01 00 00 	movb   $0x0,0x10cab(%ebx)
            G.have_dirname = FALSE;
    1848:	c7 83 b0 0c 01 00 00 	movl   $0x0,0x10cb0(%ebx)
    184f:	00 00 00 
            G.wild_dir = NULL;
    1852:	c7 83 bc 0c 01 00 00 	movl   $0x0,0x10cbc(%ebx)
    1859:	00 00 00 
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    if (G.have_dirname)
        free(G.dirname);
    return (char *)NULL;

} /* end function do_wild() */
    185c:	83 c4 2c             	add    $0x2c,%esp
        if (!iswild(wildspec)) {
            strncpy(G.matchname, wildspec, FILNAMSIZ);
            G.matchname[FILNAMSIZ-1] = '\0';
            G.have_dirname = FALSE;
            G.wild_dir = NULL;
            return G.matchname;
    185f:	89 f0                	mov    %esi,%eax
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    if (G.have_dirname)
        free(G.dirname);
    return (char *)NULL;

} /* end function do_wild() */
    1861:	5b                   	pop    %ebx
    1862:	5e                   	pop    %esi
    1863:	5f                   	pop    %edi
    1864:	5d                   	pop    %ebp
    1865:	c3                   	ret    
        if (match(fnamestart, G.wildname, TRUE WISEP)) {
            Trace((stderr, "do_wild:  match() succeeds\n"));
            /* remove trailing dot */
            fnamestart = plastchar(fnamestart, strlen(fnamestart));
            if (*fnamestart == '.')
                *fnamestart = '\0';
    1866:	c6 00 00             	movb   $0x0,(%eax)
            return G.matchname;
    1869:	8d 83 a8 0b 01 00    	lea    0x10ba8(%ebx),%eax
    186f:	e9 45 fe ff ff       	jmp    16b9 <_do_wild+0x129>
                        *fnamestart = '\0';
                    return G.matchname;
                }
            }
            /* if we get to here directory is exhausted, so close it */
            Closedir((zDIR *)G.wild_dir);
    1874:	8b b3 bc 0c 01 00    	mov    0x10cbc(%ebx),%esi
/***********************/

static void Closedir(d)
    zDIR *d;                    /* directory stream to close */
{
    FindClose(d->d_hFindFile);
    187a:	8b 86 28 01 00 00    	mov    0x128(%esi),%eax
    1880:	89 04 24             	mov    %eax,(%esp)
    1883:	e8 00 00 00 00       	call   1888 <_do_wild+0x2f8>
    1888:	57                   	push   %edi
    free(d);
    1889:	89 34 24             	mov    %esi,(%esp)
    188c:	e8 00 00 00 00       	call   1891 <_do_wild+0x301>
                    return G.matchname;
                }
            }
            /* if we get to here directory is exhausted, so close it */
            Closedir((zDIR *)G.wild_dir);
            G.wild_dir = NULL;
    1891:	c7 83 bc 0c 01 00 00 	movl   $0x0,0x10cbc(%ebx)
    1898:	00 00 00 
        Trace((stderr, "do_wild:  Opendir(%s) returns NULL\n",
          FnFilter1(G.dirname)));

        /* return the raw wildspec in case that works (e.g., directory not
         * searchable, but filespec was not wild and file is readable) */
        strncpy(G.matchname, wildspec, FILNAMSIZ);
    189b:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
    189f:	8b 44 24 44          	mov    0x44(%esp),%eax
    18a3:	89 3c 24             	mov    %edi,(%esp)
    18a6:	c7 44 24 08 04 01 00 	movl   $0x104,0x8(%esp)
    18ad:	00 
    18ae:	89 44 24 04          	mov    %eax,0x4(%esp)
    18b2:	e8 00 00 00 00       	call   18b7 <_do_wild+0x327>
        G.matchname[FILNAMSIZ-1] = '\0';
    18b7:	c6 83 ab 0c 01 00 00 	movb   $0x0,0x10cab(%ebx)
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    if (G.have_dirname)
        free(G.dirname);
    return (char *)NULL;

} /* end function do_wild() */
    18be:	83 c4 2c             	add    $0x2c,%esp

        /* return the raw wildspec in case that works (e.g., directory not
         * searchable, but filespec was not wild and file is readable) */
        strncpy(G.matchname, wildspec, FILNAMSIZ);
        G.matchname[FILNAMSIZ-1] = '\0';
        return G.matchname;
    18c1:	89 f8                	mov    %edi,%eax
    G.notfirstcall = FALSE;        /* reset for new wildspec */
    if (G.have_dirname)
        free(G.dirname);
    return (char *)NULL;

} /* end function do_wild() */
    18c3:	5b                   	pop    %ebx
    18c4:	5e                   	pop    %esi
    18c5:	5f                   	pop    %edi
    18c6:	5d                   	pop    %ebp
    18c7:	c3                   	ret    
        }
        Trace((stderr, "do_wild:  dirname = [%s]\n", FnFilter1(G.dirname)));

        if ((G.wild_dir = (zvoid *)Opendir(G.dirname)) != NULL) {
            if (G.have_dirname) {
                strcpy(G.matchname, G.dirname);
    18c8:	8d 83 a8 0b 01 00    	lea    0x10ba8(%ebx),%eax
    18ce:	89 c1                	mov    %eax,%ecx
    18d0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    18d4:	8b 83 a4 0b 01 00    	mov    0x10ba4(%ebx),%eax
    18da:	89 0c 24             	mov    %ecx,(%esp)
    18dd:	89 44 24 04          	mov    %eax,0x4(%esp)
    18e1:	e8 00 00 00 00       	call   18e6 <_do_wild+0x356>
                fnamestart = G.matchname + G.dirnamelen;
    18e6:	8b 83 b4 0c 01 00    	mov    0x10cb4(%ebx),%eax
    18ec:	8d ac 03 a8 0b 01 00 	lea    0x10ba8(%ebx,%eax,1),%ebp
    18f3:	8b 83 bc 0c 01 00    	mov    0x10cbc(%ebx),%eax
    18f9:	e9 cc fe ff ff       	jmp    17ca <_do_wild+0x23a>
                if (match(fnamestart, G.wildname, TRUE WISEP) &&
                    /* skip "." and ".." directory entries */
                    strcmp(fnamestart, ".") && strcmp(fnamestart, "..")) {
                    Trace((stderr, "do_wild:  match() succeeds\n"));
                    /* remove trailing dot */
                    fnamestart = plastchar(fnamestart, strlen(fnamestart));
    18fe:	89 2c 24             	mov    %ebp,(%esp)
    1901:	e8 00 00 00 00       	call   1906 <_do_wild+0x376>
    1906:	89 2c 24             	mov    %ebp,(%esp)
    1909:	89 44 24 04          	mov    %eax,0x4(%esp)
    190d:	e8 00 00 00 00       	call   1912 <_do_wild+0x382>
                    if (*fnamestart == '.')
    1912:	80 38 2e             	cmpb   $0x2e,(%eax)
    1915:	75 03                	jne    191a <_do_wild+0x38a>
                        *fnamestart = '\0';
    1917:	c6 00 00             	movb   $0x0,(%eax)
                    return G.matchname;
    191a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    191e:	e9 ff fc ff ff       	jmp    1622 <_do_wild+0x92>
            return G.matchname;
        }

        /* break the wildspec into a directory part and a wildcard filename */
        if ((G.wildname = MBSRCHR(wildspec, '/')) == (ZCONST char *)NULL &&
            (G.wildname = MBSRCHR(wildspec, ':')) == (ZCONST char *)NULL) {
    1923:	8b 44 24 44          	mov    0x44(%esp),%eax
    1927:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
    192e:	00 
    192f:	89 04 24             	mov    %eax,(%esp)
    1932:	e8 00 00 00 00       	call   1937 <_do_wild+0x3a7>
    1937:	89 83 a0 0b 01 00    	mov    %eax,0x10ba0(%ebx)
            G.wild_dir = NULL;
            return G.matchname;
        }

        /* break the wildspec into a directory part and a wildcard filename */
        if ((G.wildname = MBSRCHR(wildspec, '/')) == (ZCONST char *)NULL &&
    193d:	85 c0                	test   %eax,%eax
    193f:	0f 85 bc fd ff ff    	jne    1701 <_do_wild+0x171>
            (G.wildname = MBSRCHR(wildspec, ':')) == (ZCONST char *)NULL) {
            G.dirname = ".";
            G.dirnamelen = 1;
            G.have_dirname = FALSE;
            G.wildname = wildspec;
    1945:	8b 44 24 44          	mov    0x44(%esp),%eax
        }

        /* break the wildspec into a directory part and a wildcard filename */
        if ((G.wildname = MBSRCHR(wildspec, '/')) == (ZCONST char *)NULL &&
            (G.wildname = MBSRCHR(wildspec, ':')) == (ZCONST char *)NULL) {
            G.dirname = ".";
    1949:	c7 83 a4 0b 01 00 00 	movl   $0x200,0x10ba4(%ebx)
    1950:	02 00 00 
            G.dirnamelen = 1;
            G.have_dirname = FALSE;
            G.wildname = wildspec;
    1953:	89 83 a0 0b 01 00    	mov    %eax,0x10ba0(%ebx)

        /* break the wildspec into a directory part and a wildcard filename */
        if ((G.wildname = MBSRCHR(wildspec, '/')) == (ZCONST char *)NULL &&
            (G.wildname = MBSRCHR(wildspec, ':')) == (ZCONST char *)NULL) {
            G.dirname = ".";
            G.dirnamelen = 1;
    1959:	c7 83 b4 0c 01 00 01 	movl   $0x1,0x10cb4(%ebx)
    1960:	00 00 00 
            G.have_dirname = FALSE;
    1963:	c7 83 b0 0c 01 00 00 	movl   $0x0,0x10cb0(%ebx)
    196a:	00 00 00 
            G.wildname = wildspec;
    196d:	b8 00 02 00 00       	mov    $0x200,%eax
    1972:	e9 de fd ff ff       	jmp    1755 <_do_wild+0x1c5>
        } else {
            ++G.wildname;     /* point at character after '/' or ':' */
            G.dirnamelen = G.wildname - wildspec;
            if ((G.dirname = (char *)malloc(G.dirnamelen+1)) == NULL) {
                Info(slide, 1, ((char *)slide,
    1977:	8d 93 dc 08 00 00    	lea    0x8dc(%ebx),%edx
    197d:	8b ab 44 0b 01 00    	mov    0x10b44(%ebx),%ebp
    1983:	89 d7                	mov    %edx,%edi
    1985:	be 04 02 00 00       	mov    $0x204,%esi
    198a:	b8 2c 00 00 00       	mov    $0x2c,%eax
    198f:	f6 c2 01             	test   $0x1,%dl
    1992:	0f 85 94 00 00 00    	jne    1a2c <_do_wild+0x49c>
    1998:	f7 c7 02 00 00 00    	test   $0x2,%edi
    199e:	75 77                	jne    1a17 <_do_wild+0x487>
    19a0:	89 c1                	mov    %eax,%ecx
    19a2:	c1 e9 02             	shr    $0x2,%ecx
    19a5:	a8 02                	test   $0x2,%al
    19a7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    19a9:	74 0b                	je     19b6 <_do_wild+0x426>
    19ab:	66 8b 0e             	mov    (%esi),%cx
    19ae:	66 89 0f             	mov    %cx,(%edi)
    19b1:	b9 02 00 00 00       	mov    $0x2,%ecx
    19b6:	a8 01                	test   $0x1,%al
    19b8:	74 06                	je     19c0 <_do_wild+0x430>
    19ba:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    19bd:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    19c0:	89 54 24 04          	mov    %edx,0x4(%esp)
    19c4:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    19cb:	00 
    19cc:	c7 44 24 08 2b 00 00 	movl   $0x2b,0x8(%esp)
    19d3:	00 
    19d4:	89 1c 24             	mov    %ebx,(%esp)
    19d7:	ff d5                	call   *%ebp
                  "warning:  cannot allocate wildcard buffers\n"));
                strncpy(G.matchname, wildspec, FILNAMSIZ);
    19d9:	8d b3 a8 0b 01 00    	lea    0x10ba8(%ebx),%esi
            G.wildname = wildspec;
        } else {
            ++G.wildname;     /* point at character after '/' or ':' */
            G.dirnamelen = G.wildname - wildspec;
            if ((G.dirname = (char *)malloc(G.dirnamelen+1)) == NULL) {
                Info(slide, 1, ((char *)slide,
    19df:	83 ec 10             	sub    $0x10,%esp
                  "warning:  cannot allocate wildcard buffers\n"));
                strncpy(G.matchname, wildspec, FILNAMSIZ);
    19e2:	8b 44 24 44          	mov    0x44(%esp),%eax
    19e6:	c7 44 24 08 04 01 00 	movl   $0x104,0x8(%esp)
    19ed:	00 
    19ee:	89 44 24 04          	mov    %eax,0x4(%esp)
    19f2:	89 34 24             	mov    %esi,(%esp)
    19f5:	e8 00 00 00 00       	call   19fa <_do_wild+0x46a>
                G.matchname[FILNAMSIZ-1] = '\0';
    19fa:	c6 83 ab 0c 01 00 00 	movb   $0x0,0x10cab(%ebx)
                return G.matchname; /* but maybe filespec was not a wildcard */
    1a01:	89 f0                	mov    %esi,%eax
    1a03:	e9 1a fc ff ff       	jmp    1622 <_do_wild+0x92>
    1a08:	8d 83 a8 0b 01 00    	lea    0x10ba8(%ebx),%eax
    1a0e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    1a12:	e9 84 fe ff ff       	jmp    189b <_do_wild+0x30b>
            G.wildname = wildspec;
        } else {
            ++G.wildname;     /* point at character after '/' or ':' */
            G.dirnamelen = G.wildname - wildspec;
            if ((G.dirname = (char *)malloc(G.dirnamelen+1)) == NULL) {
                Info(slide, 1, ((char *)slide,
    1a17:	66 8b 0e             	mov    (%esi),%cx
    1a1a:	83 c7 02             	add    $0x2,%edi
    1a1d:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    1a21:	83 c6 02             	add    $0x2,%esi
    1a24:	83 e8 02             	sub    $0x2,%eax
    1a27:	e9 74 ff ff ff       	jmp    19a0 <_do_wild+0x410>
    1a2c:	a0 04 02 00 00       	mov    0x204,%al
    1a31:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    1a37:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    1a3d:	be 05 02 00 00       	mov    $0x205,%esi
    1a42:	b8 2b 00 00 00       	mov    $0x2b,%eax
    1a47:	e9 4c ff ff ff       	jmp    1998 <_do_wild+0x408>
    1a4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001a50 <_mapattr>:
 * permission stuff, so this function should probably be extended in the
 * future. */

int mapattr(__G)
    __GDEF
{
    1a50:	8b 44 24 04          	mov    0x4(%esp),%eax
    /* set archive bit for file entries (file is not backed up): */
    G.pInfo->file_attr = ((unsigned)G.crec.external_file_attributes |
    1a54:	8b 88 d8 08 00 00    	mov    0x8d8(%eax),%ecx
      (G.crec.external_file_attributes & FILE_ATTRIBUTE_DIRECTORY ?
    1a5a:	8b 80 60 09 01 00    	mov    0x10960(%eax),%eax
    1a60:	89 c2                	mov    %eax,%edx
    1a62:	83 e2 10             	and    $0x10,%edx

int mapattr(__G)
    __GDEF
{
    /* set archive bit for file entries (file is not backed up): */
    G.pInfo->file_attr = ((unsigned)G.crec.external_file_attributes |
    1a65:	83 fa 01             	cmp    $0x1,%edx
    1a68:	19 d2                	sbb    %edx,%edx
    1a6a:	83 e2 20             	and    $0x20,%edx
    1a6d:	09 d0                	or     %edx,%eax
      (G.crec.external_file_attributes & FILE_ATTRIBUTE_DIRECTORY ?
       0 : FILE_ATTRIBUTE_ARCHIVE)) & 0xff;
    1a6f:	25 ff 00 00 00       	and    $0xff,%eax
    1a74:	89 41 14             	mov    %eax,0x14(%ecx)
    return 0;

} /* end function mapattr() */
    1a77:	31 c0                	xor    %eax,%eax
    1a79:	c3                   	ret    
    1a7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00001a80 <_dateformat>:
/*************************/
/* Function dateformat() */
/*************************/

int dateformat()
{
    1a80:	83 ec 2c             	sub    $0x2c,%esp
  TCHAR df[2];  /* LOCALE_IDATE has a maximum value of 2 */

  if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDATE, df, 2) != 0) {
    1a83:	8d 44 24 1e          	lea    0x1e(%esp),%eax
    1a87:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
    1a8e:	00 
    1a8f:	89 44 24 08          	mov    %eax,0x8(%esp)
    1a93:	c7 44 24 04 21 00 00 	movl   $0x21,0x4(%esp)
    1a9a:	00 
    1a9b:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp)
    1aa2:	e8 00 00 00 00       	call   1aa7 <_dateformat+0x27>
    1aa7:	83 ec 10             	sub    $0x10,%esp
    1aaa:	85 c0                	test   %eax,%eax
    1aac:	74 14                	je     1ac2 <_dateformat+0x42>
    switch (df[0])
    1aae:	8a 44 24 1e          	mov    0x1e(%esp),%al
    1ab2:	3c 31                	cmp    $0x31,%al
    1ab4:	74 10                	je     1ac6 <_dateformat+0x46>
    {
      case '0':
        return DF_MDY;
    1ab6:	3c 32                	cmp    $0x32,%al
    1ab8:	0f 94 c0             	sete   %al
    1abb:	25 ff 00 00 00       	and    $0xff,%eax
    1ac0:	01 c0                	add    %eax,%eax
      case '2':
        return DF_YMD;
    }
  }
  return DF_MDY;
}
    1ac2:	83 c4 2c             	add    $0x2c,%esp
    1ac5:	c3                   	ret    
    switch (df[0])
    {
      case '0':
        return DF_MDY;
      case '1':
        return DF_DMY;
    1ac6:	b8 01 00 00 00       	mov    $0x1,%eax
      case '2':
        return DF_YMD;
    }
  }
  return DF_MDY;
}
    1acb:	83 c4 2c             	add    $0x2c,%esp
    1ace:	c3                   	ret    
    1acf:	90                   	nop

00001ad0 <_dateseparator>:
/****************************/
/* Function dateseparator() */
/****************************/

char dateseparator()
{
    1ad0:	83 ec 2c             	sub    $0x2c,%esp
  TCHAR df[2];  /* use only if it is one character */

  if ((GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDATE, df, 2) != 0) &&
    1ad3:	8d 44 24 1e          	lea    0x1e(%esp),%eax
    1ad7:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
    1ade:	00 
    1adf:	89 44 24 08          	mov    %eax,0x8(%esp)
    1ae3:	c7 44 24 04 1d 00 00 	movl   $0x1d,0x4(%esp)
    1aea:	00 
    1aeb:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp)
    1af2:	e8 00 00 00 00       	call   1af7 <_dateseparator+0x27>
      (df[0] != '\0'))
    return df[0];
  else
    return '-';
    1af7:	b2 2d                	mov    $0x2d,%dl

char dateseparator()
{
  TCHAR df[2];  /* use only if it is one character */

  if ((GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDATE, df, 2) != 0) &&
    1af9:	83 ec 10             	sub    $0x10,%esp
    1afc:	85 c0                	test   %eax,%eax
    1afe:	75 06                	jne    1b06 <_dateseparator+0x36>
      (df[0] != '\0'))
    return df[0];
  else
    return '-';
}
    1b00:	88 d0                	mov    %dl,%al
    1b02:	83 c4 2c             	add    $0x2c,%esp
    1b05:	c3                   	ret    
char dateseparator()
{
  TCHAR df[2];  /* use only if it is one character */

  if ((GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDATE, df, 2) != 0) &&
      (df[0] != '\0'))
    1b06:	8a 54 24 1e          	mov    0x1e(%esp),%dl
    return df[0];
  else
    return '-';
    1b0a:	b0 2d                	mov    $0x2d,%al
    1b0c:	84 d2                	test   %dl,%dl
    1b0e:	0f 44 d0             	cmove  %eax,%edx
}
    1b11:	88 d0                	mov    %dl,%al
    1b13:	83 c4 2c             	add    $0x2c,%esp
    1b16:	c3                   	ret    
    1b17:	89 f6                	mov    %esi,%esi
    1b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001b20 <_zstat_win32>:
 * a partial fix for 11.0 but still missed some cases.  This substitute  *
 * detects the case and fills in reasonable values.  Otherwise we get    *
 * effects like failure to extract to a root dir because it's not found. */

int zstat_win32(__W32STAT_GLOBALS__ const char *path, struct stat *buf)
{
    1b20:	55                   	push   %ebp
    1b21:	57                   	push   %edi
    1b22:	56                   	push   %esi
    1b23:	53                   	push   %ebx
    1b24:	83 ec 5c             	sub    $0x5c,%esp
    1b27:	8b 74 24 74          	mov    0x74(%esp),%esi
    1b2b:	8b 5c 24 78          	mov    0x78(%esp),%ebx
    if (!stat(path, buf))
    1b2f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1b33:	89 34 24             	mov    %esi,(%esp)
    1b36:	e8 00 00 00 00       	call   1b3b <_zstat_win32+0x1b>
    1b3b:	89 c5                	mov    %eax,%ebp
    1b3d:	85 c0                	test   %eax,%eax
    1b3f:	0f 85 5b 01 00 00    	jne    1ca0 <_zstat_win32+0x180>
/* Function FStampIsLocTime() */
/******************************/

static int FStampIsLocTime(__GPRO__ const char *path)
{
    return (NTQueryVolInfo(__G__ path) ? G.lastVolLocTim : FALSE);
    1b45:	89 f2                	mov    %esi,%edx
    1b47:	8b 44 24 70          	mov    0x70(%esp),%eax
    1b4b:	e8 b0 e4 ff ff       	call   0 <_NTQueryVolInfo>
    1b50:	89 c7                	mov    %eax,%edi
    1b52:	85 c0                	test   %eax,%eax
    1b54:	74 0a                	je     1b60 <_zstat_win32+0x40>
    1b56:	8b 44 24 70          	mov    0x70(%esp),%eax
    1b5a:	8b b8 88 0b 01 00    	mov    0x10b88(%eax),%edi
#else
#       define Ansi_Path  path
#endif

        TTrace((stdout, "stat(%s) finds modtime %08lx\n", path, buf->st_mtime));
        h = CreateFile(Ansi_Path, GENERIC_READ,
    1b60:	89 34 24             	mov    %esi,(%esp)
    1b63:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
    1b6a:	00 
    1b6b:	c7 44 24 14 80 00 00 	movl   $0x80,0x14(%esp)
    1b72:	00 
    1b73:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
    1b7a:	00 
    1b7b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1b82:	00 
    1b83:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    1b8a:	00 
    1b8b:	c7 44 24 04 00 00 00 	movl   $0x80000000,0x4(%esp)
    1b92:	80 
    1b93:	e8 00 00 00 00       	call   1b98 <_zstat_win32+0x78>
    1b98:	83 ec 1c             	sub    $0x1c,%esp
    1b9b:	89 c6                	mov    %eax,%esi
                       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (h != INVALID_HANDLE_VALUE) {
    1b9d:	83 f8 ff             	cmp    $0xffffffff,%eax
    1ba0:	0f 84 ea 00 00 00    	je     1c90 <_zstat_win32+0x170>
            BOOL ftOK = GetFileTime(h, &Creft, &Accft, &Modft);
    1ba6:	8d 44 24 40          	lea    0x40(%esp),%eax
    1baa:	8d 4c 24 38          	lea    0x38(%esp),%ecx
    1bae:	89 44 24 08          	mov    %eax,0x8(%esp)
    1bb2:	8d 44 24 48          	lea    0x48(%esp),%eax
    1bb6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    1bba:	89 44 24 04          	mov    %eax,0x4(%esp)
    1bbe:	89 34 24             	mov    %esi,(%esp)
    1bc1:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
    1bc5:	e8 00 00 00 00       	call   1bca <_zstat_win32+0xaa>
    1bca:	83 ec 10             	sub    $0x10,%esp
            CloseHandle(h);
    1bcd:	89 34 24             	mov    %esi,(%esp)
        TTrace((stdout, "stat(%s) finds modtime %08lx\n", path, buf->st_mtime));
        h = CreateFile(Ansi_Path, GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (h != INVALID_HANDLE_VALUE) {
            BOOL ftOK = GetFileTime(h, &Creft, &Accft, &Modft);
    1bd0:	89 44 24 28          	mov    %eax,0x28(%esp)
            CloseHandle(h);
    1bd4:	e8 00 00 00 00       	call   1bd9 <_zstat_win32+0xb9>
    1bd9:	50                   	push   %eax

            if (ftOK) {
    1bda:	8b 54 24 28          	mov    0x28(%esp),%edx
    1bde:	85 d2                	test   %edx,%edx
    1be0:	0f 84 aa 00 00 00    	je     1c90 <_zstat_win32+0x170>
                FTTrace((stdout, "GetFileTime returned Modft", 0, &Modft));
                FTTrace((stdout, "GetFileTime returned Creft", 0, &Creft));
#ifndef NO_W32TIMES_IZFIX
                if (!fs_uses_loctime) {
    1be6:	85 ff                	test   %edi,%edi
    1be8:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    1bec:	0f 85 3e 01 00 00    	jne    1d30 <_zstat_win32+0x210>
{
#ifdef IZ_USE_INT64
    ULLNG64 NTtime;

    NTtime = ((ULLNG64)pft->dwLowDateTime +
              ((ULLNG64)pft->dwHighDateTime << 32));
    1bf2:	8b 74 24 3c          	mov    0x3c(%esp),%esi
static int NtfsFileTime2utime(const FILETIME *pft, time_t *ut)
{
#ifdef IZ_USE_INT64
    ULLNG64 NTtime;

    NTtime = ((ULLNG64)pft->dwLowDateTime +
    1bf6:	8b 44 24 38          	mov    0x38(%esp),%eax
              ((ULLNG64)pft->dwHighDateTime << 32));
    1bfa:	89 f7                	mov    %esi,%edi
    1bfc:	31 f6                	xor    %esi,%esi
static int NtfsFileTime2utime(const FILETIME *pft, time_t *ut)
{
#ifdef IZ_USE_INT64
    ULLNG64 NTtime;

    NTtime = ((ULLNG64)pft->dwLowDateTime +
    1bfe:	31 d2                	xor    %edx,%edx
    1c00:	01 f0                	add    %esi,%eax
    1c02:	11 fa                	adc    %edi,%edx
        }
    }
    else
#endif /* CHECK_UTIME_SIGNED_UNSIGNED */
    {
        if (NTtime < ((ULLNG64)UNIX_TIME_ZERO_LO +
    1c04:	81 fa de b1 9d 01    	cmp    $0x19db1de,%edx
    1c0a:	0f 87 93 01 00 00    	ja     1da3 <_zstat_win32+0x283>
    1c10:	0f 83 82 01 00 00    	jae    1d98 <_zstat_win32+0x278>
                      ((ULLNG64)UNIX_TIME_ZERO_HI << 32))) {
            *ut = (time_t)0;
    1c16:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
                     *  the time fields of the struct stat buffer by directly
                     *  using the UTC values as returned by the Win32
                     *  GetFileTime() API call.
                     */
                    NtfsFileTime2utime(&Modft, &(buf->st_mtime));
                    if (Accft.dwLowDateTime != 0 || Accft.dwHighDateTime != 0)
    1c1d:	8b 44 24 40          	mov    0x40(%esp),%eax
    1c21:	8b 74 24 44          	mov    0x44(%esp),%esi
    1c25:	85 c0                	test   %eax,%eax
    1c27:	75 08                	jne    1c31 <_zstat_win32+0x111>
    1c29:	85 f6                	test   %esi,%esi
    1c2b:	0f 84 12 02 00 00    	je     1e43 <_zstat_win32+0x323>
{
#ifdef IZ_USE_INT64
    ULLNG64 NTtime;

    NTtime = ((ULLNG64)pft->dwLowDateTime +
              ((ULLNG64)pft->dwHighDateTime << 32));
    1c31:	89 f7                	mov    %esi,%edi
    1c33:	31 f6                	xor    %esi,%esi
static int NtfsFileTime2utime(const FILETIME *pft, time_t *ut)
{
#ifdef IZ_USE_INT64
    ULLNG64 NTtime;

    NTtime = ((ULLNG64)pft->dwLowDateTime +
    1c35:	31 d2                	xor    %edx,%edx
    1c37:	01 f0                	add    %esi,%eax
    1c39:	11 fa                	adc    %edi,%edx
        }
    }
    else
#endif /* CHECK_UTIME_SIGNED_UNSIGNED */
    {
        if (NTtime < ((ULLNG64)UNIX_TIME_ZERO_LO +
    1c3b:	81 fa de b1 9d 01    	cmp    $0x19db1de,%edx
    1c41:	0f 87 84 01 00 00    	ja     1dcb <_zstat_win32+0x2ab>
    1c47:	0f 83 73 01 00 00    	jae    1dc0 <_zstat_win32+0x2a0>
                      ((ULLNG64)UNIX_TIME_ZERO_HI << 32))) {
            *ut = (time_t)0;
    1c4d:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
                    NtfsFileTime2utime(&Modft, &(buf->st_mtime));
                    if (Accft.dwLowDateTime != 0 || Accft.dwHighDateTime != 0)
                        NtfsFileTime2utime(&Accft, &(buf->st_atime));
                    else
                        buf->st_atime = buf->st_mtime;
                    if (Creft.dwLowDateTime != 0 || Creft.dwHighDateTime != 0)
    1c54:	8b 44 24 48          	mov    0x48(%esp),%eax
    1c58:	8b 74 24 4c          	mov    0x4c(%esp),%esi
    1c5c:	85 c0                	test   %eax,%eax
    1c5e:	75 08                	jne    1c68 <_zstat_win32+0x148>
    1c60:	85 f6                	test   %esi,%esi
    1c62:	0f 84 18 01 00 00    	je     1d80 <_zstat_win32+0x260>
{
#ifdef IZ_USE_INT64
    ULLNG64 NTtime;

    NTtime = ((ULLNG64)pft->dwLowDateTime +
              ((ULLNG64)pft->dwHighDateTime << 32));
    1c68:	89 f7                	mov    %esi,%edi
    1c6a:	31 f6                	xor    %esi,%esi
static int NtfsFileTime2utime(const FILETIME *pft, time_t *ut)
{
#ifdef IZ_USE_INT64
    ULLNG64 NTtime;

    NTtime = ((ULLNG64)pft->dwLowDateTime +
    1c6c:	31 d2                	xor    %edx,%edx
    1c6e:	01 f0                	add    %esi,%eax
    1c70:	11 fa                	adc    %edi,%edx
        }
    }
    else
#endif /* CHECK_UTIME_SIGNED_UNSIGNED */
    {
        if (NTtime < ((ULLNG64)UNIX_TIME_ZERO_LO +
    1c72:	81 fa de b1 9d 01    	cmp    $0x19db1de,%edx
    1c78:	0f 87 75 01 00 00    	ja     1df3 <_zstat_win32+0x2d3>
    1c7e:	0f 83 64 01 00 00    	jae    1de8 <_zstat_win32+0x2c8>
                      ((ULLNG64)UNIX_TIME_ZERO_HI << 32))) {
            *ut = (time_t)0;
    1c84:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    1c8b:	90                   	nop
    1c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        } /* assumes: stat() won't fail on non-dirs without good reason */
#       undef Ansi_Path
    }
#endif /* W32_STATROOT_FIX */
    return -1;
}
    1c90:	83 c4 5c             	add    $0x5c,%esp
    1c93:	89 e8                	mov    %ebp,%eax
    1c95:	5b                   	pop    %ebx
    1c96:	5e                   	pop    %esi
    1c97:	5f                   	pop    %edi
    1c98:	5d                   	pop    %ebp
    1c99:	c3                   	ret    
    1c9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#       define Ansi_Path  ansi_path
#else
#       define Ansi_Path  path
#endif

        flags = GetFileAttributes(Ansi_Path);
    1ca0:	89 34 24             	mov    %esi,(%esp)
    1ca3:	e8 00 00 00 00       	call   1ca8 <_zstat_win32+0x188>
    1ca8:	89 c6                	mov    %eax,%esi
        if (flags != 0xFFFFFFFF && flags & FILE_ATTRIBUTE_DIRECTORY) {
    1caa:	83 f8 ff             	cmp    $0xffffffff,%eax
#       define Ansi_Path  ansi_path
#else
#       define Ansi_Path  path
#endif

        flags = GetFileAttributes(Ansi_Path);
    1cad:	52                   	push   %edx
        if (flags != 0xFFFFFFFF && flags & FILE_ATTRIBUTE_DIRECTORY) {
    1cae:	0f 84 dc 00 00 00    	je     1d90 <_zstat_win32+0x270>
    1cb4:	a8 10                	test   $0x10,%al
    1cb6:	0f 84 d4 00 00 00    	je     1d90 <_zstat_win32+0x270>
            Trace((stderr, "\nstat(\"%s\",...) failed on existing directory\n",
                   FnFilter1(path)));
            memset(buf, 0, sizeof(struct stat));
    1cbc:	89 df                	mov    %ebx,%edi
    1cbe:	ba 24 00 00 00       	mov    $0x24,%edx
    1cc3:	f6 c3 01             	test   $0x1,%bl
    1cc6:	0f 85 05 02 00 00    	jne    1ed1 <_zstat_win32+0x3b1>
    1ccc:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1cd2:	0f 85 e9 01 00 00    	jne    1ec1 <_zstat_win32+0x3a1>
    1cd8:	89 d1                	mov    %edx,%ecx
    1cda:	31 c0                	xor    %eax,%eax
    1cdc:	c1 e9 02             	shr    $0x2,%ecx
    1cdf:	f3 ab                	rep stos %eax,%es:(%edi)
    1ce1:	f6 c2 02             	test   $0x2,%dl
    1ce4:	74 08                	je     1cee <_zstat_win32+0x1ce>
    1ce6:	66 c7 07 00 00       	movw   $0x0,(%edi)
    1ceb:	83 c7 02             	add    $0x2,%edi
    1cee:	83 e2 01             	and    $0x1,%edx
    1cf1:	74 03                	je     1cf6 <_zstat_win32+0x1d6>
    1cf3:	c6 07 00             	movb   $0x0,(%edi)
            buf->st_atime = buf->st_ctime = buf->st_mtime =
              dos_to_unix_time(DOSTIME_MINIMUM);        /* 1-1-80 */
    1cf6:	c7 04 24 00 00 21 00 	movl   $0x210000,(%esp)
    1cfd:	e8 00 00 00 00       	call   1d02 <_zstat_win32+0x1e2>
            buf->st_mode = S_IFDIR | S_IREAD |
    1d02:	ba 80 41 00 00       	mov    $0x4180,%edx
        flags = GetFileAttributes(Ansi_Path);
        if (flags != 0xFFFFFFFF && flags & FILE_ATTRIBUTE_DIRECTORY) {
            Trace((stderr, "\nstat(\"%s\",...) failed on existing directory\n",
                   FnFilter1(path)));
            memset(buf, 0, sizeof(struct stat));
            buf->st_atime = buf->st_ctime = buf->st_mtime =
    1d07:	89 43 1c             	mov    %eax,0x1c(%ebx)
    1d0a:	89 43 20             	mov    %eax,0x20(%ebx)
    1d0d:	89 43 18             	mov    %eax,0x18(%ebx)
              dos_to_unix_time(DOSTIME_MINIMUM);        /* 1-1-80 */
            buf->st_mode = S_IFDIR | S_IREAD |
    1d10:	b8 00 41 00 00       	mov    $0x4100,%eax
    1d15:	83 e6 01             	and    $0x1,%esi
    1d18:	0f 44 c2             	cmove  %edx,%eax
    1d1b:	66 89 43 06          	mov    %ax,0x6(%ebx)
        } /* assumes: stat() won't fail on non-dirs without good reason */
#       undef Ansi_Path
    }
#endif /* W32_STATROOT_FIX */
    return -1;
}
    1d1f:	83 c4 5c             	add    $0x5c,%esp
            memset(buf, 0, sizeof(struct stat));
            buf->st_atime = buf->st_ctime = buf->st_mtime =
              dos_to_unix_time(DOSTIME_MINIMUM);        /* 1-1-80 */
            buf->st_mode = S_IFDIR | S_IREAD |
                           ((flags & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE);
            return 0;
    1d22:	31 ed                	xor    %ebp,%ebp
        } /* assumes: stat() won't fail on non-dirs without good reason */
#       undef Ansi_Path
    }
#endif /* W32_STATROOT_FIX */
    return -1;
}
    1d24:	5b                   	pop    %ebx
    1d25:	89 e8                	mov    %ebp,%eax
    1d27:	5e                   	pop    %esi
    1d28:	5f                   	pop    %edi
    1d29:	5d                   	pop    %ebp
    1d2a:	c3                   	ret    
    1d2b:	90                   	nop
    1d2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                {
                    /*  On VFAT and FAT-like filesystems, the FILETIME values
                     *  are converted back to the stable local time before
                     *  converting them to UTC unix time-stamps.
                     */
                    VFatFileTime2utime(&Modft, &(buf->st_mtime));
    1d30:	8d 53 1c             	lea    0x1c(%ebx),%edx
    1d33:	89 c8                	mov    %ecx,%eax
    1d35:	e8 76 e9 ff ff       	call   6b0 <_VFatFileTime2utime>
                    if (Accft.dwLowDateTime != 0 || Accft.dwHighDateTime != 0)
    1d3a:	8b 44 24 40          	mov    0x40(%esp),%eax
    1d3e:	85 c0                	test   %eax,%eax
    1d40:	0f 85 6a 01 00 00    	jne    1eb0 <_zstat_win32+0x390>
    1d46:	8b 7c 24 44          	mov    0x44(%esp),%edi
    1d4a:	85 ff                	test   %edi,%edi
    1d4c:	0f 85 5e 01 00 00    	jne    1eb0 <_zstat_win32+0x390>
                        VFatFileTime2utime(&Accft, &(buf->st_atime));
                    else
                        buf->st_atime = buf->st_mtime;
    1d52:	8b 43 1c             	mov    0x1c(%ebx),%eax
    1d55:	89 43 18             	mov    %eax,0x18(%ebx)
                    if (Creft.dwLowDateTime != 0 || Creft.dwHighDateTime != 0)
    1d58:	8b 74 24 48          	mov    0x48(%esp),%esi
    1d5c:	85 f6                	test   %esi,%esi
    1d5e:	75 08                	jne    1d68 <_zstat_win32+0x248>
    1d60:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
    1d64:	85 c9                	test   %ecx,%ecx
    1d66:	74 18                	je     1d80 <_zstat_win32+0x260>
                        VFatFileTime2utime(&Creft, &(buf->st_ctime));
    1d68:	8d 53 20             	lea    0x20(%ebx),%edx
    1d6b:	8d 44 24 48          	lea    0x48(%esp),%eax
    1d6f:	e8 3c e9 ff ff       	call   6b0 <_VFatFileTime2utime>
    1d74:	e9 17 ff ff ff       	jmp    1c90 <_zstat_win32+0x170>
    1d79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                    else
                        buf->st_ctime = buf->st_mtime;
    1d80:	8b 43 1c             	mov    0x1c(%ebx),%eax
    1d83:	89 43 20             	mov    %eax,0x20(%ebx)
    1d86:	e9 05 ff ff ff       	jmp    1c90 <_zstat_win32+0x170>
    1d8b:	90                   	nop
    1d8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            return 0;
        } /* assumes: stat() won't fail on non-dirs without good reason */
#       undef Ansi_Path
    }
#endif /* W32_STATROOT_FIX */
    return -1;
    1d90:	83 cd ff             	or     $0xffffffff,%ebp
    1d93:	e9 f8 fe ff ff       	jmp    1c90 <_zstat_win32+0x170>
        }
    }
    else
#endif /* CHECK_UTIME_SIGNED_UNSIGNED */
    {
        if (NTtime < ((ULLNG64)UNIX_TIME_ZERO_LO +
    1d98:	3d ff 7f 3e d5       	cmp    $0xd53e7fff,%eax
    1d9d:	0f 86 73 fe ff ff    	jbe    1c16 <_zstat_win32+0xf6>
                      ((ULLNG64)UNIX_TIME_ZERO_HI << 32))) {
            *ut = (time_t)0;
            return FALSE;
        }
        if (NTtime > ((ULLNG64)UNIX_TIME_UMAX_LO +
    1da3:	81 fa 5e 48 36 02    	cmp    $0x236485e,%edx
    1da9:	72 69                	jb     1e14 <_zstat_win32+0x2f4>
    1dab:	77 07                	ja     1db4 <_zstat_win32+0x294>
    1dad:	3d 80 e9 a5 d4       	cmp    $0xd4a5e980,%eax
    1db2:	76 60                	jbe    1e14 <_zstat_win32+0x2f4>
                      ((ULLNG64)UNIX_TIME_UMAX_HI << 32))) {
            *ut = (time_t)ULONG_MAX;
    1db4:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
    1dbb:	e9 5d fe ff ff       	jmp    1c1d <_zstat_win32+0xfd>
        }
    }
    else
#endif /* CHECK_UTIME_SIGNED_UNSIGNED */
    {
        if (NTtime < ((ULLNG64)UNIX_TIME_ZERO_LO +
    1dc0:	3d ff 7f 3e d5       	cmp    $0xd53e7fff,%eax
    1dc5:	0f 86 82 fe ff ff    	jbe    1c4d <_zstat_win32+0x12d>
                      ((ULLNG64)UNIX_TIME_ZERO_HI << 32))) {
            *ut = (time_t)0;
            return FALSE;
        }
        if (NTtime > ((ULLNG64)UNIX_TIME_UMAX_LO +
    1dcb:	81 fa 5e 48 36 02    	cmp    $0x236485e,%edx
    1dd1:	72 7d                	jb     1e50 <_zstat_win32+0x330>
    1dd3:	77 07                	ja     1ddc <_zstat_win32+0x2bc>
    1dd5:	3d 80 e9 a5 d4       	cmp    $0xd4a5e980,%eax
    1dda:	76 74                	jbe    1e50 <_zstat_win32+0x330>
                      ((ULLNG64)UNIX_TIME_UMAX_HI << 32))) {
            *ut = (time_t)ULONG_MAX;
    1ddc:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
    1de3:	e9 6c fe ff ff       	jmp    1c54 <_zstat_win32+0x134>
        }
    }
    else
#endif /* CHECK_UTIME_SIGNED_UNSIGNED */
    {
        if (NTtime < ((ULLNG64)UNIX_TIME_ZERO_LO +
    1de8:	3d ff 7f 3e d5       	cmp    $0xd53e7fff,%eax
    1ded:	0f 86 91 fe ff ff    	jbe    1c84 <_zstat_win32+0x164>
                      ((ULLNG64)UNIX_TIME_ZERO_HI << 32))) {
            *ut = (time_t)0;
            return FALSE;
        }
        if (NTtime > ((ULLNG64)UNIX_TIME_UMAX_LO +
    1df3:	81 fa 5e 48 36 02    	cmp    $0x236485e,%edx
    1df9:	0f 82 81 00 00 00    	jb     1e80 <_zstat_win32+0x360>
    1dff:	77 07                	ja     1e08 <_zstat_win32+0x2e8>
    1e01:	3d 80 e9 a5 d4       	cmp    $0xd4a5e980,%eax
    1e06:	76 78                	jbe    1e80 <_zstat_win32+0x360>
                      ((ULLNG64)UNIX_TIME_UMAX_HI << 32))) {
            *ut = (time_t)ULONG_MAX;
    1e08:	c7 43 20 ff ff ff ff 	movl   $0xffffffff,0x20(%ebx)
    1e0f:	e9 7c fe ff ff       	jmp    1c90 <_zstat_win32+0x170>
            return FALSE;
        }
    }
#endif /* !TIME_T_TYPE_DOUBLE */

    NTtime -= ((ULLNG64)UNIX_TIME_ZERO_LO +
    1e14:	05 00 80 c1 2a       	add    $0x2ac18000,%eax
               ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    *ut = (time_t)(NTtime / (unsigned long)NT_QUANTA_PER_UNIX);
    1e19:	c7 44 24 08 80 96 98 	movl   $0x989680,0x8(%esp)
    1e20:	00 
            return FALSE;
        }
    }
#endif /* !TIME_T_TYPE_DOUBLE */

    NTtime -= ((ULLNG64)UNIX_TIME_ZERO_LO +
    1e21:	81 d2 21 4e 62 fe    	adc    $0xfe624e21,%edx
               ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    *ut = (time_t)(NTtime / (unsigned long)NT_QUANTA_PER_UNIX);
    1e27:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1e2e:	00 
    1e2f:	89 04 24             	mov    %eax,(%esp)
    1e32:	89 54 24 04          	mov    %edx,0x4(%esp)
    1e36:	e8 00 00 00 00       	call   1e3b <_zstat_win32+0x31b>
    1e3b:	89 43 1c             	mov    %eax,0x1c(%ebx)
    1e3e:	e9 da fd ff ff       	jmp    1c1d <_zstat_win32+0xfd>
                     */
                    NtfsFileTime2utime(&Modft, &(buf->st_mtime));
                    if (Accft.dwLowDateTime != 0 || Accft.dwHighDateTime != 0)
                        NtfsFileTime2utime(&Accft, &(buf->st_atime));
                    else
                        buf->st_atime = buf->st_mtime;
    1e43:	8b 43 1c             	mov    0x1c(%ebx),%eax
    1e46:	89 43 18             	mov    %eax,0x18(%ebx)
    1e49:	e9 06 fe ff ff       	jmp    1c54 <_zstat_win32+0x134>
    1e4e:	66 90                	xchg   %ax,%ax
            return FALSE;
        }
    }
#endif /* !TIME_T_TYPE_DOUBLE */

    NTtime -= ((ULLNG64)UNIX_TIME_ZERO_LO +
    1e50:	05 00 80 c1 2a       	add    $0x2ac18000,%eax
               ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    *ut = (time_t)(NTtime / (unsigned long)NT_QUANTA_PER_UNIX);
    1e55:	c7 44 24 08 80 96 98 	movl   $0x989680,0x8(%esp)
    1e5c:	00 
            return FALSE;
        }
    }
#endif /* !TIME_T_TYPE_DOUBLE */

    NTtime -= ((ULLNG64)UNIX_TIME_ZERO_LO +
    1e5d:	81 d2 21 4e 62 fe    	adc    $0xfe624e21,%edx
               ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    *ut = (time_t)(NTtime / (unsigned long)NT_QUANTA_PER_UNIX);
    1e63:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1e6a:	00 
    1e6b:	89 04 24             	mov    %eax,(%esp)
    1e6e:	89 54 24 04          	mov    %edx,0x4(%esp)
    1e72:	e8 00 00 00 00       	call   1e77 <_zstat_win32+0x357>
    1e77:	89 43 18             	mov    %eax,0x18(%ebx)
    1e7a:	e9 d5 fd ff ff       	jmp    1c54 <_zstat_win32+0x134>
    1e7f:	90                   	nop
            return FALSE;
        }
    }
#endif /* !TIME_T_TYPE_DOUBLE */

    NTtime -= ((ULLNG64)UNIX_TIME_ZERO_LO +
    1e80:	05 00 80 c1 2a       	add    $0x2ac18000,%eax
               ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    *ut = (time_t)(NTtime / (unsigned long)NT_QUANTA_PER_UNIX);
    1e85:	c7 44 24 08 80 96 98 	movl   $0x989680,0x8(%esp)
    1e8c:	00 
            return FALSE;
        }
    }
#endif /* !TIME_T_TYPE_DOUBLE */

    NTtime -= ((ULLNG64)UNIX_TIME_ZERO_LO +
    1e8d:	81 d2 21 4e 62 fe    	adc    $0xfe624e21,%edx
               ((ULLNG64)UNIX_TIME_ZERO_HI << 32));
    *ut = (time_t)(NTtime / (unsigned long)NT_QUANTA_PER_UNIX);
    1e93:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1e9a:	00 
    1e9b:	89 04 24             	mov    %eax,(%esp)
    1e9e:	89 54 24 04          	mov    %edx,0x4(%esp)
    1ea2:	e8 00 00 00 00       	call   1ea7 <_zstat_win32+0x387>
    1ea7:	89 43 20             	mov    %eax,0x20(%ebx)
    1eaa:	e9 e1 fd ff ff       	jmp    1c90 <_zstat_win32+0x170>
    1eaf:	90                   	nop
                     *  are converted back to the stable local time before
                     *  converting them to UTC unix time-stamps.
                     */
                    VFatFileTime2utime(&Modft, &(buf->st_mtime));
                    if (Accft.dwLowDateTime != 0 || Accft.dwHighDateTime != 0)
                        VFatFileTime2utime(&Accft, &(buf->st_atime));
    1eb0:	8d 53 18             	lea    0x18(%ebx),%edx
    1eb3:	8d 44 24 40          	lea    0x40(%esp),%eax
    1eb7:	e8 f4 e7 ff ff       	call   6b0 <_VFatFileTime2utime>
    1ebc:	e9 97 fe ff ff       	jmp    1d58 <_zstat_win32+0x238>

        flags = GetFileAttributes(Ansi_Path);
        if (flags != 0xFFFFFFFF && flags & FILE_ATTRIBUTE_DIRECTORY) {
            Trace((stderr, "\nstat(\"%s\",...) failed on existing directory\n",
                   FnFilter1(path)));
            memset(buf, 0, sizeof(struct stat));
    1ec1:	66 c7 07 00 00       	movw   $0x0,(%edi)
    1ec6:	83 ea 02             	sub    $0x2,%edx
    1ec9:	83 c7 02             	add    $0x2,%edi
    1ecc:	e9 07 fe ff ff       	jmp    1cd8 <_zstat_win32+0x1b8>
    1ed1:	c6 03 00             	movb   $0x0,(%ebx)
    1ed4:	8d 7b 01             	lea    0x1(%ebx),%edi
    1ed7:	b2 23                	mov    $0x23,%dl
    1ed9:	e9 ee fd ff ff       	jmp    1ccc <_zstat_win32+0x1ac>
    1ede:	66 90                	xchg   %ax,%ax

00001ee0 <_checkdir>:
 *  MPN_ERR_SKIP    - path doesn't exist, tried to create and failed; or path
 *                    exists and is not a directory, but is supposed to be
 *  MPN_ERR_TOOLONG - path is too long
 *  MPN_NOMEM       - can't allocate memory for filename buffers
 */
{
    1ee0:	55                   	push   %ebp
    1ee1:	57                   	push   %edi
    1ee2:	56                   	push   %esi
    1ee3:	53                   	push   %ebx
    1ee4:	81 ec 3c 01 00 00    	sub    $0x13c,%esp
    APPEND_DIR:  append the path component to the path being built and check
    for its existence.  If doesn't exist and we are creating directories, do
    so for this one; else signal success or error as appropriate.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == APPEND_DIR) {
    1eea:	8b 9c 24 58 01 00 00 	mov    0x158(%esp),%ebx
 *  MPN_ERR_SKIP    - path doesn't exist, tried to create and failed; or path
 *                    exists and is not a directory, but is supposed to be
 *  MPN_ERR_TOOLONG - path is too long
 *  MPN_NOMEM       - can't allocate memory for filename buffers
 */
{
    1ef1:	8b ac 24 50 01 00 00 	mov    0x150(%esp),%ebp
    APPEND_DIR:  append the path component to the path being built and check
    for its existence.  If doesn't exist and we are creating directories, do
    so for this one; else signal success or error as appropriate.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == APPEND_DIR) {
    1ef8:	83 e3 07             	and    $0x7,%ebx
    1efb:	83 fb 02             	cmp    $0x2,%ebx
    1efe:	74 50                	je     1f50 <_checkdir+0x70>
    GETPATH:  copy full FAT path to the string pointed at by pathcomp (want
    filename to reflect name used on disk, not EAs; if full path is HPFS,
    buildpathFAT and buildpathHPFS will be identical).  Also free both paths.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == GETPATH) {
    1f00:	83 fb 04             	cmp    $0x4,%ebx
    1f03:	0f 84 cb 04 00 00    	je     23d4 <_checkdir+0x4f4>
/*---------------------------------------------------------------------------
    APPEND_NAME:  assume the path component is the filename; append it and
    return without checking for existence.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == APPEND_NAME) {
    1f09:	83 fb 03             	cmp    $0x3,%ebx
    1f0c:	0f 84 8e 01 00 00    	je     20a0 <_checkdir+0x1c0>
    INIT:  allocate and initialize buffer space for the file currently being
    extracted.  If file was renamed with an absolute path, don't prepend the
    extract-to path.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == INIT) {
    1f12:	83 fb 01             	cmp    $0x1,%ebx
    1f15:	0f 84 1d 05 00 00    	je     2438 <_checkdir+0x558>
    will be created if the path doesn't exist, unless this is otherwise pro-
    hibited (e.g., freshening).
  ---------------------------------------------------------------------------*/

#if (!defined(SFX) || defined(SFX_EXDIR))
    if (FUNCTION == ROOT) {
    1f1b:	85 db                	test   %ebx,%ebx
    1f1d:	0f 85 5d 01 00 00    	jne    2080 <_checkdir+0x1a0>
        Trace((stderr, "initializing root path to [%s]\n",
          FnFilter1(pathcomp)));
        if (pathcomp == NULL) {
    1f23:	8b b4 24 54 01 00 00 	mov    0x154(%esp),%esi
    1f2a:	85 f6                	test   %esi,%esi
    1f2c:	0f 84 9b 06 00 00    	je     25cd <_checkdir+0x6ed>
            G.rootlen = 0;
            return MPN_OK;
        }
        if (G.rootlen > 0)      /* rootpath was already set, nothing to do */
    1f32:	8b 8d ac 0c 01 00    	mov    0x10cac(%ebp),%ecx
    1f38:	85 c9                	test   %ecx,%ecx
    1f3a:	0f 8e e0 02 00 00    	jle    2220 <_checkdir+0x340>
        while ((*G.endFAT = *G.endHPFS) != '\0') {
            ++G.endFAT;
            ++G.endHPFS;
        }
        Trace((stderr, "[%s]\n", FnFilter1(G.buildpathHPFS)));
        return MPN_OK;
    1f40:	31 db                	xor    %ebx,%ebx
        return MPN_OK;
    }

    return MPN_INVALID; /* should never reach */

} /* end function checkdir() */
    1f42:	81 c4 3c 01 00 00    	add    $0x13c,%esp
    1f48:	89 d8                	mov    %ebx,%eax
    1f4a:	5b                   	pop    %ebx
    1f4b:	5e                   	pop    %esi
    1f4c:	5f                   	pop    %edi
    1f4d:	5d                   	pop    %ebp
    1f4e:	c3                   	ret    
    1f4f:	90                   	nop
    if (FUNCTION == APPEND_DIR) {
        char *p = pathcomp;
        int too_long = FALSE;

        Trace((stderr, "appending dir segment [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0')     /* copy to HPFS filename */
    1f50:	8b b4 24 54 01 00 00 	mov    0x154(%esp),%esi
    1f57:	8b 85 98 0b 01 00    	mov    0x10b98(%ebp),%eax
    1f5d:	8a 16                	mov    (%esi),%dl
    1f5f:	8d 5e 01             	lea    0x1(%esi),%ebx
    1f62:	88 10                	mov    %dl,(%eax)
    1f64:	84 d2                	test   %dl,%dl
    1f66:	89 d8                	mov    %ebx,%eax
    1f68:	74 20                	je     1f8a <_checkdir+0xaa>
    1f6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            ++G.endHPFS;
    1f70:	8b 8d 98 0b 01 00    	mov    0x10b98(%ebp),%ecx
    if (FUNCTION == APPEND_DIR) {
        char *p = pathcomp;
        int too_long = FALSE;

        Trace((stderr, "appending dir segment [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0')     /* copy to HPFS filename */
    1f76:	40                   	inc    %eax
            ++G.endHPFS;
    1f77:	8d 51 01             	lea    0x1(%ecx),%edx
    1f7a:	89 95 98 0b 01 00    	mov    %edx,0x10b98(%ebp)
    if (FUNCTION == APPEND_DIR) {
        char *p = pathcomp;
        int too_long = FALSE;

        Trace((stderr, "appending dir segment [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0')     /* copy to HPFS filename */
    1f80:	8a 50 ff             	mov    -0x1(%eax),%dl
    1f83:	88 51 01             	mov    %dl,0x1(%ecx)
    1f86:	84 d2                	test   %dl,%dl
    1f88:	75 e6                	jne    1f70 <_checkdir+0x90>
/* Function IsVolumeOldFAT() */
/*****************************/

static int IsVolumeOldFAT(__GPRO__ const char *name)
{
    return (NTQueryVolInfo(__G__ name) ? G.lastVolOldFAT : FALSE);
    1f8a:	8b 95 90 0b 01 00    	mov    0x10b90(%ebp),%edx
    1f90:	89 e8                	mov    %ebp,%eax
    1f92:	e8 69 e0 ff ff       	call   0 <_NTQueryVolInfo>
    1f97:	85 c0                	test   %eax,%eax
    1f99:	0f 84 41 02 00 00    	je     21e0 <_checkdir+0x300>
        int too_long = FALSE;

        Trace((stderr, "appending dir segment [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0')     /* copy to HPFS filename */
            ++G.endHPFS;
        if (!IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
    1f9f:	8b 8d 84 0b 01 00    	mov    0x10b84(%ebp),%ecx
    1fa5:	85 c9                	test   %ecx,%ecx
    1fa7:	0f 84 33 02 00 00    	je     21e0 <_checkdir+0x300>
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
                ++G.endFAT;
        } else
            map2fat(pathcomp, &G.endFAT);   /* map into FAT fn, update endFAT */
    1fad:	8d 95 9c 0b 01 00    	lea    0x10b9c(%ebp),%edx
    1fb3:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    1fba:	e8 91 e3 ff ff       	call   350 <_map2fat>
         * check endHPFS-buildpathHPFS after each append, set warning variable
         * if within 20 of FILNAMSIZ; then if var set, do careful check when
         * appending.  Clear variable when begin new path. */

        /* next check:  need to append '/', at least one-char name, '\0' */
        if ((G.endHPFS-G.buildpathHPFS) > FILNAMSIZ-3)
    1fbf:	8b 85 98 0b 01 00    	mov    0x10b98(%ebp),%eax
    1fc5:	8b 95 90 0b 01 00    	mov    0x10b90(%ebp),%edx
    1fcb:	29 d0                	sub    %edx,%eax
    1fcd:	3d 01 01 00 00       	cmp    $0x101,%eax
                return MPN_ERR_SKIP;
            }
            G.created_dir = TRUE;
        }
#endif /* FIX_STAT_BUG */
        if (SSTAT(G.buildpathFAT, &G.statbuf))   /* path doesn't exist */
    1fd2:	8d 85 7c 09 01 00    	lea    0x1097c(%ebp),%eax
    1fd8:	89 44 24 08          	mov    %eax,0x8(%esp)
    1fdc:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    1fe2:	89 2c 24             	mov    %ebp,(%esp)
    1fe5:	89 44 24 04          	mov    %eax,0x4(%esp)
         * check endHPFS-buildpathHPFS after each append, set warning variable
         * if within 20 of FILNAMSIZ; then if var set, do careful check when
         * appending.  Clear variable when begin new path. */

        /* next check:  need to append '/', at least one-char name, '\0' */
        if ((G.endHPFS-G.buildpathHPFS) > FILNAMSIZ-3)
    1fe9:	0f 9f c3             	setg   %bl
                return MPN_ERR_SKIP;
            }
            G.created_dir = TRUE;
        }
#endif /* FIX_STAT_BUG */
        if (SSTAT(G.buildpathFAT, &G.statbuf))   /* path doesn't exist */
    1fec:	e8 2f fb ff ff       	call   1b20 <_zstat_win32>
    1ff1:	85 c0                	test   %eax,%eax
    1ff3:	0f 84 29 03 00 00    	je     2322 <_checkdir+0x442>
        {
            if (!G.create_dirs) { /* told not to create (freshening) */
    1ff9:	8b 7d 7c             	mov    0x7c(%ebp),%edi
    1ffc:	85 ff                	test   %edi,%edi
    1ffe:	0f 84 3c 05 00 00    	je     2540 <_checkdir+0x660>
                free(G.buildpathHPFS);
                free(G.buildpathFAT);
                /* path doesn't exist:  nothing to do */
                return MPN_INF_SKIP;
            }
            if (too_long) {   /* GRR:  should allow FAT extraction w/o EAs */
    2004:	84 db                	test   %bl,%bl
    2006:	0f 84 19 06 00 00    	je     2625 <_checkdir+0x745>
            free(G.buildpathFAT);
            /* path existed but wasn't dir */
            return MPN_ERR_SKIP;
        }
        if (too_long) {
            Info(slide, 1, ((char *)slide,
    200c:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2012:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    2018:	89 44 24 04          	mov    %eax,0x4(%esp)
    201c:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    2022:	8b 85 90 0b 01 00    	mov    0x10b90(%ebp),%eax
    2028:	89 04 24             	mov    %eax,(%esp)
    202b:	e8 00 00 00 00       	call   2030 <_checkdir+0x150>
    2030:	89 1c 24             	mov    %ebx,(%esp)
    2033:	89 44 24 08          	mov    %eax,0x8(%esp)
    2037:	c7 44 24 04 34 02 00 	movl   $0x234,0x4(%esp)
    203e:	00 
    203f:	e8 00 00 00 00       	call   2044 <_checkdir+0x164>
    2044:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2048:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    204f:	00 
    2050:	89 44 24 08          	mov    %eax,0x8(%esp)
    2054:	89 2c 24             	mov    %ebp,(%esp)
              "checkdir error:  path too long: %s\n",
               FnFilter1(G.buildpathHPFS)));
            free(G.buildpathHPFS);
            free(G.buildpathFAT);
            /* no room for filenames:  fatal */
            return MPN_ERR_TOOLONG;
    2057:	bb 00 04 00 00       	mov    $0x400,%ebx
            free(G.buildpathFAT);
            /* path existed but wasn't dir */
            return MPN_ERR_SKIP;
        }
        if (too_long) {
            Info(slide, 1, ((char *)slide,
    205c:	ff d6                	call   *%esi
              "checkdir error:  path too long: %s\n",
               FnFilter1(G.buildpathHPFS)));
            free(G.buildpathHPFS);
    205e:	8b 85 90 0b 01 00    	mov    0x10b90(%ebp),%eax
            free(G.buildpathFAT);
            /* path existed but wasn't dir */
            return MPN_ERR_SKIP;
        }
        if (too_long) {
            Info(slide, 1, ((char *)slide,
    2064:	83 ec 10             	sub    $0x10,%esp
              "checkdir error:  path too long: %s\n",
               FnFilter1(G.buildpathHPFS)));
            free(G.buildpathHPFS);
    2067:	89 04 24             	mov    %eax,(%esp)
    206a:	e8 00 00 00 00       	call   206f <_checkdir+0x18f>
            free(G.buildpathFAT);
    206f:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    2075:	89 04 24             	mov    %eax,(%esp)
    2078:	e8 00 00 00 00       	call   207d <_checkdir+0x19d>
            /* no room for filenames:  fatal */
            return MPN_ERR_TOOLONG;
    207d:	eb 0f                	jmp    208e <_checkdir+0x1ae>
    207f:	90                   	nop

/*---------------------------------------------------------------------------
    END:  free rootpath, immediately prior to program exit.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == END) {
    2080:	83 fb 05             	cmp    $0x5,%ebx
    2083:	0f 84 17 05 00 00    	je     25a0 <_checkdir+0x6c0>
            G.rootlen = 0;
        }
        return MPN_OK;
    }

    return MPN_INVALID; /* should never reach */
    2089:	bb 00 63 00 00       	mov    $0x6300,%ebx

} /* end function checkdir() */
    208e:	81 c4 3c 01 00 00    	add    $0x13c,%esp
    2094:	89 d8                	mov    %ebx,%eax
    2096:	5b                   	pop    %ebx
    2097:	5e                   	pop    %esi
    2098:	5f                   	pop    %edi
    2099:	5d                   	pop    %ebp
    209a:	c3                   	ret    
    209b:	90                   	nop
    209c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
            ++G.endHPFS;
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
                *--G.endHPFS = '\0';
                Info(slide, 1, ((char *)slide,
    20a0:	8d b5 dc c8 00 00    	lea    0xc8dc(%ebp),%esi
    20a6:	8b 85 98 0b 01 00    	mov    0x10b98(%ebp),%eax
    20ac:	89 74 24 18          	mov    %esi,0x18(%esp)
    20b0:	8d b5 dc 88 00 00    	lea    0x88dc(%ebp),%esi
/*---------------------------------------------------------------------------
    APPEND_NAME:  assume the path component is the filename; append it and
    return without checking for existence.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == APPEND_NAME) {
    20b6:	8b bc 24 54 01 00 00 	mov    0x154(%esp),%edi
    20bd:	30 db                	xor    %bl,%bl
        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
            ++G.endHPFS;
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
                *--G.endHPFS = '\0';
                Info(slide, 1, ((char *)slide,
    20bf:	89 74 24 1c          	mov    %esi,0x1c(%esp)
    if (FUNCTION == APPEND_NAME) {
        char *p = pathcomp;
        int error = MPN_OK;

        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
    20c3:	47                   	inc    %edi
    20c4:	8a 57 ff             	mov    -0x1(%edi),%dl
    20c7:	88 10                	mov    %dl,(%eax)
    20c9:	84 d2                	test   %dl,%dl
    20cb:	0f 84 b3 00 00 00    	je     2184 <_checkdir+0x2a4>
            ++G.endHPFS;
    20d1:	8b 95 98 0b 01 00    	mov    0x10b98(%ebp),%edx
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
    20d7:	8b b5 90 0b 01 00    	mov    0x10b90(%ebp),%esi
        char *p = pathcomp;
        int error = MPN_OK;

        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
            ++G.endHPFS;
    20dd:	8d 42 01             	lea    0x1(%edx),%eax
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
    20e0:	89 c1                	mov    %eax,%ecx
        char *p = pathcomp;
        int error = MPN_OK;

        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
            ++G.endHPFS;
    20e2:	89 85 98 0b 01 00    	mov    %eax,0x10b98(%ebp)
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
    20e8:	29 f1                	sub    %esi,%ecx
    20ea:	81 f9 03 01 00 00    	cmp    $0x103,%ecx
    20f0:	7e d1                	jle    20c3 <_checkdir+0x1e3>
                *--G.endHPFS = '\0';
    20f2:	89 95 98 0b 01 00    	mov    %edx,0x10b98(%ebp)
                Info(slide, 1, ((char *)slide,
    20f8:	8b 74 24 18          	mov    0x18(%esp),%esi

        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
            ++G.endHPFS;
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
                *--G.endHPFS = '\0';
    20fc:	c6 02 00             	movb   $0x0,(%edx)
    if (FUNCTION == APPEND_NAME) {
        char *p = pathcomp;
        int error = MPN_OK;

        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
    20ff:	47                   	inc    %edi
            ++G.endHPFS;
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
                *--G.endHPFS = '\0';
                Info(slide, 1, ((char *)slide,
    2100:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    2106:	89 74 24 04          	mov    %esi,0x4(%esp)
    210a:	89 44 24 14          	mov    %eax,0x14(%esp)
    210e:	8b 85 90 0b 01 00    	mov    0x10b90(%ebp),%eax
    2114:	89 04 24             	mov    %eax,(%esp)
    2117:	e8 00 00 00 00       	call   211c <_checkdir+0x23c>
    211c:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    2120:	89 c6                	mov    %eax,%esi
    2122:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    2128:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    212c:	89 04 24             	mov    %eax,(%esp)
    212f:	e8 00 00 00 00       	call   2134 <_checkdir+0x254>
    2134:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    213a:	89 1c 24             	mov    %ebx,(%esp)
    213d:	89 74 24 0c          	mov    %esi,0xc(%esp)
    2141:	89 44 24 08          	mov    %eax,0x8(%esp)
    2145:	c7 44 24 04 fc 02 00 	movl   $0x2fc,0x4(%esp)
    214c:	00 
    214d:	e8 00 00 00 00       	call   2152 <_checkdir+0x272>
    2152:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2156:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    215d:	00 
    215e:	89 44 24 08          	mov    %eax,0x8(%esp)
    2162:	89 2c 24             	mov    %ebp,(%esp)
                  "checkdir warning:  path too long; truncating\n \
                  %s\n                -> %s\n",
                  FnFilter1(G.filename), FnFilter2(G.buildpathHPFS)));
                error = MPN_INF_TRUNC;   /* filename truncated */
    2165:	bb 00 01 00 00       	mov    $0x100,%ebx
        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
            ++G.endHPFS;
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
                *--G.endHPFS = '\0';
                Info(slide, 1, ((char *)slide,
    216a:	ff 54 24 14          	call   *0x14(%esp)
    216e:	8b 85 98 0b 01 00    	mov    0x10b98(%ebp),%eax
    if (FUNCTION == APPEND_NAME) {
        char *p = pathcomp;
        int error = MPN_OK;

        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
    2174:	8a 57 ff             	mov    -0x1(%edi),%dl
            ++G.endHPFS;
            if ((G.endHPFS-G.buildpathHPFS) >= FILNAMSIZ) {
                *--G.endHPFS = '\0';
                Info(slide, 1, ((char *)slide,
    2177:	83 ec 10             	sub    $0x10,%esp
    if (FUNCTION == APPEND_NAME) {
        char *p = pathcomp;
        int error = MPN_OK;

        Trace((stderr, "appending filename [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0') {   /* copy to HPFS filename */
    217a:	88 10                	mov    %dl,(%eax)
    217c:	84 d2                	test   %dl,%dl
    217e:	0f 85 4d ff ff ff    	jne    20d1 <_checkdir+0x1f1>
                  FnFilter1(G.filename), FnFilter2(G.buildpathHPFS)));
                error = MPN_INF_TRUNC;   /* filename truncated */
            }
        }

        if ( G.pInfo->vollabel || !IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
    2184:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    218a:	f6 40 18 20          	testb  $0x20,0x18(%eax)
    218e:	0f 84 d2 03 00 00    	je     2566 <_checkdir+0x686>
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
    2194:	8b b4 24 54 01 00 00 	mov    0x154(%esp),%esi
    219b:	8b 8d 9c 0b 01 00    	mov    0x10b9c(%ebp),%ecx
    21a1:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    21a8:	8a 16                	mov    (%esi),%dl
    21aa:	40                   	inc    %eax
    21ab:	88 11                	mov    %dl,(%ecx)
    21ad:	84 d2                	test   %dl,%dl
    21af:	0f 84 d9 fe ff ff    	je     208e <_checkdir+0x1ae>
                ++G.endFAT;
    21b5:	8b 8d 9c 0b 01 00    	mov    0x10b9c(%ebp),%ecx
            }
        }

        if ( G.pInfo->vollabel || !IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
    21bb:	40                   	inc    %eax
                ++G.endFAT;
    21bc:	8d 51 01             	lea    0x1(%ecx),%edx
    21bf:	89 95 9c 0b 01 00    	mov    %edx,0x10b9c(%ebp)
            }
        }

        if ( G.pInfo->vollabel || !IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
    21c5:	8a 50 ff             	mov    -0x1(%eax),%dl
    21c8:	88 51 01             	mov    %dl,0x1(%ecx)
    21cb:	84 d2                	test   %dl,%dl
    21cd:	75 e6                	jne    21b5 <_checkdir+0x2d5>
        return MPN_OK;
    }

    return MPN_INVALID; /* should never reach */

} /* end function checkdir() */
    21cf:	81 c4 3c 01 00 00    	add    $0x13c,%esp
    21d5:	89 d8                	mov    %ebx,%eax
    21d7:	5b                   	pop    %ebx
    21d8:	5e                   	pop    %esi
    21d9:	5f                   	pop    %edi
    21da:	5d                   	pop    %ebp
    21db:	c3                   	ret    
    21dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        Trace((stderr, "appending dir segment [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0')     /* copy to HPFS filename */
            ++G.endHPFS;
        if (!IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
    21e0:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    21e7:	8b 95 9c 0b 01 00    	mov    0x10b9c(%ebp),%edx
    21ed:	8a 00                	mov    (%eax),%al
    21ef:	88 02                	mov    %al,(%edx)
    21f1:	84 c0                	test   %al,%al
    21f3:	0f 84 c6 fd ff ff    	je     1fbf <_checkdir+0xdf>
    21f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                ++G.endFAT;
    2200:	8b 95 9c 0b 01 00    	mov    0x10b9c(%ebp),%edx
        Trace((stderr, "appending dir segment [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0')     /* copy to HPFS filename */
            ++G.endHPFS;
        if (!IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
    2206:	43                   	inc    %ebx
                ++G.endFAT;
    2207:	8d 42 01             	lea    0x1(%edx),%eax
    220a:	89 85 9c 0b 01 00    	mov    %eax,0x10b9c(%ebp)
        Trace((stderr, "appending dir segment [%s]\n", FnFilter1(pathcomp)));
        while ((*G.endHPFS = *p++) != '\0')     /* copy to HPFS filename */
            ++G.endHPFS;
        if (!IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
    2210:	8a 43 ff             	mov    -0x1(%ebx),%al
    2213:	88 42 01             	mov    %al,0x1(%edx)
    2216:	84 c0                	test   %al,%al
    2218:	75 e6                	jne    2200 <_checkdir+0x320>
    221a:	e9 a0 fd ff ff       	jmp    1fbf <_checkdir+0xdf>
    221f:	90                   	nop
            G.rootlen = 0;
            return MPN_OK;
        }
        if (G.rootlen > 0)      /* rootpath was already set, nothing to do */
            return MPN_OK;
        if ((G.rootlen = strlen(pathcomp)) > 0) {
    2220:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    2227:	89 04 24             	mov    %eax,(%esp)
    222a:	e8 00 00 00 00       	call   222f <_checkdir+0x34f>
    222f:	89 c3                	mov    %eax,%ebx
    2231:	89 85 ac 0c 01 00    	mov    %eax,0x10cac(%ebp)
    2237:	85 c0                	test   %eax,%eax
    2239:	0f 8e 01 fd ff ff    	jle    1f40 <_checkdir+0x60>
            int had_trailing_pathsep=FALSE, has_drive=FALSE, add_dot=FALSE;
            char *tmproot;

            if ((tmproot = (char *)malloc(G.rootlen+3)) == (char *)NULL) {
    223f:	8d 40 03             	lea    0x3(%eax),%eax
    2242:	89 04 24             	mov    %eax,(%esp)
    2245:	e8 00 00 00 00       	call   224a <_checkdir+0x36a>
    224a:	89 c6                	mov    %eax,%esi
    224c:	85 c0                	test   %eax,%eax
    224e:	0f 84 30 04 00 00    	je     2684 <_checkdir+0x7a4>
                G.rootlen = 0;
                return MPN_NOMEM;
            }
            strcpy(tmproot, pathcomp);
    2254:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    225b:	89 34 24             	mov    %esi,(%esp)
    225e:	89 44 24 04          	mov    %eax,0x4(%esp)
    2262:	e8 00 00 00 00       	call   2267 <_checkdir+0x387>
    2267:	8b 15 00 00 00 00    	mov    0x0,%edx
            if (isalpha((uch)tmproot[0]) && tmproot[1] == ':')
    226d:	0f b6 3e             	movzbl (%esi),%edi
    2270:	83 3a 01             	cmpl   $0x1,(%edx)
    2273:	0f 85 86 04 00 00    	jne    26ff <_checkdir+0x81f>
    2279:	8b 15 00 00 00 00    	mov    0x0,%edx
    227f:	89 f8                	mov    %edi,%eax
    2281:	25 ff 00 00 00       	and    $0xff,%eax
    2286:	8b 12                	mov    (%edx),%edx
    2288:	66 8b 04 42          	mov    (%edx,%eax,2),%ax
    228c:	25 03 01 00 00       	and    $0x103,%eax
            return MPN_OK;
        }
        if (G.rootlen > 0)      /* rootpath was already set, nothing to do */
            return MPN_OK;
        if ((G.rootlen = strlen(pathcomp)) > 0) {
            int had_trailing_pathsep=FALSE, has_drive=FALSE, add_dot=FALSE;
    2291:	31 d2                	xor    %edx,%edx
            if ((tmproot = (char *)malloc(G.rootlen+3)) == (char *)NULL) {
                G.rootlen = 0;
                return MPN_NOMEM;
            }
            strcpy(tmproot, pathcomp);
            if (isalpha((uch)tmproot[0]) && tmproot[1] == ':')
    2293:	85 c0                	test   %eax,%eax
    2295:	74 09                	je     22a0 <_checkdir+0x3c0>
            return MPN_OK;
        }
        if (G.rootlen > 0)      /* rootpath was already set, nothing to do */
            return MPN_OK;
        if ((G.rootlen = strlen(pathcomp)) > 0) {
            int had_trailing_pathsep=FALSE, has_drive=FALSE, add_dot=FALSE;
    2297:	31 d2                	xor    %edx,%edx
    2299:	80 7e 01 3a          	cmpb   $0x3a,0x1(%esi)
    229d:	0f 94 c2             	sete   %dl
                return MPN_NOMEM;
            }
            strcpy(tmproot, pathcomp);
            if (isalpha((uch)tmproot[0]) && tmproot[1] == ':')
                has_drive = TRUE;   /* drive designator */
            if (tmproot[G.rootlen-1] == '/' || tmproot[G.rootlen-1] == '\\') {
    22a0:	8a 44 1e ff          	mov    -0x1(%esi,%ebx,1),%al
    22a4:	3c 5c                	cmp    $0x5c,%al
    22a6:	0f 84 75 04 00 00    	je     2721 <_checkdir+0x841>
            return MPN_OK;
        }
        if (G.rootlen > 0)      /* rootpath was already set, nothing to do */
            return MPN_OK;
        if ((G.rootlen = strlen(pathcomp)) > 0) {
            int had_trailing_pathsep=FALSE, has_drive=FALSE, add_dot=FALSE;
    22ac:	31 c9                	xor    %ecx,%ecx
                return MPN_NOMEM;
            }
            strcpy(tmproot, pathcomp);
            if (isalpha((uch)tmproot[0]) && tmproot[1] == ':')
                has_drive = TRUE;   /* drive designator */
            if (tmproot[G.rootlen-1] == '/' || tmproot[G.rootlen-1] == '\\') {
    22ae:	3c 2f                	cmp    $0x2f,%al
    22b0:	0f 84 6b 04 00 00    	je     2721 <_checkdir+0x841>
                tmproot[--G.rootlen] = '\0';
                had_trailing_pathsep = TRUE;
            }
            if (has_drive && (G.rootlen == 2)) {
    22b6:	85 d2                	test   %edx,%edx
    22b8:	74 09                	je     22c3 <_checkdir+0x3e3>
    22ba:	83 fb 02             	cmp    $0x2,%ebx
    22bd:	0f 84 b4 05 00 00    	je     2877 <_checkdir+0x997>
                if (!had_trailing_pathsep)   /* i.e., original wasn't "x:/" */
                    add_dot = TRUE;    /* relative path: add '.' before '/' */
            } else if (G.rootlen > 0) {   /* need not check "x:." and "x:/" */
    22c3:	85 db                	test   %ebx,%ebx
    22c5:	0f 8e 81 03 00 00    	jle    264c <_checkdir+0x76c>
                if (SSTAT(tmproot, &G.statbuf) || !S_ISDIR(G.statbuf.st_mode))
    22cb:	8d 85 7c 09 01 00    	lea    0x1097c(%ebp),%eax
    22d1:	89 74 24 04          	mov    %esi,0x4(%esp)
    22d5:	89 44 24 08          	mov    %eax,0x8(%esp)
    22d9:	89 2c 24             	mov    %ebp,(%esp)
    22dc:	e8 3f f8 ff ff       	call   1b20 <_zstat_win32>
    22e1:	85 c0                	test   %eax,%eax
    22e3:	75 16                	jne    22fb <_checkdir+0x41b>
    22e5:	66 8b 85 82 09 01 00 	mov    0x10982(%ebp),%ax
    22ec:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    22f1:	66 3d 00 40          	cmp    $0x4000,%ax
    22f5:	0f 84 4b 03 00 00    	je     2646 <_checkdir+0x766>
                {
                    /* path does not exist */
                    if (!G.create_dirs /* || iswild(tmproot) */ ) {
    22fb:	8b 55 7c             	mov    0x7c(%ebp),%edx
                        free(tmproot);
    22fe:	89 34 24             	mov    %esi,(%esp)
                    add_dot = TRUE;    /* relative path: add '.' before '/' */
            } else if (G.rootlen > 0) {   /* need not check "x:." and "x:/" */
                if (SSTAT(tmproot, &G.statbuf) || !S_ISDIR(G.statbuf.st_mode))
                {
                    /* path does not exist */
                    if (!G.create_dirs /* || iswild(tmproot) */ ) {
    2301:	85 d2                	test   %edx,%edx
    2303:	0f 85 93 05 00 00    	jne    289c <_checkdir+0x9bc>
                        free(tmproot);
    2309:	e8 00 00 00 00       	call   230e <_checkdir+0x42e>
                        G.rootlen = 0;
                        /* treat as stored file */
                        return MPN_INF_SKIP;
    230e:	bb 00 02 00 00       	mov    $0x200,%ebx
                if (SSTAT(tmproot, &G.statbuf) || !S_ISDIR(G.statbuf.st_mode))
                {
                    /* path does not exist */
                    if (!G.create_dirs /* || iswild(tmproot) */ ) {
                        free(tmproot);
                        G.rootlen = 0;
    2313:	c7 85 ac 0c 01 00 00 	movl   $0x0,0x10cac(%ebp)
    231a:	00 00 00 
                        /* treat as stored file */
                        return MPN_INF_SKIP;
    231d:	e9 6c fd ff ff       	jmp    208e <_checkdir+0x1ae>
                free(G.buildpathFAT);
                /* path didn't exist, tried to create, failed */
                return MPN_ERR_SKIP;
            }
            G.created_dir = TRUE;
        } else if (!S_ISDIR(G.statbuf.st_mode)) {
    2322:	66 8b 85 82 09 01 00 	mov    0x10982(%ebp),%ax
    2329:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    232e:	66 3d 00 40          	cmp    $0x4000,%ax
    2332:	0f 84 a8 02 00 00    	je     25e0 <_checkdir+0x700>
            Info(slide, 1, ((char *)slide,
    2338:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    233e:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    2344:	89 44 24 04          	mov    %eax,0x4(%esp)
    2348:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    234e:	89 04 24             	mov    %eax,(%esp)
    2351:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    2357:	e8 00 00 00 00       	call   235c <_checkdir+0x47c>
    235c:	89 c7                	mov    %eax,%edi
    235e:	8d 85 dc c8 00 00    	lea    0xc8dc(%ebp),%eax
    2364:	89 44 24 04          	mov    %eax,0x4(%esp)
    2368:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    236e:	89 04 24             	mov    %eax,(%esp)
    2371:	e8 00 00 00 00       	call   2376 <_checkdir+0x496>
    2376:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    237a:	89 44 24 08          	mov    %eax,0x8(%esp)
    237e:	c7 44 24 04 a4 02 00 	movl   $0x2a4,0x4(%esp)
    2385:	00 
    2386:	89 1c 24             	mov    %ebx,(%esp)
    2389:	e8 00 00 00 00       	call   238e <_checkdir+0x4ae>
    238e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2392:	89 2c 24             	mov    %ebp,(%esp)
    2395:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    239c:	00 
    239d:	89 44 24 08          	mov    %eax,0x8(%esp)
              unable to process %s.\n",
              FnFilter2(G.buildpathFAT), FnFilter1(G.filename)));
            free(G.buildpathHPFS);
            free(G.buildpathFAT);
            /* path existed but wasn't dir */
            return MPN_ERR_SKIP;
    23a1:	bb 00 03 00 00       	mov    $0x300,%ebx
                /* path didn't exist, tried to create, failed */
                return MPN_ERR_SKIP;
            }
            G.created_dir = TRUE;
        } else if (!S_ISDIR(G.statbuf.st_mode)) {
            Info(slide, 1, ((char *)slide,
    23a6:	ff d6                	call   *%esi
              "checkdir error:  %s exists but is not directory\n   \
              unable to process %s.\n",
              FnFilter2(G.buildpathFAT), FnFilter1(G.filename)));
            free(G.buildpathHPFS);
    23a8:	8b 85 90 0b 01 00    	mov    0x10b90(%ebp),%eax
                /* path didn't exist, tried to create, failed */
                return MPN_ERR_SKIP;
            }
            G.created_dir = TRUE;
        } else if (!S_ISDIR(G.statbuf.st_mode)) {
            Info(slide, 1, ((char *)slide,
    23ae:	83 ec 10             	sub    $0x10,%esp
              "checkdir error:  %s exists but is not directory\n   \
              unable to process %s.\n",
              FnFilter2(G.buildpathFAT), FnFilter1(G.filename)));
            free(G.buildpathHPFS);
    23b1:	89 04 24             	mov    %eax,(%esp)
    23b4:	e8 00 00 00 00       	call   23b9 <_checkdir+0x4d9>
            free(G.buildpathFAT);
    23b9:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    23bf:	89 04 24             	mov    %eax,(%esp)
    23c2:	e8 00 00 00 00       	call   23c7 <_checkdir+0x4e7>
        return MPN_OK;
    }

    return MPN_INVALID; /* should never reach */

} /* end function checkdir() */
    23c7:	81 c4 3c 01 00 00    	add    $0x13c,%esp
    23cd:	89 d8                	mov    %ebx,%eax
    23cf:	5b                   	pop    %ebx
    23d0:	5e                   	pop    %esi
    23d1:	5f                   	pop    %edi
    23d2:	5d                   	pop    %ebp
    23d3:	c3                   	ret    
    if (FUNCTION == GETPATH) {
        Trace((stderr, "getting and freeing FAT path [%s]\n",
          FnFilter1(G.buildpathFAT)));
        Trace((stderr, "freeing HPFS path [%s]\n",
          FnFilter1(G.buildpathHPFS)));
        strcpy(pathcomp, G.buildpathFAT);
    23d4:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
        free(G.buildpathFAT);
        free(G.buildpathHPFS);
        G.buildpathHPFS = G.buildpathFAT = G.endHPFS = G.endFAT = NULL;
        return MPN_OK;
    23da:	30 db                	xor    %bl,%bl
    if (FUNCTION == GETPATH) {
        Trace((stderr, "getting and freeing FAT path [%s]\n",
          FnFilter1(G.buildpathFAT)));
        Trace((stderr, "freeing HPFS path [%s]\n",
          FnFilter1(G.buildpathHPFS)));
        strcpy(pathcomp, G.buildpathFAT);
    23dc:	89 44 24 04          	mov    %eax,0x4(%esp)
    23e0:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    23e7:	89 04 24             	mov    %eax,(%esp)
    23ea:	e8 00 00 00 00       	call   23ef <_checkdir+0x50f>
        free(G.buildpathFAT);
    23ef:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    23f5:	89 04 24             	mov    %eax,(%esp)
    23f8:	e8 00 00 00 00       	call   23fd <_checkdir+0x51d>
        free(G.buildpathHPFS);
    23fd:	8b 85 90 0b 01 00    	mov    0x10b90(%ebp),%eax
    2403:	89 04 24             	mov    %eax,(%esp)
    2406:	e8 00 00 00 00       	call   240b <_checkdir+0x52b>
        G.buildpathHPFS = G.buildpathFAT = G.endHPFS = G.endFAT = NULL;
    240b:	c7 85 9c 0b 01 00 00 	movl   $0x0,0x10b9c(%ebp)
    2412:	00 00 00 
    2415:	c7 85 98 0b 01 00 00 	movl   $0x0,0x10b98(%ebp)
    241c:	00 00 00 
    241f:	c7 85 94 0b 01 00 00 	movl   $0x0,0x10b94(%ebp)
    2426:	00 00 00 
    2429:	c7 85 90 0b 01 00 00 	movl   $0x0,0x10b90(%ebp)
    2430:	00 00 00 
        return MPN_OK;
    2433:	e9 56 fc ff ff       	jmp    208e <_checkdir+0x1ae>
        Trace((stderr, "initializing buildpathHPFS and buildpathFAT to "));
#ifdef ACORN_FTYPE_NFS
        if ((G.buildpathHPFS = (char *)malloc(G.fnlen+G.rootlen+
                                              (uO.acorn_nfs_ext ? 5 : 1)))
#else
        if ((G.buildpathHPFS = (char *)malloc(G.fnlen+G.rootlen+1))
    2438:	8b 85 ac 0c 01 00    	mov    0x10cac(%ebp),%eax
    243e:	8b 95 78 0b 01 00    	mov    0x10b78(%ebp),%edx
    2444:	01 c2                	add    %eax,%edx
    2446:	89 44 24 14          	mov    %eax,0x14(%esp)
#endif
            == NULL)
            return MPN_NOMEM;
    244a:	66 bb 00 0a          	mov    $0xa00,%bx
        Trace((stderr, "initializing buildpathHPFS and buildpathFAT to "));
#ifdef ACORN_FTYPE_NFS
        if ((G.buildpathHPFS = (char *)malloc(G.fnlen+G.rootlen+
                                              (uO.acorn_nfs_ext ? 5 : 1)))
#else
        if ((G.buildpathHPFS = (char *)malloc(G.fnlen+G.rootlen+1))
    244e:	8d 72 01             	lea    0x1(%edx),%esi
    2451:	89 34 24             	mov    %esi,(%esp)
    2454:	e8 00 00 00 00       	call   2459 <_checkdir+0x579>
    2459:	89 c7                	mov    %eax,%edi
    245b:	89 85 90 0b 01 00    	mov    %eax,0x10b90(%ebp)
    2461:	85 c0                	test   %eax,%eax
    2463:	0f 84 25 fc ff ff    	je     208e <_checkdir+0x1ae>
            return MPN_NOMEM;
#ifdef ACORN_FTYPE_NFS
        if ((G.buildpathFAT = (char *)malloc(G.fnlen+G.rootlen+
                                             (uO.acorn_nfs_ext ? 5 : 1)))
#else
        if ((G.buildpathFAT = (char *)malloc(G.fnlen+G.rootlen+1))
    2469:	89 34 24             	mov    %esi,(%esp)
    246c:	e8 00 00 00 00       	call   2471 <_checkdir+0x591>
    2471:	89 c2                	mov    %eax,%edx
    2473:	89 85 94 0b 01 00    	mov    %eax,0x10b94(%ebp)
    2479:	85 c0                	test   %eax,%eax
    247b:	0f 84 e9 03 00 00    	je     286a <_checkdir+0x98a>
#endif
            == NULL) {
            free(G.buildpathHPFS);
            return MPN_NOMEM;
        }
        if (G.pInfo->vollabel) { /* use root or renamed path, but don't store */
    2481:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    2487:	f6 40 18 20          	testb  $0x20,0x18(%eax)
    248b:	0f 84 07 02 00 00    	je     2698 <_checkdir+0x7b8>
/* GRR:  for network drives, do strchr() and return IZ_VOL_LABEL if not [1] */
            if (G.renamed_fullpath && pathcomp[1] == ':')
    2491:	8b 8d 74 0b 01 00    	mov    0x10b74(%ebp),%ecx
    2497:	85 c9                	test   %ecx,%ecx
    2499:	0f 84 97 02 00 00    	je     2736 <_checkdir+0x856>
    249f:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    24a6:	80 78 01 3a          	cmpb   $0x3a,0x1(%eax)
    24aa:	0f 84 a1 02 00 00    	je     2751 <_checkdir+0x871>
            else if (!G.renamed_fullpath && G.rootlen > 1 &&
                     G.rootpath[1] == ':')
                *G.buildpathHPFS = (char)ToLower(*G.rootpath);
            else {
                char tmpN[MAX_PATH], *tmpP;
                if (GetFullPathName(".", MAX_PATH, tmpN, &tmpP) > MAX_PATH)
    24b0:	8d 44 24 28          	lea    0x28(%esp),%eax
    24b4:	c7 44 24 04 04 01 00 	movl   $0x104,0x4(%esp)
    24bb:	00 
    24bc:	89 44 24 0c          	mov    %eax,0xc(%esp)
    24c0:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    24c4:	89 44 24 08          	mov    %eax,0x8(%esp)
    24c8:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
    24cf:	e8 00 00 00 00       	call   24d4 <_checkdir+0x5f4>
    24d4:	83 ec 10             	sub    $0x10,%esp
    24d7:	3d 04 01 00 00       	cmp    $0x104,%eax
    24dc:	0f 87 f5 02 00 00    	ja     27d7 <_checkdir+0x8f7>
                { /* by definition of MAX_PATH we should never get here */
                    Info(slide, 1, ((char *)slide,
                      "checkdir warning: current dir path too long\n"));
                    return MPN_INF_TRUNC;   /* can't get drive letter */
                }
                G.nLabelDrive = *tmpN - 'a' + 1;
    24e2:	0f be 44 24 2c       	movsbl 0x2c(%esp),%eax
                *G.buildpathHPFS = (char)(G.nLabelDrive - 1 + 'a');
    24e7:	8b 95 90 0b 01 00    	mov    0x10b90(%ebp),%edx
                { /* by definition of MAX_PATH we should never get here */
                    Info(slide, 1, ((char *)slide,
                      "checkdir warning: current dir path too long\n"));
                    return MPN_INF_TRUNC;   /* can't get drive letter */
                }
                G.nLabelDrive = *tmpN - 'a' + 1;
    24ed:	83 e8 60             	sub    $0x60,%eax
    24f0:	89 85 7c 0b 01 00    	mov    %eax,0x10b7c(%ebp)
                *G.buildpathHPFS = (char)(G.nLabelDrive - 1 + 'a');
    24f6:	83 c0 60             	add    $0x60,%eax
    24f9:	88 02                	mov    %al,(%edx)
    24fb:	8b bd 90 0b 01 00    	mov    0x10b90(%ebp),%edi
    2501:	8a 17                	mov    (%edi),%dl
            }
            G.nLabelDrive = *G.buildpathHPFS - 'a' + 1; /* save for mapname() */
    2503:	0f be c2             	movsbl %dl,%eax
    2506:	83 e8 60             	sub    $0x60,%eax
            if (uO.volflag == 0 || *G.buildpathHPFS < 'a' /* no labels/bogus? */
    2509:	8b 55 40             	mov    0x40(%ebp),%edx
                    return MPN_INF_TRUNC;   /* can't get drive letter */
                }
                G.nLabelDrive = *tmpN - 'a' + 1;
                *G.buildpathHPFS = (char)(G.nLabelDrive - 1 + 'a');
            }
            G.nLabelDrive = *G.buildpathHPFS - 'a' + 1; /* save for mapname() */
    250c:	89 85 7c 0b 01 00    	mov    %eax,0x10b7c(%ebp)
            if (uO.volflag == 0 || *G.buildpathHPFS < 'a' /* no labels/bogus? */
    2512:	85 d2                	test   %edx,%edx
    2514:	74 09                	je     251f <_checkdir+0x63f>
    2516:	80 3f 60             	cmpb   $0x60,(%edi)
    2519:	0f 8f ef 03 00 00    	jg     290e <_checkdir+0xa2e>
                || (uO.volflag == 1 && !isfloppy(G.nLabelDrive))) { /* !fixed */
                free(G.buildpathHPFS);
    251f:	89 3c 24             	mov    %edi,(%esp)
                free(G.buildpathFAT);
                return MPN_VOL_LABEL;  /* skipping with message */
    2522:	bb 00 11 00 00       	mov    $0x1100,%ebx
                *G.buildpathHPFS = (char)(G.nLabelDrive - 1 + 'a');
            }
            G.nLabelDrive = *G.buildpathHPFS - 'a' + 1; /* save for mapname() */
            if (uO.volflag == 0 || *G.buildpathHPFS < 'a' /* no labels/bogus? */
                || (uO.volflag == 1 && !isfloppy(G.nLabelDrive))) { /* !fixed */
                free(G.buildpathHPFS);
    2527:	e8 00 00 00 00       	call   252c <_checkdir+0x64c>
                free(G.buildpathFAT);
    252c:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    2532:	89 04 24             	mov    %eax,(%esp)
    2535:	e8 00 00 00 00       	call   253a <_checkdir+0x65a>
                return MPN_VOL_LABEL;  /* skipping with message */
    253a:	e9 4f fb ff ff       	jmp    208e <_checkdir+0x1ae>
    253f:	90                   	nop
        }
#endif /* FIX_STAT_BUG */
        if (SSTAT(G.buildpathFAT, &G.statbuf))   /* path doesn't exist */
        {
            if (!G.create_dirs) { /* told not to create (freshening) */
                free(G.buildpathHPFS);
    2540:	8b 85 90 0b 01 00    	mov    0x10b90(%ebp),%eax
                free(G.buildpathFAT);
                /* path doesn't exist:  nothing to do */
                return MPN_INF_SKIP;
    2546:	bb 00 02 00 00       	mov    $0x200,%ebx
        }
#endif /* FIX_STAT_BUG */
        if (SSTAT(G.buildpathFAT, &G.statbuf))   /* path doesn't exist */
        {
            if (!G.create_dirs) { /* told not to create (freshening) */
                free(G.buildpathHPFS);
    254b:	89 04 24             	mov    %eax,(%esp)
    254e:	e8 00 00 00 00       	call   2553 <_checkdir+0x673>
                free(G.buildpathFAT);
    2553:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    2559:	89 04 24             	mov    %eax,(%esp)
    255c:	e8 00 00 00 00       	call   2561 <_checkdir+0x681>
                /* path doesn't exist:  nothing to do */
                return MPN_INF_SKIP;
    2561:	e9 28 fb ff ff       	jmp    208e <_checkdir+0x1ae>
/* Function IsVolumeOldFAT() */
/*****************************/

static int IsVolumeOldFAT(__GPRO__ const char *name)
{
    return (NTQueryVolInfo(__G__ name) ? G.lastVolOldFAT : FALSE);
    2566:	8b 95 90 0b 01 00    	mov    0x10b90(%ebp),%edx
    256c:	89 e8                	mov    %ebp,%eax
    256e:	e8 8d da ff ff       	call   0 <_NTQueryVolInfo>
    2573:	85 c0                	test   %eax,%eax
    2575:	0f 84 19 fc ff ff    	je     2194 <_checkdir+0x2b4>
                  FnFilter1(G.filename), FnFilter2(G.buildpathHPFS)));
                error = MPN_INF_TRUNC;   /* filename truncated */
            }
        }

        if ( G.pInfo->vollabel || !IsVolumeOldFAT(__G__ G.buildpathHPFS)) {
    257b:	8b b5 84 0b 01 00    	mov    0x10b84(%ebp),%esi
    2581:	85 f6                	test   %esi,%esi
    2583:	0f 84 0b fc ff ff    	je     2194 <_checkdir+0x2b4>
            p = pathcomp;
            while ((*G.endFAT = *p++) != '\0')  /* copy to FAT filename, too */
                ++G.endFAT;
        } else
            map2fat(pathcomp, &G.endFAT);   /* map into FAT fn, update endFAT */
    2589:	8d 95 9c 0b 01 00    	lea    0x10b9c(%ebp),%edx
    258f:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    2596:	e8 b5 dd ff ff       	call   350 <_map2fat>
        Trace((stderr, "buildpathHPFS: %s\nbuildpathFAT:  %s\n",
          FnFilter1(G.buildpathHPFS), FnFilter2(G.buildpathFAT)));

        return error;  /* could check for existence, prompt for new name... */
    259b:	e9 ee fa ff ff       	jmp    208e <_checkdir+0x1ae>
    END:  free rootpath, immediately prior to program exit.
  ---------------------------------------------------------------------------*/

    if (FUNCTION == END) {
        Trace((stderr, "freeing rootpath\n"));
        if (G.rootlen > 0) {
    25a0:	8b 85 ac 0c 01 00    	mov    0x10cac(%ebp),%eax
    25a6:	85 c0                	test   %eax,%eax
    25a8:	0f 8e 92 f9 ff ff    	jle    1f40 <_checkdir+0x60>
            free(G.rootpath);
    25ae:	8b 85 8c 0b 01 00    	mov    0x10b8c(%ebp),%eax
            G.rootlen = 0;
        }
        return MPN_OK;
    25b4:	30 db                	xor    %bl,%bl
  ---------------------------------------------------------------------------*/

    if (FUNCTION == END) {
        Trace((stderr, "freeing rootpath\n"));
        if (G.rootlen > 0) {
            free(G.rootpath);
    25b6:	89 04 24             	mov    %eax,(%esp)
    25b9:	e8 00 00 00 00       	call   25be <_checkdir+0x6de>
            G.rootlen = 0;
    25be:	c7 85 ac 0c 01 00 00 	movl   $0x0,0x10cac(%ebp)
    25c5:	00 00 00 
    25c8:	e9 c1 fa ff ff       	jmp    208e <_checkdir+0x1ae>
#if (!defined(SFX) || defined(SFX_EXDIR))
    if (FUNCTION == ROOT) {
        Trace((stderr, "initializing root path to [%s]\n",
          FnFilter1(pathcomp)));
        if (pathcomp == NULL) {
            G.rootlen = 0;
    25cd:	c7 85 ac 0c 01 00 00 	movl   $0x0,0x10cac(%ebp)
    25d4:	00 00 00 
            return MPN_OK;
    25d7:	e9 b2 fa ff ff       	jmp    208e <_checkdir+0x1ae>
    25dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            free(G.buildpathHPFS);
            free(G.buildpathFAT);
            /* path existed but wasn't dir */
            return MPN_ERR_SKIP;
        }
        if (too_long) {
    25e0:	84 db                	test   %bl,%bl
    25e2:	0f 85 24 fa ff ff    	jne    200c <_checkdir+0x12c>
            free(G.buildpathHPFS);
            free(G.buildpathFAT);
            /* no room for filenames:  fatal */
            return MPN_ERR_TOOLONG;
        }
        *G.endHPFS++ = '/';
    25e8:	8b 85 98 0b 01 00    	mov    0x10b98(%ebp),%eax
        *G.endFAT++ = '/';
        *G.endHPFS = *G.endFAT = '\0';
        Trace((stderr, "buildpathHPFS now = [%s]\nbuildpathFAT now =  [%s]\n",
          FnFilter1(G.buildpathHPFS), FnFilter2(G.buildpathFAT)));
        return MPN_OK;
    25ee:	31 db                	xor    %ebx,%ebx
            free(G.buildpathHPFS);
            free(G.buildpathFAT);
            /* no room for filenames:  fatal */
            return MPN_ERR_TOOLONG;
        }
        *G.endHPFS++ = '/';
    25f0:	8d 50 01             	lea    0x1(%eax),%edx
    25f3:	89 95 98 0b 01 00    	mov    %edx,0x10b98(%ebp)
    25f9:	c6 00 2f             	movb   $0x2f,(%eax)
        *G.endFAT++ = '/';
    25fc:	8b 85 9c 0b 01 00    	mov    0x10b9c(%ebp),%eax
    2602:	8d 50 01             	lea    0x1(%eax),%edx
    2605:	89 95 9c 0b 01 00    	mov    %edx,0x10b9c(%ebp)
    260b:	c6 00 2f             	movb   $0x2f,(%eax)
        *G.endHPFS = *G.endFAT = '\0';
    260e:	8b 85 98 0b 01 00    	mov    0x10b98(%ebp),%eax
    2614:	8b 95 9c 0b 01 00    	mov    0x10b9c(%ebp),%edx
    261a:	c6 02 00             	movb   $0x0,(%edx)
    261d:	c6 00 00             	movb   $0x0,(%eax)
        Trace((stderr, "buildpathHPFS now = [%s]\nbuildpathFAT now =  [%s]\n",
          FnFilter1(G.buildpathHPFS), FnFilter2(G.buildpathFAT)));
        return MPN_OK;
    2620:	e9 69 fa ff ff       	jmp    208e <_checkdir+0x1ae>
                free(G.buildpathHPFS);
                free(G.buildpathFAT);
                /* no room for filenames:  fatal */
                return MPN_ERR_TOOLONG;
            }
            if (MKDIR(G.buildpathFAT, 0777) == -1) { /* create the directory */
    2625:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    262b:	89 04 24             	mov    %eax,(%esp)
    262e:	e8 00 00 00 00       	call   2633 <_checkdir+0x753>
    2633:	40                   	inc    %eax
    2634:	0f 84 2b 01 00 00    	je     2765 <_checkdir+0x885>
                free(G.buildpathHPFS);
                free(G.buildpathFAT);
                /* path didn't exist, tried to create, failed */
                return MPN_ERR_SKIP;
            }
            G.created_dir = TRUE;
    263a:	c7 85 70 0b 01 00 01 	movl   $0x1,0x10b70(%ebp)
    2641:	00 00 00 
    2644:	eb a2                	jmp    25e8 <_checkdir+0x708>
    2646:	8b 9d ac 0c 01 00    	mov    0x10cac(%ebp),%ebx
    264c:	8d 43 01             	lea    0x1(%ebx),%eax
    264f:	8d 53 02             	lea    0x2(%ebx),%edx
    2652:	89 c1                	mov    %eax,%ecx
                    }
                }
            }
            if (add_dot)                    /* had just "x:", make "x:." */
                tmproot[G.rootlen++] = '.';
            tmproot[G.rootlen++] = '/';
    2654:	c6 04 1e 2f          	movb   $0x2f,(%esi,%ebx,1)
    2658:	89 85 ac 0c 01 00    	mov    %eax,0x10cac(%ebp)
            tmproot[G.rootlen] = '\0';
    265e:	c6 04 0e 00          	movb   $0x0,(%esi,%ecx,1)
            if ((G.rootpath = (char *)realloc(tmproot, G.rootlen+1)) == NULL) {
    2662:	89 54 24 04          	mov    %edx,0x4(%esp)
    2666:	89 34 24             	mov    %esi,(%esp)
    2669:	e8 00 00 00 00       	call   266e <_checkdir+0x78e>
    266e:	89 85 8c 0b 01 00    	mov    %eax,0x10b8c(%ebp)
    2674:	85 c0                	test   %eax,%eax
    2676:	0f 85 c4 f8 ff ff    	jne    1f40 <_checkdir+0x60>
                free(tmproot);
    267c:	89 34 24             	mov    %esi,(%esp)
    267f:	e8 00 00 00 00       	call   2684 <_checkdir+0x7a4>
                G.rootlen = 0;
    2684:	c7 85 ac 0c 01 00 00 	movl   $0x0,0x10cac(%ebp)
    268b:	00 00 00 
                return MPN_NOMEM;
    268e:	bb 00 0a 00 00       	mov    $0xa00,%ebx
    2693:	e9 f6 f9 ff ff       	jmp    208e <_checkdir+0x1ae>
                free(G.buildpathHPFS);
                free(G.buildpathFAT);
                return MPN_VOL_LABEL;  /* skipping with message */
            }
            *G.buildpathHPFS = '\0';
        } else if (G.renamed_fullpath) /* pathcomp = valid data */
    2698:	8b 85 74 0b 01 00    	mov    0x10b74(%ebp),%eax
    269e:	85 c0                	test   %eax,%eax
    26a0:	0f 85 a4 01 00 00    	jne    284a <_checkdir+0x96a>
            strcpy(G.buildpathHPFS, pathcomp);
        else if (G.rootlen > 0)
    26a6:	8b 44 24 14          	mov    0x14(%esp),%eax
    26aa:	85 c0                	test   %eax,%eax
    26ac:	0f 8f 06 01 00 00    	jg     27b8 <_checkdir+0x8d8>
            strcpy(G.buildpathHPFS, G.rootpath);
        else
            *G.buildpathHPFS = '\0';
    26b2:	c6 07 00             	movb   $0x0,(%edi)
        G.endHPFS = G.buildpathHPFS;
    26b5:	89 bd 98 0b 01 00    	mov    %edi,0x10b98(%ebp)
        G.endFAT = G.buildpathFAT;
    26bb:	89 95 9c 0b 01 00    	mov    %edx,0x10b9c(%ebp)
        while ((*G.endFAT = *G.endHPFS) != '\0') {
    26c1:	8a 07                	mov    (%edi),%al
    26c3:	88 02                	mov    %al,(%edx)
    26c5:	84 c0                	test   %al,%al
    26c7:	0f 84 73 f8 ff ff    	je     1f40 <_checkdir+0x60>
    26cd:	8d 76 00             	lea    0x0(%esi),%esi
            ++G.endFAT;
    26d0:	8b 95 9c 0b 01 00    	mov    0x10b9c(%ebp),%edx
    26d6:	8d 42 01             	lea    0x1(%edx),%eax
    26d9:	89 85 9c 0b 01 00    	mov    %eax,0x10b9c(%ebp)
            ++G.endHPFS;
    26df:	8b 85 98 0b 01 00    	mov    0x10b98(%ebp),%eax
    26e5:	8d 48 01             	lea    0x1(%eax),%ecx
    26e8:	89 8d 98 0b 01 00    	mov    %ecx,0x10b98(%ebp)
            strcpy(G.buildpathHPFS, G.rootpath);
        else
            *G.buildpathHPFS = '\0';
        G.endHPFS = G.buildpathHPFS;
        G.endFAT = G.buildpathFAT;
        while ((*G.endFAT = *G.endHPFS) != '\0') {
    26ee:	8a 40 01             	mov    0x1(%eax),%al
    26f1:	88 42 01             	mov    %al,0x1(%edx)
    26f4:	84 c0                	test   %al,%al
    26f6:	75 d8                	jne    26d0 <_checkdir+0x7f0>
            ++G.endFAT;
            ++G.endHPFS;
        }
        Trace((stderr, "[%s]\n", FnFilter1(G.buildpathHPFS)));
        return MPN_OK;
    26f8:	31 db                	xor    %ebx,%ebx
    26fa:	e9 43 f8 ff ff       	jmp    1f42 <_checkdir+0x62>
            if ((tmproot = (char *)malloc(G.rootlen+3)) == (char *)NULL) {
                G.rootlen = 0;
                return MPN_NOMEM;
            }
            strcpy(tmproot, pathcomp);
            if (isalpha((uch)tmproot[0]) && tmproot[1] == ':')
    26ff:	89 f8                	mov    %edi,%eax
    2701:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
    2708:	00 
    2709:	25 ff 00 00 00       	and    $0xff,%eax
    270e:	89 04 24             	mov    %eax,(%esp)
    2711:	e8 00 00 00 00       	call   2716 <_checkdir+0x836>
    2716:	8b 9d ac 0c 01 00    	mov    0x10cac(%ebp),%ebx
    271c:	e9 70 fb ff ff       	jmp    2291 <_checkdir+0x3b1>
                has_drive = TRUE;   /* drive designator */
            if (tmproot[G.rootlen-1] == '/' || tmproot[G.rootlen-1] == '\\') {
                tmproot[--G.rootlen] = '\0';
    2721:	4b                   	dec    %ebx
                had_trailing_pathsep = TRUE;
    2722:	b9 01 00 00 00       	mov    $0x1,%ecx
            }
            strcpy(tmproot, pathcomp);
            if (isalpha((uch)tmproot[0]) && tmproot[1] == ':')
                has_drive = TRUE;   /* drive designator */
            if (tmproot[G.rootlen-1] == '/' || tmproot[G.rootlen-1] == '\\') {
                tmproot[--G.rootlen] = '\0';
    2727:	89 9d ac 0c 01 00    	mov    %ebx,0x10cac(%ebp)
    272d:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)
    2731:	e9 80 fb ff ff       	jmp    22b6 <_checkdir+0x3d6>
        }
        if (G.pInfo->vollabel) { /* use root or renamed path, but don't store */
/* GRR:  for network drives, do strchr() and return IZ_VOL_LABEL if not [1] */
            if (G.renamed_fullpath && pathcomp[1] == ':')
                *G.buildpathHPFS = (char)ToLower(*pathcomp);
            else if (!G.renamed_fullpath && G.rootlen > 1 &&
    2736:	83 7c 24 14 01       	cmpl   $0x1,0x14(%esp)
    273b:	0f 8e 6f fd ff ff    	jle    24b0 <_checkdir+0x5d0>
                     G.rootpath[1] == ':')
    2741:	8b 85 8c 0b 01 00    	mov    0x10b8c(%ebp),%eax
        }
        if (G.pInfo->vollabel) { /* use root or renamed path, but don't store */
/* GRR:  for network drives, do strchr() and return IZ_VOL_LABEL if not [1] */
            if (G.renamed_fullpath && pathcomp[1] == ':')
                *G.buildpathHPFS = (char)ToLower(*pathcomp);
            else if (!G.renamed_fullpath && G.rootlen > 1 &&
    2747:	80 78 01 3a          	cmpb   $0x3a,0x1(%eax)
    274b:	0f 85 5f fd ff ff    	jne    24b0 <_checkdir+0x5d0>
                     G.rootpath[1] == ':')
                *G.buildpathHPFS = (char)ToLower(*G.rootpath);
    2751:	0f be 00             	movsbl (%eax),%eax
    2754:	89 04 24             	mov    %eax,(%esp)
    2757:	e8 00 00 00 00       	call   275c <_checkdir+0x87c>
    275c:	88 c2                	mov    %al,%dl
    275e:	88 07                	mov    %al,(%edi)
    2760:	e9 9e fd ff ff       	jmp    2503 <_checkdir+0x623>
                free(G.buildpathFAT);
                /* no room for filenames:  fatal */
                return MPN_ERR_TOOLONG;
            }
            if (MKDIR(G.buildpathFAT, 0777) == -1) { /* create the directory */
                Info(slide, 1, ((char *)slide,
    2765:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    276b:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    2771:	89 44 24 04          	mov    %eax,0x4(%esp)
    2775:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    277b:	89 04 24             	mov    %eax,(%esp)
    277e:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    2784:	e8 00 00 00 00       	call   2789 <_checkdir+0x8a9>
    2789:	89 c7                	mov    %eax,%edi
    278b:	8d 85 dc c8 00 00    	lea    0xc8dc(%ebp),%eax
    2791:	89 44 24 04          	mov    %eax,0x4(%esp)
    2795:	8b 85 94 0b 01 00    	mov    0x10b94(%ebp),%eax
    279b:	89 04 24             	mov    %eax,(%esp)
    279e:	e8 00 00 00 00       	call   27a3 <_checkdir+0x8c3>
    27a3:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    27a7:	89 44 24 08          	mov    %eax,0x8(%esp)
    27ab:	c7 44 24 04 58 02 00 	movl   $0x258,0x4(%esp)
    27b2:	00 
    27b3:	e9 ce fb ff ff       	jmp    2386 <_checkdir+0x4a6>
            }
            *G.buildpathHPFS = '\0';
        } else if (G.renamed_fullpath) /* pathcomp = valid data */
            strcpy(G.buildpathHPFS, pathcomp);
        else if (G.rootlen > 0)
            strcpy(G.buildpathHPFS, G.rootpath);
    27b8:	8b 85 8c 0b 01 00    	mov    0x10b8c(%ebp),%eax
    27be:	89 3c 24             	mov    %edi,(%esp)
    27c1:	89 44 24 04          	mov    %eax,0x4(%esp)
    27c5:	89 54 24 14          	mov    %edx,0x14(%esp)
    27c9:	e8 00 00 00 00       	call   27ce <_checkdir+0x8ee>
    27ce:	8b 54 24 14          	mov    0x14(%esp),%edx
    27d2:	e9 de fe ff ff       	jmp    26b5 <_checkdir+0x7d5>
                *G.buildpathHPFS = (char)ToLower(*G.rootpath);
            else {
                char tmpN[MAX_PATH], *tmpP;
                if (GetFullPathName(".", MAX_PATH, tmpN, &tmpP) > MAX_PATH)
                { /* by definition of MAX_PATH we should never get here */
                    Info(slide, 1, ((char *)slide,
    27d7:	8d 95 dc 08 00 00    	lea    0x8dc(%ebp),%edx
    27dd:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    27e3:	89 d7                	mov    %edx,%edi
    27e5:	be 58 03 00 00       	mov    $0x358,%esi
    27ea:	b8 2d 00 00 00       	mov    $0x2d,%eax
    27ef:	f6 c2 01             	test   $0x1,%dl
    27f2:	0f 85 42 01 00 00    	jne    293a <_checkdir+0xa5a>
    27f8:	f7 c7 02 00 00 00    	test   $0x2,%edi
    27fe:	0f 85 21 01 00 00    	jne    2925 <_checkdir+0xa45>
    2804:	89 c1                	mov    %eax,%ecx
    2806:	c1 e9 02             	shr    $0x2,%ecx
    2809:	a8 02                	test   $0x2,%al
    280b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    280d:	74 0b                	je     281a <_checkdir+0x93a>
    280f:	66 8b 0e             	mov    (%esi),%cx
    2812:	66 89 0f             	mov    %cx,(%edi)
    2815:	b9 02 00 00 00       	mov    $0x2,%ecx
    281a:	a8 01                	test   $0x1,%al
    281c:	74 06                	je     2824 <_checkdir+0x944>
    281e:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    2821:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    2824:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    282b:	00 
    282c:	c7 44 24 08 2c 00 00 	movl   $0x2c,0x8(%esp)
    2833:	00 
    2834:	89 54 24 04          	mov    %edx,0x4(%esp)
    2838:	89 2c 24             	mov    %ebp,(%esp)
    283b:	ff d3                	call   *%ebx
                      "checkdir warning: current dir path too long\n"));
                    return MPN_INF_TRUNC;   /* can't get drive letter */
    283d:	bb 00 01 00 00       	mov    $0x100,%ebx
                *G.buildpathHPFS = (char)ToLower(*G.rootpath);
            else {
                char tmpN[MAX_PATH], *tmpP;
                if (GetFullPathName(".", MAX_PATH, tmpN, &tmpP) > MAX_PATH)
                { /* by definition of MAX_PATH we should never get here */
                    Info(slide, 1, ((char *)slide,
    2842:	83 ec 10             	sub    $0x10,%esp
    2845:	e9 44 f8 ff ff       	jmp    208e <_checkdir+0x1ae>
                free(G.buildpathFAT);
                return MPN_VOL_LABEL;  /* skipping with message */
            }
            *G.buildpathHPFS = '\0';
        } else if (G.renamed_fullpath) /* pathcomp = valid data */
            strcpy(G.buildpathHPFS, pathcomp);
    284a:	8b 84 24 54 01 00 00 	mov    0x154(%esp),%eax
    2851:	89 3c 24             	mov    %edi,(%esp)
    2854:	89 44 24 04          	mov    %eax,0x4(%esp)
    2858:	89 54 24 14          	mov    %edx,0x14(%esp)
    285c:	e8 00 00 00 00       	call   2861 <_checkdir+0x981>
    2861:	8b 54 24 14          	mov    0x14(%esp),%edx
    2865:	e9 4b fe ff ff       	jmp    26b5 <_checkdir+0x7d5>
                                             (uO.acorn_nfs_ext ? 5 : 1)))
#else
        if ((G.buildpathFAT = (char *)malloc(G.fnlen+G.rootlen+1))
#endif
            == NULL) {
            free(G.buildpathHPFS);
    286a:	89 3c 24             	mov    %edi,(%esp)
    286d:	e8 00 00 00 00       	call   2872 <_checkdir+0x992>
            return MPN_NOMEM;
    2872:	e9 17 f8 ff ff       	jmp    208e <_checkdir+0x1ae>
            if (tmproot[G.rootlen-1] == '/' || tmproot[G.rootlen-1] == '\\') {
                tmproot[--G.rootlen] = '\0';
                had_trailing_pathsep = TRUE;
            }
            if (has_drive && (G.rootlen == 2)) {
                if (!had_trailing_pathsep)   /* i.e., original wasn't "x:/" */
    2877:	85 c9                	test   %ecx,%ecx
    2879:	0f 85 cd fd ff ff    	jne    264c <_checkdir+0x76c>
                        return MPN_ERR_SKIP;
                    }
                }
            }
            if (add_dot)                    /* had just "x:", make "x:." */
                tmproot[G.rootlen++] = '.';
    287f:	c6 46 02 2e          	movb   $0x2e,0x2(%esi)
    2883:	ba 05 00 00 00       	mov    $0x5,%edx
    2888:	b9 04 00 00 00       	mov    $0x4,%ecx
    288d:	bb 03 00 00 00       	mov    $0x3,%ebx
    2892:	b8 04 00 00 00       	mov    $0x4,%eax
    2897:	e9 b8 fd ff ff       	jmp    2654 <_checkdir+0x774>
                        /* treat as stored file */
                        return MPN_INF_SKIP;
                    }
                    /* create directory (could add loop here scanning tmproot
                     * to create more than one level, but really necessary?) */
                    if (MKDIR(tmproot, 0777) == -1) {
    289c:	e8 00 00 00 00       	call   28a1 <_checkdir+0x9c1>
    28a1:	40                   	inc    %eax
    28a2:	0f 85 9e fd ff ff    	jne    2646 <_checkdir+0x766>
                        Info(slide, 1, ((char *)slide,
    28a8:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    28ae:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    28b4:	89 44 24 04          	mov    %eax,0x4(%esp)
    28b8:	89 34 24             	mov    %esi,(%esp)
    28bb:	e8 00 00 00 00       	call   28c0 <_checkdir+0x9e0>
    28c0:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    28c6:	89 1c 24             	mov    %ebx,(%esp)
    28c9:	89 44 24 08          	mov    %eax,0x8(%esp)
    28cd:	c7 44 24 04 88 03 00 	movl   $0x388,0x4(%esp)
    28d4:	00 
    28d5:	e8 00 00 00 00       	call   28da <_checkdir+0x9fa>
    28da:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    28de:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    28e5:	00 
    28e6:	89 44 24 08          	mov    %eax,0x8(%esp)
    28ea:	89 2c 24             	mov    %ebp,(%esp)
                          FnFilter1(tmproot)));
                        free(tmproot);
                        G.rootlen = 0;
                        /* path didn't exist, tried to create, failed: */
                        /* file exists, or need 2+ subdir levels */
                        return MPN_ERR_SKIP;
    28ed:	bb 00 03 00 00       	mov    $0x300,%ebx
                        return MPN_INF_SKIP;
                    }
                    /* create directory (could add loop here scanning tmproot
                     * to create more than one level, but really necessary?) */
                    if (MKDIR(tmproot, 0777) == -1) {
                        Info(slide, 1, ((char *)slide,
    28f2:	ff d7                	call   *%edi
    28f4:	83 ec 10             	sub    $0x10,%esp
                          "checkdir:  cannot create extraction directory: %s\n",
                          FnFilter1(tmproot)));
                        free(tmproot);
    28f7:	89 34 24             	mov    %esi,(%esp)
    28fa:	e8 00 00 00 00       	call   28ff <_checkdir+0xa1f>
                        G.rootlen = 0;
    28ff:	c7 85 ac 0c 01 00 00 	movl   $0x0,0x10cac(%ebp)
    2906:	00 00 00 
                        /* path didn't exist, tried to create, failed: */
                        /* file exists, or need 2+ subdir levels */
                        return MPN_ERR_SKIP;
    2909:	e9 80 f7 ff ff       	jmp    208e <_checkdir+0x1ae>
                G.nLabelDrive = *tmpN - 'a' + 1;
                *G.buildpathHPFS = (char)(G.nLabelDrive - 1 + 'a');
            }
            G.nLabelDrive = *G.buildpathHPFS - 'a' + 1; /* save for mapname() */
            if (uO.volflag == 0 || *G.buildpathHPFS < 'a' /* no labels/bogus? */
                || (uO.volflag == 1 && !isfloppy(G.nLabelDrive))) { /* !fixed */
    290e:	4a                   	dec    %edx
    290f:	74 49                	je     295a <_checkdir+0xa7a>
                free(G.buildpathHPFS);
                free(G.buildpathFAT);
                return MPN_VOL_LABEL;  /* skipping with message */
            }
            *G.buildpathHPFS = '\0';
    2911:	c6 07 00             	movb   $0x0,(%edi)
    2914:	8b bd 90 0b 01 00    	mov    0x10b90(%ebp),%edi
    291a:	8b 95 94 0b 01 00    	mov    0x10b94(%ebp),%edx
    2920:	e9 90 fd ff ff       	jmp    26b5 <_checkdir+0x7d5>
                *G.buildpathHPFS = (char)ToLower(*G.rootpath);
            else {
                char tmpN[MAX_PATH], *tmpP;
                if (GetFullPathName(".", MAX_PATH, tmpN, &tmpP) > MAX_PATH)
                { /* by definition of MAX_PATH we should never get here */
                    Info(slide, 1, ((char *)slide,
    2925:	66 8b 0e             	mov    (%esi),%cx
    2928:	83 c7 02             	add    $0x2,%edi
    292b:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    292f:	83 c6 02             	add    $0x2,%esi
    2932:	83 e8 02             	sub    $0x2,%eax
    2935:	e9 ca fe ff ff       	jmp    2804 <_checkdir+0x924>
    293a:	a0 58 03 00 00       	mov    0x358,%al
    293f:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    2945:	88 85 dc 08 00 00    	mov    %al,0x8dc(%ebp)
    294b:	be 59 03 00 00       	mov    $0x359,%esi
    2950:	b8 2c 00 00 00       	mov    $0x2c,%eax
    2955:	e9 9e fe ff ff       	jmp    27f8 <_checkdir+0x918>

static int isfloppy(int nDrive)   /* 1 == A:, 2 == B:, etc. */
{
    char rootPathName[4];

    rootPathName[0] = (char)('A' + nDrive - 1);   /* build the root path */
    295a:	83 c0 40             	add    $0x40,%eax
    rootPathName[1] = ':';                        /*  name, e.g. "A:/" */
    295d:	c6 44 24 2d 3a       	movb   $0x3a,0x2d(%esp)

static int isfloppy(int nDrive)   /* 1 == A:, 2 == B:, etc. */
{
    char rootPathName[4];

    rootPathName[0] = (char)('A' + nDrive - 1);   /* build the root path */
    2962:	88 44 24 2c          	mov    %al,0x2c(%esp)
    rootPathName[1] = ':';                        /*  name, e.g. "A:/" */
    rootPathName[2] = '/';
    rootPathName[3] = '\0';

    return (GetDriveType(rootPathName) == DRIVE_REMOVABLE);
    2966:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    296a:	89 04 24             	mov    %eax,(%esp)
{
    char rootPathName[4];

    rootPathName[0] = (char)('A' + nDrive - 1);   /* build the root path */
    rootPathName[1] = ':';                        /*  name, e.g. "A:/" */
    rootPathName[2] = '/';
    296d:	c6 44 24 2e 2f       	movb   $0x2f,0x2e(%esp)
    rootPathName[3] = '\0';
    2972:	c6 44 24 2f 00       	movb   $0x0,0x2f(%esp)

    return (GetDriveType(rootPathName) == DRIVE_REMOVABLE);
    2977:	e8 00 00 00 00       	call   297c <_checkdir+0xa9c>
                G.nLabelDrive = *tmpN - 'a' + 1;
                *G.buildpathHPFS = (char)(G.nLabelDrive - 1 + 'a');
            }
            G.nLabelDrive = *G.buildpathHPFS - 'a' + 1; /* save for mapname() */
            if (uO.volflag == 0 || *G.buildpathHPFS < 'a' /* no labels/bogus? */
                || (uO.volflag == 1 && !isfloppy(G.nLabelDrive))) { /* !fixed */
    297c:	83 f8 02             	cmp    $0x2,%eax
    rootPathName[0] = (char)('A' + nDrive - 1);   /* build the root path */
    rootPathName[1] = ':';                        /*  name, e.g. "A:/" */
    rootPathName[2] = '/';
    rootPathName[3] = '\0';

    return (GetDriveType(rootPathName) == DRIVE_REMOVABLE);
    297f:	52                   	push   %edx
    2980:	8b bd 90 0b 01 00    	mov    0x10b90(%ebp),%edi
                G.nLabelDrive = *tmpN - 'a' + 1;
                *G.buildpathHPFS = (char)(G.nLabelDrive - 1 + 'a');
            }
            G.nLabelDrive = *G.buildpathHPFS - 'a' + 1; /* save for mapname() */
            if (uO.volflag == 0 || *G.buildpathHPFS < 'a' /* no labels/bogus? */
                || (uO.volflag == 1 && !isfloppy(G.nLabelDrive))) { /* !fixed */
    2986:	0f 85 93 fb ff ff    	jne    251f <_checkdir+0x63f>
    298c:	eb 83                	jmp    2911 <_checkdir+0xa31>
    298e:	66 90                	xchg   %ax,%ax

00002990 <_mapname>:
 *  MPN_ERR_SKIP    - error -> skip entry
 *  MPN_ERR_TOOLONG - error -> path is too long
 *  MPN_NOMEM       - error (memory allocation failed) -> skip entry
 *  [also MPN_VOL_LABEL, MPN_CREATED_DIR]
 */
{
    2990:	55                   	push   %ebp
    2991:	57                   	push   %edi
    2992:	56                   	push   %esi
    2993:	53                   	push   %ebx
    2994:	81 ec 4c 01 00 00    	sub    $0x14c,%esp
    299a:	8b ac 24 60 01 00 00 	mov    0x160(%esp),%ebp
    29a1:	8b b4 24 64 01 00 00 	mov    0x164(%esp),%esi
/*---------------------------------------------------------------------------
    Initialize various pointers and counters and stuff.
  ---------------------------------------------------------------------------*/

    /* can create path as long as not just freshening, or if user told us */
    G.create_dirs = (!uO.fflag || renamed);
    29a8:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
    29ab:	85 db                	test   %ebx,%ebx
    29ad:	0f 84 80 00 00 00    	je     2a33 <_mapname+0xa3>
    29b3:	85 f6                	test   %esi,%esi
    29b5:	0f 84 15 03 00 00    	je     2cd0 <_mapname+0x340>

    G.created_dir = FALSE;      /* not yet */
    G.renamed_fullpath = FALSE;
    G.fnlen = strlen(G.filename);
    29bb:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
/*---------------------------------------------------------------------------
    Initialize various pointers and counters and stuff.
  ---------------------------------------------------------------------------*/

    /* can create path as long as not just freshening, or if user told us */
    G.create_dirs = (!uO.fflag || renamed);
    29c1:	c7 45 7c 01 00 00 00 	movl   $0x1,0x7c(%ebp)

    G.created_dir = FALSE;      /* not yet */
    29c8:	c7 85 70 0b 01 00 00 	movl   $0x0,0x10b70(%ebp)
    29cf:	00 00 00 
    G.renamed_fullpath = FALSE;
    29d2:	c7 85 74 0b 01 00 00 	movl   $0x0,0x10b74(%ebp)
    29d9:	00 00 00 
    G.fnlen = strlen(G.filename);
    29dc:	89 04 24             	mov    %eax,(%esp)
    29df:	89 44 24 20          	mov    %eax,0x20(%esp)
    29e3:	e8 00 00 00 00       	call   29e8 <_mapname+0x58>
    29e8:	89 85 78 0b 01 00    	mov    %eax,0x10b78(%ebp)

    if (renamed) {
        cp = G.filename;    /* point to beginning of renamed name... */
        if (*cp) do {
    29ee:	8a 95 e0 09 01 00    	mov    0x109e0(%ebp),%dl
    29f4:	8b 3d 00 00 00 00    	mov    0x0,%edi
    29fa:	84 d2                	test   %dl,%dl
    29fc:	0f 84 1d 02 00 00    	je     2c1f <_mapname+0x28f>
    2a02:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    2a06:	8b 3d 00 00 00 00    	mov    0x0,%edi
    2a0c:	88 d0                	mov    %dl,%al
    2a0e:	eb 1a                	jmp    2a2a <_mapname+0x9a>
            if (*cp == '\\')    /* convert backslashes to forward */
                *cp = '/';
        } while (*PREINCSTR(cp));
    2a10:	8b 07                	mov    (%edi),%eax
    2a12:	89 1c 24             	mov    %ebx,(%esp)
    2a15:	89 44 24 04          	mov    %eax,0x4(%esp)
    2a19:	e8 00 00 00 00       	call   2a1e <_mapname+0x8e>
    2a1e:	01 c3                	add    %eax,%ebx
    2a20:	8a 03                	mov    (%ebx),%al
    2a22:	84 c0                	test   %al,%al
    2a24:	0f 84 e6 01 00 00    	je     2c10 <_mapname+0x280>
    G.fnlen = strlen(G.filename);

    if (renamed) {
        cp = G.filename;    /* point to beginning of renamed name... */
        if (*cp) do {
            if (*cp == '\\')    /* convert backslashes to forward */
    2a2a:	3c 5c                	cmp    $0x5c,%al
    2a2c:	75 e2                	jne    2a10 <_mapname+0x80>
                *cp = '/';
    2a2e:	c6 03 2f             	movb   $0x2f,(%ebx)
    2a31:	eb dd                	jmp    2a10 <_mapname+0x80>
    /* can create path as long as not just freshening, or if user told us */
    G.create_dirs = (!uO.fflag || renamed);

    G.created_dir = FALSE;      /* not yet */
    G.renamed_fullpath = FALSE;
    G.fnlen = strlen(G.filename);
    2a33:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
/*---------------------------------------------------------------------------
    Initialize various pointers and counters and stuff.
  ---------------------------------------------------------------------------*/

    /* can create path as long as not just freshening, or if user told us */
    G.create_dirs = (!uO.fflag || renamed);
    2a39:	c7 45 7c 01 00 00 00 	movl   $0x1,0x7c(%ebp)

    G.created_dir = FALSE;      /* not yet */
    2a40:	c7 85 70 0b 01 00 00 	movl   $0x0,0x10b70(%ebp)
    2a47:	00 00 00 
    G.renamed_fullpath = FALSE;
    2a4a:	c7 85 74 0b 01 00 00 	movl   $0x0,0x10b74(%ebp)
    2a51:	00 00 00 
    G.fnlen = strlen(G.filename);
    2a54:	89 04 24             	mov    %eax,(%esp)
    2a57:	89 44 24 20          	mov    %eax,0x20(%esp)
    2a5b:	e8 00 00 00 00       	call   2a60 <_mapname+0xd0>

    if (renamed) {
    2a60:	85 f6                	test   %esi,%esi
    /* can create path as long as not just freshening, or if user told us */
    G.create_dirs = (!uO.fflag || renamed);

    G.created_dir = FALSE;      /* not yet */
    G.renamed_fullpath = FALSE;
    G.fnlen = strlen(G.filename);
    2a62:	89 85 78 0b 01 00    	mov    %eax,0x10b78(%ebp)

    if (renamed) {
    2a68:	75 84                	jne    29ee <_mapname+0x5e>
            *pp = '\0';
        }
    }

    /* pathcomp is ignored unless renamed_fullpath is TRUE: */
    if ((error = checkdir(__G__ pathcomp, INIT)) != 0)    /* init path buffer */
    2a6a:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    2a6e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    2a75:	00 
    2a76:	89 44 24 04          	mov    %eax,0x4(%esp)
    2a7a:	89 2c 24             	mov    %ebp,(%esp)
    2a7d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    2a81:	e8 5a f4 ff ff       	call   1ee0 <_checkdir>
    2a86:	85 c0                	test   %eax,%eax
    2a88:	0f 85 72 01 00 00    	jne    2c00 <_mapname+0x270>
        return error;           /* ...unless no mem or vol label on hard disk */

    *pathcomp = '\0';           /* initialize translation buffer */
    pp = pathcomp;              /* point to translation buffer */
    if (!renamed) {             /* cp already set if renamed */
        if (uO.jflag)           /* junking directories */
    2a8e:	8b 45 24             	mov    0x24(%ebp),%eax

    /* pathcomp is ignored unless renamed_fullpath is TRUE: */
    if ((error = checkdir(__G__ pathcomp, INIT)) != 0)    /* init path buffer */
        return error;           /* ...unless no mem or vol label on hard disk */

    *pathcomp = '\0';           /* initialize translation buffer */
    2a91:	c6 44 24 3c 00       	movb   $0x0,0x3c(%esp)
    pp = pathcomp;              /* point to translation buffer */
    if (!renamed) {             /* cp already set if renamed */
        if (uO.jflag)           /* junking directories */
    2a96:	85 c0                	test   %eax,%eax
    2a98:	0f 85 71 03 00 00    	jne    2e0f <_mapname+0x47f>
    2a9e:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    2aa2:	e9 df 01 00 00       	jmp    2c86 <_mapname+0x2f6>
                break;            /*  later, if requested */
#endif

            case ' ':             /* keep spaces unless specifically */
                /* NT cannot create filenames with spaces on FAT volumes */
                if (uO.sflag || IsVolumeOldFAT(__G__ G.filename))
    2aa7:	8b 45 3c             	mov    0x3c(%ebp),%eax
    2aaa:	85 c0                	test   %eax,%eax
    2aac:	75 22                	jne    2ad0 <_mapname+0x140>
/* Function IsVolumeOldFAT() */
/*****************************/

static int IsVolumeOldFAT(__GPRO__ const char *name)
{
    return (NTQueryVolInfo(__G__ name) ? G.lastVolOldFAT : FALSE);
    2aae:	8b 54 24 20          	mov    0x20(%esp),%edx
    2ab2:	89 e8                	mov    %ebp,%eax
    2ab4:	e8 47 d5 ff ff       	call   0 <_NTQueryVolInfo>
    2ab9:	85 c0                	test   %eax,%eax
    2abb:	0f 84 14 04 00 00    	je     2ed5 <_mapname+0x545>
                break;            /*  later, if requested */
#endif

            case ' ':             /* keep spaces unless specifically */
                /* NT cannot create filenames with spaces on FAT volumes */
                if (uO.sflag || IsVolumeOldFAT(__G__ G.filename))
    2ac1:	8b 85 84 0b 01 00    	mov    0x10b84(%ebp),%eax
    2ac7:	85 c0                	test   %eax,%eax
    2ac9:	0f 84 06 04 00 00    	je     2ed5 <_mapname+0x545>
    2acf:	90                   	nop
    2ad0:	a1 00 00 00 00       	mov    0x0,%eax
                    *pp++ = '_';
    2ad5:	c6 06 5f             	movb   $0x5f,(%esi)
    2ad8:	46                   	inc    %esi
    2ad9:	8b 00                	mov    (%eax),%eax

/*---------------------------------------------------------------------------
    Begin main loop through characters in filename.
  ---------------------------------------------------------------------------*/

    for (; (workch = (uch)*cp) != 0; INCSTR(cp)) {
    2adb:	89 1c 24             	mov    %ebx,(%esp)
    2ade:	89 44 24 04          	mov    %eax,0x4(%esp)
    2ae2:	e8 00 00 00 00       	call   2ae7 <_mapname+0x157>
    2ae7:	31 d2                	xor    %edx,%edx
    2ae9:	01 c3                	add    %eax,%ebx
    2aeb:	8a 03                	mov    (%ebx),%al
    2aed:	88 44 24 18          	mov    %al,0x18(%esp)
    2af1:	88 c2                	mov    %al,%dl
    2af3:	84 c0                	test   %al,%al
    2af5:	0f 85 b5 01 00 00    	jne    2cb0 <_mapname+0x320>
        } /* end switch */

    } /* end while loop */

    /* Show warning when stripping insecure "parent dir" path components */
    if (killed_ddot && QCOND2) {
    2afb:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    2aff:	85 c0                	test   %eax,%eax
    2b01:	74 0b                	je     2b0e <_mapname+0x17e>
    2b03:	8b 45 38             	mov    0x38(%ebp),%eax
    2b06:	85 c0                	test   %eax,%eax
    2b08:	0f 84 3a 04 00 00    	je     2f48 <_mapname+0x5b8>
    Report if directory was created (and no file to create:  filename ended
    in '/'), check name to be sure it exists, and combine path and name be-
    fore exiting.
  ---------------------------------------------------------------------------*/

    if (lastchar(G.filename, G.fnlen) == '/') {
    2b0e:	8b 85 78 0b 01 00    	mov    0x10b78(%ebp),%eax
    2b14:	89 44 24 04          	mov    %eax,0x4(%esp)
    2b18:	8b 44 24 20          	mov    0x20(%esp),%eax
    2b1c:	89 04 24             	mov    %eax,(%esp)
    2b1f:	e8 00 00 00 00       	call   2b24 <_mapname+0x194>
    2b24:	80 38 2f             	cmpb   $0x2f,(%eax)
    2b27:	0f 84 92 04 00 00    	je     2fbf <_mapname+0x62f>
        }
        /* dir existed already; don't look for data to extract */
        return (error & ~MPN_MASK) | MPN_INF_SKIP;
    }

    *pp = '\0';                   /* done with pathcomp:  terminate it */
    2b2d:	c6 06 00             	movb   $0x0,(%esi)

    /* if not saving them, remove VMS version numbers (appended "###") */
    if (!uO.V_flag && lastsemi) {
    2b30:	85 ff                	test   %edi,%edi
    2b32:	74 25                	je     2b59 <_mapname+0x1c9>
    2b34:	8b 5d 54             	mov    0x54(%ebp),%ebx
    2b37:	85 db                	test   %ebx,%ebx
    2b39:	75 1e                	jne    2b59 <_mapname+0x1c9>
        pp = lastsemi + 1;        /* semi-colon was kept:  expect #'s after */
    2b3b:	8d 57 01             	lea    0x1(%edi),%edx
        while (isdigit((uch)(*pp)))
    2b3e:	8a 4f 01             	mov    0x1(%edi),%cl
    2b41:	eb 03                	jmp    2b46 <_mapname+0x1b6>
            ++pp;
    2b43:	42                   	inc    %edx
    *pp = '\0';                   /* done with pathcomp:  terminate it */

    /* if not saving them, remove VMS version numbers (appended "###") */
    if (!uO.V_flag && lastsemi) {
        pp = lastsemi + 1;        /* semi-colon was kept:  expect #'s after */
        while (isdigit((uch)(*pp)))
    2b44:	8a 0a                	mov    (%edx),%cl
    2b46:	31 c0                	xor    %eax,%eax
    2b48:	88 c8                	mov    %cl,%al
    2b4a:	83 e8 30             	sub    $0x30,%eax
    2b4d:	83 f8 09             	cmp    $0x9,%eax
    2b50:	76 f1                	jbe    2b43 <_mapname+0x1b3>
            ++pp;
        if (*pp == '\0')          /* only digits between ';' and end:  nuke */
    2b52:	84 c9                	test   %cl,%cl
    2b54:	75 03                	jne    2b59 <_mapname+0x1c9>
            *lastsemi = '\0';
    2b56:	c6 07 00             	movb   $0x0,(%edi)
        if ((ft & 1<<31)==0) ft=0x000FFD00;
        sprintf(pathcomp+strlen(pathcomp), ",%03x", (int)(ft>>8) & 0xFFF);
    }
#endif /* ACORN_FTYPE_NFS */

    maskDOSdevice(__G__ pathcomp);
    2b59:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    2b5d:	89 e8                	mov    %ebp,%eax
    2b5f:	e8 ec da ff ff       	call   650 <_maskDOSdevice>

    if (*pathcomp == '\0') {
    2b64:	80 7c 24 3c 00       	cmpb   $0x0,0x3c(%esp)
    2b69:	0f 84 76 03 00 00    	je     2ee5 <_mapname+0x555>
        Info(slide, 1, ((char *)slide, "mapname:  conversion of %s failed\n",
          FnFilter1(G.filename)));
        return (error & ~MPN_MASK) | MPN_ERR_SKIP;
    }

    checkdir(__G__ pathcomp, APPEND_NAME);  /* returns 1 if truncated: care? */
    2b6f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    2b73:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    2b7a:	00 
    2b7b:	89 44 24 04          	mov    %eax,0x4(%esp)
    2b7f:	89 2c 24             	mov    %ebp,(%esp)
    2b82:	e8 59 f3 ff ff       	call   1ee0 <_checkdir>
    checkdir(__G__ G.filename, GETPATH);
    2b87:	8b 44 24 20          	mov    0x20(%esp),%eax
    2b8b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    2b92:	00 
    2b93:	89 44 24 04          	mov    %eax,0x4(%esp)
    2b97:	89 2c 24             	mov    %ebp,(%esp)
    2b9a:	e8 41 f3 ff ff       	call   1ee0 <_checkdir>

    if (G.pInfo->vollabel) {    /* set the volume label now */
    2b9f:	8b 95 d8 08 00 00    	mov    0x8d8(%ebp),%edx
#undef Ansi_Fname
    }

    Trace((stderr, "mapname returns with filename = [%s] (error = %d)\n\n",
      FnFilter1(G.filename), error));
    return error;
    2ba5:	8b 44 24 28          	mov    0x28(%esp),%eax
    }

    checkdir(__G__ pathcomp, APPEND_NAME);  /* returns 1 if truncated: care? */
    checkdir(__G__ G.filename, GETPATH);

    if (G.pInfo->vollabel) {    /* set the volume label now */
    2ba9:	f6 42 18 20          	testb  $0x20,0x18(%edx)
    2bad:	74 51                	je     2c00 <_mapname+0x270>
#else
#       define Ansi_Fname  G.filename
#endif

        /* Build a drive string, e.g. "b:" */
        drive[0] = (char)('a' + G.nLabelDrive - 1);
    2baf:	8a 85 7c 0b 01 00    	mov    0x10b7c(%ebp),%al
        strcpy(drive + 1, ":\\");
        if (QCOND2)
    2bb5:	8b 4d 38             	mov    0x38(%ebp),%ecx
#else
#       define Ansi_Fname  G.filename
#endif

        /* Build a drive string, e.g. "b:" */
        drive[0] = (char)('a' + G.nLabelDrive - 1);
    2bb8:	83 c0 60             	add    $0x60,%eax
        strcpy(drive + 1, ":\\");
    2bbb:	8d 5c 24 38          	lea    0x38(%esp),%ebx
#else
#       define Ansi_Fname  G.filename
#endif

        /* Build a drive string, e.g. "b:" */
        drive[0] = (char)('a' + G.nLabelDrive - 1);
    2bbf:	88 44 24 38          	mov    %al,0x38(%esp)
        strcpy(drive + 1, ":\\");
    2bc3:	66 c7 44 24 39 3a 5c 	movw   $0x5c3a,0x39(%esp)
    2bca:	c6 44 24 3b 00       	movb   $0x0,0x3b(%esp)
        if (QCOND2)
    2bcf:	85 c9                	test   %ecx,%ecx
    2bd1:	0f 84 8e 05 00 00    	je     3165 <_mapname+0x7d5>
            Info(slide, 0, ((char *)slide, "labelling %s %-22s\n", drive,
              FnFilter1(G.filename)));
        if (!SetVolumeLabel(drive, Ansi_Fname)) {
    2bd7:	8b 44 24 20          	mov    0x20(%esp),%eax
    2bdb:	89 1c 24             	mov    %ebx,(%esp)
    2bde:	89 44 24 04          	mov    %eax,0x4(%esp)
    2be2:	e8 00 00 00 00       	call   2be7 <_mapname+0x257>
    2be7:	85 c0                	test   %eax,%eax
    2be9:	52                   	push   %edx
    2bea:	52                   	push   %edx
    2beb:	0f 84 ff 04 00 00    	je     30f0 <_mapname+0x760>
            Info(slide, 1, ((char *)slide,
              "mapname:  error setting volume label\n"));
            return (error & ~MPN_MASK) | MPN_ERR_SKIP;
        }
        /* success:  skip the "extraction" quietly */
        return (error & ~MPN_MASK) | MPN_INF_SKIP;
    2bf1:	8b 44 24 28          	mov    0x28(%esp),%eax
    2bf5:	80 e4 80             	and    $0x80,%ah
    2bf8:	80 cc 02             	or     $0x2,%ah
    2bfb:	90                   	nop
    2bfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    Trace((stderr, "mapname returns with filename = [%s] (error = %d)\n\n",
      FnFilter1(G.filename), error));
    return error;

} /* end function mapname() */
    2c00:	81 c4 4c 01 00 00    	add    $0x14c,%esp
    2c06:	5b                   	pop    %ebx
    2c07:	5e                   	pop    %esi
    2c08:	5f                   	pop    %edi
    2c09:	5d                   	pop    %ebp
    2c0a:	c3                   	ret    
    2c0b:	90                   	nop
    2c0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2c10:	8a 95 e0 09 01 00    	mov    0x109e0(%ebp),%dl
            if (*cp == '\\')    /* convert backslashes to forward */
                *cp = '/';
        } while (*PREINCSTR(cp));
        cp = G.filename;
        /* use temporary rootpath if user gave full pathname */
        if (G.filename[0] == '/') {
    2c16:	80 fa 2f             	cmp    $0x2f,%dl
    2c19:	0f 84 d1 01 00 00    	je     2df0 <_mapname+0x460>
    2c1f:	83 3f 01             	cmpl   $0x1,(%edi)
    2c22:	0f 84 a8 01 00 00    	je     2dd0 <_mapname+0x440>
            G.renamed_fullpath = TRUE;
            pathcomp[0] = '/';  /* copy the '/' and terminate */
            pathcomp[1] = '\0';
            ++cp;
        } else if (isalpha((uch)G.filename[0]) && G.filename[1] == ':') {
    2c28:	31 c0                	xor    %eax,%eax
    2c2a:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
    2c31:	00 
    2c32:	88 d0                	mov    %dl,%al
    2c34:	89 04 24             	mov    %eax,(%esp)
    2c37:	e8 00 00 00 00       	call   2c3c <_mapname+0x2ac>
    2c3c:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    2c40:	85 c0                	test   %eax,%eax
    2c42:	74 0d                	je     2c51 <_mapname+0x2c1>
    2c44:	80 bd e1 09 01 00 3a 	cmpb   $0x3a,0x109e1(%ebp)
    2c4b:	0f 84 2f 04 00 00    	je     3080 <_mapname+0x6f0>
            *pp = '\0';
        }
    }

    /* pathcomp is ignored unless renamed_fullpath is TRUE: */
    if ((error = checkdir(__G__ pathcomp, INIT)) != 0)    /* init path buffer */
    2c51:	8d 44 24 3c          	lea    0x3c(%esp),%eax
    2c55:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    2c5c:	00 
    2c5d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2c61:	89 2c 24             	mov    %ebp,(%esp)
    2c64:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    2c68:	e8 73 f2 ff ff       	call   1ee0 <_checkdir>
    2c6d:	85 c0                	test   %eax,%eax
    2c6f:	75 8f                	jne    2c00 <_mapname+0x270>
        return error;           /* ...unless no mem or vol label on hard disk */

    *pathcomp = '\0';           /* initialize translation buffer */
    2c71:	c6 44 24 3c 00       	movb   $0x0,0x3c(%esp)
    pp = pathcomp;              /* point to translation buffer */
    if (!renamed) {             /* cp already set if renamed */
    2c76:	85 f6                	test   %esi,%esi
    2c78:	75 0c                	jne    2c86 <_mapname+0x2f6>
        if (uO.jflag)           /* junking directories */
    2c7a:	8b 4d 24             	mov    0x24(%ebp),%ecx
    2c7d:	85 c9                	test   %ecx,%ecx
    2c7f:	0f 85 8a 01 00 00    	jne    2e0f <_mapname+0x47f>
            cp = (char *)MBSRCHR(G.filename, '/');
        if (cp == NULL)         /* no '/' or not junking dirs */
            cp = G.filename;    /* point to internal zipfile-member pathname */
        else
            ++cp;               /* point to start of last component of path */
    2c85:	43                   	inc    %ebx

/*---------------------------------------------------------------------------
    Begin main loop through characters in filename.
  ---------------------------------------------------------------------------*/

    for (; (workch = (uch)*cp) != 0; INCSTR(cp)) {
    2c86:	8a 0b                	mov    (%ebx),%cl
    2c88:	31 d2                	xor    %edx,%edx
    2c8a:	88 ca                	mov    %cl,%dl
    2c8c:	84 c9                	test   %cl,%cl
    2c8e:	0f 84 31 05 00 00    	je     31c5 <_mapname+0x835>
    2c94:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    2c9b:	00 
    2c9c:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
    2ca3:	00 
    2ca4:	31 ff                	xor    %edi,%edi
    2ca6:	8b 74 24 1c          	mov    0x1c(%esp),%esi
__CRT_INLINE int __cdecl __MINGW_NOTHROW iscntrl(int c) {return __ISCTYPE(c, _CONTROL);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isdigit(int c) {return __ISCTYPE(c, _DIGIT);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isgraph(int c) {return __ISCTYPE(c, (_PUNCT|_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW islower(int c) {return __ISCTYPE(c, _LOWER);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isprint(int c) {return __ISCTYPE(c, (_BLANK|_PUNCT|_ALPHA|_DIGIT));}
    2caa:	88 4c 24 18          	mov    %cl,0x18(%esp)
    2cae:	66 90                	xchg   %ax,%ax

        switch (workch) {
    2cb0:	8a 44 24 18          	mov    0x18(%esp),%al
    2cb4:	8d 48 e0             	lea    -0x20(%eax),%ecx
    2cb7:	80 f9 5c             	cmp    $0x5c,%cl
    2cba:	0f 87 a0 00 00 00    	ja     2d60 <_mapname+0x3d0>
    2cc0:	31 c0                	xor    %eax,%eax
    2cc2:	88 c8                	mov    %cl,%al
    2cc4:	ff 24 85 9c 04 00 00 	jmp    *0x49c(,%eax,4)
    2ccb:	90                   	nop
    2ccc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    /* can create path as long as not just freshening, or if user told us */
    G.create_dirs = (!uO.fflag || renamed);

    G.created_dir = FALSE;      /* not yet */
    G.renamed_fullpath = FALSE;
    G.fnlen = strlen(G.filename);
    2cd0:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
/*---------------------------------------------------------------------------
    Initialize various pointers and counters and stuff.
  ---------------------------------------------------------------------------*/

    /* can create path as long as not just freshening, or if user told us */
    G.create_dirs = (!uO.fflag || renamed);
    2cd6:	c7 45 7c 00 00 00 00 	movl   $0x0,0x7c(%ebp)

    G.created_dir = FALSE;      /* not yet */
    2cdd:	c7 85 70 0b 01 00 00 	movl   $0x0,0x10b70(%ebp)
    2ce4:	00 00 00 
    G.renamed_fullpath = FALSE;
    2ce7:	c7 85 74 0b 01 00 00 	movl   $0x0,0x10b74(%ebp)
    2cee:	00 00 00 
    G.fnlen = strlen(G.filename);
    2cf1:	89 04 24             	mov    %eax,(%esp)
    2cf4:	89 44 24 20          	mov    %eax,0x20(%esp)
    2cf8:	e8 00 00 00 00       	call   2cfd <_mapname+0x36d>
    2cfd:	89 85 78 0b 01 00    	mov    %eax,0x10b78(%ebp)
    2d03:	e9 62 fd ff ff       	jmp    2a6a <_mapname+0xda>
    2d08:	a1 00 00 00 00       	mov    0x0,%eax
            case '*':
                *pp++ = '_';      /* these rules apply equally to FAT and NTFS */
                break;
            case ';':             /* start of VMS version? */
                lastsemi = pp;    /* remove VMS version later... */
                *pp++ = ';';      /*  but keep semicolon for now */
    2d0d:	c6 06 3b             	movb   $0x3b,(%esi)
                break;
    2d10:	89 f7                	mov    %esi,%edi
            case '*':
                *pp++ = '_';      /* these rules apply equally to FAT and NTFS */
                break;
            case ';':             /* start of VMS version? */
                lastsemi = pp;    /* remove VMS version later... */
                *pp++ = ';';      /*  but keep semicolon for now */
    2d12:	46                   	inc    %esi
    2d13:	8b 00                	mov    (%eax),%eax
                break;
    2d15:	e9 c1 fd ff ff       	jmp    2adb <_mapname+0x14b>
    2d1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

    for (; (workch = (uch)*cp) != 0; INCSTR(cp)) {

        switch (workch) {
            case '/':             /* can assume -j flag not given */
                *pp = '\0';
    2d20:	c6 06 00             	movb   $0x0,(%esi)
                maskDOSdevice(__G__ pathcomp);
    2d23:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    2d27:	89 f2                	mov    %esi,%edx
    2d29:	89 e8                	mov    %ebp,%eax
    2d2b:	e8 20 d9 ff ff       	call   650 <_maskDOSdevice>
                if (strcmp(pathcomp, ".") == 0) {
    2d30:	bf 00 02 00 00       	mov    $0x200,%edi
    2d35:	b9 02 00 00 00       	mov    $0x2,%ecx
    2d3a:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
    2d3c:	0f 85 1e 01 00 00    	jne    2e60 <_mapname+0x4d0>
                    /* don't bother appending "./" to the path */
                    *pathcomp = '\0';
    2d42:	c6 44 24 3c 00       	movb   $0x0,0x3c(%esp)
    2d47:	a1 00 00 00 00       	mov    0x0,%eax
                if (*pathcomp != '\0' &&
                    ((error = checkdir(__G__ pathcomp, APPEND_DIR))
                     & MPN_MASK) > MPN_INF_TRUNC)
                    return error;
                pp = pathcomp;    /* reset conversion buffer for next piece */
                lastsemi = (char *)NULL; /* leave direct. semi-colons alone */
    2d4c:	31 ff                	xor    %edi,%edi
                /* when path component is not empty, append it now */
                if (*pathcomp != '\0' &&
                    ((error = checkdir(__G__ pathcomp, APPEND_DIR))
                     & MPN_MASK) > MPN_INF_TRUNC)
                    return error;
                pp = pathcomp;    /* reset conversion buffer for next piece */
    2d4e:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    2d52:	8b 00                	mov    (%eax),%eax
    2d54:	e9 82 fd ff ff       	jmp    2adb <_mapname+0x14b>
    2d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    2d60:	a1 00 00 00 00       	mov    0x0,%eax
    2d65:	8b 00                	mov    (%eax),%eax
    2d67:	83 f8 01             	cmp    $0x1,%eax
    2d6a:	0f 85 c2 00 00 00    	jne    2e32 <_mapname+0x4a2>
    2d70:	8b 0d 00 00 00 00    	mov    0x0,%ecx
    2d76:	8b 09                	mov    (%ecx),%ecx
    2d78:	66 8b 0c 51          	mov    (%ecx,%edx,2),%cx
    2d7c:	81 e1 57 01 00 00    	and    $0x157,%ecx
                    *pp++ = ' ';
                break;

            default:
                /* allow European characters in filenames: */
                if (isprint(workch) || workch >= 127)
    2d82:	85 c9                	test   %ecx,%ecx
    2d84:	75 09                	jne    2d8f <_mapname+0x3ff>
    2d86:	83 fa 7e             	cmp    $0x7e,%edx
    2d89:	0f 86 4c fd ff ff    	jbe    2adb <_mapname+0x14b>
#ifdef _MBCS
                {
                    memcpy(pp, cp, CLEN(cp));
    2d8f:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d93:	89 1c 24             	mov    %ebx,(%esp)
    2d96:	e8 00 00 00 00       	call   2d9b <_mapname+0x40b>
    2d9b:	89 34 24             	mov    %esi,(%esp)
    2d9e:	89 44 24 08          	mov    %eax,0x8(%esp)
    2da2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2da6:	e8 00 00 00 00       	call   2dab <_mapname+0x41b>
                    INCSTR(pp);
    2dab:	a1 00 00 00 00       	mov    0x0,%eax
    2db0:	8b 00                	mov    (%eax),%eax
    2db2:	89 34 24             	mov    %esi,(%esp)
    2db5:	89 44 24 04          	mov    %eax,0x4(%esp)
    2db9:	e8 00 00 00 00       	call   2dbe <_mapname+0x42e>
    2dbe:	01 c6                	add    %eax,%esi
    2dc0:	a1 00 00 00 00       	mov    0x0,%eax
    2dc5:	8b 00                	mov    (%eax),%eax
    2dc7:	e9 0f fd ff ff       	jmp    2adb <_mapname+0x14b>
    2dcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	|| defined (__STRICT_ANSI__))

/* use  simple lookup if SB locale, else  _isctype()  */
#define __ISCTYPE(c, mask)  (MB_CUR_MAX == 1 ? (_pctype[c] & mask) : _isctype(c, mask))
__CRT_INLINE int __cdecl __MINGW_NOTHROW isalnum(int c) {return __ISCTYPE(c, (_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isalpha(int c) {return __ISCTYPE(c, _ALPHA);}
    2dd0:	31 c0                	xor    %eax,%eax
    2dd2:	88 d0                	mov    %dl,%al
    2dd4:	8b 15 00 00 00 00    	mov    0x0,%edx
    2dda:	8b 12                	mov    (%edx),%edx
    2ddc:	66 8b 04 42          	mov    (%edx,%eax,2),%ax
    2de0:	25 03 01 00 00       	and    $0x103,%eax
    2de5:	e9 52 fe ff ff       	jmp    2c3c <_mapname+0x2ac>
    2dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                *cp = '/';
        } while (*PREINCSTR(cp));
        cp = G.filename;
        /* use temporary rootpath if user gave full pathname */
        if (G.filename[0] == '/') {
            G.renamed_fullpath = TRUE;
    2df0:	c7 85 74 0b 01 00 01 	movl   $0x1,0x10b74(%ebp)
    2df7:	00 00 00 
            pathcomp[0] = '/';  /* copy the '/' and terminate */
    2dfa:	c6 44 24 3c 2f       	movb   $0x2f,0x3c(%esp)
            pathcomp[1] = '\0';
    2dff:	c6 44 24 3d 00       	movb   $0x0,0x3d(%esp)
            ++cp;
    2e04:	8d 9d e1 09 01 00    	lea    0x109e1(%ebp),%ebx
    2e0a:	e9 42 fe ff ff       	jmp    2c51 <_mapname+0x2c1>

    *pathcomp = '\0';           /* initialize translation buffer */
    pp = pathcomp;              /* point to translation buffer */
    if (!renamed) {             /* cp already set if renamed */
        if (uO.jflag)           /* junking directories */
            cp = (char *)MBSRCHR(G.filename, '/');
    2e0f:	8b 44 24 20          	mov    0x20(%esp),%eax
    2e13:	c7 44 24 04 2f 00 00 	movl   $0x2f,0x4(%esp)
    2e1a:	00 
    2e1b:	89 04 24             	mov    %eax,(%esp)
    2e1e:	e8 00 00 00 00       	call   2e23 <_mapname+0x493>
    2e23:	89 c3                	mov    %eax,%ebx
        if (cp == NULL)         /* no '/' or not junking dirs */
    2e25:	85 c0                	test   %eax,%eax
    2e27:	0f 84 71 fc ff ff    	je     2a9e <_mapname+0x10e>
    2e2d:	e9 53 fe ff ff       	jmp    2c85 <_mapname+0x2f5>
                    *pp++ = ' ';
                break;

            default:
                /* allow European characters in filenames: */
                if (isprint(workch) || workch >= 127)
    2e32:	31 c9                	xor    %ecx,%ecx
__CRT_INLINE int __cdecl __MINGW_NOTHROW iscntrl(int c) {return __ISCTYPE(c, _CONTROL);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isdigit(int c) {return __ISCTYPE(c, _DIGIT);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isgraph(int c) {return __ISCTYPE(c, (_PUNCT|_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW islower(int c) {return __ISCTYPE(c, _LOWER);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isprint(int c) {return __ISCTYPE(c, (_BLANK|_PUNCT|_ALPHA|_DIGIT));}
    2e34:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
    2e3b:	00 
    2e3c:	8a 4c 24 18          	mov    0x18(%esp),%cl
    2e40:	89 54 24 24          	mov    %edx,0x24(%esp)
    2e44:	89 0c 24             	mov    %ecx,(%esp)
    2e47:	e8 00 00 00 00       	call   2e4c <_mapname+0x4bc>
    2e4c:	8b 54 24 24          	mov    0x24(%esp),%edx
    2e50:	89 c1                	mov    %eax,%ecx
    2e52:	a1 00 00 00 00       	mov    0x0,%eax
    2e57:	8b 00                	mov    (%eax),%eax
    2e59:	e9 24 ff ff ff       	jmp    2d82 <_mapname+0x3f2>
    2e5e:	66 90                	xchg   %ax,%ax
                *pp = '\0';
                maskDOSdevice(__G__ pathcomp);
                if (strcmp(pathcomp, ".") == 0) {
                    /* don't bother appending "./" to the path */
                    *pathcomp = '\0';
                } else if (!uO.ddotflag && strcmp(pathcomp, "..") == 0) {
    2e60:	8b 55 64             	mov    0x64(%ebp),%edx
    2e63:	85 d2                	test   %edx,%edx
    2e65:	75 29                	jne    2e90 <_mapname+0x500>
    2e67:	bf 30 02 00 00       	mov    $0x230,%edi
    2e6c:	b9 03 00 00 00       	mov    $0x3,%ecx
    2e71:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    2e75:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
    2e77:	75 17                	jne    2e90 <_mapname+0x500>
                    /* "../" dir traversal detected, skip over it */
                    *pathcomp = '\0';
    2e79:	c6 44 24 3c 00       	movb   $0x0,0x3c(%esp)
                    killed_ddot = TRUE;     /* set "show message" flag */
    2e7e:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
    2e85:	00 
    2e86:	e9 bc fe ff ff       	jmp    2d47 <_mapname+0x3b7>
    2e8b:	90                   	nop
    2e8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                }
                /* when path component is not empty, append it now */
                if (*pathcomp != '\0' &&
    2e90:	80 7c 24 3c 00       	cmpb   $0x0,0x3c(%esp)
    2e95:	0f 84 ac fe ff ff    	je     2d47 <_mapname+0x3b7>
    2e9b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    2e9f:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
    2ea6:	00 
    2ea7:	89 74 24 04          	mov    %esi,0x4(%esp)
    2eab:	89 2c 24             	mov    %ebp,(%esp)
    2eae:	e8 2d f0 ff ff       	call   1ee0 <_checkdir>
    2eb3:	89 44 24 28          	mov    %eax,0x28(%esp)
                    ((error = checkdir(__G__ pathcomp, APPEND_DIR))
                     & MPN_MASK) > MPN_INF_TRUNC)
    2eb7:	25 00 7f 00 00       	and    $0x7f00,%eax
                    /* "../" dir traversal detected, skip over it */
                    *pathcomp = '\0';
                    killed_ddot = TRUE;     /* set "show message" flag */
                }
                /* when path component is not empty, append it now */
                if (*pathcomp != '\0' &&
    2ebc:	3d 00 01 00 00       	cmp    $0x100,%eax
    2ec1:	0f 8f f5 02 00 00    	jg     31bc <_mapname+0x82c>
    2ec7:	a1 00 00 00 00       	mov    0x0,%eax
                    ((error = checkdir(__G__ pathcomp, APPEND_DIR))
                     & MPN_MASK) > MPN_INF_TRUNC)
                    return error;
                pp = pathcomp;    /* reset conversion buffer for next piece */
                lastsemi = (char *)NULL; /* leave direct. semi-colons alone */
    2ecc:	31 ff                	xor    %edi,%edi
    2ece:	8b 00                	mov    (%eax),%eax
    2ed0:	e9 06 fc ff ff       	jmp    2adb <_mapname+0x14b>
    2ed5:	a1 00 00 00 00       	mov    0x0,%eax
            case ' ':             /* keep spaces unless specifically */
                /* NT cannot create filenames with spaces on FAT volumes */
                if (uO.sflag || IsVolumeOldFAT(__G__ G.filename))
                    *pp++ = '_';
                else
                    *pp++ = ' ';
    2eda:	c6 06 20             	movb   $0x20,(%esi)
    2edd:	46                   	inc    %esi
    2ede:	8b 00                	mov    (%eax),%eax
    2ee0:	e9 f6 fb ff ff       	jmp    2adb <_mapname+0x14b>
#endif /* ACORN_FTYPE_NFS */

    maskDOSdevice(__G__ pathcomp);

    if (*pathcomp == '\0') {
        Info(slide, 1, ((char *)slide, "mapname:  conversion of %s failed\n",
    2ee5:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2eeb:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    2ef1:	89 44 24 04          	mov    %eax,0x4(%esp)
    2ef5:	8b 44 24 20          	mov    0x20(%esp),%eax
    2ef9:	89 04 24             	mov    %eax,(%esp)
    2efc:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    2f02:	e8 00 00 00 00       	call   2f07 <_mapname+0x577>
    2f07:	89 1c 24             	mov    %ebx,(%esp)
    2f0a:	89 44 24 08          	mov    %eax,0x8(%esp)
    2f0e:	c7 44 24 04 3c 04 00 	movl   $0x43c,0x4(%esp)
    2f15:	00 
    2f16:	e8 00 00 00 00       	call   2f1b <_mapname+0x58b>
    2f1b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2f1f:	89 2c 24             	mov    %ebp,(%esp)
    2f22:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    2f29:	00 
    2f2a:	89 44 24 08          	mov    %eax,0x8(%esp)
    2f2e:	ff d6                	call   *%esi
    2f30:	83 ec 10             	sub    $0x10,%esp
          FnFilter1(G.filename)));
        return (error & ~MPN_MASK) | MPN_ERR_SKIP;
    2f33:	8b 44 24 28          	mov    0x28(%esp),%eax

    Trace((stderr, "mapname returns with filename = [%s] (error = %d)\n\n",
      FnFilter1(G.filename), error));
    return error;

} /* end function mapname() */
    2f37:	81 c4 4c 01 00 00    	add    $0x14c,%esp
    maskDOSdevice(__G__ pathcomp);

    if (*pathcomp == '\0') {
        Info(slide, 1, ((char *)slide, "mapname:  conversion of %s failed\n",
          FnFilter1(G.filename)));
        return (error & ~MPN_MASK) | MPN_ERR_SKIP;
    2f3d:	80 e4 80             	and    $0x80,%ah

    Trace((stderr, "mapname returns with filename = [%s] (error = %d)\n\n",
      FnFilter1(G.filename), error));
    return error;

} /* end function mapname() */
    2f40:	5b                   	pop    %ebx
    maskDOSdevice(__G__ pathcomp);

    if (*pathcomp == '\0') {
        Info(slide, 1, ((char *)slide, "mapname:  conversion of %s failed\n",
          FnFilter1(G.filename)));
        return (error & ~MPN_MASK) | MPN_ERR_SKIP;
    2f41:	80 cc 03             	or     $0x3,%ah

    Trace((stderr, "mapname returns with filename = [%s] (error = %d)\n\n",
      FnFilter1(G.filename), error));
    return error;

} /* end function mapname() */
    2f44:	5e                   	pop    %esi
    2f45:	5f                   	pop    %edi
    2f46:	5d                   	pop    %ebp
    2f47:	c3                   	ret    

    } /* end while loop */

    /* Show warning when stripping insecure "parent dir" path components */
    if (killed_ddot && QCOND2) {
        Info(slide, 0, ((char *)slide,
    2f48:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    2f4e:	8b 4c 24 20          	mov    0x20(%esp),%ecx
    2f52:	89 44 24 18          	mov    %eax,0x18(%esp)
    2f56:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    2f5c:	89 0c 24             	mov    %ecx,(%esp)
    2f5f:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f63:	e8 00 00 00 00       	call   2f68 <_mapname+0x5d8>
    2f68:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    2f6e:	89 44 24 08          	mov    %eax,0x8(%esp)
    2f72:	c7 44 24 04 bc 03 00 	movl   $0x3bc,0x4(%esp)
    2f79:	00 
    2f7a:	89 1c 24             	mov    %ebx,(%esp)
    2f7d:	e8 00 00 00 00       	call   2f82 <_mapname+0x5f2>
    2f82:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2f89:	00 
    2f8a:	89 44 24 08          	mov    %eax,0x8(%esp)
    2f8e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2f92:	89 2c 24             	mov    %ebp,(%esp)
    2f95:	ff 54 24 18          	call   *0x18(%esp)
    2f99:	83 ec 10             	sub    $0x10,%esp
          "warning:  skipped \"../\" path component(s) in %s\n",
          FnFilter1(G.filename)));
        if (!(error & ~MPN_MASK))
    2f9c:	f7 44 24 28 ff 80 ff 	testl  $0xffff80ff,0x28(%esp)
    2fa3:	ff 
    2fa4:	0f 85 64 fb ff ff    	jne    2b0e <_mapname+0x17e>
            error = (error & MPN_MASK) | PK_WARN;
    2faa:	8b 44 24 28          	mov    0x28(%esp),%eax
    2fae:	25 00 7f 00 00       	and    $0x7f00,%eax
    2fb3:	83 c8 01             	or     $0x1,%eax
    2fb6:	89 44 24 28          	mov    %eax,0x28(%esp)
    2fba:	e9 4f fb ff ff       	jmp    2b0e <_mapname+0x17e>
        INTERN_TO_ISO(G.filename, ansi_name);
#       define Ansi_Fname  ansi_name
#else
#       define Ansi_Fname  G.filename
#endif
        checkdir(__G__ G.filename, GETPATH);
    2fbf:	8b 44 24 20          	mov    0x20(%esp),%eax
    2fc3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    2fca:	00 
    2fcb:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fcf:	89 2c 24             	mov    %ebp,(%esp)
    2fd2:	e8 09 ef ff ff       	call   1ee0 <_checkdir>
        if (G.created_dir) {
    2fd7:	8b 85 70 0b 01 00    	mov    0x10b70(%ebp),%eax
    2fdd:	85 c0                	test   %eax,%eax
    2fdf:	0f 85 cf 00 00 00    	jne    30b4 <_mapname+0x724>
                      (int)GetLastError(), FnFilter1(G.filename)));
            }

            /* set dir time (note trailing '/') */
            return (error & ~MPN_MASK) | MPN_CREATED_DIR;
        } else if (IS_OVERWRT_ALL) {
    2fe5:	83 7d 78 01          	cmpl   $0x1,0x78(%ebp)
    2fe9:	0f 85 02 fc ff ff    	jne    2bf1 <_mapname+0x261>
            /* overwrite attributes of existing directory on user's request */

            /* set file attributes: */
            if(G.pInfo->file_attr & (0x7F & ~FILE_ATTRIBUTE_DIRECTORY)) {
    2fef:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    2ff5:	8b 40 14             	mov    0x14(%eax),%eax
    2ff8:	a8 6f                	test   $0x6f,%al
    2ffa:	0f 84 f1 fb ff ff    	je     2bf1 <_mapname+0x261>
                if (!SetFileAttributes(Ansi_Fname, G.pInfo->file_attr & 0x7F))
    3000:	83 e0 7f             	and    $0x7f,%eax
    3003:	89 44 24 04          	mov    %eax,0x4(%esp)
    3007:	8b 44 24 20          	mov    0x20(%esp),%eax
    300b:	89 04 24             	mov    %eax,(%esp)
    300e:	e8 00 00 00 00       	call   3013 <_mapname+0x683>
    3013:	85 c0                	test   %eax,%eax
    3015:	56                   	push   %esi
    3016:	56                   	push   %esi
    3017:	0f 85 d4 fb ff ff    	jne    2bf1 <_mapname+0x261>
                    Info(slide, 1, ((char *)slide,
    301d:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3023:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3029:	89 44 24 04          	mov    %eax,0x4(%esp)
    302d:	8b 44 24 20          	mov    0x20(%esp),%eax
    3031:	89 04 24             	mov    %eax,(%esp)
    3034:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    303a:	e8 00 00 00 00       	call   303f <_mapname+0x6af>
    303f:	89 c7                	mov    %eax,%edi
    3041:	e8 00 00 00 00       	call   3046 <_mapname+0x6b6>
    3046:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    304a:	89 44 24 08          	mov    %eax,0x8(%esp)
    304e:	c7 44 24 04 04 04 00 	movl   $0x404,0x4(%esp)
    3055:	00 
    3056:	89 1c 24             	mov    %ebx,(%esp)
    3059:	e8 00 00 00 00       	call   305e <_mapname+0x6ce>
    305e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3065:	00 
    3066:	89 44 24 08          	mov    %eax,0x8(%esp)
    306a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    306e:	89 2c 24             	mov    %ebp,(%esp)
    3071:	ff d6                	call   *%esi
    3073:	83 ec 10             	sub    $0x10,%esp
    3076:	e9 76 fb ff ff       	jmp    2bf1 <_mapname+0x261>
    307b:	90                   	nop
    307c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            pathcomp[1] = '\0';
            ++cp;
        } else if (isalpha((uch)G.filename[0]) && G.filename[1] == ':') {
            G.renamed_fullpath = TRUE;
            pp = pathcomp;
            *pp++ = *cp++;      /* copy the "d:" (+ '/', possibly) */
    3080:	8a 85 e0 09 01 00    	mov    0x109e0(%ebp),%al
            G.renamed_fullpath = TRUE;
            pathcomp[0] = '/';  /* copy the '/' and terminate */
            pathcomp[1] = '\0';
            ++cp;
        } else if (isalpha((uch)G.filename[0]) && G.filename[1] == ':') {
            G.renamed_fullpath = TRUE;
    3086:	c7 85 74 0b 01 00 01 	movl   $0x1,0x10b74(%ebp)
    308d:	00 00 00 
            pp = pathcomp;
            *pp++ = *cp++;      /* copy the "d:" (+ '/', possibly) */
    3090:	88 44 24 3c          	mov    %al,0x3c(%esp)
            *pp++ = *cp++;
    3094:	c6 44 24 3d 3a       	movb   $0x3a,0x3d(%esp)
            if (*cp == '/')
    3099:	80 bd e2 09 01 00 2f 	cmpb   $0x2f,0x109e2(%ebp)
    30a0:	74 3d                	je     30df <_mapname+0x74f>
            ++cp;
        } else if (isalpha((uch)G.filename[0]) && G.filename[1] == ':') {
            G.renamed_fullpath = TRUE;
            pp = pathcomp;
            *pp++ = *cp++;      /* copy the "d:" (+ '/', possibly) */
            *pp++ = *cp++;
    30a2:	8d 9d e2 09 01 00    	lea    0x109e2(%ebp),%ebx
    30a8:	8d 44 24 3e          	lea    0x3e(%esp),%eax
            if (*cp == '/')
                *pp++ = *cp++;  /* otherwise add "./"? */
            *pp = '\0';
    30ac:	c6 00 00             	movb   $0x0,(%eax)
    30af:	e9 9d fb ff ff       	jmp    2c51 <_mapname+0x2c1>
#else
#       define Ansi_Fname  G.filename
#endif
        checkdir(__G__ G.filename, GETPATH);
        if (G.created_dir) {
            if (QCOND2) {
    30b4:	8b 45 38             	mov    0x38(%ebp),%eax
    30b7:	85 c0                	test   %eax,%eax
    30b9:	0f 84 94 01 00 00    	je     3253 <_mapname+0x8c3>
               The default for newly created directories is "DIR attribute
               flags set", so there is no need to change attributes unless
               one of the DOS style attribute flags is set. The readonly
               attribute need not be masked, since it does not prevent
               modifications in the new directory. */
            if(G.pInfo->file_attr & (0x7F & ~FILE_ATTRIBUTE_DIRECTORY)) {
    30bf:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    30c5:	8b 40 14             	mov    0x14(%eax),%eax
    30c8:	a8 6f                	test   $0x6f,%al
    30ca:	0f 85 08 01 00 00    	jne    31d8 <_mapname+0x848>
                      "\nwarning (%d): could not set file attributes for %s\n",
                      (int)GetLastError(), FnFilter1(G.filename)));
            }

            /* set dir time (note trailing '/') */
            return (error & ~MPN_MASK) | MPN_CREATED_DIR;
    30d0:	8b 44 24 28          	mov    0x28(%esp),%eax
    30d4:	80 e4 80             	and    $0x80,%ah
    30d7:	80 cc 10             	or     $0x10,%ah
    30da:	e9 21 fb ff ff       	jmp    2c00 <_mapname+0x270>
            G.renamed_fullpath = TRUE;
            pp = pathcomp;
            *pp++ = *cp++;      /* copy the "d:" (+ '/', possibly) */
            *pp++ = *cp++;
            if (*cp == '/')
                *pp++ = *cp++;  /* otherwise add "./"? */
    30df:	8d 9d e3 09 01 00    	lea    0x109e3(%ebp),%ebx
    30e5:	c6 44 24 3e 2f       	movb   $0x2f,0x3e(%esp)
    30ea:	8d 44 24 3f          	lea    0x3f(%esp),%eax
    30ee:	eb bc                	jmp    30ac <_mapname+0x71c>
        strcpy(drive + 1, ":\\");
        if (QCOND2)
            Info(slide, 0, ((char *)slide, "labelling %s %-22s\n", drive,
              FnFilter1(G.filename)));
        if (!SetVolumeLabel(drive, Ansi_Fname)) {
            Info(slide, 1, ((char *)slide,
    30f0:	8d 95 dc 08 00 00    	lea    0x8dc(%ebp),%edx
    30f6:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    30fc:	89 d7                	mov    %edx,%edi
    30fe:	be 74 04 00 00       	mov    $0x474,%esi
    3103:	b0 26                	mov    $0x26,%al
    3105:	f6 c2 01             	test   $0x1,%dl
    3108:	0f 85 98 01 00 00    	jne    32a6 <_mapname+0x916>
    310e:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3114:	0f 85 ac 01 00 00    	jne    32c6 <_mapname+0x936>
    311a:	89 c1                	mov    %eax,%ecx
    311c:	c1 e9 02             	shr    $0x2,%ecx
    311f:	a8 02                	test   $0x2,%al
    3121:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3123:	74 0b                	je     3130 <_mapname+0x7a0>
    3125:	66 8b 0e             	mov    (%esi),%cx
    3128:	66 89 0f             	mov    %cx,(%edi)
    312b:	b9 02 00 00 00       	mov    $0x2,%ecx
    3130:	a8 01                	test   $0x1,%al
    3132:	74 06                	je     313a <_mapname+0x7aa>
    3134:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    3137:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    313a:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    3141:	00 
    3142:	c7 44 24 08 25 00 00 	movl   $0x25,0x8(%esp)
    3149:	00 
    314a:	89 54 24 04          	mov    %edx,0x4(%esp)
    314e:	89 2c 24             	mov    %ebp,(%esp)
    3151:	ff d3                	call   *%ebx
    3153:	83 ec 10             	sub    $0x10,%esp
              "mapname:  error setting volume label\n"));
            return (error & ~MPN_MASK) | MPN_ERR_SKIP;
    3156:	8b 44 24 28          	mov    0x28(%esp),%eax
    315a:	80 e4 80             	and    $0x80,%ah
    315d:	80 cc 03             	or     $0x3,%ah
    3160:	e9 9b fa ff ff       	jmp    2c00 <_mapname+0x270>

        /* Build a drive string, e.g. "b:" */
        drive[0] = (char)('a' + G.nLabelDrive - 1);
        strcpy(drive + 1, ":\\");
        if (QCOND2)
            Info(slide, 0, ((char *)slide, "labelling %s %-22s\n", drive,
    3165:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    316b:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3171:	89 44 24 04          	mov    %eax,0x4(%esp)
    3175:	8b 44 24 20          	mov    0x20(%esp),%eax
    3179:	89 04 24             	mov    %eax,(%esp)
    317c:	8d bd dc 08 00 00    	lea    0x8dc(%ebp),%edi
    3182:	e8 00 00 00 00       	call   3187 <_mapname+0x7f7>
    3187:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    318b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    318f:	c7 44 24 04 5f 04 00 	movl   $0x45f,0x4(%esp)
    3196:	00 
    3197:	89 3c 24             	mov    %edi,(%esp)
    319a:	e8 00 00 00 00       	call   319f <_mapname+0x80f>
    319f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    31a6:	00 
    31a7:	89 44 24 08          	mov    %eax,0x8(%esp)
    31ab:	89 7c 24 04          	mov    %edi,0x4(%esp)
    31af:	89 2c 24             	mov    %ebp,(%esp)
    31b2:	ff d6                	call   *%esi
    31b4:	83 ec 10             	sub    $0x10,%esp
    31b7:	e9 1b fa ff ff       	jmp    2bd7 <_mapname+0x247>
    31bc:	8b 44 24 28          	mov    0x28(%esp),%eax
    31c0:	e9 3b fa ff ff       	jmp    2c00 <_mapname+0x270>

/*---------------------------------------------------------------------------
    Begin main loop through characters in filename.
  ---------------------------------------------------------------------------*/

    for (; (workch = (uch)*cp) != 0; INCSTR(cp)) {
    31c5:	31 ff                	xor    %edi,%edi
    31c7:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    31cb:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
    31d2:	00 
    31d3:	e9 36 f9 ff ff       	jmp    2b0e <_mapname+0x17e>
               flags set", so there is no need to change attributes unless
               one of the DOS style attribute flags is set. The readonly
               attribute need not be masked, since it does not prevent
               modifications in the new directory. */
            if(G.pInfo->file_attr & (0x7F & ~FILE_ATTRIBUTE_DIRECTORY)) {
                if (!SetFileAttributes(Ansi_Fname, G.pInfo->file_attr & 0x7F))
    31d8:	83 e0 7f             	and    $0x7f,%eax
    31db:	89 44 24 04          	mov    %eax,0x4(%esp)
    31df:	8b 44 24 20          	mov    0x20(%esp),%eax
    31e3:	89 04 24             	mov    %eax,(%esp)
    31e6:	e8 00 00 00 00       	call   31eb <_mapname+0x85b>
    31eb:	85 c0                	test   %eax,%eax
    31ed:	57                   	push   %edi
    31ee:	57                   	push   %edi
    31ef:	0f 85 db fe ff ff    	jne    30d0 <_mapname+0x740>
                    Info(slide, 1, ((char *)slide,
    31f5:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    31fb:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3201:	89 44 24 04          	mov    %eax,0x4(%esp)
    3205:	8b 44 24 20          	mov    0x20(%esp),%eax
    3209:	89 04 24             	mov    %eax,(%esp)
    320c:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    3212:	e8 00 00 00 00       	call   3217 <_mapname+0x887>
    3217:	89 c7                	mov    %eax,%edi
    3219:	e8 00 00 00 00       	call   321e <_mapname+0x88e>
    321e:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    3222:	89 44 24 08          	mov    %eax,0x8(%esp)
    3226:	c7 44 24 04 04 04 00 	movl   $0x404,0x4(%esp)
    322d:	00 
    322e:	89 1c 24             	mov    %ebx,(%esp)
    3231:	e8 00 00 00 00       	call   3236 <_mapname+0x8a6>
    3236:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    323d:	00 
    323e:	89 44 24 08          	mov    %eax,0x8(%esp)
    3242:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3246:	89 2c 24             	mov    %ebp,(%esp)
    3249:	ff d6                	call   *%esi
    324b:	83 ec 10             	sub    $0x10,%esp
    324e:	e9 7d fe ff ff       	jmp    30d0 <_mapname+0x740>
#       define Ansi_Fname  G.filename
#endif
        checkdir(__G__ G.filename, GETPATH);
        if (G.created_dir) {
            if (QCOND2) {
                Info(slide, 0, ((char *)slide, "   creating: %-22s\n",
    3253:	8d 85 dc 88 00 00    	lea    0x88dc(%ebp),%eax
    3259:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    325f:	89 44 24 04          	mov    %eax,0x4(%esp)
    3263:	8b 44 24 20          	mov    0x20(%esp),%eax
    3267:	89 04 24             	mov    %eax,(%esp)
    326a:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    3270:	e8 00 00 00 00       	call   3275 <_mapname+0x8e5>
    3275:	c7 44 24 04 ed 03 00 	movl   $0x3ed,0x4(%esp)
    327c:	00 
    327d:	89 44 24 08          	mov    %eax,0x8(%esp)
    3281:	89 1c 24             	mov    %ebx,(%esp)
    3284:	e8 00 00 00 00       	call   3289 <_mapname+0x8f9>
    3289:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3290:	00 
    3291:	89 44 24 08          	mov    %eax,0x8(%esp)
    3295:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3299:	89 2c 24             	mov    %ebp,(%esp)
    329c:	ff d6                	call   *%esi
    329e:	83 ec 10             	sub    $0x10,%esp
    32a1:	e9 19 fe ff ff       	jmp    30bf <_mapname+0x72f>
        strcpy(drive + 1, ":\\");
        if (QCOND2)
            Info(slide, 0, ((char *)slide, "labelling %s %-22s\n", drive,
              FnFilter1(G.filename)));
        if (!SetVolumeLabel(drive, Ansi_Fname)) {
            Info(slide, 1, ((char *)slide,
    32a6:	a0 74 04 00 00       	mov    0x474,%al
    32ab:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    32b1:	88 85 dc 08 00 00    	mov    %al,0x8dc(%ebp)
    32b7:	be 75 04 00 00       	mov    $0x475,%esi
    32bc:	b8 25 00 00 00       	mov    $0x25,%eax
    32c1:	e9 48 fe ff ff       	jmp    310e <_mapname+0x77e>
    32c6:	66 8b 0e             	mov    (%esi),%cx
    32c9:	83 c7 02             	add    $0x2,%edi
    32cc:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    32d0:	83 c6 02             	add    $0x2,%esi
    32d3:	83 e8 02             	sub    $0x2,%eax
    32d6:	e9 3f fe ff ff       	jmp    311a <_mapname+0x78a>
    32db:	90                   	nop
    32dc:	90                   	nop
    32dd:	90                   	nop
    32de:	90                   	nop
    32df:	90                   	nop

windll.o:     file format pe-i386


Disassembly of section .text:

00000000 <_DummySound@0>:
fNoPrinting = f;
}

/* Dummy sound function for those applications that don't use sound */
static void WINAPI DummySound(void)
{
   0:	c3                   	ret    
   1:	eb 0d                	jmp    10 <_DllMessagePrint@16>
   3:	90                   	nop
   4:	90                   	nop
   5:	90                   	nop
   6:	90                   	nop
   7:	90                   	nop
   8:	90                   	nop
   9:	90                   	nop
   a:	90                   	nop
   b:	90                   	nop
   c:	90                   	nop
   d:	90                   	nop
   e:	90                   	nop
   f:	90                   	nop

00000010 <_DllMessagePrint@16>:
static int UZ_EXP DllMessagePrint(pG, buf, size, flag)
    zvoid *pG;      /* globals struct:  always passed */
    uch *buf;       /* preformatted string to be printed */
    ulg size;       /* length of string (may include nulls) */
    int flag;       /* flag bits */
{
  10:	83 ec 1c             	sub    $0x1c,%esp
if (!fNoPrinting)
  13:	8b 0d 00 00 00 00    	mov    0x0,%ecx
   return G.lpUserFunctions->print((LPSTR)buf, size);
else
   return (int)size;
  19:	8b 44 24 28          	mov    0x28(%esp),%eax
    zvoid *pG;      /* globals struct:  always passed */
    uch *buf;       /* preformatted string to be printed */
    ulg size;       /* length of string (may include nulls) */
    int flag;       /* flag bits */
{
if (!fNoPrinting)
  1d:	85 c9                	test   %ecx,%ecx
  1f:	74 06                	je     27 <_DllMessagePrint@16+0x17>
   return G.lpUserFunctions->print((LPSTR)buf, size);
else
   return (int)size;
}
  21:	83 c4 1c             	add    $0x1c,%esp
  24:	c2 10 00             	ret    $0x10
    uch *buf;       /* preformatted string to be printed */
    ulg size;       /* length of string (may include nulls) */
    int flag;       /* flag bits */
{
if (!fNoPrinting)
   return G.lpUserFunctions->print((LPSTR)buf, size);
  27:	8b 54 24 20          	mov    0x20(%esp),%edx
  2b:	8b 92 58 0b 01 00    	mov    0x10b58(%edx),%edx
  31:	89 44 24 04          	mov    %eax,0x4(%esp)
  35:	8b 44 24 24          	mov    0x24(%esp),%eax
  39:	89 04 24             	mov    %eax,(%esp)
  3c:	ff 12                	call   *(%edx)
  3e:	52                   	push   %edx
  3f:	52                   	push   %edx
else
   return (int)size;
}
  40:	83 c4 1c             	add    $0x1c,%esp
  43:	c2 10 00             	ret    $0x10
  46:	8d 76 00             	lea    0x0(%esi),%esi
  49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000050 <_Wiz_StatReportCB@20>:
#ifdef __BORLANDC__
#pragma argsused
#endif
static int WINAPI Wiz_StatReportCB(zvoid *pG, int fnflag, ZCONST char *zfn,
                    ZCONST char *efn, ZCONST zvoid *details)
{
  50:	83 ec 1c             	sub    $0x1c,%esp
    int rval = UZ_ST_CONTINUE;

    switch (fnflag) {
  53:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
  58:	74 4e                	je     a8 <_Wiz_StatReportCB@20+0x58>
  5a:	83 7c 24 24 03       	cmpl   $0x3,0x24(%esp)
  5f:	75 3f                	jne    a0 <_Wiz_StatReportCB@20+0x50>
      case UZ_ST_START_EXTRACT:
        if (G.lpUserFunctions->sound != NULL)
            (*G.lpUserFunctions->sound)();
        break;
      case UZ_ST_FINISH_MEMBER:
        if ((G.lpUserFunctions->ServCallBk != NULL) &&
  61:	8b 44 24 20          	mov    0x20(%esp),%eax
  65:	8b 80 58 0b 01 00    	mov    0x10b58(%eax),%eax
  6b:	8b 40 14             	mov    0x14(%eax),%eax
  6e:	85 c0                	test   %eax,%eax
  70:	74 2e                	je     a0 <_Wiz_StatReportCB@20+0x50>
            (*G.lpUserFunctions->ServCallBk)(efn,
  72:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  76:	85 c9                	test   %ecx,%ecx
  78:	74 49                	je     c3 <_Wiz_StatReportCB@20+0x73>
  7a:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  7e:	8b 11                	mov    (%ecx),%edx
  80:	89 54 24 04          	mov    %edx,0x4(%esp)
  84:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  88:	89 14 24             	mov    %edx,(%esp)
  8b:	ff d0                	call   *%eax
      case UZ_ST_START_EXTRACT:
        if (G.lpUserFunctions->sound != NULL)
            (*G.lpUserFunctions->sound)();
        break;
      case UZ_ST_FINISH_MEMBER:
        if ((G.lpUserFunctions->ServCallBk != NULL) &&
  8d:	85 c0                	test   %eax,%eax
            (*G.lpUserFunctions->ServCallBk)(efn,
  8f:	52                   	push   %edx
  90:	52                   	push   %edx
#pragma argsused
#endif
static int WINAPI Wiz_StatReportCB(zvoid *pG, int fnflag, ZCONST char *zfn,
                    ZCONST char *efn, ZCONST zvoid *details)
{
    int rval = UZ_ST_CONTINUE;
  91:	0f 95 c0             	setne  %al
  94:	25 ff 00 00 00       	and    $0xff,%eax
        break;
      default:
        break;
    }
    return rval;
}
  99:	83 c4 1c             	add    $0x1c,%esp
  9c:	c2 14 00             	ret    $0x14
  9f:	90                   	nop
#pragma argsused
#endif
static int WINAPI Wiz_StatReportCB(zvoid *pG, int fnflag, ZCONST char *zfn,
                    ZCONST char *efn, ZCONST zvoid *details)
{
    int rval = UZ_ST_CONTINUE;
  a0:	31 c0                	xor    %eax,%eax
        break;
      default:
        break;
    }
    return rval;
}
  a2:	83 c4 1c             	add    $0x1c,%esp
  a5:	c2 14 00             	ret    $0x14
{
    int rval = UZ_ST_CONTINUE;

    switch (fnflag) {
      case UZ_ST_START_EXTRACT:
        if (G.lpUserFunctions->sound != NULL)
  a8:	8b 44 24 20          	mov    0x20(%esp),%eax
  ac:	8b 80 58 0b 01 00    	mov    0x10b58(%eax),%eax
  b2:	8b 40 04             	mov    0x4(%eax),%eax
  b5:	85 c0                	test   %eax,%eax
  b7:	74 e7                	je     a0 <_Wiz_StatReportCB@20+0x50>
            (*G.lpUserFunctions->sound)();
  b9:	ff d0                	call   *%eax
#pragma argsused
#endif
static int WINAPI Wiz_StatReportCB(zvoid *pG, int fnflag, ZCONST char *zfn,
                    ZCONST char *efn, ZCONST zvoid *details)
{
    int rval = UZ_ST_CONTINUE;
  bb:	31 c0                	xor    %eax,%eax
        break;
      default:
        break;
    }
    return rval;
}
  bd:	83 c4 1c             	add    $0x1c,%esp
  c0:	c2 14 00             	ret    $0x14
        if (G.lpUserFunctions->sound != NULL)
            (*G.lpUserFunctions->sound)();
        break;
      case UZ_ST_FINISH_MEMBER:
        if ((G.lpUserFunctions->ServCallBk != NULL) &&
            (*G.lpUserFunctions->ServCallBk)(efn,
  c3:	31 d2                	xor    %edx,%edx
  c5:	eb b9                	jmp    80 <_Wiz_StatReportCB@20+0x30>
  c7:	89 f6                	mov    %esi,%esi
  c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000000d0 <_FreeDllMem.isra.2>:
    _ISO_INTERN(G.wildzipfn);

    return TRUE;    /* set up was OK */
}

static void FreeDllMem(__GPRO)
  d0:	53                   	push   %ebx
  d1:	89 c3                	mov    %eax,%ebx
  d3:	83 ec 28             	sub    $0x28,%esp
{
    if (G.wildzipfn) {
  d6:	8b 02                	mov    (%edx),%eax
  d8:	85 c0                	test   %eax,%eax
  da:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  de:	74 18                	je     f8 <_FreeDllMem.isra.2+0x28>
        GlobalUnlock(hwildZipFN);
  e0:	a1 00 00 00 00       	mov    0x0,%eax
  e5:	89 04 24             	mov    %eax,(%esp)
  e8:	e8 00 00 00 00       	call   ed <_FreeDllMem.isra.2+0x1d>
  ed:	51                   	push   %ecx
        G.wildzipfn = NULL;
  ee:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  f2:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    }
    if (hwildZipFN)
  f8:	8b 15 00 00 00 00    	mov    0x0,%edx
  fe:	85 d2                	test   %edx,%edx
 100:	74 0e                	je     110 <_FreeDllMem.isra.2+0x40>
        hwildZipFN = GlobalFree(hwildZipFN);
 102:	89 14 24             	mov    %edx,(%esp)
 105:	e8 00 00 00 00       	call   10a <_FreeDllMem.isra.2+0x3a>
 10a:	a3 00 00 00 00       	mov    %eax,0x0
 10f:	52                   	push   %edx

    uO.zipinfo_mode = FALSE;
 110:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
 116:	83 c4 28             	add    $0x28,%esp
 119:	5b                   	pop    %ebx
 11a:	c3                   	ret    
 11b:	90                   	nop
 11c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000120 <_Wiz_Init@8>:
/* DLL calls */

BOOL WINAPI Wiz_Init(pG, lpUserFunc)
zvoid *pG;
LPUSERFUNCTIONS lpUserFunc;
{
 120:	53                   	push   %ebx
 121:	83 ec 18             	sub    $0x18,%esp
 124:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 128:	8b 44 24 24          	mov    0x24(%esp),%eax
G.message = DllMessagePrint;
 12c:	c7 83 44 0b 01 00 10 	movl   $0x10,0x10b44(%ebx)
 133:	00 00 00 
G.statreportcb = Wiz_StatReportCB;
 136:	c7 83 54 0b 01 00 50 	movl   $0x50,0x10b54(%ebx)
 13d:	00 00 00 
if (lpUserFunc->sound == NULL)
 140:	8b 50 04             	mov    0x4(%eax),%edx
 143:	85 d2                	test   %edx,%edx
 145:	74 4a                	je     191 <_Wiz_Init@8+0x71>
   lpUserFunc->sound = DummySound;
G.lpUserFunctions = lpUserFunc;
 147:	89 83 58 0b 01 00    	mov    %eax,0x10b58(%ebx)

SETLOCALE(LC_CTYPE, "");
 14d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 154:	00 
 155:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 15c:	e8 00 00 00 00       	call   161 <_Wiz_Init@8+0x41>

if (!G.lpUserFunctions->print ||
 161:	8b 83 58 0b 01 00    	mov    0x10b58(%ebx),%eax
 167:	8b 08                	mov    (%eax),%ecx
 169:	85 c9                	test   %ecx,%ecx
 16b:	74 1b                	je     188 <_Wiz_Init@8+0x68>
 16d:	8b 50 04             	mov    0x4(%eax),%edx
 170:	85 d2                	test   %edx,%edx
 172:	74 14                	je     188 <_Wiz_Init@8+0x68>
    !G.lpUserFunctions->sound ||
 174:	8b 40 08             	mov    0x8(%eax),%eax
 177:	85 c0                	test   %eax,%eax
    !G.lpUserFunctions->replace)
    return FALSE;
 179:	0f 95 c0             	setne  %al

return TRUE;
}
 17c:	83 c4 18             	add    $0x18,%esp
SETLOCALE(LC_CTYPE, "");

if (!G.lpUserFunctions->print ||
    !G.lpUserFunctions->sound ||
    !G.lpUserFunctions->replace)
    return FALSE;
 17f:	25 ff 00 00 00       	and    $0xff,%eax

return TRUE;
}
 184:	5b                   	pop    %ebx
 185:	c2 08 00             	ret    $0x8
 188:	83 c4 18             	add    $0x18,%esp
SETLOCALE(LC_CTYPE, "");

if (!G.lpUserFunctions->print ||
    !G.lpUserFunctions->sound ||
    !G.lpUserFunctions->replace)
    return FALSE;
 18b:	31 c0                	xor    %eax,%eax

return TRUE;
}
 18d:	5b                   	pop    %ebx
 18e:	c2 08 00             	ret    $0x8
LPUSERFUNCTIONS lpUserFunc;
{
G.message = DllMessagePrint;
G.statreportcb = Wiz_StatReportCB;
if (lpUserFunc->sound == NULL)
   lpUserFunc->sound = DummySound;
 191:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 198:	eb ad                	jmp    147 <_Wiz_Init@8+0x27>
 19a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000001a0 <_Wiz_SetOpts@8>:
 */

BOOL WINAPI Wiz_SetOpts(pG, lpDCL)
zvoid *pG;
LPDCL lpDCL;
{
 1a0:	56                   	push   %esi
 1a1:	53                   	push   %ebx
 1a2:	83 ec 14             	sub    $0x14,%esp
    uO.qflag = lpDCL->fQuiet;  /* Quiet flag */
    G.pfnames = (char **)&fnames[0];    /* assign default file name vector */
    G.pxnames = (char **)&fnames[1];

    uO.jflag = (lpDCL->ndflag == 0);
 1a5:	31 d2                	xor    %edx,%edx
 */

BOOL WINAPI Wiz_SetOpts(pG, lpDCL)
zvoid *pG;
LPDCL lpDCL;
{
 1a7:	8b 74 24 24          	mov    0x24(%esp),%esi
 1ab:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    uO.qflag = lpDCL->fQuiet;  /* Quiet flag */
 1af:	8b 46 0c             	mov    0xc(%esi),%eax
    G.pfnames = (char **)&fnames[0];    /* assign default file name vector */
 1b2:	c7 83 c0 00 00 00 00 	movl   $0x0,0xc0(%ebx)
 1b9:	00 00 00 

BOOL WINAPI Wiz_SetOpts(pG, lpDCL)
zvoid *pG;
LPDCL lpDCL;
{
    uO.qflag = lpDCL->fQuiet;  /* Quiet flag */
 1bc:	89 43 38             	mov    %eax,0x38(%ebx)
    G.pfnames = (char **)&fnames[0];    /* assign default file name vector */
    G.pxnames = (char **)&fnames[1];

    uO.jflag = (lpDCL->ndflag == 0);
 1bf:	8b 46 24             	mov    0x24(%esi),%eax
 1c2:	85 c0                	test   %eax,%eax
zvoid *pG;
LPDCL lpDCL;
{
    uO.qflag = lpDCL->fQuiet;  /* Quiet flag */
    G.pfnames = (char **)&fnames[0];    /* assign default file name vector */
    G.pxnames = (char **)&fnames[1];
 1c4:	c7 83 c4 00 00 00 04 	movl   $0x4,0xc4(%ebx)
 1cb:	00 00 00 

    uO.jflag = (lpDCL->ndflag == 0);
 1ce:	0f 94 c2             	sete   %dl
    uO.ddotflag = (lpDCL->ndflag >= 2);
 1d1:	48                   	dec    %eax
{
    uO.qflag = lpDCL->fQuiet;  /* Quiet flag */
    G.pfnames = (char **)&fnames[0];    /* assign default file name vector */
    G.pxnames = (char **)&fnames[1];

    uO.jflag = (lpDCL->ndflag == 0);
 1d2:	89 53 24             	mov    %edx,0x24(%ebx)
    uO.ddotflag = (lpDCL->ndflag >= 2);
 1d5:	0f 9f c0             	setg   %al
 1d8:	25 ff 00 00 00       	and    $0xff,%eax
    uO.cflag = lpDCL->ncflag;
 1dd:	8b 56 10             	mov    0x10(%esi),%edx
    uO.qflag = lpDCL->fQuiet;  /* Quiet flag */
    G.pfnames = (char **)&fnames[0];    /* assign default file name vector */
    G.pxnames = (char **)&fnames[1];

    uO.jflag = (lpDCL->ndflag == 0);
    uO.ddotflag = (lpDCL->ndflag >= 2);
 1e0:	89 43 64             	mov    %eax,0x64(%ebx)
    uO.cflag = lpDCL->ncflag;
    uO.tflag = lpDCL->ntflag;
 1e3:	8b 46 14             	mov    0x14(%esi),%eax
 1e6:	89 43 44             	mov    %eax,0x44(%ebx)
    uO.vflag = lpDCL->nvflag;
 1e9:	8b 46 18             	mov    0x18(%esi),%eax
 1ec:	89 43 50             	mov    %eax,0x50(%ebx)
    uO.zflag = lpDCL->nzflag;
 1ef:	8b 46 20             	mov    0x20(%esi),%eax
 1f2:	89 43 60             	mov    %eax,0x60(%ebx)
    uO.aflag = lpDCL->naflag;
 1f5:	8b 46 2c             	mov    0x2c(%esi),%eax
 1f8:	89 43 10             	mov    %eax,0x10(%ebx)
    uO.C_flag = lpDCL->C_flag;
 1fb:	8b 46 34             	mov    0x34(%esi),%eax
 1fe:	89 43 18             	mov    %eax,0x18(%ebx)
    uO.overwrite_all = lpDCL->noflag;
 201:	8b 46 28             	mov    0x28(%esi),%eax
    uO.overwrite_none = !(lpDCL->noflag || lpDCL->PromptToOverwrite);
 204:	31 c9                	xor    %ecx,%ecx
    G.pfnames = (char **)&fnames[0];    /* assign default file name vector */
    G.pxnames = (char **)&fnames[1];

    uO.jflag = (lpDCL->ndflag == 0);
    uO.ddotflag = (lpDCL->ndflag >= 2);
    uO.cflag = lpDCL->ncflag;
 206:	89 53 14             	mov    %edx,0x14(%ebx)
    uO.tflag = lpDCL->ntflag;
    uO.vflag = lpDCL->nvflag;
    uO.zflag = lpDCL->nzflag;
    uO.aflag = lpDCL->naflag;
    uO.C_flag = lpDCL->C_flag;
    uO.overwrite_all = lpDCL->noflag;
 209:	89 43 34             	mov    %eax,0x34(%ebx)
    uO.overwrite_none = !(lpDCL->noflag || lpDCL->PromptToOverwrite);
 20c:	85 c0                	test   %eax,%eax
 20e:	75 0a                	jne    21a <_Wiz_SetOpts@8+0x7a>
 210:	31 c9                	xor    %ecx,%ecx
 212:	8b 46 08             	mov    0x8(%esi),%eax
 215:	85 c0                	test   %eax,%eax
 217:	0f 94 c1             	sete   %cl
    uO.uflag = lpDCL->ExtractOnlyNewer || lpDCL->nfflag;
 21a:	8b 06                	mov    (%esi),%eax
    uO.vflag = lpDCL->nvflag;
    uO.zflag = lpDCL->nzflag;
    uO.aflag = lpDCL->naflag;
    uO.C_flag = lpDCL->C_flag;
    uO.overwrite_all = lpDCL->noflag;
    uO.overwrite_none = !(lpDCL->noflag || lpDCL->PromptToOverwrite);
 21c:	89 4b 30             	mov    %ecx,0x30(%ebx)
    uO.uflag = lpDCL->ExtractOnlyNewer || lpDCL->nfflag;
 21f:	85 c0                	test   %eax,%eax
 221:	8b 46 1c             	mov    0x1c(%esi),%eax
 224:	0f 84 a6 00 00 00    	je     2d0 <_Wiz_SetOpts@8+0x130>
 22a:	b9 01 00 00 00       	mov    $0x1,%ecx
    uO.fflag = lpDCL->nfflag;
 22f:	89 43 1c             	mov    %eax,0x1c(%ebx)
#ifdef WIN32
    uO.X_flag = lpDCL->fPrivilege;
 232:	8b 46 38             	mov    0x38(%esi),%eax
 235:	89 43 5c             	mov    %eax,0x5c(%ebx)
#endif
    uO.sflag = lpDCL->SpaceToUnderscore; /* Translate spaces to underscores? */
 238:	8b 46 04             	mov    0x4(%esi),%eax
 23b:	89 43 3c             	mov    %eax,0x3c(%ebx)
    if (lpDCL->nZIflag)
 23e:	8b 46 30             	mov    0x30(%esi),%eax
    uO.zflag = lpDCL->nzflag;
    uO.aflag = lpDCL->naflag;
    uO.C_flag = lpDCL->C_flag;
    uO.overwrite_all = lpDCL->noflag;
    uO.overwrite_none = !(lpDCL->noflag || lpDCL->PromptToOverwrite);
    uO.uflag = lpDCL->ExtractOnlyNewer || lpDCL->nfflag;
 241:	89 4b 4c             	mov    %ecx,0x4c(%ebx)
    uO.fflag = lpDCL->nfflag;
#ifdef WIN32
    uO.X_flag = lpDCL->fPrivilege;
#endif
    uO.sflag = lpDCL->SpaceToUnderscore; /* Translate spaces to underscores? */
    if (lpDCL->nZIflag)
 244:	85 c0                	test   %eax,%eax
 246:	0f 84 94 00 00 00    	je     2e0 <_Wiz_SetOpts@8+0x140>
      {
      uO.zipinfo_mode = TRUE;
 24c:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
      uO.hflag = TRUE;
 253:	c7 43 20 01 00 00 00 	movl   $0x1,0x20(%ebx)
      uO.lflag = 10;
 25a:	c7 43 28 0a 00 00 00 	movl   $0xa,0x28(%ebx)
      uO.qflag = 2;
 261:	c7 43 38 02 00 00 00 	movl   $0x2,0x38(%ebx)
    else
      {
      uO.zipinfo_mode = FALSE;
      }

    G.extract_flag = (!uO.zipinfo_mode &&
 268:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
 26f:	00 00 00 
#endif
       uO.exdir = pExDirRoot;
       }
    else
       {
       uO.exdir = (char *)NULL;
 272:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
       }

/* G.wildzipfn needs to be initialized so that do_wild does not wind
   up clearing out the zip file name when it returns in process.c
*/
    hwildZipFN = GlobalAlloc(GPTR, FILNAMSIZ);
 279:	c7 44 24 04 04 01 00 	movl   $0x104,0x4(%esp)
 280:	00 
 281:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
 288:	e8 00 00 00 00       	call   28d <_Wiz_SetOpts@8+0xed>
 28d:	a3 00 00 00 00       	mov    %eax,0x0
    if (hwildZipFN == (HGLOBAL) NULL)
 292:	85 c0                	test   %eax,%eax
       }

/* G.wildzipfn needs to be initialized so that do_wild does not wind
   up clearing out the zip file name when it returns in process.c
*/
    hwildZipFN = GlobalAlloc(GPTR, FILNAMSIZ);
 294:	52                   	push   %edx
 295:	52                   	push   %edx
    if (hwildZipFN == (HGLOBAL) NULL)
 296:	0f 84 9c 00 00 00    	je     338 <_Wiz_SetOpts@8+0x198>
       return FALSE;

    G.wildzipfn = GlobalLock(hwildZipFN);
 29c:	89 04 24             	mov    %eax,(%esp)
 29f:	e8 00 00 00 00       	call   2a4 <_Wiz_SetOpts@8+0x104>
 2a4:	52                   	push   %edx
 2a5:	89 83 00 09 01 00    	mov    %eax,0x10900(%ebx)
    lstrcpy(G.wildzipfn, lpDCL->lpszZipFN);
 2ab:	8b 56 3c             	mov    0x3c(%esi),%edx
 2ae:	89 04 24             	mov    %eax,(%esp)
 2b1:	89 54 24 04          	mov    %edx,0x4(%esp)
 2b5:	e8 00 00 00 00       	call   2ba <_Wiz_SetOpts@8+0x11a>
    _ISO_INTERN(G.wildzipfn);

    return TRUE;    /* set up was OK */
 2ba:	b8 01 00 00 00       	mov    $0x1,%eax
    hwildZipFN = GlobalAlloc(GPTR, FILNAMSIZ);
    if (hwildZipFN == (HGLOBAL) NULL)
       return FALSE;

    G.wildzipfn = GlobalLock(hwildZipFN);
    lstrcpy(G.wildzipfn, lpDCL->lpszZipFN);
 2bf:	51                   	push   %ecx
 2c0:	51                   	push   %ecx
    _ISO_INTERN(G.wildzipfn);

    return TRUE;    /* set up was OK */
}
 2c1:	83 c4 14             	add    $0x14,%esp
 2c4:	5b                   	pop    %ebx
 2c5:	5e                   	pop    %esi
 2c6:	c2 08 00             	ret    $0x8
 2c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    uO.zflag = lpDCL->nzflag;
    uO.aflag = lpDCL->naflag;
    uO.C_flag = lpDCL->C_flag;
    uO.overwrite_all = lpDCL->noflag;
    uO.overwrite_none = !(lpDCL->noflag || lpDCL->PromptToOverwrite);
    uO.uflag = lpDCL->ExtractOnlyNewer || lpDCL->nfflag;
 2d0:	31 c9                	xor    %ecx,%ecx
 2d2:	85 c0                	test   %eax,%eax
 2d4:	0f 95 c1             	setne  %cl
 2d7:	e9 53 ff ff ff       	jmp    22f <_Wiz_SetOpts@8+0x8f>
 2dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
      uO.lflag = 10;
      uO.qflag = 2;
      }
    else
      {
      uO.zipinfo_mode = FALSE;
 2e0:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      }

    G.extract_flag = (!uO.zipinfo_mode &&
 2e7:	85 d2                	test   %edx,%edx
 2e9:	0f 85 79 ff ff ff    	jne    268 <_Wiz_SetOpts@8+0xc8>
                      !uO.cflag && !uO.tflag && !uO.vflag && !uO.zflag
 2ef:	8b 43 44             	mov    0x44(%ebx),%eax
 2f2:	85 c0                	test   %eax,%eax
 2f4:	0f 85 6e ff ff ff    	jne    268 <_Wiz_SetOpts@8+0xc8>
 2fa:	8b 43 50             	mov    0x50(%ebx),%eax
 2fd:	85 c0                	test   %eax,%eax
 2ff:	0f 85 63 ff ff ff    	jne    268 <_Wiz_SetOpts@8+0xc8>
 305:	8b 43 60             	mov    0x60(%ebx),%eax
 308:	85 c0                	test   %eax,%eax
 30a:	0f 85 58 ff ff ff    	jne    268 <_Wiz_SetOpts@8+0xc8>
#ifdef TIMESTAMP
                      && !uO.T_flag
 310:	8b 4b 48             	mov    0x48(%ebx),%ecx
 313:	85 c9                	test   %ecx,%ecx
 315:	0f 85 4d ff ff ff    	jne    268 <_Wiz_SetOpts@8+0xc8>
#endif
                     );

    if (lpDCL->lpszExtractDir != NULL && G.extract_flag)
 31b:	8b 46 40             	mov    0x40(%esi),%eax
    else
      {
      uO.zipinfo_mode = FALSE;
      }

    G.extract_flag = (!uO.zipinfo_mode &&
 31e:	c7 83 80 00 00 00 01 	movl   $0x1,0x80(%ebx)
 325:	00 00 00 
#ifdef TIMESTAMP
                      && !uO.T_flag
#endif
                     );

    if (lpDCL->lpszExtractDir != NULL && G.extract_flag)
 328:	85 c0                	test   %eax,%eax
 32a:	0f 84 42 ff ff ff    	je     272 <_Wiz_SetOpts@8+0xd2>
           return FALSE;
       ISO_TO_INTERN(lpDCL->lpszExtractDir, pExDirRoot);
#else
#  define pExDirRoot lpDCL->lpszExtractDir
#endif
       uO.exdir = pExDirRoot;
 330:	89 43 04             	mov    %eax,0x4(%ebx)
 333:	e9 41 ff ff ff       	jmp    279 <_Wiz_SetOpts@8+0xd9>
    G.wildzipfn = GlobalLock(hwildZipFN);
    lstrcpy(G.wildzipfn, lpDCL->lpszZipFN);
    _ISO_INTERN(G.wildzipfn);

    return TRUE;    /* set up was OK */
}
 338:	83 c4 14             	add    $0x14,%esp
/* G.wildzipfn needs to be initialized so that do_wild does not wind
   up clearing out the zip file name when it returns in process.c
*/
    hwildZipFN = GlobalAlloc(GPTR, FILNAMSIZ);
    if (hwildZipFN == (HGLOBAL) NULL)
       return FALSE;
 33b:	31 c0                	xor    %eax,%eax
    G.wildzipfn = GlobalLock(hwildZipFN);
    lstrcpy(G.wildzipfn, lpDCL->lpszZipFN);
    _ISO_INTERN(G.wildzipfn);

    return TRUE;    /* set up was OK */
}
 33d:	5b                   	pop    %ebx
 33e:	5e                   	pop    %esi
 33f:	c2 08 00             	ret    $0x8
 342:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 349:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000350 <_Wiz_Unzip@20>:
zvoid *pG;
int ifnc;
char **ifnv;
int xfnc;
char **xfnv;
{
 350:	55                   	push   %ebp
 351:	89 e5                	mov    %esp,%ebp
 353:	57                   	push   %edi
 354:	56                   	push   %esi
 355:	53                   	push   %ebx
 356:	83 ec 2c             	sub    $0x2c,%esp
 359:	8b 75 10             	mov    0x10(%ebp),%esi
 35c:	8b 55 0c             	mov    0xc(%ebp),%edx
 35f:	8b 4d 14             	mov    0x14(%ebp),%ecx
 362:	8b 5d 18             	mov    0x18(%ebp),%ebx
int retcode, f_cnt;
#ifndef CRTL_CP_IS_ISO
char **intern_ifv = NULL, **intern_xfv = NULL;
#endif

if (ifnv == (char **)NULL && ifnc != 0)
 365:	85 f6                	test   %esi,%esi
 367:	75 3e                	jne    3a7 <_Wiz_Unzip@20+0x57>
 369:	85 d2                	test   %edx,%edx
 36b:	74 3a                	je     3a7 <_Wiz_Unzip@20+0x57>
 36d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ifnc = 0;
 374:	31 c0                	xor    %eax,%eax
    for (f_cnt = 0; f_cnt < ifnc; f_cnt++)
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
 376:	85 db                	test   %ebx,%ebx
 378:	0f 85 d2 00 00 00    	jne    450 <_Wiz_Unzip@20+0x100>
 37e:	85 c9                	test   %ecx,%ecx
 380:	0f 84 ca 00 00 00    	je     450 <_Wiz_Unzip@20+0x100>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 386:	8b 7d 08             	mov    0x8(%ebp),%edi
 389:	85 c0                	test   %eax,%eax
 38b:	0f 94 c0             	sete   %al
 38e:	25 ff 00 00 00       	and    $0xff,%eax
 393:	89 47 74             	mov    %eax,0x74(%edi)
G.filespecs = ifnc;
 396:	89 f8                	mov    %edi,%eax
 398:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 39b:	89 78 6c             	mov    %edi,0x6c(%eax)
G.xfilespecs = xfnc;
 39e:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
 3a5:	eb 6f                	jmp    416 <_Wiz_Unzip@20+0xc6>
#endif

if (ifnv == (char **)NULL && ifnc != 0)
    ifnc = 0;
else
    for (f_cnt = 0; f_cnt < ifnc; f_cnt++)
 3a7:	85 d2                	test   %edx,%edx
 3a9:	0f 8e e6 01 00 00    	jle    595 <_Wiz_Unzip@20+0x245>
        if (ifnv[f_cnt] == (char *)NULL) {
 3af:	8b 06                	mov    (%esi),%eax
 3b1:	85 c0                	test   %eax,%eax
 3b3:	0f 84 0f 02 00 00    	je     5c8 <_Wiz_Unzip@20+0x278>
 3b9:	31 c0                	xor    %eax,%eax
 3bb:	eb 11                	jmp    3ce <_Wiz_Unzip@20+0x7e>
 3bd:	8d 76 00             	lea    0x0(%esi),%esi
 3c0:	8b 3c 86             	mov    (%esi,%eax,4),%edi
 3c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 3c6:	85 ff                	test   %edi,%edi
 3c8:	0f 84 fa 00 00 00    	je     4c8 <_Wiz_Unzip@20+0x178>
#endif

if (ifnv == (char **)NULL && ifnc != 0)
    ifnc = 0;
else
    for (f_cnt = 0; f_cnt < ifnc; f_cnt++)
 3ce:	40                   	inc    %eax
 3cf:	39 d0                	cmp    %edx,%eax
 3d1:	75 ed                	jne    3c0 <_Wiz_Unzip@20+0x70>
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
 3d3:	85 db                	test   %ebx,%ebx
 3d5:	0f 85 85 01 00 00    	jne    560 <_Wiz_Unzip@20+0x210>
 3db:	85 c9                	test   %ecx,%ecx
 3dd:	0f 84 7d 01 00 00    	je     560 <_Wiz_Unzip@20+0x210>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 3e3:	8b 7d 08             	mov    0x8(%ebp),%edi
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
 3e6:	31 d2                	xor    %edx,%edx
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 3e8:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
G.filespecs = ifnc;
 3ef:	89 47 6c             	mov    %eax,0x6c(%edi)
G.xfilespecs = xfnc;
 3f2:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
 3f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

if (ifnc > 0) {
#ifdef CRTL_CP_IS_ISO
    G.pfnames = ifnv;
 400:	8b 45 08             	mov    0x8(%ebp),%eax
 403:	89 b0 c0 00 00 00    	mov    %esi,0xc0(%eax)
    intern_ifv[ifnc] = (char *)NULL;
    G.pfnames = intern_ifv;
#endif /* ?CRTL_CP_IS_ISO */
    }

if (xfnc > 0) {
 409:	85 d2                	test   %edx,%edx
 40b:	7e 09                	jle    416 <_Wiz_Unzip@20+0xc6>
#ifdef CRTL_CP_IS_ISO
    G.pxnames = xfnv;
 40d:	8b 45 08             	mov    0x8(%ebp),%eax
 410:	89 98 c4 00 00 00    	mov    %ebx,0xc4(%eax)

/*---------------------------------------------------------------------------
    Okey dokey, we have everything we need to get started.  Let's roll.
  ---------------------------------------------------------------------------*/

retcode = setjmp(dll_error_return);
 416:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 41d:	e8 00 00 00 00       	call   422 <_Wiz_Unzip@20+0xd2>
if (retcode)
 422:	85 c0                	test   %eax,%eax
 424:	8b 45 08             	mov    0x8(%ebp),%eax
 427:	74 78                	je     4a1 <_Wiz_Unzip@20+0x151>
 429:	8d 90 00 09 01 00    	lea    0x10900(%eax),%edx
 42f:	83 c0 0c             	add    $0xc,%eax
      {
      free(intern_ifv[0]);
      free(intern_ifv);
      }
#endif
   FreeDllMem(__G);
 432:	e8 99 fc ff ff       	call   d0 <_FreeDllMem.isra.2>
   free(intern_ifv);
   }
#endif
FreeDllMem(__G);
return retcode;
}
 437:	83 c4 2c             	add    $0x2c,%esp
      free(intern_ifv[0]);
      free(intern_ifv);
      }
#endif
   FreeDllMem(__G);
   return PK_BADERR;
 43a:	b8 03 00 00 00       	mov    $0x3,%eax
   free(intern_ifv);
   }
#endif
FreeDllMem(__G);
return retcode;
}
 43f:	5b                   	pop    %ebx
 440:	5e                   	pop    %esi
 441:	5f                   	pop    %edi
 442:	5d                   	pop    %ebp
 443:	c2 14 00             	ret    $0x14
    for (f_cnt = 0; f_cnt < ifnc; f_cnt++)
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
 446:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 44d:	31 c0                	xor    %eax,%eax
 44f:	90                   	nop
    xfnc = 0;
else
    for (f_cnt = 0; f_cnt < xfnc; f_cnt++)
 450:	85 c9                	test   %ecx,%ecx
 452:	0f 8e bc 01 00 00    	jle    614 <_Wiz_Unzip@20+0x2c4>
        if (xfnv[f_cnt] == (char *)NULL) {
 458:	8b 13                	mov    (%ebx),%edx
 45a:	85 d2                	test   %edx,%edx
 45c:	0f 84 3d 01 00 00    	je     59f <_Wiz_Unzip@20+0x24f>

if (ifnv == (char **)NULL && ifnc != 0)
    ifnc = 0;
else
    for (f_cnt = 0; f_cnt < ifnc; f_cnt++)
        if (ifnv[f_cnt] == (char *)NULL) {
 462:	31 d2                	xor    %edx,%edx
 464:	eb 0b                	jmp    471 <_Wiz_Unzip@20+0x121>
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
else
    for (f_cnt = 0; f_cnt < xfnc; f_cnt++)
        if (xfnv[f_cnt] == (char *)NULL) {
 466:	8b 3c 93             	mov    (%ebx,%edx,4),%edi
 469:	85 ff                	test   %edi,%edi
 46b:	0f 84 bf 00 00 00    	je     530 <_Wiz_Unzip@20+0x1e0>
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
else
    for (f_cnt = 0; f_cnt < xfnc; f_cnt++)
 471:	42                   	inc    %edx
 472:	39 ca                	cmp    %ecx,%edx
 474:	75 f0                	jne    466 <_Wiz_Unzip@20+0x116>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 476:	89 c7                	mov    %eax,%edi
 478:	09 cf                	or     %ecx,%edi
 47a:	8b 7d 08             	mov    0x8(%ebp),%edi
 47d:	0f 94 c2             	sete   %dl
 480:	81 e2 ff 00 00 00    	and    $0xff,%edx
G.filespecs = ifnc;
G.xfilespecs = xfnc;
 486:	89 4f 70             	mov    %ecx,0x70(%edi)
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 489:	89 57 74             	mov    %edx,0x74(%edi)
G.filespecs = ifnc;
 48c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 48f:	89 57 6c             	mov    %edx,0x6c(%edi)
G.xfilespecs = xfnc;

if (ifnc > 0) {
 492:	85 c0                	test   %eax,%eax
 494:	0f 8e 73 ff ff ff    	jle    40d <_Wiz_Unzip@20+0xbd>
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
 49a:	89 ca                	mov    %ecx,%edx
 49c:	e9 5f ff ff ff       	jmp    400 <_Wiz_Unzip@20+0xb0>
#endif
   FreeDllMem(__G);
   return PK_BADERR;
   }

retcode = process_zipfiles(__G);
 4a1:	89 04 24             	mov    %eax,(%esp)
 4a4:	e8 00 00 00 00       	call   4a9 <_Wiz_Unzip@20+0x159>
 4a9:	89 c3                	mov    %eax,%ebx
 4ab:	8b 45 08             	mov    0x8(%ebp),%eax
 4ae:	8d 90 00 09 01 00    	lea    0x10900(%eax),%edx
 4b4:	83 c0 0c             	add    $0xc,%eax
   {
   free(intern_ifv[0]);
   free(intern_ifv);
   }
#endif
FreeDllMem(__G);
 4b7:	e8 14 fc ff ff       	call   d0 <_FreeDllMem.isra.2>
return retcode;
}
 4bc:	83 c4 2c             	add    $0x2c,%esp
   free(intern_ifv[0]);
   free(intern_ifv);
   }
#endif
FreeDllMem(__G);
return retcode;
 4bf:	89 d8                	mov    %ebx,%eax
}
 4c1:	5b                   	pop    %ebx
 4c2:	5e                   	pop    %esi
 4c3:	5f                   	pop    %edi
 4c4:	5d                   	pop    %ebp
 4c5:	c2 14 00             	ret    $0x14
    for (f_cnt = 0; f_cnt < ifnc; f_cnt++)
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
 4c8:	85 db                	test   %ebx,%ebx
 4ca:	75 2a                	jne    4f6 <_Wiz_Unzip@20+0x1a6>
 4cc:	85 c9                	test   %ecx,%ecx
 4ce:	74 26                	je     4f6 <_Wiz_Unzip@20+0x1a6>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 4d0:	8b 7d 08             	mov    0x8(%ebp),%edi
 4d3:	31 d2                	xor    %edx,%edx
 4d5:	85 c0                	test   %eax,%eax
 4d7:	0f 94 c2             	sete   %dl
 4da:	89 57 74             	mov    %edx,0x74(%edi)
G.filespecs = ifnc;
 4dd:	89 47 6c             	mov    %eax,0x6c(%edi)
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
 4e0:	31 d2                	xor    %edx,%edx
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
G.filespecs = ifnc;
G.xfilespecs = xfnc;
 4e2:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)

if (ifnc > 0) {
 4e9:	85 c0                	test   %eax,%eax
 4eb:	0f 8f 0f ff ff ff    	jg     400 <_Wiz_Unzip@20+0xb0>
 4f1:	e9 20 ff ff ff       	jmp    416 <_Wiz_Unzip@20+0xc6>
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
else
    for (f_cnt = 0; f_cnt < xfnc; f_cnt++)
 4f6:	85 c9                	test   %ecx,%ecx
 4f8:	0f 8f 5a ff ff ff    	jg     458 <_Wiz_Unzip@20+0x108>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 4fe:	89 c7                	mov    %eax,%edi
 500:	09 cf                	or     %ecx,%edi
 502:	8b 7d 08             	mov    0x8(%ebp),%edi
 505:	0f 94 c2             	sete   %dl
 508:	81 e2 ff 00 00 00    	and    $0xff,%edx
G.filespecs = ifnc;
G.xfilespecs = xfnc;
 50e:	89 4f 70             	mov    %ecx,0x70(%edi)
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 511:	89 57 74             	mov    %edx,0x74(%edi)
G.filespecs = ifnc;
 514:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 517:	89 57 6c             	mov    %edx,0x6c(%edi)
G.xfilespecs = xfnc;

if (ifnc > 0) {
 51a:	85 c0                	test   %eax,%eax
 51c:	0f 8e f4 fe ff ff    	jle    416 <_Wiz_Unzip@20+0xc6>
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
 522:	89 ca                	mov    %ecx,%edx
 524:	e9 d7 fe ff ff       	jmp    400 <_Wiz_Unzip@20+0xb0>
 529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 530:	89 d1                	mov    %edx,%ecx
 532:	8b 7d 08             	mov    0x8(%ebp),%edi
 535:	09 c1                	or     %eax,%ecx
 537:	0f 94 c1             	sete   %cl
 53a:	81 e1 ff 00 00 00    	and    $0xff,%ecx
G.filespecs = ifnc;
G.xfilespecs = xfnc;
 540:	89 57 70             	mov    %edx,0x70(%edi)
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 543:	89 4f 74             	mov    %ecx,0x74(%edi)
G.filespecs = ifnc;
 546:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 549:	89 4f 6c             	mov    %ecx,0x6c(%edi)
G.xfilespecs = xfnc;

if (ifnc > 0) {
 54c:	85 c0                	test   %eax,%eax
 54e:	0f 8f ac fe ff ff    	jg     400 <_Wiz_Unzip@20+0xb0>
 554:	e9 b0 fe ff ff       	jmp    409 <_Wiz_Unzip@20+0xb9>
 559:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 560:	89 55 e4             	mov    %edx,-0x1c(%ebp)
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
else
    for (f_cnt = 0; f_cnt < xfnc; f_cnt++)
 563:	85 c9                	test   %ecx,%ecx
 565:	0f 8e 8a 00 00 00    	jle    5f5 <_Wiz_Unzip@20+0x2a5>
        if (xfnv[f_cnt] == (char *)NULL) {
 56b:	8b 3b                	mov    (%ebx),%edi
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
else
    for (f_cnt = 0; f_cnt < xfnc; f_cnt++)
 56d:	89 d0                	mov    %edx,%eax
        if (xfnv[f_cnt] == (char *)NULL) {
 56f:	85 ff                	test   %edi,%edi
 571:	0f 85 eb fe ff ff    	jne    462 <_Wiz_Unzip@20+0x112>
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 577:	8b 7d 08             	mov    0x8(%ebp),%edi
 57a:	31 c0                	xor    %eax,%eax
 57c:	85 d2                	test   %edx,%edx
 57e:	0f 94 c0             	sete   %al
G.filespecs = ifnc;
 581:	89 57 6c             	mov    %edx,0x6c(%edi)
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 584:	89 47 74             	mov    %eax,0x74(%edi)
G.filespecs = ifnc;
G.xfilespecs = xfnc;
 587:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
 58e:	31 d2                	xor    %edx,%edx
 590:	e9 6b fe ff ff       	jmp    400 <_Wiz_Unzip@20+0xb0>
 595:	89 d0                	mov    %edx,%eax
 597:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 59a:	e9 d7 fd ff ff       	jmp    376 <_Wiz_Unzip@20+0x26>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 59f:	8b 7d 08             	mov    0x8(%ebp),%edi
 5a2:	31 d2                	xor    %edx,%edx
G.filespecs = ifnc;
 5a4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 5a7:	85 c0                	test   %eax,%eax
 5a9:	0f 94 c2             	sete   %dl
 5ac:	89 57 74             	mov    %edx,0x74(%edi)
G.filespecs = ifnc;
 5af:	89 4f 6c             	mov    %ecx,0x6c(%edi)
G.xfilespecs = xfnc;

if (ifnc > 0) {
 5b2:	31 d2                	xor    %edx,%edx
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
G.filespecs = ifnc;
G.xfilespecs = xfnc;
 5b4:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)

if (ifnc > 0) {
 5bb:	85 c0                	test   %eax,%eax
 5bd:	0f 8f 3d fe ff ff    	jg     400 <_Wiz_Unzip@20+0xb0>
 5c3:	e9 4e fe ff ff       	jmp    416 <_Wiz_Unzip@20+0xc6>
    for (f_cnt = 0; f_cnt < ifnc; f_cnt++)
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
 5c8:	85 db                	test   %ebx,%ebx
 5ca:	0f 85 76 fe ff ff    	jne    446 <_Wiz_Unzip@20+0xf6>
 5d0:	85 c9                	test   %ecx,%ecx
 5d2:	0f 84 6e fe ff ff    	je     446 <_Wiz_Unzip@20+0xf6>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 5d8:	8b 45 08             	mov    0x8(%ebp),%eax
 5db:	c7 40 74 01 00 00 00 	movl   $0x1,0x74(%eax)
G.filespecs = ifnc;
 5e2:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
G.xfilespecs = xfnc;
 5e9:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
 5f0:	e9 21 fe ff ff       	jmp    416 <_Wiz_Unzip@20+0xc6>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 5f5:	89 d0                	mov    %edx,%eax
 5f7:	8b 7d 08             	mov    0x8(%ebp),%edi
 5fa:	09 c8                	or     %ecx,%eax
 5fc:	0f 94 c0             	sete   %al
 5ff:	25 ff 00 00 00       	and    $0xff,%eax
G.filespecs = ifnc;
 604:	89 57 6c             	mov    %edx,0x6c(%edi)
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 607:	89 47 74             	mov    %eax,0x74(%edi)
G.filespecs = ifnc;
G.xfilespecs = xfnc;
 60a:	89 4f 70             	mov    %ecx,0x70(%edi)
        if (ifnv[f_cnt] == (char *)NULL) {
            ifnc = f_cnt;
            break;
        }
if (xfnv == (char **)NULL && xfnc != 0)
    xfnc = 0;
 60d:	89 ca                	mov    %ecx,%edx
 60f:	e9 ec fd ff ff       	jmp    400 <_Wiz_Unzip@20+0xb0>
        if (xfnv[f_cnt] == (char *)NULL) {
            xfnc = f_cnt;
            break;
        }

G.process_all_files = (ifnc == 0 && xfnc == 0);         /* for speed */
 614:	8b 7d 08             	mov    0x8(%ebp),%edi
 617:	09 c8                	or     %ecx,%eax
 619:	0f 94 c0             	sete   %al
 61c:	25 ff 00 00 00       	and    $0xff,%eax
 621:	89 47 74             	mov    %eax,0x74(%edi)
G.filespecs = ifnc;
 624:	89 f8                	mov    %edi,%eax
 626:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 629:	89 78 6c             	mov    %edi,0x6c(%eax)
G.xfilespecs = xfnc;
 62c:	89 48 70             	mov    %ecx,0x70(%eax)
 62f:	e9 e2 fd ff ff       	jmp    416 <_Wiz_Unzip@20+0xc6>
 634:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 63a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000640 <_Wiz_SingleEntryUnzip@24>:
}


int WINAPI Wiz_SingleEntryUnzip(int ifnc, char **ifnv, int xfnc, char **xfnv,
   LPDCL lpDCL, LPUSERFUNCTIONS lpUserFunc)
{
 640:	56                   	push   %esi
 641:	53                   	push   %ebx
 642:	83 ec 24             	sub    $0x24,%esp
int retcode;
CONSTRUCTGLOBALS();
 645:	e8 00 00 00 00       	call   64a <_Wiz_SingleEntryUnzip@24+0xa>
 64a:	89 c3                	mov    %eax,%ebx

if (!Wiz_Init((zvoid *)&G, lpUserFunc))
 64c:	8b 44 24 44          	mov    0x44(%esp),%eax
 650:	89 44 24 04          	mov    %eax,0x4(%esp)
 654:	89 1c 24             	mov    %ebx,(%esp)
 657:	e8 c4 fa ff ff       	call   120 <_Wiz_Init@8>
 65c:	85 c0                	test   %eax,%eax
 65e:	56                   	push   %esi
 65f:	56                   	push   %esi
 660:	74 3e                	je     6a0 <_Wiz_SingleEntryUnzip@24+0x60>
   {
   DESTROYGLOBALS();
   return PK_BADERR;
   }

if (lpDCL->lpszZipFN == NULL)
 662:	8b 44 24 40          	mov    0x40(%esp),%eax
 666:	8b 48 3c             	mov    0x3c(%eax),%ecx
 669:	85 c9                	test   %ecx,%ecx
 66b:	74 53                	je     6c0 <_Wiz_SingleEntryUnzip@24+0x80>
   /* Something has screwed up, we don't have a filename */
   DESTROYGLOBALS();
   return PK_NOZIP;
   }

if (!Wiz_SetOpts((zvoid *)&G, lpDCL))
 66d:	8b 44 24 40          	mov    0x40(%esp),%eax
 671:	89 1c 24             	mov    %ebx,(%esp)
 674:	89 44 24 04          	mov    %eax,0x4(%esp)
 678:	e8 23 fb ff ff       	call   1a0 <_Wiz_SetOpts@8>
 67d:	85 c0                	test   %eax,%eax
 67f:	52                   	push   %edx
 680:	52                   	push   %edx
 681:	75 5d                	jne    6e0 <_Wiz_SingleEntryUnzip@24+0xa0>
   {
   DESTROYGLOBALS();
 683:	89 1c 24             	mov    %ebx,(%esp)
 686:	e8 00 00 00 00       	call   68b <_Wiz_SingleEntryUnzip@24+0x4b>
 68b:	89 1c 24             	mov    %ebx,(%esp)
 68e:	e8 00 00 00 00       	call   693 <_Wiz_SingleEntryUnzip@24+0x53>
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);

DESTROYGLOBALS();
return retcode;
}
 693:	83 c4 24             	add    $0x24,%esp
   }

if (!Wiz_SetOpts((zvoid *)&G, lpDCL))
   {
   DESTROYGLOBALS();
   return PK_MEM;
 696:	b8 04 00 00 00       	mov    $0x4,%eax
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);

DESTROYGLOBALS();
return retcode;
}
 69b:	5b                   	pop    %ebx
 69c:	5e                   	pop    %esi
 69d:	c2 18 00             	ret    $0x18
int retcode;
CONSTRUCTGLOBALS();

if (!Wiz_Init((zvoid *)&G, lpUserFunc))
   {
   DESTROYGLOBALS();
 6a0:	89 1c 24             	mov    %ebx,(%esp)
 6a3:	e8 00 00 00 00       	call   6a8 <_Wiz_SingleEntryUnzip@24+0x68>
 6a8:	89 1c 24             	mov    %ebx,(%esp)
 6ab:	e8 00 00 00 00       	call   6b0 <_Wiz_SingleEntryUnzip@24+0x70>
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);

DESTROYGLOBALS();
return retcode;
}
 6b0:	83 c4 24             	add    $0x24,%esp
CONSTRUCTGLOBALS();

if (!Wiz_Init((zvoid *)&G, lpUserFunc))
   {
   DESTROYGLOBALS();
   return PK_BADERR;
 6b3:	b8 03 00 00 00       	mov    $0x3,%eax
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);

DESTROYGLOBALS();
return retcode;
}
 6b8:	5b                   	pop    %ebx
 6b9:	5e                   	pop    %esi
 6ba:	c2 18 00             	ret    $0x18
 6bd:	8d 76 00             	lea    0x0(%esi),%esi
   }

if (lpDCL->lpszZipFN == NULL)
   {
   /* Something has screwed up, we don't have a filename */
   DESTROYGLOBALS();
 6c0:	89 1c 24             	mov    %ebx,(%esp)
 6c3:	e8 00 00 00 00       	call   6c8 <_Wiz_SingleEntryUnzip@24+0x88>
 6c8:	89 1c 24             	mov    %ebx,(%esp)
 6cb:	e8 00 00 00 00       	call   6d0 <_Wiz_SingleEntryUnzip@24+0x90>
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);

DESTROYGLOBALS();
return retcode;
}
 6d0:	83 c4 24             	add    $0x24,%esp

if (lpDCL->lpszZipFN == NULL)
   {
   /* Something has screwed up, we don't have a filename */
   DESTROYGLOBALS();
   return PK_NOZIP;
 6d3:	b8 09 00 00 00       	mov    $0x9,%eax
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);

DESTROYGLOBALS();
return retcode;
}
 6d8:	5b                   	pop    %ebx
 6d9:	5e                   	pop    %esi
 6da:	c2 18 00             	ret    $0x18
 6dd:	8d 76 00             	lea    0x0(%esi),%esi
#endif

/* Here is the actual call to "unzip" the files (or whatever else you
 * are doing.)
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);
 6e0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 6e4:	89 1c 24             	mov    %ebx,(%esp)
 6e7:	89 44 24 10          	mov    %eax,0x10(%esp)
 6eb:	8b 44 24 38          	mov    0x38(%esp),%eax
 6ef:	89 44 24 0c          	mov    %eax,0xc(%esp)
 6f3:	8b 44 24 34          	mov    0x34(%esp),%eax
 6f7:	89 44 24 08          	mov    %eax,0x8(%esp)
 6fb:	8b 44 24 30          	mov    0x30(%esp),%eax
 6ff:	89 44 24 04          	mov    %eax,0x4(%esp)
 703:	e8 48 fc ff ff       	call   350 <_Wiz_Unzip@20>
 708:	83 ec 14             	sub    $0x14,%esp
 70b:	89 c6                	mov    %eax,%esi

DESTROYGLOBALS();
 70d:	89 1c 24             	mov    %ebx,(%esp)
 710:	e8 00 00 00 00       	call   715 <_Wiz_SingleEntryUnzip@24+0xd5>
 715:	89 1c 24             	mov    %ebx,(%esp)
 718:	e8 00 00 00 00       	call   71d <_Wiz_SingleEntryUnzip@24+0xdd>
return retcode;
}
 71d:	83 c4 24             	add    $0x24,%esp
 * are doing.)
 */
retcode = Wiz_Unzip((zvoid *)&G, ifnc, ifnv, xfnc, xfnv);

DESTROYGLOBALS();
return retcode;
 720:	89 f0                	mov    %esi,%eax
}
 722:	5b                   	pop    %ebx
 723:	5e                   	pop    %esi
 724:	c2 18 00             	ret    $0x18
 727:	89 f6                	mov    %esi,%esi
 729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000730 <_win_fprintf>:


int win_fprintf(zvoid *pG, FILE *file, unsigned int size, char far *buffer)
{
 730:	57                   	push   %edi
 731:	56                   	push   %esi
 732:	53                   	push   %ebx
 733:	83 ec 10             	sub    $0x10,%esp
if ((file != stderr) && (file != stdout))
 736:	8b 15 00 00 00 00    	mov    0x0,%edx
return retcode;
}


int win_fprintf(zvoid *pG, FILE *file, unsigned int size, char far *buffer)
{
 73c:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 740:	8b 74 24 20          	mov    0x20(%esp),%esi
if ((file != stderr) && (file != stdout))
 744:	8d 7a 40             	lea    0x40(%edx),%edi
return retcode;
}


int win_fprintf(zvoid *pG, FILE *file, unsigned int size, char far *buffer)
{
 747:	8b 44 24 28          	mov    0x28(%esp),%eax
 74b:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
if ((file != stderr) && (file != stdout))
 74f:	39 f9                	cmp    %edi,%ecx
 751:	74 1d                	je     770 <_win_fprintf+0x40>
 753:	83 c2 20             	add    $0x20,%edx
 756:	39 d1                	cmp    %edx,%ecx
 758:	74 16                	je     770 <_win_fprintf+0x40>
   {
   return write(fileno(file),(char far *)(buffer),size);
 75a:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 75e:	8b 41 10             	mov    0x10(%ecx),%eax
 761:	89 44 24 20          	mov    %eax,0x20(%esp)
   }
if (!fNoPrinting)
   return G.lpUserFunctions->print((LPSTR)buffer, size);
return (int)size;
}
 765:	83 c4 10             	add    $0x10,%esp
 768:	5b                   	pop    %ebx
 769:	5e                   	pop    %esi
 76a:	5f                   	pop    %edi

int win_fprintf(zvoid *pG, FILE *file, unsigned int size, char far *buffer)
{
if ((file != stderr) && (file != stdout))
   {
   return write(fileno(file),(char far *)(buffer),size);
 76b:	e9 00 00 00 00       	jmp    770 <_win_fprintf+0x40>
   }
if (!fNoPrinting)
 770:	8b 0d 00 00 00 00    	mov    0x0,%ecx
 776:	85 c9                	test   %ecx,%ecx
 778:	74 07                	je     781 <_win_fprintf+0x51>
   return G.lpUserFunctions->print((LPSTR)buffer, size);
return (int)size;
}
 77a:	83 c4 10             	add    $0x10,%esp
 77d:	5b                   	pop    %ebx
 77e:	5e                   	pop    %esi
 77f:	5f                   	pop    %edi
 780:	c3                   	ret    
if ((file != stderr) && (file != stdout))
   {
   return write(fileno(file),(char far *)(buffer),size);
   }
if (!fNoPrinting)
   return G.lpUserFunctions->print((LPSTR)buffer, size);
 781:	8b 96 58 0b 01 00    	mov    0x10b58(%esi),%edx
 787:	89 1c 24             	mov    %ebx,(%esp)
 78a:	89 44 24 04          	mov    %eax,0x4(%esp)
 78e:	ff 12                	call   *(%edx)
 790:	52                   	push   %edx
 791:	52                   	push   %edx
return (int)size;
}
 792:	83 c4 10             	add    $0x10,%esp
 795:	5b                   	pop    %ebx
 796:	5e                   	pop    %esi
 797:	5f                   	pop    %edi
 798:	c3                   	ret    
 799:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000007a0 <_UzpPassword@24>:
    int *rcnt;          /* retry counter */
    char *pwbuf;        /* buffer for password */
    int size;           /* size of password buffer */
    ZCONST char *zfn;   /* name of zip archiv */
    ZCONST char *efn;   /* name of archiv entry being processed */
{
 7a0:	83 ec 1c             	sub    $0x1c,%esp
 7a3:	8b 54 24 24          	mov    0x24(%esp),%edx
#if CRYPT
    LPSTR m;

    if (*rcnt == 0) {
 7a7:	8b 02                	mov    (%edx),%eax
 7a9:	85 c0                	test   %eax,%eax
 7ab:	74 39                	je     7e6 <_UzpPassword@24+0x46>
        *rcnt = 2;
        m = "Enter password for: ";
    } else {
        (*rcnt)--;
 7ad:	48                   	dec    %eax
 7ae:	89 02                	mov    %eax,(%edx)
        m = "Password incorrect--reenter: ";
 7b0:	ba 16 00 00 00       	mov    $0x16,%edx
    }

    return (*G.lpUserFunctions->password)((LPSTR)pwbuf, size, m, (LPSTR)efn);
 7b5:	8b 44 24 20          	mov    0x20(%esp),%eax
 7b9:	8b 4c 24 34          	mov    0x34(%esp),%ecx
 7bd:	8b 80 58 0b 01 00    	mov    0x10b58(%eax),%eax
 7c3:	89 54 24 08          	mov    %edx,0x8(%esp)
 7c7:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 7cb:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
 7cf:	89 54 24 04          	mov    %edx,0x4(%esp)
 7d3:	8b 54 24 28          	mov    0x28(%esp),%edx
 7d7:	89 14 24             	mov    %edx,(%esp)
 7da:	ff 50 0c             	call   *0xc(%eax)
 7dd:	83 ec 10             	sub    $0x10,%esp
#else /* !CRYPT */
    return IZ_PW_ERROR; /* internal error, function should never get called */
#endif /* ?CRYPT */
} /* end function UzpPassword() */
 7e0:	83 c4 1c             	add    $0x1c,%esp
 7e3:	c2 18 00             	ret    $0x18
{
#if CRYPT
    LPSTR m;

    if (*rcnt == 0) {
        *rcnt = 2;
 7e6:	c7 02 02 00 00 00    	movl   $0x2,(%edx)
        m = "Enter password for: ";
 7ec:	ba 01 00 00 00       	mov    $0x1,%edx
 7f1:	eb c2                	jmp    7b5 <_UzpPassword@24+0x15>
 7f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 7f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000800 <_Wiz_NoPrinting@4>:
} /* end function UzpPassword() */

/* Turn off all messages to the calling application */
void WINAPI Wiz_NoPrinting(int f)
{
fNoPrinting = f;
 800:	8b 44 24 04          	mov    0x4(%esp),%eax
 804:	a3 00 00 00 00       	mov    %eax,0x0
 809:	c2 04 00             	ret    $0x4
 80c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000810 <_Wiz_UnzipToMemory@16>:
#ifndef SFX
#ifndef __16BIT__

int WINAPI Wiz_UnzipToMemory(LPSTR zip, LPSTR file,
    LPUSERFUNCTIONS lpUserFunctions, UzpBuffer *retstr)
{
 810:	56                   	push   %esi
 811:	53                   	push   %ebx
 812:	83 ec 24             	sub    $0x24,%esp
    int r;
#ifndef CRTL_CP_IS_ISO
    char *intern_zip, *intern_file;
#endif

    CONSTRUCTGLOBALS();
 815:	e8 00 00 00 00       	call   81a <_Wiz_UnzipToMemory@16+0xa>
 81a:	89 c3                	mov    %eax,%ebx
    ISO_TO_INTERN(zip, intern_zip);
    ISO_TO_INTERN(file, intern_file);
#   define zip intern_zip
#   define file intern_file
#endif
    if (!Wiz_Init((zvoid *)&G, lpUserFunctions)) {
 81c:	8b 44 24 38          	mov    0x38(%esp),%eax
 820:	89 44 24 04          	mov    %eax,0x4(%esp)
 824:	89 1c 24             	mov    %ebx,(%esp)
 827:	e8 f4 f8 ff ff       	call   120 <_Wiz_Init@8>
 82c:	85 c0                	test   %eax,%eax
 82e:	51                   	push   %ecx
 82f:	51                   	push   %ecx
 830:	75 1e                	jne    850 <_Wiz_UnzipToMemory@16+0x40>
       DESTROYGLOBALS();
 832:	89 1c 24             	mov    %ebx,(%esp)
 835:	e8 00 00 00 00       	call   83a <_Wiz_UnzipToMemory@16+0x2a>
 83a:	89 1c 24             	mov    %ebx,(%esp)
 83d:	e8 00 00 00 00       	call   842 <_Wiz_UnzipToMemory@16+0x32>
       return PK_BADERR;
 842:	b8 03 00 00 00       	mov    $0x3,%eax
    if (!r && retstr->strlength) {
       free(retstr->strptr);
       retstr->strptr = NULL;
    }
    return r;
}
 847:	83 c4 24             	add    $0x24,%esp
 84a:	5b                   	pop    %ebx
 84b:	5e                   	pop    %esi
 84c:	c2 10 00             	ret    $0x10
 84f:	90                   	nop
       DESTROYGLOBALS();
       return PK_BADERR;
    }
    G.redirect_data = 1;

    r = (unzipToMemory(__G__ zip, file, retstr) == PK_COOL);
 850:	8b 44 24 3c          	mov    0x3c(%esp),%eax
#endif
    if (!Wiz_Init((zvoid *)&G, lpUserFunctions)) {
       DESTROYGLOBALS();
       return PK_BADERR;
    }
    G.redirect_data = 1;
 854:	c7 83 a0 00 00 00 01 	movl   $0x1,0xa0(%ebx)
 85b:	00 00 00 

    r = (unzipToMemory(__G__ zip, file, retstr) == PK_COOL);
 85e:	89 44 24 0c          	mov    %eax,0xc(%esp)
 862:	8b 44 24 34          	mov    0x34(%esp),%eax
 866:	89 44 24 08          	mov    %eax,0x8(%esp)
 86a:	8b 44 24 30          	mov    0x30(%esp),%eax
 86e:	89 44 24 04          	mov    %eax,0x4(%esp)
 872:	89 1c 24             	mov    %ebx,(%esp)
 875:	e8 00 00 00 00       	call   87a <_Wiz_UnzipToMemory@16+0x6a>

    DESTROYGLOBALS();
 87a:	89 1c 24             	mov    %ebx,(%esp)
       DESTROYGLOBALS();
       return PK_BADERR;
    }
    G.redirect_data = 1;

    r = (unzipToMemory(__G__ zip, file, retstr) == PK_COOL);
 87d:	89 c6                	mov    %eax,%esi

    DESTROYGLOBALS();
 87f:	e8 00 00 00 00       	call   884 <_Wiz_UnzipToMemory@16+0x74>
 884:	89 1c 24             	mov    %ebx,(%esp)
 887:	e8 00 00 00 00       	call   88c <_Wiz_UnzipToMemory@16+0x7c>
 88c:	b8 01 00 00 00       	mov    $0x1,%eax
#  undef file
#  undef zip
    free(intern_file);
    free(intern_zip);
#endif
    if (!r && retstr->strlength) {
 891:	85 f6                	test   %esi,%esi
 893:	74 b2                	je     847 <_Wiz_UnzipToMemory@16+0x37>
 895:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
 899:	30 c0                	xor    %al,%al
 89b:	8b 11                	mov    (%ecx),%edx
 89d:	85 d2                	test   %edx,%edx
 89f:	74 a6                	je     847 <_Wiz_UnzipToMemory@16+0x37>
       free(retstr->strptr);
 8a1:	8b 51 04             	mov    0x4(%ecx),%edx
 8a4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 8a8:	89 14 24             	mov    %edx,(%esp)
 8ab:	e8 00 00 00 00       	call   8b0 <_Wiz_UnzipToMemory@16+0xa0>
       retstr->strptr = NULL;
 8b0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 8b4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 8bb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8bf:	eb 86                	jmp    847 <_Wiz_UnzipToMemory@16+0x37>
 8c1:	eb 0d                	jmp    8d0 <_Wiz_Grep@24>
 8c3:	90                   	nop
 8c4:	90                   	nop
 8c5:	90                   	nop
 8c6:	90                   	nop
 8c7:	90                   	nop
 8c8:	90                   	nop
 8c9:	90                   	nop
 8ca:	90                   	nop
 8cb:	90                   	nop
 8cc:	90                   	nop
 8cd:	90                   	nop
 8ce:	90                   	nop
 8cf:	90                   	nop

000008d0 <_Wiz_Grep@24>:
             matching occurrence of the pattern.
 */

int WINAPI Wiz_Grep(LPSTR archive, LPSTR file, LPSTR pattern, int cmd,
                   int SkipBin, LPUSERFUNCTIONS lpUserFunctions)
{
 8d0:	55                   	push   %ebp
 8d1:	57                   	push   %edi
 8d2:	56                   	push   %esi
 8d3:	53                   	push   %ebx
 8d4:	83 ec 3c             	sub    $0x3c,%esp
} /* end function UzpPassword() */

/* Turn off all messages to the calling application */
void WINAPI Wiz_NoPrinting(int f)
{
fNoPrinting = f;
 8d7:	c7 05 00 00 00 00 01 	movl   $0x1,0x0
 8de:	00 00 00 
    /* Turn off any windows printing functions, as they may not have been
     * identified yet. There is no requirement that we initialize the
     * dll with printing stuff for this. */
    Wiz_NoPrinting(TRUE);

    if (!Wiz_UnzipToMemory(archive, file, lpUserFunctions, &retstr)) {
 8e1:	8d 44 24 28          	lea    0x28(%esp),%eax
 8e5:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8e9:	8b 44 24 64          	mov    0x64(%esp),%eax
 8ed:	89 44 24 08          	mov    %eax,0x8(%esp)
 8f1:	8b 44 24 54          	mov    0x54(%esp),%eax
 8f5:	89 44 24 04          	mov    %eax,0x4(%esp)
 8f9:	8b 44 24 50          	mov    0x50(%esp),%eax
 8fd:	89 04 24             	mov    %eax,(%esp)
 900:	e8 0b ff ff ff       	call   810 <_Wiz_UnzipToMemory@16>
 905:	83 ec 10             	sub    $0x10,%esp
 908:	85 c0                	test   %eax,%eax
 90a:	0f 84 32 02 00 00    	je     b42 <_Wiz_Grep@24+0x272>
       Wiz_NoPrinting(FALSE);
       return -1;   /* not enough memory, file not found, or other error */
    }

    if (SkipBin) {
 910:	8b 54 24 60          	mov    0x60(%esp),%edx
        if (retstr.strlength < 100)
 914:	8b 44 24 28          	mov    0x28(%esp),%eax
    if (!Wiz_UnzipToMemory(archive, file, lpUserFunctions, &retstr)) {
       Wiz_NoPrinting(FALSE);
       return -1;   /* not enough memory, file not found, or other error */
    }

    if (SkipBin) {
 918:	85 d2                	test   %edx,%edx
 91a:	74 77                	je     993 <_Wiz_Grep@24+0xc3>
        if (retstr.strlength < 100)
 91c:	83 f8 63             	cmp    $0x63,%eax
 91f:	0f 87 d9 01 00 00    	ja     afe <_Wiz_Grep@24+0x22e>
            buflen = retstr.strlength;
        else
            buflen = 100;
        for (i = 0; i < buflen; i++) {
 925:	85 c0                	test   %eax,%eax
 927:	0f 84 27 02 00 00    	je     b54 <_Wiz_Grep@24+0x284>
 92d:	8b 7c 24 2c          	mov    0x2c(%esp),%edi

    if (SkipBin) {
        if (retstr.strlength < 100)
            buflen = retstr.strlength;
        else
            buflen = 100;
 931:	31 db                	xor    %ebx,%ebx

/* use  simple lookup if SB locale, else  _isctype()  */
#define __ISCTYPE(c, mask)  (MB_CUR_MAX == 1 ? (_pctype[c] & mask) : _isctype(c, mask))
__CRT_INLINE int __cdecl __MINGW_NOTHROW isalnum(int c) {return __ISCTYPE(c, (_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isalpha(int c) {return __ISCTYPE(c, _ALPHA);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW iscntrl(int c) {return __ISCTYPE(c, _CONTROL);}
 933:	89 fa                	mov    %edi,%edx
 935:	8b 35 00 00 00 00    	mov    0x0,%esi
 93b:	8b 2d 00 00 00 00    	mov    0x0,%ebp
 941:	89 c7                	mov    %eax,%edi
 943:	eb 2f                	jmp    974 <_Wiz_Grep@24+0xa4>
 945:	8b 4d 00             	mov    0x0(%ebp),%ecx
 948:	66 8b 04 41          	mov    (%ecx,%eax,2),%ax
 94c:	83 e0 20             	and    $0x20,%eax
 94f:	25 ff ff 00 00       	and    $0xffff,%eax
        for (i = 0; i < buflen; i++) {
            if (iscntrl(retstr.strptr[i])) {
 954:	85 c0                	test   %eax,%eax
 956:	74 13                	je     96b <_Wiz_Grep@24+0x9b>
                if ((retstr.strptr[i] != 0x0A) &&
 958:	8a 04 1a             	mov    (%edx,%ebx,1),%al
                    (retstr.strptr[i] != 0x0D) &&
 95b:	8d 48 f7             	lea    -0x9(%eax),%ecx
 95e:	80 f9 01             	cmp    $0x1,%cl
 961:	76 08                	jbe    96b <_Wiz_Grep@24+0x9b>
 963:	3c 0d                	cmp    $0xd,%al
 965:	0f 85 9d 01 00 00    	jne    b08 <_Wiz_Grep@24+0x238>
    if (SkipBin) {
        if (retstr.strlength < 100)
            buflen = retstr.strlength;
        else
            buflen = 100;
        for (i = 0; i < buflen; i++) {
 96b:	43                   	inc    %ebx
 96c:	39 fb                	cmp    %edi,%ebx
 96e:	0f 83 5d 01 00 00    	jae    ad1 <_Wiz_Grep@24+0x201>
            if (iscntrl(retstr.strptr[i])) {
 974:	0f be 04 1a          	movsbl (%edx,%ebx,1),%eax
 978:	83 3e 01             	cmpl   $0x1,(%esi)
 97b:	74 c8                	je     945 <_Wiz_Grep@24+0x75>
 97d:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 984:	00 
 985:	89 04 24             	mov    %eax,(%esp)
 988:	e8 00 00 00 00       	call   98d <_Wiz_Grep@24+0xbd>
 98d:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 991:	eb c1                	jmp    954 <_Wiz_Grep@24+0x84>
 993:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 997:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
                }
            }
        }
    }

    patternLen = strlen(pattern);
 99b:	8b 44 24 58          	mov    0x58(%esp),%eax
 99f:	89 04 24             	mov    %eax,(%esp)
 9a2:	e8 00 00 00 00       	call   9a7 <_Wiz_Grep@24+0xd7>
 9a7:	89 c6                	mov    %eax,%esi

    if (retstr.strlength < patternLen) {
 9a9:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
 9ad:	0f 87 2d 01 00 00    	ja     ae0 <_Wiz_Grep@24+0x210>
        free(retstr.strptr);
        Wiz_NoPrinting(FALSE);
        return FALSE;
    }

    sz = malloc(patternLen + 3); /* add two in case doing whole words only */
 9b3:	8d 40 03             	lea    0x3(%eax),%eax
 9b6:	89 04 24             	mov    %eax,(%esp)
 9b9:	e8 00 00 00 00       	call   9be <_Wiz_Grep@24+0xee>
    if (cmd > 1) {
 9be:	83 7c 24 5c 01       	cmpl   $0x1,0x5c(%esp)
        free(retstr.strptr);
        Wiz_NoPrinting(FALSE);
        return FALSE;
    }

    sz = malloc(patternLen + 3); /* add two in case doing whole words only */
 9c3:	89 c3                	mov    %eax,%ebx
    if (cmd > 1) {
 9c5:	0f 8e 5b 01 00 00    	jle    b26 <_Wiz_Grep@24+0x256>
        strcpy(sz, " ");
 9cb:	c6 00 20             	movb   $0x20,(%eax)
        strcat(sz, pattern);
 9ce:	8b 54 24 58          	mov    0x58(%esp),%edx
 9d2:	8d 40 01             	lea    0x1(%eax),%eax
 9d5:	89 74 24 08          	mov    %esi,0x8(%esp)
 9d9:	89 54 24 04          	mov    %edx,0x4(%esp)
 9dd:	89 04 24             	mov    %eax,(%esp)
 9e0:	e8 00 00 00 00       	call   9e5 <_Wiz_Grep@24+0x115>
        strcat(sz, " ");
 9e5:	66 c7 44 33 01 20 00 	movw   $0x20,0x1(%ebx,%esi,1)
    } else
        strcpy(sz, pattern);

    if ((cmd == 0) || (cmd == 2)) {
 9ec:	f7 44 24 5c fd ff ff 	testl  $0xfffffffd,0x5c(%esp)
 9f3:	ff 
 9f4:	75 7e                	jne    a74 <_Wiz_Grep@24+0x1a4>
 9f6:	31 ed                	xor    %ebp,%ebp
        for (i = 0; i < strlen(sz); i++)
 9f8:	89 da                	mov    %ebx,%edx
 9fa:	8b 0a                	mov    (%edx),%ecx
 9fc:	83 c2 04             	add    $0x4,%edx
 9ff:	8d 81 ff fe fe fe    	lea    -0x1010101(%ecx),%eax
 a05:	83 f1 ff             	xor    $0xffffffff,%ecx
 a08:	21 c8                	and    %ecx,%eax
 a0a:	25 80 80 80 80       	and    $0x80808080,%eax
 a0f:	74 e9                	je     9fa <_Wiz_Grep@24+0x12a>
 a11:	89 c1                	mov    %eax,%ecx
 a13:	c1 e9 10             	shr    $0x10,%ecx
 a16:	a9 80 80 00 00       	test   $0x8080,%eax
 a1b:	0f 44 c1             	cmove  %ecx,%eax
 a1e:	8d 4a 02             	lea    0x2(%edx),%ecx
 a21:	0f 44 d1             	cmove  %ecx,%edx
 a24:	00 c0                	add    %al,%al
 a26:	83 da 03             	sbb    $0x3,%edx
 a29:	29 da                	sub    %ebx,%edx
 a2b:	39 d5                	cmp    %edx,%ebp
 a2d:	73 12                	jae    a41 <_Wiz_Grep@24+0x171>
            sz[i] = toupper(sz[i]);
 a2f:	0f be 04 2b          	movsbl (%ebx,%ebp,1),%eax
 a33:	89 04 24             	mov    %eax,(%esp)
 a36:	e8 00 00 00 00       	call   a3b <_Wiz_Grep@24+0x16b>
 a3b:	88 04 2b             	mov    %al,(%ebx,%ebp,1)
        strcat(sz, " ");
    } else
        strcpy(sz, pattern);

    if ((cmd == 0) || (cmd == 2)) {
        for (i = 0; i < strlen(sz); i++)
 a3e:	45                   	inc    %ebp
 a3f:	eb b7                	jmp    9f8 <_Wiz_Grep@24+0x128>
            sz[i] = toupper(sz[i]);
        for (i = 0; i < retstr.strlength; i++)
 a41:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 a45:	85 c0                	test   %eax,%eax
 a47:	74 2b                	je     a74 <_Wiz_Grep@24+0x1a4>
 a49:	31 ed                	xor    %ebp,%ebp
 a4b:	eb 07                	jmp    a54 <_Wiz_Grep@24+0x184>
 a4d:	8d 76 00             	lea    0x0(%esi),%esi
 a50:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
            retstr.strptr[i] = toupper(retstr.strptr[i]);
 a54:	01 ef                	add    %ebp,%edi
        strcpy(sz, pattern);

    if ((cmd == 0) || (cmd == 2)) {
        for (i = 0; i < strlen(sz); i++)
            sz[i] = toupper(sz[i]);
        for (i = 0; i < retstr.strlength; i++)
 a56:	45                   	inc    %ebp
            retstr.strptr[i] = toupper(retstr.strptr[i]);
 a57:	0f be 07             	movsbl (%edi),%eax
 a5a:	89 04 24             	mov    %eax,(%esp)
 a5d:	e8 00 00 00 00       	call   a62 <_Wiz_Grep@24+0x192>
 a62:	88 07                	mov    %al,(%edi)
        strcpy(sz, pattern);

    if ((cmd == 0) || (cmd == 2)) {
        for (i = 0; i < strlen(sz); i++)
            sz[i] = toupper(sz[i]);
        for (i = 0; i < retstr.strlength; i++)
 a64:	8b 44 24 28          	mov    0x28(%esp),%eax
 a68:	39 e8                	cmp    %ebp,%eax
 a6a:	77 e4                	ja     a50 <_Wiz_Grep@24+0x180>
 a6c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 a70:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
            retstr.strptr[i] = toupper(retstr.strptr[i]);
    }

    for (i = 0; i < (retstr.strlength - patternLen); i++) {
 a74:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 a78:	29 f1                	sub    %esi,%ecx
 a7a:	74 51                	je     acd <_Wiz_Grep@24+0x1fd>
 a7c:	01 f9                	add    %edi,%ecx
 a7e:	89 fa                	mov    %edi,%edx
 a80:	89 cd                	mov    %ecx,%ebp
        p = &retstr.strptr[i];
        compare = TRUE;
        for (j = 0; j < patternLen; j++) {
 a82:	85 f6                	test   %esi,%esi
 a84:	74 17                	je     a9d <_Wiz_Grep@24+0x1cd>
            /* We cannot do strncmp here, as we may be dealing with a
             * "binary" file, such as a word processing file, or perhaps
             * even a true executable of some sort. */
            if (p[j] != sz[j]) {
 a86:	8a 03                	mov    (%ebx),%al
 a88:	38 02                	cmp    %al,(%edx)
 a8a:	75 3c                	jne    ac8 <_Wiz_Grep@24+0x1f8>
 a8c:	31 c0                	xor    %eax,%eax
 a8e:	eb 08                	jmp    a98 <_Wiz_Grep@24+0x1c8>
 a90:	8a 0c 03             	mov    (%ebx,%eax,1),%cl
 a93:	38 0c 02             	cmp    %cl,(%edx,%eax,1)
 a96:	75 30                	jne    ac8 <_Wiz_Grep@24+0x1f8>
    }

    for (i = 0; i < (retstr.strlength - patternLen); i++) {
        p = &retstr.strptr[i];
        compare = TRUE;
        for (j = 0; j < patternLen; j++) {
 a98:	40                   	inc    %eax
 a99:	39 f0                	cmp    %esi,%eax
 a9b:	75 f3                	jne    a90 <_Wiz_Grep@24+0x1c0>
                compare = FALSE;
                break;
            }
        }
        if (compare == TRUE) {
            retcode = TRUE;
 a9d:	be 01 00 00 00       	mov    $0x1,%esi
            break;
        }
    }

    free(sz);
 aa2:	89 1c 24             	mov    %ebx,(%esp)
 aa5:	e8 00 00 00 00       	call   aaa <_Wiz_Grep@24+0x1da>
    free(retstr.strptr);
 aaa:	89 3c 24             	mov    %edi,(%esp)
 aad:	e8 00 00 00 00       	call   ab2 <_Wiz_Grep@24+0x1e2>
} /* end function UzpPassword() */

/* Turn off all messages to the calling application */
void WINAPI Wiz_NoPrinting(int f)
{
fNoPrinting = f;
 ab2:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 ab9:	00 00 00 
    }

    free(sz);
    free(retstr.strptr);
    Wiz_NoPrinting(FALSE); /* Turn printing back on */
    return retcode;
 abc:	89 f0                	mov    %esi,%eax
}
 abe:	83 c4 3c             	add    $0x3c,%esp
 ac1:	5b                   	pop    %ebx
 ac2:	5e                   	pop    %esi
 ac3:	5f                   	pop    %edi
 ac4:	5d                   	pop    %ebp
 ac5:	c2 18 00             	ret    $0x18
 ac8:	42                   	inc    %edx
            sz[i] = toupper(sz[i]);
        for (i = 0; i < retstr.strlength; i++)
            retstr.strptr[i] = toupper(retstr.strptr[i]);
    }

    for (i = 0; i < (retstr.strlength - patternLen); i++) {
 ac9:	39 ea                	cmp    %ebp,%edx
 acb:	75 b5                	jne    a82 <_Wiz_Grep@24+0x1b2>
 */

int WINAPI Wiz_Grep(LPSTR archive, LPSTR file, LPSTR pattern, int cmd,
                   int SkipBin, LPUSERFUNCTIONS lpUserFunctions)
{
    int retcode = FALSE, compare;
 acd:	31 f6                	xor    %esi,%esi
 acf:	eb d1                	jmp    aa2 <_Wiz_Grep@24+0x1d2>
 ad1:	8b 44 24 28          	mov    0x28(%esp),%eax
 ad5:	89 d7                	mov    %edx,%edi
 ad7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 adb:	e9 bb fe ff ff       	jmp    99b <_Wiz_Grep@24+0xcb>
    }

    patternLen = strlen(pattern);

    if (retstr.strlength < patternLen) {
        free(retstr.strptr);
 ae0:	89 3c 24             	mov    %edi,(%esp)
 ae3:	e8 00 00 00 00       	call   ae8 <_Wiz_Grep@24+0x218>
} /* end function UzpPassword() */

/* Turn off all messages to the calling application */
void WINAPI Wiz_NoPrinting(int f)
{
fNoPrinting = f;
 ae8:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 aef:	00 00 00 

    free(sz);
    free(retstr.strptr);
    Wiz_NoPrinting(FALSE); /* Turn printing back on */
    return retcode;
}
 af2:	83 c4 3c             	add    $0x3c,%esp
    patternLen = strlen(pattern);

    if (retstr.strlength < patternLen) {
        free(retstr.strptr);
        Wiz_NoPrinting(FALSE);
        return FALSE;
 af5:	31 c0                	xor    %eax,%eax

    free(sz);
    free(retstr.strptr);
    Wiz_NoPrinting(FALSE); /* Turn printing back on */
    return retcode;
}
 af7:	5b                   	pop    %ebx
 af8:	5e                   	pop    %esi
 af9:	5f                   	pop    %edi
 afa:	5d                   	pop    %ebp
 afb:	c2 18 00             	ret    $0x18

    if (SkipBin) {
        if (retstr.strlength < 100)
            buflen = retstr.strlength;
        else
            buflen = 100;
 afe:	b8 64 00 00 00       	mov    $0x64,%eax
 b03:	e9 25 fe ff ff       	jmp    92d <_Wiz_Grep@24+0x5d>
                if ((retstr.strptr[i] != 0x0A) &&
                    (retstr.strptr[i] != 0x0D) &&
                    (retstr.strptr[i] != 0x09))
                {
                    /* OK, we now think we have a binary file of some sort */
                    free(retstr.strptr);
 b08:	89 14 24             	mov    %edx,(%esp)
 b0b:	e8 00 00 00 00       	call   b10 <_Wiz_Grep@24+0x240>
} /* end function UzpPassword() */

/* Turn off all messages to the calling application */
void WINAPI Wiz_NoPrinting(int f)
{
fNoPrinting = f;
 b10:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 b17:	00 00 00 

    free(sz);
    free(retstr.strptr);
    Wiz_NoPrinting(FALSE); /* Turn printing back on */
    return retcode;
}
 b1a:	83 c4 3c             	add    $0x3c,%esp
                    (retstr.strptr[i] != 0x09))
                {
                    /* OK, we now think we have a binary file of some sort */
                    free(retstr.strptr);
                    Wiz_NoPrinting(FALSE);
                    return FALSE;
 b1d:	31 c0                	xor    %eax,%eax

    free(sz);
    free(retstr.strptr);
    Wiz_NoPrinting(FALSE); /* Turn printing back on */
    return retcode;
}
 b1f:	5b                   	pop    %ebx
 b20:	5e                   	pop    %esi
 b21:	5f                   	pop    %edi
 b22:	5d                   	pop    %ebp
 b23:	c2 18 00             	ret    $0x18
    if (cmd > 1) {
        strcpy(sz, " ");
        strcat(sz, pattern);
        strcat(sz, " ");
    } else
        strcpy(sz, pattern);
 b26:	8d 46 01             	lea    0x1(%esi),%eax
 b29:	89 1c 24             	mov    %ebx,(%esp)
 b2c:	89 44 24 08          	mov    %eax,0x8(%esp)
 b30:	8b 44 24 58          	mov    0x58(%esp),%eax
 b34:	89 44 24 04          	mov    %eax,0x4(%esp)
 b38:	e8 00 00 00 00       	call   b3d <_Wiz_Grep@24+0x26d>
 b3d:	e9 aa fe ff ff       	jmp    9ec <_Wiz_Grep@24+0x11c>
} /* end function UzpPassword() */

/* Turn off all messages to the calling application */
void WINAPI Wiz_NoPrinting(int f)
{
fNoPrinting = f;
 b42:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 b49:	00 00 00 
     * dll with printing stuff for this. */
    Wiz_NoPrinting(TRUE);

    if (!Wiz_UnzipToMemory(archive, file, lpUserFunctions, &retstr)) {
       Wiz_NoPrinting(FALSE);
       return -1;   /* not enough memory, file not found, or other error */
 b4c:	83 c8 ff             	or     $0xffffffff,%eax
 b4f:	e9 6a ff ff ff       	jmp    abe <_Wiz_Grep@24+0x1ee>
 b54:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
    if (SkipBin) {
        if (retstr.strlength < 100)
            buflen = retstr.strlength;
        else
            buflen = 100;
        for (i = 0; i < buflen; i++) {
 b58:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 b5f:	00 
 b60:	e9 36 fe ff ff       	jmp    99b <_Wiz_Grep@24+0xcb>
 b65:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 b69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000b70 <_Wiz_Validate@8>:
    return retcode;
}
#endif /* !__16BIT__ */

int WINAPI Wiz_Validate(LPSTR archive, int AllCodes)
{
 b70:	55                   	push   %ebp
 b71:	89 e5                	mov    %esp,%ebp
    return UzpValidate((char *)archive, AllCodes);
}
 b73:	c9                   	leave  
}
#endif /* !__16BIT__ */

int WINAPI Wiz_Validate(LPSTR archive, int AllCodes)
{
    return UzpValidate((char *)archive, AllCodes);
 b74:	e9 00 00 00 00       	jmp    b79 <_Wiz_Validate@8+0x9>
 b79:	90                   	nop
 b7a:	90                   	nop
 b7b:	90                   	nop
 b7c:	90                   	nop
 b7d:	90                   	nop
 b7e:	90                   	nop
 b7f:	90                   	nop

zipinfo.o:     file format pe-i386


Disassembly of section .text:

00000000 <_zi_showMacTypeCreator>:
/**************************************/

static void zi_showMacTypeCreator(__G__ ebfield)
    __GDEF
    uch *ebfield;
{
       0:	55                   	push   %ebp
       1:	57                   	push   %edi
       2:	56                   	push   %esi
       3:	53                   	push   %ebx
       4:	83 ec 4c             	sub    $0x4c,%esp
       7:	89 d3                	mov    %edx,%ebx
__CRT_INLINE int __cdecl __MINGW_NOTHROW isalpha(int c) {return __ISCTYPE(c, _ALPHA);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW iscntrl(int c) {return __ISCTYPE(c, _CONTROL);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isdigit(int c) {return __ISCTYPE(c, _DIGIT);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isgraph(int c) {return __ISCTYPE(c, (_PUNCT|_ALPHA|_DIGIT));}
__CRT_INLINE int __cdecl __MINGW_NOTHROW islower(int c) {return __ISCTYPE(c, _LOWER);}
__CRT_INLINE int __cdecl __MINGW_NOTHROW isprint(int c) {return __ISCTYPE(c, (_BLANK|_PUNCT|_ALPHA|_DIGIT));}
       9:	8b 35 00 00 00 00    	mov    0x0,%esi
       f:	89 44 24 30          	mov    %eax,0x30(%esp)
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
      13:	8a 02                	mov    (%edx),%al
      15:	88 44 24 38          	mov    %al,0x38(%esp)
      19:	83 3e 01             	cmpl   $0x1,(%esi)
      1c:	0f 84 cf 01 00 00    	je     1f1 <_zi_showMacTypeCreator+0x1f1>
      22:	31 c9                	xor    %ecx,%ecx
      24:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
      2b:	00 
      2c:	8a 4c 24 38          	mov    0x38(%esp),%cl
      30:	89 0c 24             	mov    %ecx,(%esp)
      33:	e8 00 00 00 00       	call   38 <_zi_showMacTypeCreator+0x38>
      38:	85 c0                	test   %eax,%eax
      3a:	74 32                	je     6e <_zi_showMacTypeCreator+0x6e>
      3c:	8a 43 01             	mov    0x1(%ebx),%al
      3f:	83 3e 01             	cmpl   $0x1,(%esi)
      42:	88 44 24 39          	mov    %al,0x39(%esp)
      46:	88 44 24 3e          	mov    %al,0x3e(%esp)
      4a:	0f 84 f4 00 00 00    	je     144 <_zi_showMacTypeCreator+0x144>
      50:	31 c0                	xor    %eax,%eax
      52:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
      59:	00 
      5a:	8a 44 24 39          	mov    0x39(%esp),%al
      5e:	89 04 24             	mov    %eax,(%esp)
      61:	e8 00 00 00 00       	call   66 <_zi_showMacTypeCreator+0x66>
      66:	85 c0                	test   %eax,%eax
      68:	0f 85 09 01 00 00    	jne    177 <_zi_showMacTypeCreator+0x177>
      6e:	31 c0                	xor    %eax,%eax
      70:	8a 03                	mov    (%ebx),%al
      72:	89 c2                	mov    %eax,%edx
      74:	8a 43 04             	mov    0x4(%ebx),%al
      77:	88 c1                	mov    %al,%cl
      79:	8a 43 05             	mov    0x5(%ebx),%al
      7c:	88 44 24 3b          	mov    %al,0x3b(%esp)
      80:	8a 43 06             	mov    0x6(%ebx),%al
      83:	88 44 24 3c          	mov    %al,0x3c(%esp)
      87:	8a 43 01             	mov    0x1(%ebx),%al
      8a:	88 44 24 39          	mov    %al,0x39(%esp)
      8e:	8a 43 02             	mov    0x2(%ebx),%al
      91:	88 44 24 34          	mov    %al,0x34(%esp)
      95:	8a 43 03             	mov    0x3(%ebx),%al
      98:	88 44 24 3a          	mov    %al,0x3a(%esp)
      9c:	8a 43 07             	mov    0x7(%ebx),%al
      9f:	88 44 24 3d          	mov    %al,0x3d(%esp)
            native(ebfield[0]), native(ebfield[1]),
            native(ebfield[2]), native(ebfield[3]),
            native(ebfield[4]), native(ebfield[5]),
            native(ebfield[6]), native(ebfield[7])));
    } else {
       Info(slide, 0, ((char *)slide, LoadFarString(MacOSdata1),
      a3:	89 cd                	mov    %ecx,%ebp
      a5:	31 c9                	xor    %ecx,%ecx
      a7:	8a 4c 24 3b          	mov    0x3b(%esp),%cl
      ab:	8b 44 24 30          	mov    0x30(%esp),%eax
      af:	c1 e5 18             	shl    $0x18,%ebp
      b2:	c1 e1 10             	shl    $0x10,%ecx
      b5:	8b 98 44 0b 01 00    	mov    0x10b44(%eax),%ebx
      bb:	01 e9                	add    %ebp,%ecx
      bd:	8d b0 dc 08 00 00    	lea    0x8dc(%eax),%esi
      c3:	0f b6 6c 24 3d       	movzbl 0x3d(%esp),%ebp
      c8:	81 e5 ff 00 00 00    	and    $0xff,%ebp
      ce:	31 c0                	xor    %eax,%eax
      d0:	01 e9                	add    %ebp,%ecx
      d2:	8a 44 24 39          	mov    0x39(%esp),%al
      d6:	0f b6 6c 24 3c       	movzbl 0x3c(%esp),%ebp
      db:	81 e5 ff 00 00 00    	and    $0xff,%ebp
      e1:	c7 44 24 04 e0 09 00 	movl   $0x9e0,0x4(%esp)
      e8:	00 
      e9:	0f b6 7c 24 3a       	movzbl 0x3a(%esp),%edi
      ee:	c1 e5 08             	shl    $0x8,%ebp
      f1:	81 e7 ff 00 00 00    	and    $0xff,%edi
      f7:	01 e9                	add    %ebp,%ecx
      f9:	89 d5                	mov    %edx,%ebp
      fb:	c1 e5 18             	shl    $0x18,%ebp
      fe:	31 d2                	xor    %edx,%edx
     100:	8a 54 24 34          	mov    0x34(%esp),%dl
     104:	01 fd                	add    %edi,%ebp
     106:	c1 e0 10             	shl    $0x10,%eax
     109:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     10d:	01 e8                	add    %ebp,%eax
     10f:	89 34 24             	mov    %esi,(%esp)
     112:	c1 e2 08             	shl    $0x8,%edx
     115:	01 c2                	add    %eax,%edx
     117:	89 54 24 08          	mov    %edx,0x8(%esp)
     11b:	e8 00 00 00 00       	call   120 <_zi_showMacTypeCreator+0x120>
     120:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     127:	00 
     128:	89 44 24 08          	mov    %eax,0x8(%esp)
     12c:	8b 44 24 30          	mov    0x30(%esp),%eax
     130:	89 74 24 04          	mov    %esi,0x4(%esp)
     134:	89 04 24             	mov    %eax,(%esp)
     137:	ff d3                	call   *%ebx
     139:	83 ec 10             	sub    $0x10,%esp
            (((ulg)ebfield[4]) << 24) +
            (((ulg)ebfield[5]) << 16) +
            (((ulg)ebfield[6]) << 8)  +
            ((ulg)ebfield[7])));
    }
} /* end function zi_showMacTypeCreator() */
     13c:	83 c4 4c             	add    $0x4c,%esp
     13f:	5b                   	pop    %ebx
     140:	5e                   	pop    %esi
     141:	5f                   	pop    %edi
     142:	5d                   	pop    %ebp
     143:	c3                   	ret    
     144:	8a 03                	mov    (%ebx),%al
     146:	8b 35 00 00 00 00    	mov    0x0,%esi
     14c:	88 44 24 38          	mov    %al,0x38(%esp)
     150:	0f b6 7c 24 3e       	movzbl 0x3e(%esp),%edi
     155:	8b 16                	mov    (%esi),%edx
     157:	81 e7 ff 00 00 00    	and    $0xff,%edi
static void zi_showMacTypeCreator(__G__ ebfield)
    __GDEF
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
     15d:	66 f7 04 7a 57 01    	testw  $0x157,(%edx,%edi,2)
     163:	0f 84 b7 00 00 00    	je     220 <_zi_showMacTypeCreator+0x220>
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
     169:	8a 43 02             	mov    0x2(%ebx),%al
     16c:	89 c5                	mov    %eax,%ebp
     16e:	88 44 24 34          	mov    %al,0x34(%esp)
     172:	e9 df 00 00 00       	jmp    256 <_zi_showMacTypeCreator+0x256>
     177:	8a 43 02             	mov    0x2(%ebx),%al
     17a:	83 3e 01             	cmpl   $0x1,(%esi)
     17d:	88 44 24 34          	mov    %al,0x34(%esp)
     181:	89 c5                	mov    %eax,%ebp
     183:	0f 84 ba 00 00 00    	je     243 <_zi_showMacTypeCreator+0x243>
     189:	31 d2                	xor    %edx,%edx
     18b:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
     192:	00 
     193:	8a 54 24 34          	mov    0x34(%esp),%dl
     197:	89 14 24             	mov    %edx,(%esp)
     19a:	e8 00 00 00 00       	call   19f <_zi_showMacTypeCreator+0x19f>
static void zi_showMacTypeCreator(__G__ ebfield)
    __GDEF
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
     19f:	85 c0                	test   %eax,%eax
     1a1:	0f 84 c7 fe ff ff    	je     6e <_zi_showMacTypeCreator+0x6e>
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
     1a7:	8a 43 03             	mov    0x3(%ebx),%al
     1aa:	83 3e 01             	cmpl   $0x1,(%esi)
     1ad:	88 44 24 3a          	mov    %al,0x3a(%esp)
     1b1:	88 44 24 3f          	mov    %al,0x3f(%esp)
     1b5:	0f 85 fb 00 00 00    	jne    2b6 <_zi_showMacTypeCreator+0x2b6>
     1bb:	8a 03                	mov    (%ebx),%al
     1bd:	8b 35 00 00 00 00    	mov    0x0,%esi
     1c3:	88 44 24 38          	mov    %al,0x38(%esp)
     1c7:	8a 43 01             	mov    0x1(%ebx),%al
     1ca:	88 44 24 3e          	mov    %al,0x3e(%esp)
     1ce:	8a 43 02             	mov    0x2(%ebx),%al
     1d1:	89 c5                	mov    %eax,%ebp
     1d3:	31 d2                	xor    %edx,%edx
     1d5:	8b 06                	mov    (%esi),%eax
     1d7:	8a 54 24 3f          	mov    0x3f(%esp),%dl
     1db:	66 f7 04 50 57 01    	testw  $0x157,(%eax,%edx,2)
     1e1:	0f 84 69 02 00 00    	je     450 <_zi_showMacTypeCreator+0x450>
        isprint(native(ebfield[4])) && isprint(native(ebfield[5])) &&
     1e7:	8a 43 04             	mov    0x4(%ebx),%al
     1ea:	88 c1                	mov    %al,%cl
     1ec:	e9 3e 02 00 00       	jmp    42f <_zi_showMacTypeCreator+0x42f>
     1f1:	8b 35 00 00 00 00    	mov    0x0,%esi
     1f7:	89 c5                	mov    %eax,%ebp
     1f9:	81 e5 ff 00 00 00    	and    $0xff,%ebp
     1ff:	8b 06                	mov    (%esi),%eax
static void zi_showMacTypeCreator(__G__ ebfield)
    __GDEF
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
     201:	66 f7 04 68 57 01    	testw  $0x157,(%eax,%ebp,2)
     207:	74 77                	je     280 <_zi_showMacTypeCreator+0x280>
     209:	8a 42 01             	mov    0x1(%edx),%al
     20c:	88 44 24 3e          	mov    %al,0x3e(%esp)
     210:	88 44 24 39          	mov    %al,0x39(%esp)
     214:	e9 37 ff ff ff       	jmp    150 <_zi_showMacTypeCreator+0x150>
     219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     220:	8a 44 24 38          	mov    0x38(%esp),%al
     224:	25 ff 00 00 00       	and    $0xff,%eax
     229:	89 c2                	mov    %eax,%edx
     22b:	8a 43 04             	mov    0x4(%ebx),%al
     22e:	88 c1                	mov    %al,%cl
     230:	8a 43 05             	mov    0x5(%ebx),%al
     233:	88 44 24 3b          	mov    %al,0x3b(%esp)
     237:	8a 43 06             	mov    0x6(%ebx),%al
     23a:	88 44 24 3c          	mov    %al,0x3c(%esp)
     23e:	e9 4b fe ff ff       	jmp    8e <_zi_showMacTypeCreator+0x8e>
     243:	8a 03                	mov    (%ebx),%al
     245:	8b 35 00 00 00 00    	mov    0x0,%esi
     24b:	88 44 24 38          	mov    %al,0x38(%esp)
     24f:	8a 43 01             	mov    0x1(%ebx),%al
     252:	88 44 24 3e          	mov    %al,0x3e(%esp)
     256:	89 ef                	mov    %ebp,%edi
     258:	8b 06                	mov    (%esi),%eax
     25a:	81 e7 ff 00 00 00    	and    $0xff,%edi
     260:	66 f7 04 78 57 01    	testw  $0x157,(%eax,%edi,2)
     266:	0f 84 6b 01 00 00    	je     3d7 <_zi_showMacTypeCreator+0x3d7>
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
     26c:	8a 43 03             	mov    0x3(%ebx),%al
     26f:	88 44 24 3f          	mov    %al,0x3f(%esp)
     273:	88 44 24 3a          	mov    %al,0x3a(%esp)
     277:	e9 57 ff ff ff       	jmp    1d3 <_zi_showMacTypeCreator+0x1d3>
     27c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     280:	8a 42 04             	mov    0x4(%edx),%al
     283:	88 c1                	mov    %al,%cl
     285:	8a 42 05             	mov    0x5(%edx),%al
     288:	88 44 24 3b          	mov    %al,0x3b(%esp)
     28c:	8a 42 06             	mov    0x6(%edx),%al
     28f:	88 44 24 3c          	mov    %al,0x3c(%esp)
     293:	8a 42 01             	mov    0x1(%edx),%al
     296:	88 44 24 39          	mov    %al,0x39(%esp)
     29a:	8a 42 02             	mov    0x2(%edx),%al
     29d:	88 44 24 34          	mov    %al,0x34(%esp)
     2a1:	8a 42 03             	mov    0x3(%edx),%al
     2a4:	88 44 24 3a          	mov    %al,0x3a(%esp)
     2a8:	8a 42 07             	mov    0x7(%edx),%al
     2ab:	88 44 24 3d          	mov    %al,0x3d(%esp)
static void zi_showMacTypeCreator(__G__ ebfield)
    __GDEF
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
     2af:	89 ea                	mov    %ebp,%edx
     2b1:	e9 ed fd ff ff       	jmp    a3 <_zi_showMacTypeCreator+0xa3>
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
     2b6:	0f b6 7c 24 3a       	movzbl 0x3a(%esp),%edi
     2bb:	81 e7 ff 00 00 00    	and    $0xff,%edi
     2c1:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
     2c8:	00 
     2c9:	89 3c 24             	mov    %edi,(%esp)
     2cc:	e8 00 00 00 00       	call   2d1 <_zi_showMacTypeCreator+0x2d1>
     2d1:	85 c0                	test   %eax,%eax
     2d3:	0f 84 95 fd ff ff    	je     6e <_zi_showMacTypeCreator+0x6e>
        isprint(native(ebfield[4])) && isprint(native(ebfield[5])) &&
     2d9:	8a 43 04             	mov    0x4(%ebx),%al
     2dc:	83 3e 01             	cmpl   $0x1,(%esi)
     2df:	88 c1                	mov    %al,%cl
     2e1:	0f 84 29 01 00 00    	je     410 <_zi_showMacTypeCreator+0x410>
     2e7:	89 c7                	mov    %eax,%edi
     2e9:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
     2f0:	00 
     2f1:	81 e7 ff 00 00 00    	and    $0xff,%edi
     2f7:	89 3c 24             	mov    %edi,(%esp)
     2fa:	e8 00 00 00 00       	call   2ff <_zi_showMacTypeCreator+0x2ff>
    __GDEF
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
     2ff:	85 c0                	test   %eax,%eax
     301:	0f 84 67 fd ff ff    	je     6e <_zi_showMacTypeCreator+0x6e>
        isprint(native(ebfield[4])) && isprint(native(ebfield[5])) &&
     307:	8a 43 05             	mov    0x5(%ebx),%al
     30a:	83 3e 01             	cmpl   $0x1,(%esi)
     30d:	88 44 24 3b          	mov    %al,0x3b(%esp)
     311:	89 c7                	mov    %eax,%edi
     313:	0f 85 6f 01 00 00    	jne    488 <_zi_showMacTypeCreator+0x488>
     319:	8a 53 01             	mov    0x1(%ebx),%dl
     31c:	8a 03                	mov    (%ebx),%al
     31e:	88 54 24 3e          	mov    %dl,0x3e(%esp)
     322:	8a 53 02             	mov    0x2(%ebx),%dl
     325:	89 d5                	mov    %edx,%ebp
     327:	8a 53 03             	mov    0x3(%ebx),%dl
     32a:	88 44 24 38          	mov    %al,0x38(%esp)
     32e:	8b 35 00 00 00 00    	mov    0x0,%esi
     334:	8a 43 04             	mov    0x4(%ebx),%al
     337:	88 54 24 3f          	mov    %dl,0x3f(%esp)
     33b:	89 fa                	mov    %edi,%edx
     33d:	8b 0e                	mov    (%esi),%ecx
     33f:	81 e2 ff 00 00 00    	and    $0xff,%edx
     345:	66 f7 04 51 57 01    	testw  $0x157,(%ecx,%edx,2)
     34b:	0f 84 2f 02 00 00    	je     580 <_zi_showMacTypeCreator+0x580>
        isprint(native(ebfield[6])) && isprint(native(ebfield[7]))) {
     351:	8a 53 06             	mov    0x6(%ebx),%dl
     354:	88 54 24 39          	mov    %dl,0x39(%esp)
     358:	88 54 24 3c          	mov    %dl,0x3c(%esp)
     35c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     360:	8a 54 24 39          	mov    0x39(%esp),%dl
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
        isprint(native(ebfield[4])) && isprint(native(ebfield[5])) &&
     364:	8b 0e                	mov    (%esi),%ecx
     366:	81 e2 ff 00 00 00    	and    $0xff,%edx
     36c:	66 f7 04 51 57 01    	testw  $0x157,(%ecx,%edx,2)
     372:	0f 84 67 02 00 00    	je     5df <_zi_showMacTypeCreator+0x5df>
        isprint(native(ebfield[6])) && isprint(native(ebfield[7]))) {
     378:	8a 53 07             	mov    0x7(%ebx),%dl
     37b:	88 54 24 3d          	mov    %dl,0x3d(%esp)
     37f:	8a 54 24 3d          	mov    0x3d(%esp),%dl
     383:	8b 1e                	mov    (%esi),%ebx
     385:	81 e2 ff 00 00 00    	and    $0xff,%edx
     38b:	66 8b 1c 53          	mov    (%ebx,%edx,2),%bx
     38f:	89 de                	mov    %ebx,%esi
     391:	81 e6 57 01 00 00    	and    $0x157,%esi
     397:	85 f6                	test   %esi,%esi
     399:	0f 85 5a 02 00 00    	jne    5f9 <_zi_showMacTypeCreator+0x5f9>
     39f:	88 c1                	mov    %al,%cl
     3a1:	89 f8                	mov    %edi,%eax
     3a3:	88 44 24 3b          	mov    %al,0x3b(%esp)
     3a7:	8a 44 24 39          	mov    0x39(%esp),%al
     3ab:	0f b6 74 24 38       	movzbl 0x38(%esp),%esi
     3b0:	88 44 24 3c          	mov    %al,0x3c(%esp)
     3b4:	8a 44 24 3e          	mov    0x3e(%esp),%al
     3b8:	88 44 24 39          	mov    %al,0x39(%esp)
     3bc:	89 e8                	mov    %ebp,%eax
     3be:	81 e6 ff 00 00 00    	and    $0xff,%esi
     3c4:	88 44 24 34          	mov    %al,0x34(%esp)
     3c8:	8a 44 24 3f          	mov    0x3f(%esp),%al
     3cc:	89 f2                	mov    %esi,%edx
     3ce:	88 44 24 3a          	mov    %al,0x3a(%esp)
     3d2:	e9 cc fc ff ff       	jmp    a3 <_zi_showMacTypeCreator+0xa3>
     3d7:	8a 44 24 38          	mov    0x38(%esp),%al
     3db:	25 ff 00 00 00       	and    $0xff,%eax
     3e0:	89 c2                	mov    %eax,%edx
     3e2:	8a 43 04             	mov    0x4(%ebx),%al
     3e5:	88 c1                	mov    %al,%cl
     3e7:	8a 43 05             	mov    0x5(%ebx),%al
     3ea:	88 44 24 3b          	mov    %al,0x3b(%esp)
     3ee:	8a 43 06             	mov    0x6(%ebx),%al
     3f1:	88 44 24 3c          	mov    %al,0x3c(%esp)
     3f5:	8a 44 24 3e          	mov    0x3e(%esp),%al
     3f9:	88 44 24 39          	mov    %al,0x39(%esp)
     3fd:	8a 43 03             	mov    0x3(%ebx),%al
     400:	88 44 24 3a          	mov    %al,0x3a(%esp)
     404:	8a 43 07             	mov    0x7(%ebx),%al
     407:	88 44 24 3d          	mov    %al,0x3d(%esp)
     40b:	e9 93 fc ff ff       	jmp    a3 <_zi_showMacTypeCreator+0xa3>
     410:	8a 13                	mov    (%ebx),%dl
     412:	8b 35 00 00 00 00    	mov    0x0,%esi
     418:	88 54 24 38          	mov    %dl,0x38(%esp)
     41c:	8a 53 01             	mov    0x1(%ebx),%dl
     41f:	88 54 24 3e          	mov    %dl,0x3e(%esp)
     423:	8a 53 02             	mov    0x2(%ebx),%dl
     426:	89 d5                	mov    %edx,%ebp
     428:	8a 53 03             	mov    0x3(%ebx),%dl
     42b:	88 54 24 3f          	mov    %dl,0x3f(%esp)
     42f:	31 d2                	xor    %edx,%edx
     431:	8b 3e                	mov    (%esi),%edi
     433:	88 c2                	mov    %al,%dl
    __GDEF
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
     435:	66 f7 04 57 57 01    	testw  $0x157,(%edi,%edx,2)
     43b:	0f 84 a0 00 00 00    	je     4e1 <_zi_showMacTypeCreator+0x4e1>
        isprint(native(ebfield[4])) && isprint(native(ebfield[5])) &&
     441:	0f b6 7b 05          	movzbl 0x5(%ebx),%edi
     445:	89 fa                	mov    %edi,%edx
     447:	88 54 24 3b          	mov    %dl,0x3b(%esp)
     44b:	e9 eb fe ff ff       	jmp    33b <_zi_showMacTypeCreator+0x33b>
     450:	8a 44 24 38          	mov    0x38(%esp),%al
     454:	25 ff 00 00 00       	and    $0xff,%eax
     459:	89 c2                	mov    %eax,%edx
     45b:	8a 43 04             	mov    0x4(%ebx),%al
     45e:	88 c1                	mov    %al,%cl
     460:	8a 43 05             	mov    0x5(%ebx),%al
     463:	88 44 24 3b          	mov    %al,0x3b(%esp)
     467:	8a 43 06             	mov    0x6(%ebx),%al
     46a:	88 44 24 3c          	mov    %al,0x3c(%esp)
     46e:	8a 44 24 3e          	mov    0x3e(%esp),%al
     472:	88 44 24 39          	mov    %al,0x39(%esp)
     476:	89 e8                	mov    %ebp,%eax
     478:	88 44 24 34          	mov    %al,0x34(%esp)
     47c:	8a 43 07             	mov    0x7(%ebx),%al
     47f:	88 44 24 3d          	mov    %al,0x3d(%esp)
     483:	e9 1b fc ff ff       	jmp    a3 <_zi_showMacTypeCreator+0xa3>
     488:	31 c9                	xor    %ecx,%ecx
     48a:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
     491:	00 
     492:	8a 4c 24 3b          	mov    0x3b(%esp),%cl
     496:	89 0c 24             	mov    %ecx,(%esp)
     499:	e8 00 00 00 00       	call   49e <_zi_showMacTypeCreator+0x49e>
     49e:	85 c0                	test   %eax,%eax
     4a0:	0f 84 c8 fb ff ff    	je     6e <_zi_showMacTypeCreator+0x6e>
        isprint(native(ebfield[6])) && isprint(native(ebfield[7]))) {
     4a6:	8a 43 06             	mov    0x6(%ebx),%al
     4a9:	83 3e 01             	cmpl   $0x1,(%esi)
     4ac:	88 44 24 3c          	mov    %al,0x3c(%esp)
     4b0:	88 44 24 39          	mov    %al,0x39(%esp)
     4b4:	75 6a                	jne    520 <_zi_showMacTypeCreator+0x520>
     4b6:	8a 53 01             	mov    0x1(%ebx),%dl
     4b9:	8a 03                	mov    (%ebx),%al
     4bb:	88 54 24 3e          	mov    %dl,0x3e(%esp)
     4bf:	8a 53 02             	mov    0x2(%ebx),%dl
     4c2:	89 d5                	mov    %edx,%ebp
     4c4:	8a 53 03             	mov    0x3(%ebx),%dl
     4c7:	88 44 24 38          	mov    %al,0x38(%esp)
     4cb:	8b 35 00 00 00 00    	mov    0x0,%esi
     4d1:	8a 43 04             	mov    0x4(%ebx),%al
     4d4:	88 54 24 3f          	mov    %dl,0x3f(%esp)
     4d8:	0f b6 7b 05          	movzbl 0x5(%ebx),%edi
     4dc:	e9 7f fe ff ff       	jmp    360 <_zi_showMacTypeCreator+0x360>
     4e1:	8a 44 24 38          	mov    0x38(%esp),%al
     4e5:	25 ff 00 00 00       	and    $0xff,%eax
     4ea:	89 c2                	mov    %eax,%edx
     4ec:	8a 43 05             	mov    0x5(%ebx),%al
     4ef:	88 44 24 3b          	mov    %al,0x3b(%esp)
     4f3:	8a 43 06             	mov    0x6(%ebx),%al
     4f6:	88 44 24 3c          	mov    %al,0x3c(%esp)
     4fa:	8a 44 24 3e          	mov    0x3e(%esp),%al
     4fe:	88 44 24 39          	mov    %al,0x39(%esp)
     502:	89 e8                	mov    %ebp,%eax
     504:	88 44 24 34          	mov    %al,0x34(%esp)
     508:	8a 44 24 3f          	mov    0x3f(%esp),%al
     50c:	88 44 24 3a          	mov    %al,0x3a(%esp)
     510:	8a 43 07             	mov    0x7(%ebx),%al
     513:	88 44 24 3d          	mov    %al,0x3d(%esp)
     517:	e9 87 fb ff ff       	jmp    a3 <_zi_showMacTypeCreator+0xa3>
     51c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     520:	31 c0                	xor    %eax,%eax
     522:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
     529:	00 
     52a:	8a 44 24 3c          	mov    0x3c(%esp),%al
     52e:	89 04 24             	mov    %eax,(%esp)
     531:	e8 00 00 00 00       	call   536 <_zi_showMacTypeCreator+0x536>
    uch *ebfield;
{
    /* not every Type / Creator character is printable */
    if (isprint(native(ebfield[0])) && isprint(native(ebfield[1])) &&
        isprint(native(ebfield[2])) && isprint(native(ebfield[3])) &&
        isprint(native(ebfield[4])) && isprint(native(ebfield[5])) &&
     536:	85 c0                	test   %eax,%eax
     538:	0f 84 30 fb ff ff    	je     6e <_zi_showMacTypeCreator+0x6e>
        isprint(native(ebfield[6])) && isprint(native(ebfield[7]))) {
     53e:	8a 43 07             	mov    0x7(%ebx),%al
     541:	83 3e 01             	cmpl   $0x1,(%esi)
     544:	88 44 24 3d          	mov    %al,0x3d(%esp)
     548:	75 4a                	jne    594 <_zi_showMacTypeCreator+0x594>
     54a:	8a 53 06             	mov    0x6(%ebx),%dl
     54d:	8a 03                	mov    (%ebx),%al
     54f:	88 54 24 39          	mov    %dl,0x39(%esp)
     553:	8a 53 01             	mov    0x1(%ebx),%dl
     556:	88 54 24 3e          	mov    %dl,0x3e(%esp)
     55a:	8a 53 02             	mov    0x2(%ebx),%dl
     55d:	89 d5                	mov    %edx,%ebp
     55f:	8a 53 03             	mov    0x3(%ebx),%dl
     562:	88 44 24 38          	mov    %al,0x38(%esp)
     566:	8b 35 00 00 00 00    	mov    0x0,%esi
     56c:	8a 43 04             	mov    0x4(%ebx),%al
     56f:	88 54 24 3f          	mov    %dl,0x3f(%esp)
     573:	0f b6 7b 05          	movzbl 0x5(%ebx),%edi
     577:	e9 03 fe ff ff       	jmp    37f <_zi_showMacTypeCreator+0x37f>
     57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     580:	0f b6 7c 24 38       	movzbl 0x38(%esp),%edi
     585:	81 e7 ff 00 00 00    	and    $0xff,%edi
     58b:	88 c1                	mov    %al,%cl
     58d:	89 fa                	mov    %edi,%edx
     58f:	e9 5f ff ff ff       	jmp    4f3 <_zi_showMacTypeCreator+0x4f3>
     594:	31 c0                	xor    %eax,%eax
     596:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
     59d:	00 
     59e:	8a 44 24 3d          	mov    0x3d(%esp),%al
     5a2:	89 04 24             	mov    %eax,(%esp)
     5a5:	e8 00 00 00 00       	call   5aa <_zi_showMacTypeCreator+0x5aa>
     5aa:	8a 53 06             	mov    0x6(%ebx),%dl
     5ad:	88 54 24 39          	mov    %dl,0x39(%esp)
     5b1:	8a 53 01             	mov    0x1(%ebx),%dl
     5b4:	89 c6                	mov    %eax,%esi
     5b6:	88 54 24 3e          	mov    %dl,0x3e(%esp)
     5ba:	8a 43 07             	mov    0x7(%ebx),%al
     5bd:	8a 53 02             	mov    0x2(%ebx),%dl
     5c0:	88 44 24 3d          	mov    %al,0x3d(%esp)
     5c4:	89 d5                	mov    %edx,%ebp
     5c6:	8a 03                	mov    (%ebx),%al
     5c8:	8a 53 03             	mov    0x3(%ebx),%dl
     5cb:	88 44 24 38          	mov    %al,0x38(%esp)
     5cf:	88 54 24 3f          	mov    %dl,0x3f(%esp)
     5d3:	8a 43 04             	mov    0x4(%ebx),%al
     5d6:	0f b6 7b 05          	movzbl 0x5(%ebx),%edi
     5da:	e9 b8 fd ff ff       	jmp    397 <_zi_showMacTypeCreator+0x397>
     5df:	0f b6 74 24 38       	movzbl 0x38(%esp),%esi
     5e4:	88 c1                	mov    %al,%cl
     5e6:	81 e6 ff 00 00 00    	and    $0xff,%esi
     5ec:	89 f8                	mov    %edi,%eax
     5ee:	89 f2                	mov    %esi,%edx
     5f0:	88 44 24 3b          	mov    %al,0x3b(%esp)
     5f4:	e9 01 ff ff ff       	jmp    4fa <_zi_showMacTypeCreator+0x4fa>
       Info(slide, 0, ((char *)slide, LoadFarString(MacOSdata),
     5f9:	8b 74 24 30          	mov    0x30(%esp),%esi
     5fd:	31 c9                	xor    %ecx,%ecx
     5ff:	8a 4c 24 38          	mov    0x38(%esp),%cl
     603:	8b 96 44 0b 01 00    	mov    0x10b44(%esi),%edx
     609:	8d 9e dc 08 00 00    	lea    0x8dc(%esi),%ebx
     60f:	89 54 24 34          	mov    %edx,0x34(%esp)
     613:	8a 54 24 3d          	mov    0x3d(%esp),%dl
     617:	81 e2 ff 00 00 00    	and    $0xff,%edx
     61d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
     621:	89 54 24 24          	mov    %edx,0x24(%esp)
     625:	31 d2                	xor    %edx,%edx
     627:	8a 54 24 39          	mov    0x39(%esp),%dl
     62b:	c7 44 24 04 40 0a 00 	movl   $0xa40,0x4(%esp)
     632:	00 
     633:	89 54 24 20          	mov    %edx,0x20(%esp)
     637:	89 fa                	mov    %edi,%edx
     639:	81 e2 ff 00 00 00    	and    $0xff,%edx
     63f:	89 c7                	mov    %eax,%edi
     641:	31 c0                	xor    %eax,%eax
     643:	89 54 24 1c          	mov    %edx,0x1c(%esp)
     647:	8a 44 24 3f          	mov    0x3f(%esp),%al
     64b:	89 ea                	mov    %ebp,%edx
     64d:	0f b6 6c 24 3e       	movzbl 0x3e(%esp),%ebp
     652:	89 44 24 14          	mov    %eax,0x14(%esp)
     656:	31 c0                	xor    %eax,%eax
     658:	88 d0                	mov    %dl,%al
     65a:	81 e7 ff 00 00 00    	and    $0xff,%edi
     660:	81 e5 ff 00 00 00    	and    $0xff,%ebp
     666:	89 7c 24 18          	mov    %edi,0x18(%esp)
     66a:	89 44 24 10          	mov    %eax,0x10(%esp)
     66e:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
     672:	89 1c 24             	mov    %ebx,(%esp)
     675:	e8 00 00 00 00       	call   67a <_zi_showMacTypeCreator+0x67a>
     67a:	8b 74 24 30          	mov    0x30(%esp),%esi
     67e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     685:	00 
     686:	89 44 24 08          	mov    %eax,0x8(%esp)
     68a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     68e:	89 34 24             	mov    %esi,(%esp)
     691:	ff 54 24 34          	call   *0x34(%esp)
     695:	83 ec 10             	sub    $0x10,%esp
     698:	e9 9f fa ff ff       	jmp    13c <_zi_showMacTypeCreator+0x13c>
     69d:	8d 76 00             	lea    0x0(%esi),%esi

000006a0 <_zi_time.isra.0>:

/************************/
/*  Function zi_time()  */
/************************/

static char *zi_time(__G__ datetimez, modtimez, d_t_str)
     6a0:	55                   	push   %ebp
     6a1:	57                   	push   %edi
     6a2:	56                   	push   %esi
     6a3:	53                   	push   %ebx
     6a4:	83 ec 5c             	sub    $0x5c,%esp
     6a7:	89 c7                	mov    %eax,%edi
     6a9:	89 cb                	mov    %ecx,%ebx
     6ab:	8b 44 24 70          	mov    0x70(%esp),%eax
     6af:	89 54 24 34          	mov    %edx,0x34(%esp)
    on values of lflag and T_flag.  If using Unix-time extra fields, convert
    to local time or not, depending on value of first character in d_t_str[].
  ---------------------------------------------------------------------------*/

#ifdef USE_EF_UT_TIME
    if (modtimez != NULL) {
     6b3:	85 c0                	test   %eax,%eax
     6b5:	0f 84 d5 01 00 00    	je     890 <_zi_time.isra.0+0x1f0>
#ifndef NO_GMTIME
        /* check for our secret message from above... */
        t = (d_t_str[0] == (char)1)? gmtime(modtimez) : localtime(modtimez);
     6bb:	8b 74 24 74          	mov    0x74(%esp),%esi
     6bf:	80 3e 01             	cmpb   $0x1,(%esi)
     6c2:	89 04 24             	mov    %eax,(%esp)
     6c5:	0f 84 b5 01 00 00    	je     880 <_zi_time.isra.0+0x1e0>
     6cb:	e8 00 00 00 00       	call   6d0 <_zi_time.isra.0+0x30>
#else
        t = localtime(modtimez);
#endif
        if (uO.lflag > 9 && t == (struct tm *)NULL)
     6d0:	83 3f 09             	cmpl   $0x9,(%edi)
     6d3:	0f 8f 97 00 00 00    	jg     770 <_zi_time.isra.0+0xd0>
             * return string with '?' instead of data
             */
            return (strcpy(d_t_str, LoadFarString(YMDHMSTimeError)));
    } else
        t = (struct tm *)NULL;
    if (t != (struct tm *)NULL) {
     6d9:	85 c0                	test   %eax,%eax
     6db:	0f 84 af 01 00 00    	je     890 <_zi_time.isra.0+0x1f0>
        mo = (unsigned)(t->tm_mon + 1);
     6e1:	8b 48 10             	mov    0x10(%eax),%ecx
        dy = (unsigned)(t->tm_mday);
     6e4:	8b 70 0c             	mov    0xc(%eax),%esi
        yr = (unsigned)(t->tm_year);
     6e7:	8b 50 14             	mov    0x14(%eax),%edx
            return (strcpy(d_t_str, LoadFarString(YMDHMSTimeError)));
    } else
        t = (struct tm *)NULL;
    if (t != (struct tm *)NULL) {
        mo = (unsigned)(t->tm_mon + 1);
        dy = (unsigned)(t->tm_mday);
     6ea:	89 74 24 2c          	mov    %esi,0x2c(%esp)
        yr = (unsigned)(t->tm_year);
     6ee:	89 54 24 30          	mov    %edx,0x30(%esp)
             */
            return (strcpy(d_t_str, LoadFarString(YMDHMSTimeError)));
    } else
        t = (struct tm *)NULL;
    if (t != (struct tm *)NULL) {
        mo = (unsigned)(t->tm_mon + 1);
     6f2:	8d 59 01             	lea    0x1(%ecx),%ebx
        dy = (unsigned)(t->tm_mday);
        yr = (unsigned)(t->tm_year);

        hh = (unsigned)(t->tm_hour);
     6f5:	8b 68 08             	mov    0x8(%eax),%ebp
        mm = (unsigned)(t->tm_min);
     6f8:	8b 50 04             	mov    0x4(%eax),%edx
        ss = (unsigned)(t->tm_sec);
     6fb:	8b 30                	mov    (%eax),%esi
        hh = (((unsigned)*datetimez >> 11) & 0x1f);
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
        ss = (((unsigned)*datetimez << 1) & 0x3e);
    }

    if (mo == 0 || mo > 12) {
     6fd:	8d 43 ff             	lea    -0x1(%ebx),%eax
     700:	83 f8 0b             	cmp    $0xb,%eax
        sprintf(monthbuf, LoadFarString(BogusFmt), mo);
        monthstr = monthbuf;
    } else
        monthstr = LoadFarStringSmall(month[mo-1]);
     703:	8d 0c 85 c0 04 00 00 	lea    0x4c0(,%eax,4),%ecx
        hh = (((unsigned)*datetimez >> 11) & 0x1f);
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
        ss = (((unsigned)*datetimez << 1) & 0x3e);
    }

    if (mo == 0 || mo > 12) {
     70a:	0f 87 f5 00 00 00    	ja     805 <_zi_time.isra.0+0x165>
        sprintf(monthbuf, LoadFarString(BogusFmt), mo);
        monthstr = monthbuf;
    } else
        monthstr = LoadFarStringSmall(month[mo-1]);

    if (uO.lflag > 9)   /* verbose listing format */
     710:	83 3f 09             	cmpl   $0x9,(%edi)
     713:	0f 8f 1d 01 00 00    	jg     836 <_zi_time.isra.0+0x196>
        sprintf(d_t_str, LoadFarString(YMDHMSTime), yr+1900, monthstr, dy, hh,
          mm, ss);
    else if (uO.T_flag)
     719:	8b 44 24 34          	mov    0x34(%esp),%eax
     71d:	8b 00                	mov    (%eax),%eax
     71f:	85 c0                	test   %eax,%eax
     721:	0f 85 99 00 00 00    	jne    7c0 <_zi_time.isra.0+0x120>
        sprintf(d_t_str, LoadFarString(DecimalTime), yr+1900, mo, dy, hh, mm,
          ss);
    else   /* was:  if ((uO.lflag >= 3) && (uO.lflag <= 5)) */
        sprintf(d_t_str, LoadFarString(DMYHMTime), dy, monthstr, yr%100, hh,
     727:	89 54 24 18          	mov    %edx,0x18(%esp)
     72b:	bb 64 00 00 00       	mov    $0x64,%ebx
     730:	8b 44 24 30          	mov    0x30(%esp),%eax
     734:	31 d2                	xor    %edx,%edx
     736:	f7 f3                	div    %ebx
     738:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     73c:	89 6c 24 14          	mov    %ebp,0x14(%esp)
     740:	89 44 24 08          	mov    %eax,0x8(%esp)
     744:	8b 44 24 74          	mov    0x74(%esp),%eax
     748:	89 54 24 10          	mov    %edx,0x10(%esp)
     74c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     750:	c7 44 24 04 1c 06 00 	movl   $0x61c,0x4(%esp)
     757:	00 
     758:	89 04 24             	mov    %eax,(%esp)
     75b:	e8 00 00 00 00       	call   760 <_zi_time.isra.0+0xc0>
          mm);

    return d_t_str;

} /* end function zi_time() */
     760:	8b 44 24 74          	mov    0x74(%esp),%eax
     764:	83 c4 5c             	add    $0x5c,%esp
     767:	5b                   	pop    %ebx
     768:	5e                   	pop    %esi
     769:	5f                   	pop    %edi
     76a:	5d                   	pop    %ebp
     76b:	c3                   	ret    
     76c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        /* check for our secret message from above... */
        t = (d_t_str[0] == (char)1)? gmtime(modtimez) : localtime(modtimez);
#else
        t = localtime(modtimez);
#endif
        if (uO.lflag > 9 && t == (struct tm *)NULL)
     770:	85 c0                	test   %eax,%eax
     772:	0f 85 69 ff ff ff    	jne    6e1 <_zi_time.isra.0+0x41>
            /* time conversion error in verbose listing format,
             * return string with '?' instead of data
             */
            return (strcpy(d_t_str, LoadFarString(YMDHMSTimeError)));
     778:	8b 7c 24 74          	mov    0x74(%esp),%edi
     77c:	be 00 00 00 00       	mov    $0x0,%esi
     781:	b0 15                	mov    $0x15,%al
     783:	f7 c7 01 00 00 00    	test   $0x1,%edi
     789:	0f 85 52 01 00 00    	jne    8e1 <_zi_time.isra.0+0x241>
     78f:	f7 c7 02 00 00 00    	test   $0x2,%edi
     795:	0f 85 31 01 00 00    	jne    8cc <_zi_time.isra.0+0x22c>
     79b:	89 c1                	mov    %eax,%ecx
     79d:	31 d2                	xor    %edx,%edx
     79f:	c1 e9 02             	shr    $0x2,%ecx
     7a2:	a8 02                	test   $0x2,%al
     7a4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     7a6:	74 0b                	je     7b3 <_zi_time.isra.0+0x113>
     7a8:	66 8b 16             	mov    (%esi),%dx
     7ab:	66 89 17             	mov    %dx,(%edi)
     7ae:	ba 02 00 00 00       	mov    $0x2,%edx
     7b3:	a8 01                	test   $0x1,%al
     7b5:	74 a9                	je     760 <_zi_time.isra.0+0xc0>
     7b7:	8a 04 16             	mov    (%esi,%edx,1),%al
     7ba:	88 04 17             	mov    %al,(%edi,%edx,1)
     7bd:	eb a1                	jmp    760 <_zi_time.isra.0+0xc0>
     7bf:	90                   	nop

    if (uO.lflag > 9)   /* verbose listing format */
        sprintf(d_t_str, LoadFarString(YMDHMSTime), yr+1900, monthstr, dy, hh,
          mm, ss);
    else if (uO.T_flag)
        sprintf(d_t_str, LoadFarString(DecimalTime), yr+1900, mo, dy, hh, mm,
     7c0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     7c4:	89 74 24 1c          	mov    %esi,0x1c(%esp)
     7c8:	89 44 24 10          	mov    %eax,0x10(%esp)
     7cc:	8b 44 24 30          	mov    0x30(%esp),%eax
     7d0:	05 6c 07 00 00       	add    $0x76c,%eax
     7d5:	89 6c 24 14          	mov    %ebp,0x14(%esp)
     7d9:	89 44 24 08          	mov    %eax,0x8(%esp)
     7dd:	8b 44 24 74          	mov    0x74(%esp),%eax
     7e1:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
     7e5:	89 54 24 18          	mov    %edx,0x18(%esp)
     7e9:	c7 44 24 04 e8 05 00 	movl   $0x5e8,0x4(%esp)
     7f0:	00 
     7f1:	89 04 24             	mov    %eax,(%esp)
     7f4:	e8 00 00 00 00       	call   7f9 <_zi_time.isra.0+0x159>
        sprintf(d_t_str, LoadFarString(DMYHMTime), dy, monthstr, yr%100, hh,
          mm);

    return d_t_str;

} /* end function zi_time() */
     7f9:	8b 44 24 74          	mov    0x74(%esp),%eax
     7fd:	83 c4 5c             	add    $0x5c,%esp
     800:	5b                   	pop    %ebx
     801:	5e                   	pop    %esi
     802:	5f                   	pop    %edi
     803:	5d                   	pop    %ebp
     804:	c3                   	ret    
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
        ss = (((unsigned)*datetimez << 1) & 0x3e);
    }

    if (mo == 0 || mo > 12) {
        sprintf(monthbuf, LoadFarString(BogusFmt), mo);
     805:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
     809:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     80d:	89 0c 24             	mov    %ecx,(%esp)
     810:	c7 44 24 04 34 06 00 	movl   $0x634,0x4(%esp)
     817:	00 
     818:	89 54 24 3c          	mov    %edx,0x3c(%esp)
     81c:	89 4c 24 38          	mov    %ecx,0x38(%esp)
     820:	e8 00 00 00 00       	call   825 <_zi_time.isra.0+0x185>
        monthstr = monthbuf;
     825:	8b 4c 24 38          	mov    0x38(%esp),%ecx
     829:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    } else
        monthstr = LoadFarStringSmall(month[mo-1]);

    if (uO.lflag > 9)   /* verbose listing format */
     82d:	83 3f 09             	cmpl   $0x9,(%edi)
     830:	0f 8e e3 fe ff ff    	jle    719 <_zi_time.isra.0+0x79>
        sprintf(d_t_str, LoadFarString(YMDHMSTime), yr+1900, monthstr, dy, hh,
     836:	8b 44 24 2c          	mov    0x2c(%esp),%eax
     83a:	89 74 24 1c          	mov    %esi,0x1c(%esp)
     83e:	89 44 24 10          	mov    %eax,0x10(%esp)
     842:	8b 44 24 30          	mov    0x30(%esp),%eax
     846:	05 6c 07 00 00       	add    $0x76c,%eax
     84b:	89 6c 24 14          	mov    %ebp,0x14(%esp)
     84f:	89 44 24 08          	mov    %eax,0x8(%esp)
     853:	8b 44 24 74          	mov    0x74(%esp),%eax
     857:	89 54 24 18          	mov    %edx,0x18(%esp)
     85b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     85f:	c7 44 24 04 04 06 00 	movl   $0x604,0x4(%esp)
     866:	00 
     867:	89 04 24             	mov    %eax,(%esp)
     86a:	e8 00 00 00 00       	call   86f <_zi_time.isra.0+0x1cf>
        sprintf(d_t_str, LoadFarString(DMYHMTime), dy, monthstr, yr%100, hh,
          mm);

    return d_t_str;

} /* end function zi_time() */
     86f:	8b 44 24 74          	mov    0x74(%esp),%eax
     873:	83 c4 5c             	add    $0x5c,%esp
     876:	5b                   	pop    %ebx
     877:	5e                   	pop    %esi
     878:	5f                   	pop    %edi
     879:	5d                   	pop    %ebp
     87a:	c3                   	ret    
     87b:	90                   	nop
     87c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

#ifdef USE_EF_UT_TIME
    if (modtimez != NULL) {
#ifndef NO_GMTIME
        /* check for our secret message from above... */
        t = (d_t_str[0] == (char)1)? gmtime(modtimez) : localtime(modtimez);
     880:	e8 00 00 00 00       	call   885 <_zi_time.isra.0+0x1e5>
     885:	e9 46 fe ff ff       	jmp    6d0 <_zi_time.isra.0+0x30>
     88a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        mm = (unsigned)(t->tm_min);
        ss = (unsigned)(t->tm_sec);
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
     890:	8b 33                	mov    (%ebx),%esi
     892:	89 f0                	mov    %esi,%eax
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
     894:	89 f3                	mov    %esi,%ebx
        mm = (unsigned)(t->tm_min);
        ss = (unsigned)(t->tm_sec);
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
     896:	c1 e8 19             	shr    $0x19,%eax
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);

        hh = (((unsigned)*datetimez >> 11) & 0x1f);
     899:	89 f5                	mov    %esi,%ebp
        mm = (unsigned)(t->tm_min);
        ss = (unsigned)(t->tm_sec);
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
     89b:	83 c0 50             	add    $0x50,%eax
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);

        hh = (((unsigned)*datetimez >> 11) & 0x1f);
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
     89e:	89 f2                	mov    %esi,%edx
        ss = (unsigned)(t->tm_sec);
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
     8a0:	c1 eb 15             	shr    $0x15,%ebx
        mm = (unsigned)(t->tm_min);
        ss = (unsigned)(t->tm_sec);
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
     8a3:	89 44 24 30          	mov    %eax,0x30(%esp)
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);
     8a7:	89 f0                	mov    %esi,%eax

        hh = (((unsigned)*datetimez >> 11) & 0x1f);
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
        ss = (((unsigned)*datetimez << 1) & 0x3e);
     8a9:	01 f6                	add    %esi,%esi
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);
     8ab:	c1 e8 10             	shr    $0x10,%eax
        ss = (unsigned)(t->tm_sec);
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
     8ae:	83 e3 0f             	and    $0xf,%ebx
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);
     8b1:	83 e0 1f             	and    $0x1f,%eax

        hh = (((unsigned)*datetimez >> 11) & 0x1f);
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
        ss = (((unsigned)*datetimez << 1) & 0x3e);
     8b4:	83 e6 3e             	and    $0x3e,%esi
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);

        hh = (((unsigned)*datetimez >> 11) & 0x1f);
     8b7:	c1 ed 0b             	shr    $0xb,%ebp
    } else
#endif /* USE_EF_UT_TIME */
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);
     8ba:	89 44 24 2c          	mov    %eax,0x2c(%esp)

        hh = (((unsigned)*datetimez >> 11) & 0x1f);
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
     8be:	c1 ea 05             	shr    $0x5,%edx
    {
        yr = ((unsigned)(*datetimez >> 25) & 0x7f) + 80;
        mo = ((unsigned)(*datetimez >> 21) & 0x0f);
        dy = ((unsigned)(*datetimez >> 16) & 0x1f);

        hh = (((unsigned)*datetimez >> 11) & 0x1f);
     8c1:	83 e5 1f             	and    $0x1f,%ebp
        mm = (((unsigned)*datetimez >> 5) & 0x3f);
     8c4:	83 e2 3f             	and    $0x3f,%edx
     8c7:	e9 31 fe ff ff       	jmp    6fd <_zi_time.isra.0+0x5d>
#endif
        if (uO.lflag > 9 && t == (struct tm *)NULL)
            /* time conversion error in verbose listing format,
             * return string with '?' instead of data
             */
            return (strcpy(d_t_str, LoadFarString(YMDHMSTimeError)));
     8cc:	66 8b 16             	mov    (%esi),%dx
     8cf:	83 c7 02             	add    $0x2,%edi
     8d2:	66 89 57 fe          	mov    %dx,-0x2(%edi)
     8d6:	83 c6 02             	add    $0x2,%esi
     8d9:	83 e8 02             	sub    $0x2,%eax
     8dc:	e9 ba fe ff ff       	jmp    79b <_zi_time.isra.0+0xfb>
     8e1:	a0 00 00 00 00       	mov    0x0,%al
     8e6:	be 01 00 00 00       	mov    $0x1,%esi
     8eb:	88 07                	mov    %al,(%edi)
     8ed:	8b 44 24 74          	mov    0x74(%esp),%eax
     8f1:	8d 78 01             	lea    0x1(%eax),%edi
     8f4:	b8 14 00 00 00       	mov    $0x14,%eax
     8f9:	e9 91 fe ff ff       	jmp    78f <_zi_time.isra.0+0xef>
     8fe:	66 90                	xchg   %ax,%ax

00000900 <_zi_end_central>:
/*  Function zi_end_central()  */
/*******************************/

int zi_end_central(__G)   /* return PK-type error code */
    __GDEF
{
     900:	55                   	push   %ebp
     901:	57                   	push   %edi
     902:	56                   	push   %esi
     903:	53                   	push   %ebx
     904:	83 ec 3c             	sub    $0x3c,%esp
     907:	8b 5c 24 50          	mov    0x50(%esp),%ebx
/*---------------------------------------------------------------------------
    Print out various interesting things about the zipfile.
  ---------------------------------------------------------------------------*/

    /* header fits on one line, for anything up to 10GB and 10000 files: */
    if (uO.hflag)
     90b:	8b 53 20             	mov    0x20(%ebx),%edx
     90e:	85 d2                	test   %edx,%edx
     910:	0f 84 97 00 00 00    	je     9ad <_zi_end_central+0xad>
        Info(slide, 0, ((char *)slide, ((int)strlen(G.zipfn) < 39)?
     916:	8b 83 44 0b 01 00    	mov    0x10b44(%ebx),%eax
     91c:	66 8b 93 6e 09 01 00 	mov    0x1096e(%ebx),%dx
     923:	89 44 24 24          	mov    %eax,0x24(%esp)
     927:	bf c8 1f 00 00       	mov    $0x1fc8,%edi
     92c:	b8 c6 1f 00 00       	mov    $0x1fc6,%eax
     931:	8b 8b 0c 09 01 00    	mov    0x1090c(%ebx),%ecx
     937:	66 83 fa 01          	cmp    $0x1,%dx
     93b:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
     93f:	0f 45 f8             	cmovne %eax,%edi
     942:	31 f6                	xor    %esi,%esi
     944:	bd a0 1f 00 00       	mov    $0x1fa0,%ebp
     949:	66 89 d6             	mov    %dx,%si
     94c:	8b 93 04 09 01 00    	mov    0x10904(%ebx),%edx
     952:	89 14 24             	mov    %edx,(%esp)
     955:	89 54 24 28          	mov    %edx,0x28(%esp)
     959:	e8 00 00 00 00       	call   95e <_zi_end_central+0x5e>
     95e:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
     962:	83 f8 27             	cmp    $0x27,%eax
     965:	b8 68 1f 00 00       	mov    $0x1f68,%eax
     96a:	0f 4c c5             	cmovl  %ebp,%eax
     96d:	8b 54 24 28          	mov    0x28(%esp),%edx
     971:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     977:	89 7c 24 14          	mov    %edi,0x14(%esp)
     97b:	89 74 24 10          	mov    %esi,0x10(%esp)
     97f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     983:	89 54 24 08          	mov    %edx,0x8(%esp)
     987:	89 44 24 04          	mov    %eax,0x4(%esp)
     98b:	89 2c 24             	mov    %ebp,(%esp)
     98e:	e8 00 00 00 00       	call   993 <_zi_end_central+0x93>
     993:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     99a:	00 
     99b:	89 44 24 08          	mov    %eax,0x8(%esp)
     99f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     9a3:	89 1c 24             	mov    %ebx,(%esp)
     9a6:	ff 54 24 24          	call   *0x24(%esp)
     9aa:	83 ec 10             	sub    $0x10,%esp
          (long)G.ziplen, G.ecrec.total_entries_central_dir,
          (G.ecrec.total_entries_central_dir==1)?
          nullStr : PlurSufx));

    /* verbose format */
    if (uO.lflag > 9) {
     9ad:	83 7b 28 09          	cmpl   $0x9,0x28(%ebx)
     9b1:	0f 8f 20 00 00 00    	jg     9d7 <_zi_end_central+0xd7>
                Info(slide, 0, ((char *)slide,
                  LoadFarString(ZipfileCommTrunc2)));
        } /* endif (comment exists) */

    /* non-verbose mode:  print zipfile comment only if requested */
    } else if (uO.zflag && G.ecrec.zipfile_comment_length) {
     9b7:	8b 43 60             	mov    0x60(%ebx),%eax
     9ba:	85 c0                	test   %eax,%eax
     9bc:	74 0f                	je     9cd <_zi_end_central+0xcd>
     9be:	8b b3 78 09 01 00    	mov    0x10978(%ebx),%esi
     9c4:	66 85 f6             	test   %si,%si
     9c7:	0f 85 cb 03 00 00    	jne    d98 <_zi_end_central+0x498>
        }
    } /* endif (verbose) */

    return error;

} /* end function zi_end_central() */
     9cd:	83 c4 3c             	add    $0x3c,%esp
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
     9d0:	31 c0                	xor    %eax,%eax
        }
    } /* endif (verbose) */

    return error;

} /* end function zi_end_central() */
     9d2:	5b                   	pop    %ebx
     9d3:	5e                   	pop    %esi
     9d4:	5f                   	pop    %edi
     9d5:	5d                   	pop    %ebp
     9d6:	c3                   	ret    
          (G.ecrec.total_entries_central_dir==1)?
          nullStr : PlurSufx));

    /* verbose format */
    if (uO.lflag > 9) {
        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));
     9d7:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     9dd:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     9e3:	89 ef                	mov    %ebp,%edi
     9e5:	be 2c 00 00 00       	mov    $0x2c,%esi
     9ea:	b8 23 00 00 00       	mov    $0x23,%eax
     9ef:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     9f5:	0f 85 05 06 00 00    	jne    1000 <_zi_end_central+0x700>
     9fb:	f7 c7 02 00 00 00    	test   $0x2,%edi
     a01:	0f 85 19 06 00 00    	jne    1020 <_zi_end_central+0x720>
     a07:	89 c1                	mov    %eax,%ecx
     a09:	c1 e9 02             	shr    $0x2,%ecx
     a0c:	a8 02                	test   $0x2,%al
     a0e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     a10:	0f 85 aa 04 00 00    	jne    ec0 <_zi_end_central+0x5c0>
     a16:	a8 01                	test   $0x1,%al
     a18:	0f 85 97 04 00 00    	jne    eb5 <_zi_end_central+0x5b5>
     a1e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     a25:	00 
     a26:	c7 44 24 08 22 00 00 	movl   $0x22,0x8(%esp)
     a2d:	00 
     a2e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     a32:	89 1c 24             	mov    %ebx,(%esp)
     a35:	ff d2                	call   *%edx
        Info(slide, 0, ((char *)slide, LoadFarString(LineSeparators)));
     a37:	89 ef                	mov    %ebp,%edi
          (G.ecrec.total_entries_central_dir==1)?
          nullStr : PlurSufx));

    /* verbose format */
    if (uO.lflag > 9) {
        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));
     a39:	83 ec 10             	sub    $0x10,%esp
        Info(slide, 0, ((char *)slide, LoadFarString(LineSeparators)));
     a3c:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     a42:	be 50 00 00 00       	mov    $0x50,%esi
     a47:	b8 22 00 00 00       	mov    $0x22,%eax
     a4c:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     a52:	0f 85 dd 05 00 00    	jne    1035 <_zi_end_central+0x735>
     a58:	f7 c7 02 00 00 00    	test   $0x2,%edi
     a5e:	0f 85 f1 05 00 00    	jne    1055 <_zi_end_central+0x755>
     a64:	89 c1                	mov    %eax,%ecx
     a66:	c1 e9 02             	shr    $0x2,%ecx
     a69:	a8 02                	test   $0x2,%al
     a6b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     a6d:	0f 85 2d 04 00 00    	jne    ea0 <_zi_end_central+0x5a0>
     a73:	a8 01                	test   $0x1,%al
     a75:	0f 85 15 04 00 00    	jne    e90 <_zi_end_central+0x590>
     a7b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     a82:	00 
     a83:	c7 44 24 08 21 00 00 	movl   $0x21,0x8(%esp)
     a8a:	00 
     a8b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     a8f:	89 1c 24             	mov    %ebx,(%esp)
     a92:	ff d2                	call   *%edx

        Info(slide, 0, ((char *)slide, LoadFarString(ActOffsetCentDir),
     a94:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
          nullStr : PlurSufx));

    /* verbose format */
    if (uO.lflag > 9) {
        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));
        Info(slide, 0, ((char *)slide, LoadFarString(LineSeparators)));
     a9a:	83 ec 10             	sub    $0x10,%esp

        Info(slide, 0, ((char *)slide, LoadFarString(ActOffsetCentDir),
     a9d:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
     aa3:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     aa9:	89 54 24 14          	mov    %edx,0x14(%esp)
     aad:	89 54 24 10          	mov    %edx,0x10(%esp)
     ab1:	89 44 24 0c          	mov    %eax,0xc(%esp)
     ab5:	89 44 24 08          	mov    %eax,0x8(%esp)
     ab9:	c7 44 24 04 a0 1e 00 	movl   $0x1ea0,0x4(%esp)
     ac0:	00 
     ac1:	89 2c 24             	mov    %ebp,(%esp)
     ac4:	e8 00 00 00 00       	call   ac9 <_zi_end_central+0x1c9>
     ac9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     ad0:	00 
     ad1:	89 44 24 08          	mov    %eax,0x8(%esp)
     ad5:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     ad9:	89 1c 24             	mov    %ebx,(%esp)
     adc:	ff d6                	call   *%esi
          (long)G.real_ecrec_offset, (long)G.real_ecrec_offset,
          (long)G.expect_ecrec_offset, (long)G.expect_ecrec_offset));

        if (G.ecrec.number_this_disk == 0) {
     ade:	8b 83 68 09 01 00    	mov    0x10968(%ebx),%eax
    /* verbose format */
    if (uO.lflag > 9) {
        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));
        Info(slide, 0, ((char *)slide, LoadFarString(LineSeparators)));

        Info(slide, 0, ((char *)slide, LoadFarString(ActOffsetCentDir),
     ae4:	83 ec 10             	sub    $0x10,%esp
          (long)G.real_ecrec_offset, (long)G.real_ecrec_offset,
          (long)G.expect_ecrec_offset, (long)G.expect_ecrec_offset));

        if (G.ecrec.number_this_disk == 0) {
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive1),
     ae7:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi

        Info(slide, 0, ((char *)slide, LoadFarString(ActOffsetCentDir),
          (long)G.real_ecrec_offset, (long)G.real_ecrec_offset,
          (long)G.expect_ecrec_offset, (long)G.expect_ecrec_offset));

        if (G.ecrec.number_this_disk == 0) {
     aed:	66 85 c0             	test   %ax,%ax
     af0:	66 89 44 24 24       	mov    %ax,0x24(%esp)
     af5:	0f 84 15 03 00 00    	je     e10 <_zi_end_central+0x510>
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive2),
              G.ecrec.offset_start_central_directory,
              G.ecrec.offset_start_central_directory));
        } else {
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive1),
     afb:	8b 83 6c 09 01 00    	mov    0x1096c(%ebx),%eax
     b01:	bf 26 00 00 00       	mov    $0x26,%edi
     b06:	66 83 f8 01          	cmp    $0x1,%ax
     b0a:	b9 23 00 00 00       	mov    $0x23,%ecx
     b0f:	0f 45 cf             	cmovne %edi,%ecx
     b12:	31 d2                	xor    %edx,%edx
     b14:	89 4c 24 14          	mov    %ecx,0x14(%esp)
     b18:	66 89 c2             	mov    %ax,%dx
     b1b:	31 c0                	xor    %eax,%eax
     b1d:	89 54 24 10          	mov    %edx,0x10(%esp)
     b21:	31 d2                	xor    %edx,%edx
     b23:	66 8b 93 6a 09 01 00 	mov    0x1096a(%ebx),%dx
     b2a:	66 8b 44 24 24       	mov    0x24(%esp),%ax
     b2f:	42                   	inc    %edx
     b30:	40                   	inc    %eax
     b31:	89 54 24 0c          	mov    %edx,0xc(%esp)
     b35:	89 44 24 08          	mov    %eax,0x8(%esp)
     b39:	c7 44 24 04 e0 1c 00 	movl   $0x1ce0,0x4(%esp)
     b40:	00 
     b41:	89 2c 24             	mov    %ebp,(%esp)
     b44:	e8 00 00 00 00       	call   b49 <_zi_end_central+0x249>
     b49:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     b50:	00 
     b51:	89 44 24 08          	mov    %eax,0x8(%esp)
     b55:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     b59:	89 1c 24             	mov    %ebx,(%esp)
              G.ecrec.number_this_disk + 1,
              G.ecrec.num_disk_start_cdir + 1,
              G.ecrec.num_entries_centrl_dir_ths_disk,
              (G.ecrec.num_entries_centrl_dir_ths_disk == 1)? "is" : "are"));
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive2),
     b5c:	bf 1b 00 00 00       	mov    $0x1b,%edi
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive2),
              G.ecrec.offset_start_central_directory,
              G.ecrec.offset_start_central_directory));
        } else {
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive1),
     b61:	ff d6                	call   *%esi
              G.ecrec.number_this_disk + 1,
              G.ecrec.num_disk_start_cdir + 1,
              G.ecrec.num_entries_centrl_dir_ths_disk,
              (G.ecrec.num_entries_centrl_dir_ths_disk == 1)? "is" : "are"));
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive2),
     b63:	66 8b 83 6e 09 01 00 	mov    0x1096e(%ebx),%ax
     b6a:	ba 15 00 00 00       	mov    $0x15,%edx
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive2),
              G.ecrec.offset_start_central_directory,
              G.ecrec.offset_start_central_directory));
        } else {
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive1),
     b6f:	83 ec 10             	sub    $0x10,%esp
              G.ecrec.number_this_disk + 1,
              G.ecrec.num_disk_start_cdir + 1,
              G.ecrec.num_entries_centrl_dir_ths_disk,
              (G.ecrec.num_entries_centrl_dir_ths_disk == 1)? "is" : "are"));
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive2),
     b72:	66 83 f8 01          	cmp    $0x1,%ax
     b76:	8b 8b 70 09 01 00    	mov    0x10970(%ebx),%ecx
     b7c:	0f 45 d7             	cmovne %edi,%edx
     b7f:	89 c7                	mov    %eax,%edi
     b81:	31 c0                	xor    %eax,%eax
     b83:	66 89 f8             	mov    %di,%ax
     b86:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     b8c:	89 4c 24 14          	mov    %ecx,0x14(%esp)
     b90:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     b94:	89 54 24 0c          	mov    %edx,0xc(%esp)
     b98:	89 44 24 08          	mov    %eax,0x8(%esp)
     b9c:	c7 44 24 04 40 1c 00 	movl   $0x1c40,0x4(%esp)
     ba3:	00 
     ba4:	89 2c 24             	mov    %ebp,(%esp)
     ba7:	e8 00 00 00 00       	call   bac <_zi_end_central+0x2ac>
     bac:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     bb3:	00 
     bb4:	89 44 24 08          	mov    %eax,0x8(%esp)
     bb8:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     bbc:	89 1c 24             	mov    %ebx,(%esp)
     bbf:	ff d6                	call   *%esi
              G.ecrec.total_entries_central_dir,
              (G.ecrec.total_entries_central_dir == 1) ? "entry" : "entries",
              G.ecrec.size_central_directory,
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive3),
     bc1:	8b 83 74 09 01 00    	mov    0x10974(%ebx),%eax
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive1),
              G.ecrec.number_this_disk + 1,
              G.ecrec.num_disk_start_cdir + 1,
              G.ecrec.num_entries_centrl_dir_ths_disk,
              (G.ecrec.num_entries_centrl_dir_ths_disk == 1)? "is" : "are"));
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive2),
     bc7:	83 ec 10             	sub    $0x10,%esp
              G.ecrec.total_entries_central_dir,
              (G.ecrec.total_entries_central_dir == 1) ? "entry" : "entries",
              G.ecrec.size_central_directory,
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive3),
     bca:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     bd0:	89 44 24 0c          	mov    %eax,0xc(%esp)
     bd4:	89 44 24 08          	mov    %eax,0x8(%esp)
     bd8:	c7 44 24 04 e0 1b 00 	movl   $0x1be0,0x4(%esp)
     bdf:	00 
     be0:	89 2c 24             	mov    %ebp,(%esp)
     be3:	e8 00 00 00 00       	call   be8 <_zi_end_central+0x2e8>
     be8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     bef:	00 
     bf0:	89 44 24 08          	mov    %eax,0x8(%esp)
     bf4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     bf8:	89 1c 24             	mov    %ebx,(%esp)
     bfb:	ff d6                	call   *%esi
        Get the zipfile comment, if any, and print it out.  (Comment may be
        up to 64KB long.  May the fleas of a thousand camels infest the arm-
        pits of anyone who actually takes advantage of this fact.)
      -----------------------------------------------------------------------*/

        if (!G.ecrec.zipfile_comment_length)
     bfd:	8b bb 78 09 01 00    	mov    0x10978(%ebx),%edi
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive2),
              G.ecrec.total_entries_central_dir,
              (G.ecrec.total_entries_central_dir == 1) ? "entry" : "entries",
              G.ecrec.size_central_directory,
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive3),
     c03:	83 ec 10             	sub    $0x10,%esp
        Get the zipfile comment, if any, and print it out.  (Comment may be
        up to 64KB long.  May the fleas of a thousand camels infest the arm-
        pits of anyone who actually takes advantage of this fact.)
      -----------------------------------------------------------------------*/

        if (!G.ecrec.zipfile_comment_length)
     c06:	66 85 ff             	test   %di,%di
     c09:	0f 84 c6 02 00 00    	je     ed5 <_zi_end_central+0x5d5>
            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));
        else {
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
     c0f:	31 c0                	xor    %eax,%eax
     c11:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     c17:	66 89 f8             	mov    %di,%ax
     c1a:	c7 44 24 04 80 1b 00 	movl   $0x1b80,0x4(%esp)
     c21:	00 
     c22:	89 44 24 08          	mov    %eax,0x8(%esp)
     c26:	89 2c 24             	mov    %ebp,(%esp)
     c29:	e8 00 00 00 00       	call   c2e <_zi_end_central+0x32e>
     c2e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     c35:	00 
     c36:	89 44 24 08          	mov    %eax,0x8(%esp)
     c3a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     c3e:	89 1c 24             	mov    %ebx,(%esp)
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
     c41:	89 ef                	mov    %ebp,%edi
      -----------------------------------------------------------------------*/

        if (!G.ecrec.zipfile_comment_length)
            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));
        else {
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
     c43:	ff d6                	call   *%esi
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
     c45:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
      -----------------------------------------------------------------------*/

        if (!G.ecrec.zipfile_comment_length)
            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));
        else {
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
     c4b:	83 ec 10             	sub    $0x10,%esp
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
     c4e:	be 74 00 00 00       	mov    $0x74,%esi
     c53:	b8 4c 00 00 00       	mov    $0x4c,%eax
     c58:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     c5e:	0f 85 0c 04 00 00    	jne    1070 <_zi_end_central+0x770>
     c64:	f7 c7 02 00 00 00    	test   $0x2,%edi
     c6a:	0f 85 20 04 00 00    	jne    1090 <_zi_end_central+0x790>
     c70:	89 c1                	mov    %eax,%ecx
     c72:	c1 e9 02             	shr    $0x2,%ecx
     c75:	a8 02                	test   $0x2,%al
     c77:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     c79:	74 0b                	je     c86 <_zi_end_central+0x386>
     c7b:	66 8b 0e             	mov    (%esi),%cx
     c7e:	66 89 0f             	mov    %cx,(%edi)
     c81:	b9 02 00 00 00       	mov    $0x2,%ecx
     c86:	a8 01                	test   $0x1,%al
     c88:	74 06                	je     c90 <_zi_end_central+0x390>
     c8a:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     c8d:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     c90:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     c97:	00 
     c98:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
     c9f:	00 
     ca0:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     ca4:	89 1c 24             	mov    %ebx,(%esp)
     ca7:	ff d2                	call   *%edx
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
     ca9:	31 c0                	xor    %eax,%eax
        if (!G.ecrec.zipfile_comment_length)
            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));
        else {
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
     cab:	83 ec 10             	sub    $0x10,%esp
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
     cae:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
     cb5:	00 
     cb6:	66 8b 83 78 09 01 00 	mov    0x10978(%ebx),%ax
     cbd:	89 1c 24             	mov    %ebx,(%esp)
     cc0:	89 44 24 04          	mov    %eax,0x4(%esp)
     cc4:	e8 00 00 00 00       	call   cc9 <_zi_end_central+0x3c9>
     cc9:	85 c0                	test   %eax,%eax
     ccb:	0f 84 6f 02 00 00    	je     f40 <_zi_end_central+0x640>
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
     cd1:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     cd7:	89 ef                	mov    %ebp,%edi
     cd9:	be c0 00 00 00       	mov    $0xc0,%esi
     cde:	b8 4c 00 00 00       	mov    $0x4c,%eax
     ce3:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     ce9:	0f 85 3b 04 00 00    	jne    112a <_zi_end_central+0x82a>
     cef:	f7 c7 02 00 00 00    	test   $0x2,%edi
     cf5:	0f 85 6f 04 00 00    	jne    116a <_zi_end_central+0x86a>
     cfb:	89 c1                	mov    %eax,%ecx
     cfd:	c1 e9 02             	shr    $0x2,%ecx
     d00:	a8 02                	test   $0x2,%al
     d02:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     d04:	0f 85 c6 02 00 00    	jne    fd0 <_zi_end_central+0x6d0>
     d0a:	a8 01                	test   $0x1,%al
     d0c:	0f 85 ae 02 00 00    	jne    fc0 <_zi_end_central+0x6c0>
     d12:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     d19:	00 
     d1a:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
     d21:	00 
     d22:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     d26:	89 1c 24             	mov    %ebx,(%esp)
     d29:	ff d2                	call   *%edx
            if (error)
                Info(slide, 0, ((char *)slide,
     d2b:	89 ef                	mov    %ebp,%edi
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
     d2d:	83 ec 10             	sub    $0x10,%esp
            if (error)
                Info(slide, 0, ((char *)slide,
     d30:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     d36:	be 0c 01 00 00       	mov    $0x10c,%esi
     d3b:	b8 26 00 00 00       	mov    $0x26,%eax
     d40:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     d46:	0f 85 fe 03 00 00    	jne    114a <_zi_end_central+0x84a>
     d4c:	f7 c7 02 00 00 00    	test   $0x2,%edi
     d52:	0f 85 bd 03 00 00    	jne    1115 <_zi_end_central+0x815>
     d58:	89 c1                	mov    %eax,%ecx
     d5a:	c1 e9 02             	shr    $0x2,%ecx
     d5d:	a8 02                	test   $0x2,%al
     d5f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     d61:	0f 85 49 02 00 00    	jne    fb0 <_zi_end_central+0x6b0>
     d67:	a8 01                	test   $0x1,%al
     d69:	0f 85 36 02 00 00    	jne    fa5 <_zi_end_central+0x6a5>
     d6f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     d76:	00 
     d77:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     d7b:	89 1c 24             	mov    %ebx,(%esp)
     d7e:	c7 44 24 08 25 00 00 	movl   $0x25,0x8(%esp)
     d85:	00 
     d86:	ff d2                	call   *%edx
     d88:	b8 01 00 00 00       	mov    $0x1,%eax
     d8d:	83 ec 10             	sub    $0x10,%esp
        }
    } /* endif (verbose) */

    return error;

} /* end function zi_end_central() */
     d90:	83 c4 3c             	add    $0x3c,%esp
     d93:	5b                   	pop    %ebx
     d94:	5e                   	pop    %esi
     d95:	5f                   	pop    %edi
     d96:	5d                   	pop    %ebp
     d97:	c3                   	ret    
                  LoadFarString(ZipfileCommTrunc2)));
        } /* endif (comment exists) */

    /* non-verbose mode:  print zipfile comment only if requested */
    } else if (uO.zflag && G.ecrec.zipfile_comment_length) {
        if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY)) {
     d98:	31 c0                	xor    %eax,%eax
     d9a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
     da1:	00 
     da2:	66 89 f0             	mov    %si,%ax
     da5:	89 1c 24             	mov    %ebx,(%esp)
     da8:	89 44 24 04          	mov    %eax,0x4(%esp)
     dac:	e8 00 00 00 00       	call   db1 <_zi_end_central+0x4b1>
     db1:	85 c0                	test   %eax,%eax
     db3:	0f 84 14 fc ff ff    	je     9cd <_zi_end_central+0xcd>
            Info(slide, 0x401, ((char *)slide,
     db9:	8d ab dc 08 00 00    	lea    0x8dc(%ebx),%ebp
     dbf:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     dc5:	89 ef                	mov    %ebp,%edi
     dc7:	be 34 01 00 00       	mov    $0x134,%esi
     dcc:	b8 26 00 00 00       	mov    $0x26,%eax
     dd1:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     dd7:	0f 85 b7 03 00 00    	jne    1194 <_zi_end_central+0x894>
     ddd:	f7 c7 02 00 00 00    	test   $0x2,%edi
     de3:	0f 85 96 03 00 00    	jne    117f <_zi_end_central+0x87f>
     de9:	89 c1                	mov    %eax,%ecx
     deb:	c1 e9 02             	shr    $0x2,%ecx
     dee:	a8 02                	test   $0x2,%al
     df0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     df2:	0f 85 f8 01 00 00    	jne    ff0 <_zi_end_central+0x6f0>
     df8:	a8 01                	test   $0x1,%al
     dfa:	0f 85 e0 01 00 00    	jne    fe0 <_zi_end_central+0x6e0>
     e00:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
     e07:	00 
     e08:	e9 6a ff ff ff       	jmp    d77 <_zi_end_central+0x477>
     e0d:	8d 76 00             	lea    0x0(%esi),%esi
        Info(slide, 0, ((char *)slide, LoadFarString(ActOffsetCentDir),
          (long)G.real_ecrec_offset, (long)G.real_ecrec_offset,
          (long)G.expect_ecrec_offset, (long)G.expect_ecrec_offset));

        if (G.ecrec.number_this_disk == 0) {
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive1),
     e10:	66 8b 83 6e 09 01 00 	mov    0x1096e(%ebx),%ax
     e17:	bf 1b 00 00 00       	mov    $0x1b,%edi
     e1c:	ba 15 00 00 00       	mov    $0x15,%edx
     e21:	8b 8b 70 09 01 00    	mov    0x10970(%ebx),%ecx
     e27:	66 83 f8 01          	cmp    $0x1,%ax
     e2b:	89 4c 24 14          	mov    %ecx,0x14(%esp)
     e2f:	0f 45 d7             	cmovne %edi,%edx
     e32:	89 c7                	mov    %eax,%edi
     e34:	31 c0                	xor    %eax,%eax
     e36:	66 89 f8             	mov    %di,%ax
     e39:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     e3d:	89 54 24 0c          	mov    %edx,0xc(%esp)
     e41:	89 44 24 08          	mov    %eax,0x8(%esp)
     e45:	c7 44 24 04 c0 1d 00 	movl   $0x1dc0,0x4(%esp)
     e4c:	00 
     e4d:	89 2c 24             	mov    %ebp,(%esp)
     e50:	e8 00 00 00 00       	call   e55 <_zi_end_central+0x555>
     e55:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     e5c:	00 
     e5d:	89 44 24 08          	mov    %eax,0x8(%esp)
     e61:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     e65:	89 1c 24             	mov    %ebx,(%esp)
     e68:	ff d6                	call   *%esi
              G.ecrec.total_entries_central_dir,
              (G.ecrec.total_entries_central_dir == 1)? "entry" : "entries",
              G.ecrec.size_central_directory,
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive2),
     e6a:	8b 83 74 09 01 00    	mov    0x10974(%ebx),%eax
        Info(slide, 0, ((char *)slide, LoadFarString(ActOffsetCentDir),
          (long)G.real_ecrec_offset, (long)G.real_ecrec_offset,
          (long)G.expect_ecrec_offset, (long)G.expect_ecrec_offset));

        if (G.ecrec.number_this_disk == 0) {
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive1),
     e70:	83 ec 10             	sub    $0x10,%esp
              G.ecrec.total_entries_central_dir,
              (G.ecrec.total_entries_central_dir == 1)? "entry" : "entries",
              G.ecrec.size_central_directory,
              G.ecrec.size_central_directory));
            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive2),
     e73:	8b b3 44 0b 01 00    	mov    0x10b44(%ebx),%esi
     e79:	89 44 24 0c          	mov    %eax,0xc(%esp)
     e7d:	89 44 24 08          	mov    %eax,0x8(%esp)
     e81:	c7 44 24 04 80 1d 00 	movl   $0x1d80,0x4(%esp)
     e88:	00 
     e89:	e9 52 fd ff ff       	jmp    be0 <_zi_end_central+0x2e0>
     e8e:	66 90                	xchg   %ax,%ax
          nullStr : PlurSufx));

    /* verbose format */
    if (uO.lflag > 9) {
        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));
        Info(slide, 0, ((char *)slide, LoadFarString(LineSeparators)));
     e90:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     e93:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     e96:	e9 e0 fb ff ff       	jmp    a7b <_zi_end_central+0x17b>
     e9b:	90                   	nop
     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     ea0:	66 8b 0e             	mov    (%esi),%cx
     ea3:	a8 01                	test   $0x1,%al
     ea5:	66 89 0f             	mov    %cx,(%edi)
     ea8:	b9 02 00 00 00       	mov    $0x2,%ecx
     ead:	0f 84 c8 fb ff ff    	je     a7b <_zi_end_central+0x17b>
     eb3:	eb db                	jmp    e90 <_zi_end_central+0x590>
          (G.ecrec.total_entries_central_dir==1)?
          nullStr : PlurSufx));

    /* verbose format */
    if (uO.lflag > 9) {
        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));
     eb5:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     eb8:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     ebb:	e9 5e fb ff ff       	jmp    a1e <_zi_end_central+0x11e>
     ec0:	66 8b 0e             	mov    (%esi),%cx
     ec3:	a8 01                	test   $0x1,%al
     ec5:	66 89 0f             	mov    %cx,(%edi)
     ec8:	b9 02 00 00 00       	mov    $0x2,%ecx
     ecd:	0f 84 4b fb ff ff    	je     a1e <_zi_end_central+0x11e>
     ed3:	eb e0                	jmp    eb5 <_zi_end_central+0x5b5>
        up to 64KB long.  May the fleas of a thousand camels infest the arm-
        pits of anyone who actually takes advantage of this fact.)
      -----------------------------------------------------------------------*/

        if (!G.ecrec.zipfile_comment_length)
            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));
     ed5:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     edb:	89 ef                	mov    %ebp,%edi
     edd:	be 5c 01 00 00       	mov    $0x15c,%esi
     ee2:	b8 20 00 00 00       	mov    $0x20,%eax
     ee7:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     eed:	0f 85 cd 01 00 00    	jne    10c0 <_zi_end_central+0x7c0>
     ef3:	f7 c7 02 00 00 00    	test   $0x2,%edi
     ef9:	0f 85 a6 01 00 00    	jne    10a5 <_zi_end_central+0x7a5>
     eff:	89 c1                	mov    %eax,%ecx
     f01:	c1 e9 02             	shr    $0x2,%ecx
     f04:	a8 02                	test   $0x2,%al
     f06:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     f08:	74 0b                	je     f15 <_zi_end_central+0x615>
     f0a:	66 8b 0e             	mov    (%esi),%cx
     f0d:	66 89 0f             	mov    %cx,(%edi)
     f10:	b9 02 00 00 00       	mov    $0x2,%ecx
     f15:	a8 01                	test   $0x1,%al
     f17:	74 06                	je     f1f <_zi_end_central+0x61f>
     f19:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     f1c:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     f1f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     f26:	00 
     f27:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
     f2e:	00 
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
     f2f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     f33:	89 1c 24             	mov    %ebx,(%esp)
     f36:	ff d2                	call   *%edx
     f38:	83 ec 10             	sub    $0x10,%esp
     f3b:	e9 8d fa ff ff       	jmp    9cd <_zi_end_central+0xcd>
     f40:	8b 93 44 0b 01 00    	mov    0x10b44(%ebx),%edx
     f46:	89 ef                	mov    %ebp,%edi
     f48:	be c0 00 00 00       	mov    $0xc0,%esi
     f4d:	b8 4c 00 00 00       	mov    $0x4c,%eax
     f52:	f7 c5 01 00 00 00    	test   $0x1,%ebp
     f58:	0f 85 97 01 00 00    	jne    10f5 <_zi_end_central+0x7f5>
     f5e:	f7 c7 02 00 00 00    	test   $0x2,%edi
     f64:	0f 85 76 01 00 00    	jne    10e0 <_zi_end_central+0x7e0>
     f6a:	89 c1                	mov    %eax,%ecx
     f6c:	c1 e9 02             	shr    $0x2,%ecx
     f6f:	a8 02                	test   $0x2,%al
     f71:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
     f73:	75 23                	jne    f98 <_zi_end_central+0x698>
     f75:	a8 01                	test   $0x1,%al
     f77:	75 17                	jne    f90 <_zi_end_central+0x690>
     f79:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     f80:	00 
     f81:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
     f88:	00 
     f89:	eb a4                	jmp    f2f <_zi_end_central+0x62f>
     f8b:	90                   	nop
     f8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     f90:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     f93:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     f96:	eb e1                	jmp    f79 <_zi_end_central+0x679>
     f98:	66 8b 0e             	mov    (%esi),%cx
     f9b:	66 89 0f             	mov    %cx,(%edi)
     f9e:	b9 02 00 00 00       	mov    $0x2,%ecx
     fa3:	eb d0                	jmp    f75 <_zi_end_central+0x675>
            if (error)
                Info(slide, 0, ((char *)slide,
     fa5:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     fa8:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     fab:	e9 bf fd ff ff       	jmp    d6f <_zi_end_central+0x46f>
     fb0:	66 8b 0e             	mov    (%esi),%cx
     fb3:	66 89 0f             	mov    %cx,(%edi)
     fb6:	b9 02 00 00 00       	mov    $0x2,%ecx
     fbb:	e9 a7 fd ff ff       	jmp    d67 <_zi_end_central+0x467>
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
     fc0:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     fc3:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     fc6:	e9 47 fd ff ff       	jmp    d12 <_zi_end_central+0x412>
     fcb:	90                   	nop
     fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     fd0:	66 8b 0e             	mov    (%esi),%cx
     fd3:	66 89 0f             	mov    %cx,(%edi)
     fd6:	b9 02 00 00 00       	mov    $0x2,%ecx
     fdb:	e9 2a fd ff ff       	jmp    d0a <_zi_end_central+0x40a>
        } /* endif (comment exists) */

    /* non-verbose mode:  print zipfile comment only if requested */
    } else if (uO.zflag && G.ecrec.zipfile_comment_length) {
        if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY)) {
            Info(slide, 0x401, ((char *)slide,
     fe0:	8a 04 0e             	mov    (%esi,%ecx,1),%al
     fe3:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     fe6:	e9 15 fe ff ff       	jmp    e00 <_zi_end_central+0x500>
     feb:	90                   	nop
     fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     ff0:	66 8b 0e             	mov    (%esi),%cx
     ff3:	66 89 0f             	mov    %cx,(%edi)
     ff6:	b9 02 00 00 00       	mov    $0x2,%ecx
     ffb:	e9 f8 fd ff ff       	jmp    df8 <_zi_end_central+0x4f8>
          (G.ecrec.total_entries_central_dir==1)?
          nullStr : PlurSufx));

    /* verbose format */
    if (uO.lflag > 9) {
        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));
    1000:	a0 2c 00 00 00       	mov    0x2c,%al
    1005:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    100b:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    1011:	be 2d 00 00 00       	mov    $0x2d,%esi
    1016:	b8 22 00 00 00       	mov    $0x22,%eax
    101b:	e9 db f9 ff ff       	jmp    9fb <_zi_end_central+0xfb>
    1020:	66 8b 0e             	mov    (%esi),%cx
    1023:	83 c7 02             	add    $0x2,%edi
    1026:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    102a:	83 c6 02             	add    $0x2,%esi
    102d:	83 e8 02             	sub    $0x2,%eax
    1030:	e9 d2 f9 ff ff       	jmp    a07 <_zi_end_central+0x107>
        Info(slide, 0, ((char *)slide, LoadFarString(LineSeparators)));
    1035:	a0 50 00 00 00       	mov    0x50,%al
    103a:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    1040:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    1046:	be 51 00 00 00       	mov    $0x51,%esi
    104b:	b8 21 00 00 00       	mov    $0x21,%eax
    1050:	e9 03 fa ff ff       	jmp    a58 <_zi_end_central+0x158>
    1055:	66 8b 0e             	mov    (%esi),%cx
    1058:	83 c7 02             	add    $0x2,%edi
    105b:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    105f:	83 c6 02             	add    $0x2,%esi
    1062:	83 e8 02             	sub    $0x2,%eax
    1065:	e9 fa f9 ff ff       	jmp    a64 <_zi_end_central+0x164>
    106a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        if (!G.ecrec.zipfile_comment_length)
            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));
        else {
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
    1070:	a0 74 00 00 00       	mov    0x74,%al
    1075:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    107b:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    1081:	be 75 00 00 00       	mov    $0x75,%esi
    1086:	b8 4b 00 00 00       	mov    $0x4b,%eax
    108b:	e9 d4 fb ff ff       	jmp    c64 <_zi_end_central+0x364>
    1090:	66 8b 0e             	mov    (%esi),%cx
    1093:	83 c7 02             	add    $0x2,%edi
    1096:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    109a:	83 c6 02             	add    $0x2,%esi
    109d:	83 e8 02             	sub    $0x2,%eax
    10a0:	e9 cb fb ff ff       	jmp    c70 <_zi_end_central+0x370>
        up to 64KB long.  May the fleas of a thousand camels infest the arm-
        pits of anyone who actually takes advantage of this fact.)
      -----------------------------------------------------------------------*/

        if (!G.ecrec.zipfile_comment_length)
            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));
    10a5:	66 8b 0e             	mov    (%esi),%cx
    10a8:	83 c7 02             	add    $0x2,%edi
    10ab:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    10af:	83 c6 02             	add    $0x2,%esi
    10b2:	83 e8 02             	sub    $0x2,%eax
    10b5:	e9 45 fe ff ff       	jmp    eff <_zi_end_central+0x5ff>
    10ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    10c0:	a0 5c 01 00 00       	mov    0x15c,%al
    10c5:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    10cb:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    10d1:	be 5d 01 00 00       	mov    $0x15d,%esi
    10d6:	b8 1f 00 00 00       	mov    $0x1f,%eax
    10db:	e9 13 fe ff ff       	jmp    ef3 <_zi_end_central+0x5f3>
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
    10e0:	66 8b 0e             	mov    (%esi),%cx
    10e3:	83 c7 02             	add    $0x2,%edi
    10e6:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    10ea:	83 c6 02             	add    $0x2,%esi
    10ed:	83 e8 02             	sub    $0x2,%eax
    10f0:	e9 75 fe ff ff       	jmp    f6a <_zi_end_central+0x66a>
    10f5:	a0 c0 00 00 00       	mov    0xc0,%al
    10fa:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    1100:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    1106:	be c1 00 00 00       	mov    $0xc1,%esi
    110b:	b8 4b 00 00 00       	mov    $0x4b,%eax
    1110:	e9 49 fe ff ff       	jmp    f5e <_zi_end_central+0x65e>
            if (error)
                Info(slide, 0, ((char *)slide,
    1115:	66 8b 0e             	mov    (%esi),%cx
    1118:	83 c7 02             	add    $0x2,%edi
    111b:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    111f:	83 c6 02             	add    $0x2,%esi
    1122:	83 e8 02             	sub    $0x2,%eax
    1125:	e9 2e fc ff ff       	jmp    d58 <_zi_end_central+0x458>
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
    112a:	a0 c0 00 00 00       	mov    0xc0,%al
    112f:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    1135:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    113b:	be c1 00 00 00       	mov    $0xc1,%esi
    1140:	b8 4b 00 00 00       	mov    $0x4b,%eax
    1145:	e9 a5 fb ff ff       	jmp    cef <_zi_end_central+0x3ef>
            if (error)
                Info(slide, 0, ((char *)slide,
    114a:	a0 0c 01 00 00       	mov    0x10c,%al
    114f:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    1155:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    115b:	be 0d 01 00 00       	mov    $0x10d,%esi
    1160:	b8 25 00 00 00       	mov    $0x25,%eax
    1165:	e9 e2 fb ff ff       	jmp    d4c <_zi_end_central+0x44c>
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),
              G.ecrec.zipfile_comment_length));
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));
            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))
                error = PK_WARN;
            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));
    116a:	66 8b 0e             	mov    (%esi),%cx
    116d:	83 c7 02             	add    $0x2,%edi
    1170:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    1174:	83 c6 02             	add    $0x2,%esi
    1177:	83 e8 02             	sub    $0x2,%eax
    117a:	e9 7c fb ff ff       	jmp    cfb <_zi_end_central+0x3fb>
        } /* endif (comment exists) */

    /* non-verbose mode:  print zipfile comment only if requested */
    } else if (uO.zflag && G.ecrec.zipfile_comment_length) {
        if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY)) {
            Info(slide, 0x401, ((char *)slide,
    117f:	66 8b 0e             	mov    (%esi),%cx
    1182:	83 c7 02             	add    $0x2,%edi
    1185:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    1189:	83 c6 02             	add    $0x2,%esi
    118c:	83 e8 02             	sub    $0x2,%eax
    118f:	e9 55 fc ff ff       	jmp    de9 <_zi_end_central+0x4e9>
    1194:	a0 34 01 00 00       	mov    0x134,%al
    1199:	8d bb dd 08 00 00    	lea    0x8dd(%ebx),%edi
    119f:	88 83 dc 08 00 00    	mov    %al,0x8dc(%ebx)
    11a5:	be 35 01 00 00       	mov    $0x135,%esi
    11aa:	b8 25 00 00 00       	mov    $0x25,%eax
    11af:	e9 29 fc ff ff       	jmp    ddd <_zi_end_central+0x4dd>
    11b4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    11ba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000011c0 <_zipinfo>:
/*  Function zipinfo()  */
/************************/

int zipinfo(__G)   /* return PK-type error code */
    __GDEF
{
    11c0:	55                   	push   %ebp
    11c1:	57                   	push   %edi
    11c2:	56                   	push   %esi
    11c3:	53                   	push   %ebx
    11c4:	81 ec 2c 01 00 00    	sub    $0x12c,%esp
    11ca:	8b ac 24 40 01 00 00 	mov    0x140(%esp),%ebp
/*---------------------------------------------------------------------------
    Malloc space for check on unmatched filespecs (no big deal if one or both
    are NULL).
  ---------------------------------------------------------------------------*/

    if (G.filespecs > 0  &&
    11d1:	8b 45 6c             	mov    0x6c(%ebp),%eax
    11d4:	85 c0                	test   %eax,%eax
    11d6:	0f 85 ca 1c 00 00    	jne    2ea6 <_zipinfo+0x1ce6>

int zipinfo(__G)   /* return PK-type error code */
    __GDEF
{
    int do_this_file=FALSE, error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
    11dc:	c7 84 24 80 00 00 00 	movl   $0x0,0x80(%esp)
    11e3:	00 00 00 00 
    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != NULL)
        for (j = 0;  j < G.filespecs;  ++j)
            fn_matched[j] = FALSE;

    if (G.xfilespecs > 0  &&
    11e7:	8b 45 70             	mov    0x70(%ebp),%eax
    11ea:	85 c0                	test   %eax,%eax
    11ec:	0f 85 82 1c 00 00    	jne    2e74 <_zipinfo+0x1cb4>

int zipinfo(__G)   /* return PK-type error code */
    __GDEF
{
    int do_this_file=FALSE, error, error_in_archive=PK_COOL;
    int *fn_matched=NULL, *xn_matched=NULL;
    11f2:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%esp)
    11f9:	00 
    better be the *only* disk in the archive, but maybe someday we'll add
    multi-disk support.
  ---------------------------------------------------------------------------*/

    uO.L_flag = FALSE;      /* zipinfo mode: never convert name to lowercase */
    G.pInfo = G.info;       /* (re-)initialize, (just to make sure) */
    11fa:	8d 85 d8 00 00 00    	lea    0xd8(%ebp),%eax
    the disk on which the central directory starts.  In practice, this had
    better be the *only* disk in the archive, but maybe someday we'll add
    multi-disk support.
  ---------------------------------------------------------------------------*/

    uO.L_flag = FALSE;      /* zipinfo mode: never convert name to lowercase */
    1200:	c7 45 2c 00 00 00 00 	movl   $0x0,0x2c(%ebp)
    G.pInfo = G.info;       /* (re-)initialize, (just to make sure) */
    1207:	89 85 d8 08 00 00    	mov    %eax,0x8d8(%ebp)
    G.pInfo->textmode = 0;  /* so one can read on screen (is this ever used?) */

    /* reset endprev for new zipfile; account for multi-part archives (?) */
    endprev = (G.crec.relative_offset_local_header == 4L)? 4L : 0L;
    120d:	31 c0                	xor    %eax,%eax
    multi-disk support.
  ---------------------------------------------------------------------------*/

    uO.L_flag = FALSE;      /* zipinfo mode: never convert name to lowercase */
    G.pInfo = G.info;       /* (re-)initialize, (just to make sure) */
    G.pInfo->textmode = 0;  /* so one can read on screen (is this ever used?) */
    120f:	80 a5 f0 00 00 00 f7 	andb   $0xf7,0xf0(%ebp)

    /* reset endprev for new zipfile; account for multi-part archives (?) */
    endprev = (G.crec.relative_offset_local_header == 4L)? 4L : 0L;
    1216:	83 bd 64 09 01 00 04 	cmpl   $0x4,0x10964(%ebp)
    121d:	0f 94 c0             	sete   %al
    1220:	c1 e0 02             	shl    $0x2,%eax
    1223:	c7 44 24 5c 00 00 00 	movl   $0x0,0x5c(%esp)
    122a:	00 
    122b:	89 44 24 64          	mov    %eax,0x64(%esp)
    122f:	8d 85 c8 00 00 00    	lea    0xc8(%ebp),%eax
    1235:	89 44 24 48          	mov    %eax,0x48(%esp)
                            return error;
                    }
                    break;

                case 10:
                    Info(slide, 0, ((char *)slide,
    1239:	8d 85 dc 08 00 00    	lea    0x8dc(%ebp),%eax
    123f:	89 44 24 3c          	mov    %eax,0x3c(%esp)
    }

    if (!G.crec.file_comment_length)
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    else {
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommBegin)));
    1243:	83 e0 01             	and    $0x1,%eax
    uO.L_flag = FALSE;      /* zipinfo mode: never convert name to lowercase */
    G.pInfo = G.info;       /* (re-)initialize, (just to make sure) */
    G.pInfo->textmode = 0;  /* so one can read on screen (is this ever used?) */

    /* reset endprev for new zipfile; account for multi-part archives (?) */
    endprev = (G.crec.relative_offset_local_header == 4L)? 4L : 0L;
    1246:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
    124d:	00 
    124e:	c7 44 24 58 00 00 00 	movl   $0x0,0x58(%esp)
    1255:	00 
    1256:	c7 44 24 44 01 00 00 	movl   $0x1,0x44(%esp)
    125d:	00 
    125e:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
    1265:	00 
    1266:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
    126d:	00 
    }

    if (!G.crec.file_comment_length)
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    else {
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommBegin)));
    126e:	89 84 24 88 00 00 00 	mov    %eax,0x88(%esp)
    /* reset endprev for new zipfile; account for multi-part archives (?) */
    endprev = (G.crec.relative_offset_local_header == 4L)? 4L : 0L;


    for (j = 1L;; j++) {
        if (readbuf(__G__ G.sig, 4) == 0)
    1275:	8b 74 24 48          	mov    0x48(%esp),%esi
    1279:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    1280:	00 
    1281:	89 74 24 04          	mov    %esi,0x4(%esp)
    1285:	89 2c 24             	mov    %ebp,(%esp)
    1288:	e8 00 00 00 00       	call   128d <_zipinfo+0xcd>
    128d:	85 c0                	test   %eax,%eax
    128f:	0f 84 6b 1f 00 00    	je     3200 <_zipinfo+0x2040>
            return PK_EOF;
        if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a CentDir entry? */
    1295:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    129c:	00 
    129d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    12a4:	00 
    12a5:	89 34 24             	mov    %esi,(%esp)
    12a8:	e8 00 00 00 00       	call   12ad <_zipinfo+0xed>
    12ad:	85 c0                	test   %eax,%eax
    12af:	0f 85 5d 1f 00 00    	jne    3212 <_zipinfo+0x2052>
                     ((char *)slide, LoadFarString(ReportMsg)));
                return PK_BADERR;   /* sig not found */
            }
        }
        /* process_cdir_file_hdr() sets pInfo->hostnum, pInfo->lcflag, ...: */
        if ((error = process_cdir_file_hdr(__G)) != PK_COOL)
    12b5:	89 2c 24             	mov    %ebp,(%esp)
    12b8:	e8 00 00 00 00       	call   12bd <_zipinfo+0xfd>
    12bd:	85 c0                	test   %eax,%eax
    12bf:	0f 85 fe 0c 00 00    	jne    1fc3 <_zipinfo+0xe03>
            return error;       /* only PK_EOF defined */

        if ((error = do_string(__G__ G.crec.filename_length, DS_FN)) !=
    12c5:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
    12cc:	00 
    12cd:	31 c0                	xor    %eax,%eax
    12cf:	66 8b 85 54 09 01 00 	mov    0x10954(%ebp),%ax
    12d6:	89 2c 24             	mov    %ebp,(%esp)
    12d9:	89 44 24 04          	mov    %eax,0x4(%esp)
    12dd:	e8 00 00 00 00       	call   12e2 <_zipinfo+0x122>
    12e2:	85 c0                	test   %eax,%eax
    12e4:	74 0d                	je     12f3 <_zipinfo+0x133>
             PK_COOL)
        {
          error_in_archive = error;   /* might be warning */
          if (error > PK_WARN)        /* fatal */
    12e6:	83 f8 01             	cmp    $0x1,%eax
    12e9:	0f 8f d4 0c 00 00    	jg     1fc3 <_zipinfo+0xe03>
    12ef:	89 44 24 50          	mov    %eax,0x50(%esp)
              return error;
        }

        if (!G.process_all_files) {   /* check if specified on command line */
    12f3:	8b 45 74             	mov    0x74(%ebp),%eax
    12f6:	85 c0                	test   %eax,%eax
    12f8:	0f 85 b6 00 00 00    	jne    13b4 <_zipinfo+0x1f4>
            unsigned i;

            if (G.filespecs == 0)
    12fe:	8b 5d 6c             	mov    0x6c(%ebp),%ebx
    1301:	85 db                	test   %ebx,%ebx
    1303:	0f 84 77 0b 00 00    	je     1e80 <_zipinfo+0xcc0>
    1309:	8d b5 e0 09 01 00    	lea    0x109e0(%ebp),%esi
    130f:	31 db                	xor    %ebx,%ebx
    1311:	eb 0a                	jmp    131d <_zipinfo+0x15d>
                do_this_file = TRUE;
            else {  /* check if this entry matches an `include' argument */
                do_this_file = FALSE;
                for (i = 0; i < G.filespecs; i++)
    1313:	43                   	inc    %ebx
    1314:	39 5d 6c             	cmp    %ebx,0x6c(%ebp)
    1317:	0f 86 8c 00 00 00    	jbe    13a9 <_zipinfo+0x1e9>
                    if (match(G.filename, G.pfnames[i], uO.C_flag WISEP)) {
    131d:	8b 45 18             	mov    0x18(%ebp),%eax
    1320:	8d 3c 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edi
    1327:	89 44 24 08          	mov    %eax,0x8(%esp)
    132b:	8b 85 c0 00 00 00    	mov    0xc0(%ebp),%eax
    1331:	8b 04 38             	mov    (%eax,%edi,1),%eax
    1334:	89 34 24             	mov    %esi,(%esp)
    1337:	89 44 24 04          	mov    %eax,0x4(%esp)
    133b:	e8 00 00 00 00       	call   1340 <_zipinfo+0x180>
    1340:	85 c0                	test   %eax,%eax
    1342:	74 cf                	je     1313 <_zipinfo+0x153>
                        do_this_file = TRUE;
                        if (fn_matched)
    1344:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    134b:	85 c0                	test   %eax,%eax
    134d:	74 07                	je     1356 <_zipinfo+0x196>
                            fn_matched[i] = TRUE;
    134f:	c7 04 38 01 00 00 00 	movl   $0x1,(%eax,%edi,1)
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
    1356:	8b 7d 70             	mov    0x70(%ebp),%edi
    1359:	85 ff                	test   %edi,%edi
    135b:	0f 84 b2 0a 00 00    	je     1e13 <_zipinfo+0xc53>
        }

        if (!G.process_all_files) {   /* check if specified on command line */
            unsigned i;

            if (G.filespecs == 0)
    1361:	31 db                	xor    %ebx,%ebx
    1363:	eb 0a                	jmp    136f <_zipinfo+0x1af>
                            fn_matched[i] = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
    1365:	43                   	inc    %ebx
    1366:	39 5d 70             	cmp    %ebx,0x70(%ebp)
    1369:	0f 86 a4 0a 00 00    	jbe    1e13 <_zipinfo+0xc53>
                    if (match(G.filename, G.pxnames[i], uO.C_flag WISEP)) {
    136f:	8b 45 18             	mov    0x18(%ebp),%eax
    1372:	8d 3c 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edi
    1379:	89 44 24 08          	mov    %eax,0x8(%esp)
    137d:	8b 85 c4 00 00 00    	mov    0xc4(%ebp),%eax
    1383:	8b 04 38             	mov    (%eax,%edi,1),%eax
    1386:	89 34 24             	mov    %esi,(%esp)
    1389:	89 44 24 04          	mov    %eax,0x4(%esp)
    138d:	e8 00 00 00 00       	call   1392 <_zipinfo+0x1d2>
    1392:	85 c0                	test   %eax,%eax
    1394:	74 cf                	je     1365 <_zipinfo+0x1a5>
                        do_this_file = FALSE;  /* ^-- ignore case in match */
                        if (xn_matched)
    1396:	8b 4c 24 70          	mov    0x70(%esp),%ecx
    139a:	85 c9                	test   %ecx,%ecx
    139c:	74 0b                	je     13a9 <_zipinfo+0x1e9>
                            xn_matched[i] = TRUE;
    139e:	8b 44 24 70          	mov    0x70(%esp),%eax
    13a2:	c7 04 38 01 00 00 00 	movl   $0x1,(%eax,%edi,1)
    13a9:	8b 45 74             	mov    0x74(%ebp),%eax
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
                    if (match(G.filename, G.pxnames[i], uO.C_flag WISEP)) {
                        do_this_file = FALSE;  /* ^-- ignore case in match */
    13ac:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
    13b3:	00 
        If current file was specified on command line, or if no names were
        specified, do the listing for this file.  Otherwise, get rid of the
        file comment and go back for the next file.
      -----------------------------------------------------------------------*/

        if (G.process_all_files || do_this_file) {
    13b4:	0b 44 24 40          	or     0x40(%esp),%eax
    13b8:	0f 84 6a 0a 00 00    	je     1e28 <_zipinfo+0xc68>

            switch (uO.lflag) {
    13be:	83 7d 28 0a          	cmpl   $0xa,0x28(%ebp)
    13c2:	0f 87 a8 09 00 00    	ja     1d70 <_zipinfo+0xbb0>
    13c8:	8b 45 28             	mov    0x28(%ebp),%eax
    13cb:	ff 24 85 70 03 00 00 	jmp    *0x370(,%eax,4)
                            return error;
                    }
                    break;

                case 10:
                    Info(slide, 0, ((char *)slide,
    13d2:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    13d6:	8b 44 24 44          	mov    0x44(%esp),%eax
    13da:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    13e0:	89 44 24 08          	mov    %eax,0x8(%esp)
    13e4:	c7 44 24 04 40 1b 00 	movl   $0x1b40,0x4(%esp)
    13eb:	00 
    13ec:	89 34 24             	mov    %esi,(%esp)
    13ef:	e8 00 00 00 00       	call   13f4 <_zipinfo+0x234>
    13f4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    13fb:	00 
    13fc:	89 44 24 08          	mov    %eax,0x8(%esp)
    1400:	89 74 24 04          	mov    %esi,0x4(%esp)
    1404:	89 2c 24             	mov    %ebp,(%esp)
    1407:	ff d3                	call   *%ebx
    Check whether there's any extra space inside the zipfile.  If *pEndprev is
    zero, it's probably a signal that OS/2 extra fields are involved (with
    unknown compressed size).  We won't worry about prepended junk here...
  ---------------------------------------------------------------------------*/

    if (G.crec.relative_offset_local_header != *pEndprev && *pEndprev > 0L) {
    1409:	8b 9d 64 09 01 00    	mov    0x10964(%ebp),%ebx
                            return error;
                    }
                    break;

                case 10:
                    Info(slide, 0, ((char *)slide,
    140f:	83 ec 10             	sub    $0x10,%esp
    Check whether there's any extra space inside the zipfile.  If *pEndprev is
    zero, it's probably a signal that OS/2 extra fields are involved (with
    unknown compressed size).  We won't worry about prepended junk here...
  ---------------------------------------------------------------------------*/

    if (G.crec.relative_offset_local_header != *pEndprev && *pEndprev > 0L) {
    1412:	8b 44 24 64          	mov    0x64(%esp),%eax
    1416:	39 c3                	cmp    %eax,%ebx
    1418:	74 42                	je     145c <_zipinfo+0x29c>
    141a:	85 c0                	test   %eax,%eax
    141c:	74 3e                	je     145c <_zipinfo+0x29c>
        /*  GRR DEBUG
        Info(slide, 0, ((char *)slide,
          "  [crec.relative_offset_local_header = %lu, endprev = %lu]\n",
          G.crec.relative_offset_local_header, *pEndprev));
         */
        Info(slide, 0, ((char *)slide, LoadFarString(ExtraBytesPreceding),
    141e:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    1422:	29 c3                	sub    %eax,%ebx
    1424:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    142a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    142e:	c7 44 24 04 c0 18 00 	movl   $0x18c0,0x4(%esp)
    1435:	00 
    1436:	89 3c 24             	mov    %edi,(%esp)
    1439:	e8 00 00 00 00       	call   143e <_zipinfo+0x27e>
    143e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1445:	00 
    1446:	89 44 24 08          	mov    %eax,0x8(%esp)
    144a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    144e:	89 2c 24             	mov    %ebp,(%esp)
    1451:	ff d6                	call   *%esi
    1453:	8b 9d 64 09 01 00    	mov    0x10964(%ebp),%ebx
    1459:	83 ec 10             	sub    $0x10,%esp
    }

    /* calculate endprev for next time around (problem:  extra fields may
     * differ in length between local and central-directory records) */
    *pEndprev = G.crec.relative_offset_local_header + (4L + LREC_SIZE) +
      G.crec.filename_length + G.crec.extra_field_length + G.crec.csize;
    145c:	31 c0                	xor    %eax,%eax
    145e:	8b 8d 4c 09 01 00    	mov    0x1094c(%ebp),%ecx
    1464:	66 8b 85 56 09 01 00 	mov    0x10956(%ebp),%ax
          (long)G.crec.relative_offset_local_header - (long)(*pEndprev)));
    }

    /* calculate endprev for next time around (problem:  extra fields may
     * differ in length between local and central-directory records) */
    *pEndprev = G.crec.relative_offset_local_header + (4L + LREC_SIZE) +
    146b:	31 d2                	xor    %edx,%edx
    146d:	66 8b 95 54 09 01 00 	mov    0x10954(%ebp),%dx
    1474:	01 c1                	add    %eax,%ecx

/*---------------------------------------------------------------------------
    Read the extra field, if any. It may be used to get UNIX style modtime.
  ---------------------------------------------------------------------------*/

    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)
    1476:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    147d:	00 
    147e:	89 44 24 04          	mov    %eax,0x4(%esp)
    1482:	8d 54 11 1e          	lea    0x1e(%ecx,%edx,1),%edx
    1486:	89 2c 24             	mov    %ebp,(%esp)
    }

    /* calculate endprev for next time around (problem:  extra fields may
     * differ in length between local and central-directory records) */
    *pEndprev = G.crec.relative_offset_local_header + (4L + LREC_SIZE) +
      G.crec.filename_length + G.crec.extra_field_length + G.crec.csize;
    1489:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
    148c:	89 4c 24 64          	mov    %ecx,0x64(%esp)

/*---------------------------------------------------------------------------
    Read the extra field, if any. It may be used to get UNIX style modtime.
  ---------------------------------------------------------------------------*/

    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)
    1490:	e8 00 00 00 00       	call   1495 <_zipinfo+0x2d5>
    ulg *pEndprev;                   /* for zi_long() check of extra bytes */
{
#ifdef USE_EF_UT_TIME
    iztimes z_utime;
#endif
    int  error, error_in_archive=PK_COOL;
    1495:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%esp)
    149c:	00 

/*---------------------------------------------------------------------------
    Read the extra field, if any. It may be used to get UNIX style modtime.
  ---------------------------------------------------------------------------*/

    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)
    149d:	89 44 24 6c          	mov    %eax,0x6c(%esp)
    14a1:	85 c0                	test   %eax,%eax
    14a3:	74 28                	je     14cd <_zipinfo+0x30d>
    {
        if (G.extra_field != NULL) {
    14a5:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
    14ab:	85 c0                	test   %eax,%eax
    14ad:	0f 84 93 1e 00 00    	je     3346 <_zipinfo+0x2186>
            free(G.extra_field);
    14b3:	89 04 24             	mov    %eax,(%esp)
    14b6:	e8 00 00 00 00       	call   14bb <_zipinfo+0x2fb>
            G.extra_field = NULL;
    14bb:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    14bf:	c7 85 18 09 01 00 00 	movl   $0x0,0x10918(%ebp)
    14c6:	00 00 00 
    14c9:	89 44 24 74          	mov    %eax,0x74(%esp)

/*---------------------------------------------------------------------------
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    hostnum = (unsigned)(G.pInfo->hostnum);
    14cd:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
    14d3:	8a 48 13             	mov    0x13(%eax),%cl
    14d6:	88 8c 24 87 00 00 00 	mov    %cl,0x87(%esp)
    14dd:	89 ce                	mov    %ecx,%esi
    hostver = (unsigned)(G.pInfo->hostver);
    14df:	31 c9                	xor    %ecx,%ecx

/*---------------------------------------------------------------------------
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    hostnum = (unsigned)(G.pInfo->hostnum);
    14e1:	81 e6 ff 00 00 00    	and    $0xff,%esi
    hostver = (unsigned)(G.pInfo->hostver);
    14e7:	8a 48 12             	mov    0x12(%eax),%cl

/*---------------------------------------------------------------------------
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    hostnum = (unsigned)(G.pInfo->hostnum);
    14ea:	89 74 24 54          	mov    %esi,0x54(%esp)
    hostver = (unsigned)(G.pInfo->hostver);
    14ee:	89 4c 24 60          	mov    %ecx,0x60(%esp)
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    14f2:	8a 8d 3f 09 01 00    	mov    0x1093f(%ebp),%cl
    14f8:	81 e1 ff 00 00 00    	and    $0xff,%ecx
    14fe:	b8 1f 00 00 00       	mov    $0x1f,%eax
    1503:	89 ce                	mov    %ecx,%esi
    1505:	80 bd 3f 09 01 00 1e 	cmpb   $0x1e,0x1093f(%ebp)
    150c:	0f 47 f0             	cmova  %eax,%esi
    extver = (unsigned)G.crec.version_needed_to_extract[0];
    150f:	31 c0                	xor    %eax,%eax
    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    1511:	31 db                	xor    %ebx,%ebx
  ---------------------------------------------------------------------------*/

    hostnum = (unsigned)(G.pInfo->hostnum);
    hostver = (unsigned)(G.pInfo->hostver);
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    extver = (unsigned)G.crec.version_needed_to_extract[0];
    1513:	8a 85 3e 09 01 00    	mov    0x1093e(%ebp),%al
    1519:	89 44 24 68          	mov    %eax,0x68(%esp)
    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    151d:	66 8b 85 42 09 01 00 	mov    0x10942(%ebp),%ax
    1524:	66 83 f8 0c          	cmp    $0xc,%ax
    1528:	66 89 c3             	mov    %ax,%bx

    (*G.message)((zvoid *)&G, (uch *)"  ", 2L, 0);  fnprint(__G);
    152b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1532:	00 

    hostnum = (unsigned)(G.pInfo->hostnum);
    hostver = (unsigned)(G.pInfo->hostver);
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    extver = (unsigned)G.crec.version_needed_to_extract[0];
    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    1533:	b8 0d 00 00 00       	mov    $0xd,%eax

    (*G.message)((zvoid *)&G, (uch *)"  ", 2L, 0);  fnprint(__G);
    1538:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
    153f:	00 
    1540:	c7 44 24 04 4e 02 00 	movl   $0x24e,0x4(%esp)
    1547:	00 
    1548:	89 2c 24             	mov    %ebp,(%esp)

    hostnum = (unsigned)(G.pInfo->hostnum);
    hostver = (unsigned)(G.pInfo->hostver);
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    extver = (unsigned)G.crec.version_needed_to_extract[0];
    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    154b:	0f 47 d8             	cmova  %eax,%ebx

    (*G.message)((zvoid *)&G, (uch *)"  ", 2L, 0);  fnprint(__G);
    154e:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
    1554:	83 ec 10             	sub    $0x10,%esp
    1557:	89 2c 24             	mov    %ebp,(%esp)
    155a:	e8 00 00 00 00       	call   155f <_zipinfo+0x39f>

    Info(slide, 0, ((char *)slide, LoadFarString(LocalHeaderOffset),
    155f:	8b 85 64 09 01 00    	mov    0x10964(%ebp),%eax
    1565:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
    1569:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    156f:	89 0c 24             	mov    %ecx,(%esp)
    1572:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1576:	89 44 24 08          	mov    %eax,0x8(%esp)
    157a:	c7 44 24 04 60 18 00 	movl   $0x1860,0x4(%esp)
    1581:	00 
    1582:	e8 00 00 00 00       	call   1587 <_zipinfo+0x3c7>
    1587:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
    158b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1592:	00 
    1593:	89 44 24 08          	mov    %eax,0x8(%esp)
    1597:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    159b:	89 2c 24             	mov    %ebp,(%esp)
    159e:	ff d7                	call   *%edi
    15a0:	83 ec 10             	sub    $0x10,%esp
      G.crec.relative_offset_local_header,
      G.crec.relative_offset_local_header));

    if (hostnum >= NUM_HOSTS) {
    15a3:	83 7c 24 54 1e       	cmpl   $0x1e,0x54(%esp)
    15a8:	0f 87 23 15 00 00    	ja     2ad1 <_zipinfo+0x1911>
        sprintf(unkn, LoadFarString(UnknownNo),
                (int)G.crec.version_made_by[1]);
        varmsg_str = unkn;
    } else {
        varmsg_str = LoadFarStringSmall(os[hostnum]);
    15ae:	8b 44 24 54          	mov    0x54(%esp),%eax
    15b2:	8b 04 85 40 04 00 00 	mov    0x440(,%eax,4),%eax
            /* entry made by old non-official THEOS port zip archive */
            varmsg_str = LoadFarStringSmall(OS_TheosOld);
        }
#endif /* OLD_THEOS_EXTRA */
    }
    Info(slide, 0, ((char *)slide, LoadFarString(HostOS), varmsg_str));
    15b9:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    15bf:	89 44 24 08          	mov    %eax,0x8(%esp)
    15c3:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    15c7:	c7 44 24 04 20 18 00 	movl   $0x1820,0x4(%esp)
    15ce:	00 
    15cf:	89 04 24             	mov    %eax,(%esp)
    15d2:	e8 00 00 00 00       	call   15d7 <_zipinfo+0x417>
    15d7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    15de:	00 
    15df:	89 44 24 08          	mov    %eax,0x8(%esp)
    15e3:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    15e7:	89 44 24 04          	mov    %eax,0x4(%esp)
    15eb:	89 2c 24             	mov    %ebp,(%esp)
    15ee:	ff d7                	call   *%edi
    Info(slide, 0, ((char *)slide, LoadFarString(EncodeSWVer), hostver/10,
    15f0:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
            /* entry made by old non-official THEOS port zip archive */
            varmsg_str = LoadFarStringSmall(OS_TheosOld);
        }
#endif /* OLD_THEOS_EXTRA */
    }
    Info(slide, 0, ((char *)slide, LoadFarString(HostOS), varmsg_str));
    15f5:	83 ec 10             	sub    $0x10,%esp
    Info(slide, 0, ((char *)slide, LoadFarString(EncodeSWVer), hostver/10,
    15f8:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    15fe:	8b 44 24 60          	mov    0x60(%esp),%eax
    1602:	8b 4c 24 60          	mov    0x60(%esp),%ecx
    1606:	f7 e2                	mul    %edx
    1608:	c1 ea 03             	shr    $0x3,%edx
    160b:	c7 44 24 04 e0 17 00 	movl   $0x17e0,0x4(%esp)
    1612:	00 
    1613:	89 54 24 08          	mov    %edx,0x8(%esp)
    1617:	8d 04 92             	lea    (%edx,%edx,4),%eax
    161a:	01 c0                	add    %eax,%eax
    161c:	29 c1                	sub    %eax,%ecx
    161e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    1622:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    1626:	89 04 24             	mov    %eax,(%esp)
    1629:	e8 00 00 00 00       	call   162e <_zipinfo+0x46e>
    162e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1635:	00 
    1636:	89 44 24 08          	mov    %eax,0x8(%esp)
    163a:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    163e:	89 44 24 04          	mov    %eax,0x4(%esp)
    1642:	89 2c 24             	mov    %ebp,(%esp)
    1645:	ff d7                	call   *%edi
    1647:	83 ec 10             	sub    $0x10,%esp
      hostver%10));

    if ((extnum >= NUM_HOSTS) || (os[extnum] == NULL)) {
    164a:	83 fe 1f             	cmp    $0x1f,%esi
    164d:	0f 84 7f 09 00 00    	je     1fd2 <_zipinfo+0xe12>
    1653:	8b 04 b5 40 04 00 00 	mov    0x440(,%esi,4),%eax
    165a:	85 c0                	test   %eax,%eax
    165c:	0f 84 70 09 00 00    	je     1fd2 <_zipinfo+0xe12>
                (int)G.crec.version_needed_to_extract[1]);
        varmsg_str = unkn;
    } else {
        varmsg_str = LoadFarStringSmall(os[extnum]);
    }
    Info(slide, 0, ((char *)slide, LoadFarString(MinOSCompReq), varmsg_str));
    1662:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    1666:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    166c:	89 44 24 08          	mov    %eax,0x8(%esp)
    1670:	c7 44 24 04 a0 17 00 	movl   $0x17a0,0x4(%esp)
    1677:	00 
    1678:	89 3c 24             	mov    %edi,(%esp)
    167b:	e8 00 00 00 00       	call   1680 <_zipinfo+0x4c0>
    1680:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1687:	00 
    1688:	89 44 24 08          	mov    %eax,0x8(%esp)
    168c:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1690:	89 2c 24             	mov    %ebp,(%esp)
    1693:	ff d6                	call   *%esi
    Info(slide, 0, ((char *)slide, LoadFarString(MinSWVerReq), extver/10,
    1695:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
                (int)G.crec.version_needed_to_extract[1]);
        varmsg_str = unkn;
    } else {
        varmsg_str = LoadFarStringSmall(os[extnum]);
    }
    Info(slide, 0, ((char *)slide, LoadFarString(MinOSCompReq), varmsg_str));
    169a:	83 ec 10             	sub    $0x10,%esp
    Info(slide, 0, ((char *)slide, LoadFarString(MinSWVerReq), extver/10,
    169d:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    16a3:	8b 44 24 68          	mov    0x68(%esp),%eax
    16a7:	8b 4c 24 68          	mov    0x68(%esp),%ecx
    16ab:	f7 e2                	mul    %edx
    16ad:	c1 ea 03             	shr    $0x3,%edx
    16b0:	c7 44 24 04 60 17 00 	movl   $0x1760,0x4(%esp)
    16b7:	00 
    16b8:	89 54 24 08          	mov    %edx,0x8(%esp)
    16bc:	89 3c 24             	mov    %edi,(%esp)
    16bf:	8d 04 92             	lea    (%edx,%edx,4),%eax
    16c2:	01 c0                	add    %eax,%eax
    16c4:	29 c1                	sub    %eax,%ecx
    16c6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    16ca:	e8 00 00 00 00       	call   16cf <_zipinfo+0x50f>
    16cf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    16d6:	00 
    16d7:	89 44 24 08          	mov    %eax,0x8(%esp)
    16db:	89 7c 24 04          	mov    %edi,0x4(%esp)
    16df:	89 2c 24             	mov    %ebp,(%esp)
    16e2:	ff d6                	call   *%esi
    16e4:	83 ec 10             	sub    $0x10,%esp
      extver%10));

    if (methnum >= NUM_METHODS) {
    16e7:	83 fb 0d             	cmp    $0xd,%ebx
    16ea:	0f 84 82 13 00 00    	je     2a72 <_zipinfo+0x18b2>
        sprintf(unkn, LoadFarString(UnknownNo), G.crec.compression_method);
        varmsg_str = unkn;
    } else {
        varmsg_str = LoadFarStringSmall(method[methnum]);
    }
    Info(slide, 0, ((char *)slide, LoadFarString(CompressMethod), varmsg_str));
    16f0:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    16f4:	8b 04 9d 00 04 00 00 	mov    0x400(,%ebx,4),%eax
    16fb:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    1701:	89 44 24 08          	mov    %eax,0x8(%esp)
    1705:	c7 44 24 04 20 17 00 	movl   $0x1720,0x4(%esp)
    170c:	00 
    170d:	89 3c 24             	mov    %edi,(%esp)
    1710:	e8 00 00 00 00       	call   1715 <_zipinfo+0x555>
    1715:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    171c:	00 
    171d:	89 44 24 08          	mov    %eax,0x8(%esp)
    1721:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1725:	89 2c 24             	mov    %ebp,(%esp)
    1728:	ff d6                	call   *%esi
    172a:	83 ec 10             	sub    $0x10,%esp
    if (methnum == IMPLODED) {
    172d:	83 fb 06             	cmp    $0x6,%ebx
    1730:	0f 84 1a 15 00 00    	je     2c50 <_zipinfo+0x1a90>
        Info(slide, 0, ((char *)slide, LoadFarString(SlideWindowSizeImplode),
          (G.crec.general_purpose_bit_flag & 2)? '8' : '4'));
        Info(slide, 0, ((char *)slide, LoadFarString(ShannonFanoTrees),
          (G.crec.general_purpose_bit_flag & 4)? '3' : '2'));
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
    1736:	83 eb 08             	sub    $0x8,%ebx
    1739:	83 fb 01             	cmp    $0x1,%ebx
    173c:	0f 86 1a 1f 00 00    	jbe    365c <_zipinfo+0x249c>

        Info(slide, 0, ((char *)slide, LoadFarString(CompressSubtype),
          LoadFarStringSmall(dtypelng[dnum])));
    }

    Info(slide, 0, ((char *)slide, LoadFarString(FileSecurity),
    1742:	ba 7c 01 00 00       	mov    $0x17c,%edx
    1747:	b8 c8 1f 00 00       	mov    $0x1fc8,%eax
    174c:	f6 85 40 09 01 00 01 	testb  $0x1,0x10940(%ebp)
    1753:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    1757:	0f 44 c2             	cmove  %edx,%eax
    175a:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1760:	89 34 24             	mov    %esi,(%esp)
    1763:	89 44 24 08          	mov    %eax,0x8(%esp)
    1767:	c7 44 24 04 00 16 00 	movl   $0x1600,0x4(%esp)
    176e:	00 
    176f:	e8 00 00 00 00       	call   1774 <_zipinfo+0x5b4>
    1774:	89 74 24 04          	mov    %esi,0x4(%esp)
    1778:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    177f:	00 
    1780:	89 44 24 08          	mov    %eax,0x8(%esp)
    1784:	89 2c 24             	mov    %ebp,(%esp)
    1787:	ff d3                	call   *%ebx
      (G.crec.general_purpose_bit_flag & 1) ? nullStr : "not "));
    Info(slide, 0, ((char *)slide, LoadFarString(ExtendedLocalHdr),
    1789:	ba 85 01 00 00       	mov    $0x185,%edx

        Info(slide, 0, ((char *)slide, LoadFarString(CompressSubtype),
          LoadFarStringSmall(dtypelng[dnum])));
    }

    Info(slide, 0, ((char *)slide, LoadFarString(FileSecurity),
    178e:	83 ec 10             	sub    $0x10,%esp
      (G.crec.general_purpose_bit_flag & 1) ? nullStr : "not "));
    Info(slide, 0, ((char *)slide, LoadFarString(ExtendedLocalHdr),
    1791:	b8 81 01 00 00       	mov    $0x181,%eax
    1796:	f6 85 40 09 01 00 08 	testb  $0x8,0x10940(%ebp)
    179d:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    17a3:	0f 44 c2             	cmove  %edx,%eax
    17a6:	89 34 24             	mov    %esi,(%esp)
    17a9:	89 44 24 08          	mov    %eax,0x8(%esp)
    17ad:	c7 44 24 04 c0 15 00 	movl   $0x15c0,0x4(%esp)
    17b4:	00 
    17b5:	e8 00 00 00 00       	call   17ba <_zipinfo+0x5fa>
    17ba:	89 74 24 04          	mov    %esi,0x4(%esp)
    17be:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    17c5:	00 
    17c6:	89 44 24 08          	mov    %eax,0x8(%esp)
    17ca:	89 2c 24             	mov    %ebp,(%esp)
    17cd:	89 74 24 3c          	mov    %esi,0x3c(%esp)
    17d1:	ff d3                	call   *%ebx
    17d3:	8d 55 28             	lea    0x28(%ebp),%edx
    17d6:	83 ec 10             	sub    $0x10,%esp
    17d9:	89 d7                	mov    %edx,%edi
    17db:	8d 5d 48             	lea    0x48(%ebp),%ebx
     * To save stack space, we reuse the "char attribs[22]" buffer which
     * is not used yet.
     */
#   define d_t_buf attribs

    zi_time(__G__ &G.crec.last_mod_dos_datetime, NULL, d_t_buf);
    17de:	8d 8d 44 09 01 00    	lea    0x10944(%ebp),%ecx
    17e4:	8d b4 24 ba 00 00 00 	lea    0xba(%esp),%esi
    17eb:	89 54 24 68          	mov    %edx,0x68(%esp)
    17ef:	89 74 24 04          	mov    %esi,0x4(%esp)
    17f3:	89 da                	mov    %ebx,%edx
    17f5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    17fc:	89 f8                	mov    %edi,%eax
    17fe:	89 4c 24 60          	mov    %ecx,0x60(%esp)
    1802:	e8 99 ee ff ff       	call   6a0 <_zi_time.isra.0>
    Info(slide, 0, ((char *)slide, LoadFarString(FileModDate), d_t_buf));
    1807:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    180b:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    1811:	89 74 24 08          	mov    %esi,0x8(%esp)
    1815:	c7 44 24 04 80 15 00 	movl   $0x1580,0x4(%esp)
    181c:	00 
    181d:	89 04 24             	mov    %eax,(%esp)
    1820:	e8 00 00 00 00       	call   1825 <_zipinfo+0x665>
    1825:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    182c:	00 
    182d:	89 44 24 08          	mov    %eax,0x8(%esp)
    1831:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    1835:	89 44 24 04          	mov    %eax,0x4(%esp)
    1839:	89 2c 24             	mov    %ebp,(%esp)
    183c:	ff d7                	call   *%edi
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
    183e:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
     * is not used yet.
     */
#   define d_t_buf attribs

    zi_time(__G__ &G.crec.last_mod_dos_datetime, NULL, d_t_buf);
    Info(slide, 0, ((char *)slide, LoadFarString(FileModDate), d_t_buf));
    1844:	83 ec 10             	sub    $0x10,%esp
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
    1847:	85 c0                	test   %eax,%eax
    1849:	74 42                	je     188d <_zipinfo+0x6cd>
#ifdef IZ_CHECK_TZ
        G.tz_is_valid &&
#endif
        (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
    184b:	8d 94 24 90 00 00 00 	lea    0x90(%esp),%edx
    1852:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    1859:	00 
    185a:	89 54 24 10          	mov    %edx,0x10(%esp)
    185e:	8b 95 44 09 01 00    	mov    0x10944(%ebp),%edx
    1864:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    186b:	00 
    186c:	89 54 24 0c          	mov    %edx,0xc(%esp)
    1870:	31 d2                	xor    %edx,%edx
    1872:	66 8b 95 56 09 01 00 	mov    0x10956(%ebp),%dx
    1879:	89 04 24             	mov    %eax,(%esp)
    187c:	89 54 24 04          	mov    %edx,0x4(%esp)
    1880:	e8 00 00 00 00       	call   1885 <_zipinfo+0x6c5>
#   define d_t_buf attribs

    zi_time(__G__ &G.crec.last_mod_dos_datetime, NULL, d_t_buf);
    Info(slide, 0, ((char *)slide, LoadFarString(FileModDate), d_t_buf));
#ifdef USE_EF_UT_TIME
    if (G.extra_field &&
    1885:	a8 01                	test   $0x1,%al
    1887:	0f 85 55 16 00 00    	jne    2ee2 <_zipinfo+0x1d22>
          d_t_buf, LoadFarStringSmall(GMTime)));
#endif /* !NO_GMTIME */
    }
#endif /* USE_EF_UT_TIME */

    Info(slide, 0, ((char *)slide, LoadFarString(CRC32Value), G.crec.crc32));
    188d:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    1891:	8b 85 48 09 01 00    	mov    0x10948(%ebp),%eax
    1897:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    189d:	89 44 24 08          	mov    %eax,0x8(%esp)
    18a1:	c7 44 24 04 e0 14 00 	movl   $0x14e0,0x4(%esp)
    18a8:	00 
    18a9:	89 3c 24             	mov    %edi,(%esp)
    18ac:	e8 00 00 00 00       	call   18b1 <_zipinfo+0x6f1>
    18b1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    18b8:	00 
    18b9:	89 44 24 08          	mov    %eax,0x8(%esp)
    18bd:	89 7c 24 04          	mov    %edi,0x4(%esp)
    18c1:	89 2c 24             	mov    %ebp,(%esp)
    18c4:	ff d3                	call   *%ebx
    Info(slide, 0, ((char *)slide, LoadFarString(CompressedFileSize),
    18c6:	8b 85 4c 09 01 00    	mov    0x1094c(%ebp),%eax
          d_t_buf, LoadFarStringSmall(GMTime)));
#endif /* !NO_GMTIME */
    }
#endif /* USE_EF_UT_TIME */

    Info(slide, 0, ((char *)slide, LoadFarString(CRC32Value), G.crec.crc32));
    18cc:	83 ec 10             	sub    $0x10,%esp
    Info(slide, 0, ((char *)slide, LoadFarString(CompressedFileSize),
    18cf:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    18d5:	89 44 24 08          	mov    %eax,0x8(%esp)
    18d9:	c7 44 24 04 a0 14 00 	movl   $0x14a0,0x4(%esp)
    18e0:	00 
    18e1:	89 3c 24             	mov    %edi,(%esp)
    18e4:	e8 00 00 00 00       	call   18e9 <_zipinfo+0x729>
    18e9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    18f0:	00 
    18f1:	89 44 24 08          	mov    %eax,0x8(%esp)
    18f5:	89 7c 24 04          	mov    %edi,0x4(%esp)
    18f9:	89 2c 24             	mov    %ebp,(%esp)
    18fc:	ff d3                	call   *%ebx
      G.crec.csize));
    Info(slide, 0, ((char *)slide, LoadFarString(UncompressedFileSize),
    18fe:	8b 85 50 09 01 00    	mov    0x10950(%ebp),%eax
#endif /* !NO_GMTIME */
    }
#endif /* USE_EF_UT_TIME */

    Info(slide, 0, ((char *)slide, LoadFarString(CRC32Value), G.crec.crc32));
    Info(slide, 0, ((char *)slide, LoadFarString(CompressedFileSize),
    1904:	83 ec 10             	sub    $0x10,%esp
      G.crec.csize));
    Info(slide, 0, ((char *)slide, LoadFarString(UncompressedFileSize),
    1907:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    190d:	89 44 24 08          	mov    %eax,0x8(%esp)
    1911:	c7 44 24 04 60 14 00 	movl   $0x1460,0x4(%esp)
    1918:	00 
    1919:	89 3c 24             	mov    %edi,(%esp)
    191c:	e8 00 00 00 00       	call   1921 <_zipinfo+0x761>
    1921:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1928:	00 
    1929:	89 44 24 08          	mov    %eax,0x8(%esp)
    192d:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1931:	89 2c 24             	mov    %ebp,(%esp)
    1934:	ff d3                	call   *%ebx
      G.crec.ucsize));
    Info(slide, 0, ((char *)slide, LoadFarString(FilenameLength),
    1936:	31 c0                	xor    %eax,%eax
#endif /* USE_EF_UT_TIME */

    Info(slide, 0, ((char *)slide, LoadFarString(CRC32Value), G.crec.crc32));
    Info(slide, 0, ((char *)slide, LoadFarString(CompressedFileSize),
      G.crec.csize));
    Info(slide, 0, ((char *)slide, LoadFarString(UncompressedFileSize),
    1938:	83 ec 10             	sub    $0x10,%esp
      G.crec.ucsize));
    Info(slide, 0, ((char *)slide, LoadFarString(FilenameLength),
    193b:	66 8b 85 54 09 01 00 	mov    0x10954(%ebp),%ax
    1942:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1948:	89 44 24 08          	mov    %eax,0x8(%esp)
    194c:	c7 44 24 04 00 14 00 	movl   $0x1400,0x4(%esp)
    1953:	00 
    1954:	89 3c 24             	mov    %edi,(%esp)
    1957:	e8 00 00 00 00       	call   195c <_zipinfo+0x79c>
    195c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1963:	00 
    1964:	89 44 24 08          	mov    %eax,0x8(%esp)
    1968:	89 7c 24 04          	mov    %edi,0x4(%esp)
    196c:	89 2c 24             	mov    %ebp,(%esp)
    196f:	ff d3                	call   *%ebx
      G.crec.filename_length));
    Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldLength),
    1971:	31 c0                	xor    %eax,%eax
    Info(slide, 0, ((char *)slide, LoadFarString(CRC32Value), G.crec.crc32));
    Info(slide, 0, ((char *)slide, LoadFarString(CompressedFileSize),
      G.crec.csize));
    Info(slide, 0, ((char *)slide, LoadFarString(UncompressedFileSize),
      G.crec.ucsize));
    Info(slide, 0, ((char *)slide, LoadFarString(FilenameLength),
    1973:	83 ec 10             	sub    $0x10,%esp
      G.crec.filename_length));
    Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldLength),
    1976:	66 8b 85 56 09 01 00 	mov    0x10956(%ebp),%ax
    197d:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1983:	89 44 24 08          	mov    %eax,0x8(%esp)
    1987:	c7 44 24 04 c0 13 00 	movl   $0x13c0,0x4(%esp)
    198e:	00 
    198f:	89 3c 24             	mov    %edi,(%esp)
    1992:	e8 00 00 00 00       	call   1997 <_zipinfo+0x7d7>
    1997:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    199e:	00 
    199f:	89 44 24 08          	mov    %eax,0x8(%esp)
    19a3:	89 7c 24 04          	mov    %edi,0x4(%esp)
    19a7:	89 2c 24             	mov    %ebp,(%esp)
    19aa:	ff d3                	call   *%ebx
      G.crec.extra_field_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileCommentLength),
    19ac:	31 c0                	xor    %eax,%eax
      G.crec.csize));
    Info(slide, 0, ((char *)slide, LoadFarString(UncompressedFileSize),
      G.crec.ucsize));
    Info(slide, 0, ((char *)slide, LoadFarString(FilenameLength),
      G.crec.filename_length));
    Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldLength),
    19ae:	83 ec 10             	sub    $0x10,%esp
      G.crec.extra_field_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileCommentLength),
    19b1:	66 8b 85 58 09 01 00 	mov    0x10958(%ebp),%ax
    19b8:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    19be:	89 44 24 08          	mov    %eax,0x8(%esp)
    19c2:	c7 44 24 04 60 13 00 	movl   $0x1360,0x4(%esp)
    19c9:	00 
    19ca:	89 3c 24             	mov    %edi,(%esp)
    19cd:	e8 00 00 00 00       	call   19d2 <_zipinfo+0x812>
    19d2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    19d9:	00 
    19da:	89 44 24 08          	mov    %eax,0x8(%esp)
    19de:	89 7c 24 04          	mov    %edi,0x4(%esp)
    19e2:	89 2c 24             	mov    %ebp,(%esp)
    19e5:	ff d3                	call   *%ebx
      G.crec.file_comment_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileDiskNum),
    19e7:	31 c0                	xor    %eax,%eax
      G.crec.ucsize));
    Info(slide, 0, ((char *)slide, LoadFarString(FilenameLength),
      G.crec.filename_length));
    Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldLength),
      G.crec.extra_field_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileCommentLength),
    19e9:	83 ec 10             	sub    $0x10,%esp
      G.crec.file_comment_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileDiskNum),
    19ec:	66 8b 85 5a 09 01 00 	mov    0x1095a(%ebp),%ax
    19f3:	40                   	inc    %eax
    19f4:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    19fa:	89 44 24 08          	mov    %eax,0x8(%esp)
    19fe:	c7 44 24 04 20 13 00 	movl   $0x1320,0x4(%esp)
    1a05:	00 
    1a06:	89 3c 24             	mov    %edi,(%esp)
    1a09:	e8 00 00 00 00       	call   1a0e <_zipinfo+0x84e>
    1a0e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1a15:	00 
    1a16:	89 44 24 08          	mov    %eax,0x8(%esp)
    1a1a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1a1e:	89 2c 24             	mov    %ebp,(%esp)
    1a21:	ff d3                	call   *%ebx
      G.crec.disk_number_start + 1));
    Info(slide, 0, ((char *)slide, LoadFarString(ApparentFileType),
    1a23:	8b 95 5c 09 01 00    	mov    0x1095c(%ebp),%edx
      G.crec.filename_length));
    Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldLength),
      G.crec.extra_field_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileCommentLength),
      G.crec.file_comment_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileDiskNum),
    1a29:	83 ec 10             	sub    $0x10,%esp
      G.crec.disk_number_start + 1));
    Info(slide, 0, ((char *)slide, LoadFarString(ApparentFileType),
    1a2c:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1a32:	b8 88 01 00 00       	mov    $0x188,%eax
    1a37:	f6 c2 01             	test   $0x1,%dl
    1a3a:	75 10                	jne    1a4c <_zipinfo+0x88c>
    1a3c:	83 e2 02             	and    $0x2,%edx
    1a3f:	b8 94 01 00 00       	mov    $0x194,%eax
    1a44:	ba 8d 01 00 00       	mov    $0x18d,%edx
    1a49:	0f 44 c2             	cmove  %edx,%eax
    1a4c:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    1a50:	89 44 24 08          	mov    %eax,0x8(%esp)
    1a54:	89 3c 24             	mov    %edi,(%esp)
    1a57:	c7 44 24 04 e0 12 00 	movl   $0x12e0,0x4(%esp)
    1a5e:	00 
    1a5f:	e8 00 00 00 00       	call   1a64 <_zipinfo+0x8a4>
    1a64:	89 7c 24 04          	mov    %edi,0x4(%esp)
    1a68:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1a6f:	00 
    1a70:	89 44 24 08          	mov    %eax,0x8(%esp)
    1a74:	89 2c 24             	mov    %ebp,(%esp)
    1a77:	ff d3                	call   *%ebx
              : "binary"));             /* changed to accept EBCDIC */
#ifdef ATARI
    printf("  external file attributes (hex):                   %.8lx\n",
      G.crec.external_file_attributes);
#endif
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    1a79:	8b 85 60 09 01 00    	mov    0x10960(%ebp),%eax
      G.crec.extra_field_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileCommentLength),
      G.crec.file_comment_length));
    Info(slide, 0, ((char *)slide, LoadFarString(FileDiskNum),
      G.crec.disk_number_start + 1));
    Info(slide, 0, ((char *)slide, LoadFarString(ApparentFileType),
    1a7f:	83 ec 10             	sub    $0x10,%esp
              : "binary"));             /* changed to accept EBCDIC */
#ifdef ATARI
    printf("  external file attributes (hex):                   %.8lx\n",
      G.crec.external_file_attributes);
#endif
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    1a82:	89 c7                	mov    %eax,%edi
    1a84:	c1 ef 10             	shr    $0x10,%edi
    if (hostnum == VMS_) {
    1a87:	83 7c 24 54 02       	cmpl   $0x2,0x54(%esp)
    1a8c:	0f 84 9e 10 00 00    	je     2b30 <_zipinfo+0x1970>
        *p-- = '\0';
        *p = ')';   /* overwrite last comma */
        Info(slide, 0, ((char *)slide, LoadFarString(VMSFileAttributes), xattr,
          attribs));

    } else if (hostnum == AMIGA_) {
    1a92:	83 7c 24 54 01       	cmpl   $0x1,0x54(%esp)
    1a97:	0f 84 c9 12 00 00    	je     2d66 <_zipinfo+0x1ba6>
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
          xattr, attribs));

    } else if (hostnum == THEOS_) {
    1a9d:	83 7c 24 54 12       	cmpl   $0x12,0x54(%esp)
    1aa2:	0f 84 ab 18 00 00    	je     3353 <_zipinfo+0x2193>
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
          xattr, attribs));
#endif /* OLD_THEOS_EXTRA */

    } else if ((hostnum != FS_FAT_) && (hostnum != FS_HPFS_) &&
    1aa8:	f6 84 24 87 00 00 00 	testb  $0xfb,0x87(%esp)
    1aaf:	fb 
    1ab0:	74 12                	je     1ac4 <_zipinfo+0x904>
    1ab2:	8b 4c 24 54          	mov    0x54(%esp),%ecx
    1ab6:	83 f9 06             	cmp    $0x6,%ecx
    1ab9:	74 09                	je     1ac4 <_zipinfo+0x904>
               (hostnum != FS_NTFS_) && (hostnum != FS_VFAT_) &&
    1abb:	83 f9 0b             	cmp    $0xb,%ecx
    1abe:	0f 85 da 19 00 00    	jne    349e <_zipinfo+0x22de>

        Info(slide, 0, ((char *)slide, LoadFarString(UnixFileAttributes), xattr,
          attribs));

    } else {
        Info(slide, 0, ((char *)slide, LoadFarString(NonMSDOSFileAttributes),
    1ac4:	c1 e8 08             	shr    $0x8,%eax
    1ac7:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    1acb:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    1ad1:	89 44 24 08          	mov    %eax,0x8(%esp)
    1ad5:	c7 44 24 04 e0 11 00 	movl   $0x11e0,0x4(%esp)
    1adc:	00 
    1add:	89 34 24             	mov    %esi,(%esp)
    1ae0:	e8 00 00 00 00       	call   1ae5 <_zipinfo+0x925>
    1ae5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1aec:	00 
    1aed:	89 44 24 08          	mov    %eax,0x8(%esp)
    1af1:	89 74 24 04          	mov    %esi,0x4(%esp)
    1af5:	89 2c 24             	mov    %ebp,(%esp)
    1af8:	ff d3                	call   *%ebx
            G.crec.external_file_attributes >> 8));

    } /* endif (hostnum: external attributes format) */

    if ((xattr=(unsigned)(G.crec.external_file_attributes & 0xFF)) == 0)
    1afa:	8b 85 60 09 01 00    	mov    0x10960(%ebp),%eax

        Info(slide, 0, ((char *)slide, LoadFarString(UnixFileAttributes), xattr,
          attribs));

    } else {
        Info(slide, 0, ((char *)slide, LoadFarString(NonMSDOSFileAttributes),
    1b00:	83 ec 10             	sub    $0x10,%esp
            G.crec.external_file_attributes >> 8));

    } /* endif (hostnum: external attributes format) */

    if ((xattr=(unsigned)(G.crec.external_file_attributes & 0xFF)) == 0)
    1b03:	89 c1                	mov    %eax,%ecx
    1b05:	81 e1 ff 00 00 00    	and    $0xff,%ecx
    1b0b:	89 4c 24 60          	mov    %ecx,0x60(%esp)
    1b0f:	0f 84 92 0e 00 00    	je     29a7 <_zipinfo+0x17e7>
        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributes),
          xattr));
    else if (xattr == 1)
    1b15:	83 7c 24 60 01       	cmpl   $0x1,0x60(%esp)
    1b1a:	0f 84 0e 21 00 00    	je     3c2e <_zipinfo+0x2a6e>
        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributesRO),
          xattr));
    else
        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributesAlpha),
    1b20:	8b 8d 44 0b 01 00    	mov    0x10b44(%ebp),%ecx
    1b26:	ba c8 1f 00 00       	mov    $0x1fc8,%edx
    1b2b:	89 4c 24 68          	mov    %ecx,0x68(%esp)
    1b2f:	b9 9b 01 00 00       	mov    $0x19b,%ecx
    1b34:	a8 80                	test   $0x80,%al
    1b36:	bf a9 01 00 00       	mov    $0x1a9,%edi
    1b3b:	0f 44 ca             	cmove  %edx,%ecx
    1b3e:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    1b42:	b9 9f 01 00 00       	mov    $0x19f,%ecx
    1b47:	a8 40                	test   $0x40,%al
    1b49:	be ae 01 00 00       	mov    $0x1ae,%esi
    1b4e:	0f 44 ca             	cmove  %edx,%ecx
    1b51:	89 4c 24 24          	mov    %ecx,0x24(%esp)
    1b55:	b9 a4 01 00 00       	mov    $0x1a4,%ecx
    1b5a:	a8 20                	test   $0x20,%al
    1b5c:	bb b3 01 00 00       	mov    $0x1b3,%ebx
    1b61:	0f 44 ca             	cmove  %edx,%ecx
    1b64:	89 4c 24 20          	mov    %ecx,0x20(%esp)
    1b68:	b9 b8 01 00 00       	mov    $0x1b8,%ecx
    1b6d:	a8 10                	test   $0x10,%al
    1b6f:	c7 44 24 04 e0 10 00 	movl   $0x10e0,0x4(%esp)
    1b76:	00 
    1b77:	0f 44 fa             	cmove  %edx,%edi
    1b7a:	a8 08                	test   $0x8,%al
    1b7c:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
    1b80:	0f 44 f2             	cmove  %edx,%esi
    1b83:	a8 04                	test   $0x4,%al
    1b85:	89 74 24 18          	mov    %esi,0x18(%esp)
    1b89:	0f 44 da             	cmove  %edx,%ebx
    1b8c:	a8 02                	test   $0x2,%al
    1b8e:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    1b92:	0f 44 ca             	cmove  %edx,%ecx
    1b95:	a8 01                	test   $0x1,%al
    1b97:	b8 bd 01 00 00       	mov    $0x1bd,%eax
    1b9c:	0f 45 d0             	cmovne %eax,%edx
    1b9f:	8b 44 24 60          	mov    0x60(%esp),%eax
    1ba3:	89 5c 24 14          	mov    %ebx,0x14(%esp)
    1ba7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    1bab:	89 54 24 0c          	mov    %edx,0xc(%esp)
    1baf:	89 44 24 08          	mov    %eax,0x8(%esp)
    1bb3:	89 34 24             	mov    %esi,(%esp)
    1bb6:	e8 00 00 00 00       	call   1bbb <_zipinfo+0x9fb>
    1bbb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1bc2:	00 
    1bc3:	89 44 24 08          	mov    %eax,0x8(%esp)
    1bc7:	89 74 24 04          	mov    %esi,0x4(%esp)
    1bcb:	89 2c 24             	mov    %ebp,(%esp)
    1bce:	ff 54 24 68          	call   *0x68(%esp)
    1bd2:	83 ec 10             	sub    $0x10,%esp
    Analyze the extra field, if any, and print the file comment, if any (the
    filename has already been printed, above).  That finishes up this file
    entry...
  ---------------------------------------------------------------------------*/

    if (G.crec.extra_field_length > 0) {
    1bd5:	66 8b 85 56 09 01 00 	mov    0x10956(%ebp),%ax
    1bdc:	66 85 c0             	test   %ax,%ax
    1bdf:	66 89 44 24 60       	mov    %ax,0x60(%esp)
    1be4:	0f 84 88 0c 00 00    	je     2872 <_zipinfo+0x16b2>
        uch *ef_ptr = G.extra_field;
    1bea:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
    1bf0:	89 44 24 68          	mov    %eax,0x68(%esp)
        ush ef_len = G.crec.extra_field_length;
        ush eb_id, eb_datalen;
        ZCONST char Far *ef_fieldname;

        if (error_in_archive > PK_WARN)   /* fatal:  can't continue */
    1bf4:	83 7c 24 74 01       	cmpl   $0x1,0x74(%esp)
    1bf9:	0f 8e 4b 14 00 00    	jle    304a <_zipinfo+0x1e8a>
                    break;

                case 10:
                    Info(slide, 0, ((char *)slide,
                      LoadFarString(CentralDirEntry), j));
                    if ((error = zi_long(__G__ &endprev)) != PK_COOL) {
    1bff:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    1c03:	85 f6                	test   %esi,%esi
    1c05:	0f 84 dc 00 00 00    	je     1ce7 <_zipinfo+0xb27>
    1c0b:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    1c0f:	89 44 24 50          	mov    %eax,0x50(%esp)
                        error_in_archive = error;   /* might be warning */
                        if (error > PK_WARN)        /* fatal */
    1c13:	48                   	dec    %eax
    1c14:	0f 8e cd 00 00 00    	jle    1ce7 <_zipinfo+0xb27>
    1c1a:	8b 5c 24 6c          	mov    0x6c(%esp),%ebx
    1c1e:	e9 a2 03 00 00       	jmp    1fc5 <_zipinfo+0xe05>

/*---------------------------------------------------------------------------
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    1c23:	66 8b 9d 42 09 01 00 	mov    0x10942(%ebp),%bx
    1c2a:	66 83 fb 0c          	cmp    $0xc,%bx
    1c2e:	0f 87 9c 02 00 00    	ja     1ed0 <_zipinfo+0xd10>
    hostnum = (unsigned)(G.pInfo->hostnum);
    1c34:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax

/*---------------------------------------------------------------------------
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    1c3a:	31 ff                	xor    %edi,%edi
    1c3c:	66 89 df             	mov    %bx,%di
    hostnum = (unsigned)(G.pInfo->hostnum);
    1c3f:	8a 48 13             	mov    0x13(%eax),%cl
    1c42:	88 4c 24 68          	mov    %cl,0x68(%esp)
    1c46:	81 e1 ff 00 00 00    	and    $0xff,%ecx
    1c4c:	89 4c 24 60          	mov    %ecx,0x60(%esp)
    hostver = (unsigned)(G.pInfo->hostver);
    1c50:	31 c9                	xor    %ecx,%ecx
    1c52:	8a 48 12             	mov    0x12(%eax),%cl
/*
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    extver = (unsigned)G.crec.version_needed_to_extract[0];
 */

    zfstrcpy(methbuf, method[methnum]);
    1c55:	8d 84 bf a0 05 00 00 	lea    0x5a0(%edi,%edi,4),%eax
    1c5c:	89 44 24 04          	mov    %eax,0x4(%esp)
    1c60:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
    1c67:	89 04 24             	mov    %eax,(%esp)
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    hostnum = (unsigned)(G.pInfo->hostnum);
    hostver = (unsigned)(G.pInfo->hostver);
    1c6a:	89 4c 24 54          	mov    %ecx,0x54(%esp)
/*
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    extver = (unsigned)G.crec.version_needed_to_extract[0];
 */

    zfstrcpy(methbuf, method[methnum]);
    1c6e:	89 44 24 6c          	mov    %eax,0x6c(%esp)
    1c72:	e8 00 00 00 00       	call   1c77 <_zipinfo+0xab7>
    if (methnum == IMPLODED) {
    1c77:	66 83 fb 06          	cmp    $0x6,%bx
    1c7b:	0f 85 41 01 00 00    	jne    1dc2 <_zipinfo+0xc02>
        methbuf[1] = (char)((G.crec.general_purpose_bit_flag & 2)? '8' : '4');
    1c81:	8b 95 40 09 01 00    	mov    0x10940(%ebp),%edx
    1c87:	89 d0                	mov    %edx,%eax
    1c89:	83 e0 02             	and    $0x2,%eax
    1c8c:	66 83 f8 01          	cmp    $0x1,%ax
    1c90:	19 c0                	sbb    %eax,%eax
    1c92:	83 e0 fc             	and    $0xfffffffc,%eax
    1c95:	83 c0 38             	add    $0x38,%eax
    1c98:	88 84 24 9d 00 00 00 	mov    %al,0x9d(%esp)
        methbuf[3] = (char)((G.crec.general_purpose_bit_flag & 4)? '3' : '2');
    1c9f:	89 d0                	mov    %edx,%eax
    1ca1:	83 e0 04             	and    $0x4,%eax
    1ca4:	66 83 f8 01          	cmp    $0x1,%ax
    1ca8:	19 c0                	sbb    %eax,%eax
    1caa:	83 c0 33             	add    $0x33,%eax
    1cad:	88 84 24 9f 00 00 00 	mov    %al,0x9f(%esp)
    1cb4:	e9 15 01 00 00       	jmp    1dce <_zipinfo+0xc0e>
    1cb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        if (G.process_all_files || do_this_file) {

            switch (uO.lflag) {
                case 1:
                case 2:
                    fnprint(__G);
    1cc0:	89 2c 24             	mov    %ebp,(%esp)
    1cc3:	e8 00 00 00 00       	call   1cc8 <_zipinfo+0xb08>
                    SKIP_(G.crec.extra_field_length)
    1cc8:	66 8b 8d 56 09 01 00 	mov    0x10956(%ebp),%cx
    1ccf:	66 85 c9             	test   %cx,%cx
    1cd2:	0f 85 48 0d 00 00    	jne    2a20 <_zipinfo+0x1860>
                    SKIP_(G.crec.file_comment_length)
    1cd8:	8b 8d 58 09 01 00    	mov    0x10958(%ebp),%ecx
    1cde:	66 85 c9             	test   %cx,%cx
    1ce1:	0f 85 79 0d 00 00    	jne    2a60 <_zipinfo+0x18a0>
                    SKIP_(G.crec.file_comment_length)
                    break;

            } /* end switch (lflag) */

            tot_csize += G.crec.csize;
    1ce7:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    1ceb:	8b 95 4c 09 01 00    	mov    0x1094c(%ebp),%edx
    1cf1:	01 d0                	add    %edx,%eax
            tot_ucsize += G.crec.ucsize;
    1cf3:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
    1cf7:	8b b5 50 09 01 00    	mov    0x10950(%ebp),%esi
            if (G.crec.general_purpose_bit_flag & 1)
                tot_csize -= 12;   /* don't count encryption header */
            ++members;
    1cfd:	8b 5c 24 58          	mov    0x58(%esp),%ebx
            } /* end switch (lflag) */

            tot_csize += G.crec.csize;
            tot_ucsize += G.crec.ucsize;
            if (G.crec.general_purpose_bit_flag & 1)
                tot_csize -= 12;   /* don't count encryption header */
    1d01:	8d 50 f4             	lea    -0xc(%eax),%edx
                    break;

            } /* end switch (lflag) */

            tot_csize += G.crec.csize;
            tot_ucsize += G.crec.ucsize;
    1d04:	01 f1                	add    %esi,%ecx
            if (G.crec.general_purpose_bit_flag & 1)
                tot_csize -= 12;   /* don't count encryption header */
    1d06:	f6 85 40 09 01 00 01 	testb  $0x1,0x10940(%ebp)
                    break;

            } /* end switch (lflag) */

            tot_csize += G.crec.csize;
            tot_ucsize += G.crec.ucsize;
    1d0d:	89 4c 24 5c          	mov    %ecx,0x5c(%esp)
            if (G.crec.general_purpose_bit_flag & 1)
                tot_csize -= 12;   /* don't count encryption header */
    1d11:	0f 45 c2             	cmovne %edx,%eax
    1d14:	89 44 24 4c          	mov    %eax,0x4c(%esp)
            ++members;
    1d18:	43                   	inc    %ebx

#ifdef DLL
            if ((G.statreportcb != NULL) &&
    1d19:	8b 85 54 0b 01 00    	mov    0x10b54(%ebp),%eax

            tot_csize += G.crec.csize;
            tot_ucsize += G.crec.ucsize;
            if (G.crec.general_purpose_bit_flag & 1)
                tot_csize -= 12;   /* don't count encryption header */
            ++members;
    1d1f:	89 5c 24 58          	mov    %ebx,0x58(%esp)

#ifdef DLL
            if ((G.statreportcb != NULL) &&
    1d23:	85 c0                	test   %eax,%eax
    1d25:	74 36                	je     1d5d <_zipinfo+0xb9d>
                (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,
                                  G.filename, (zvoid *)&G.crec.ucsize)) {
    1d27:	8d 95 50 09 01 00    	lea    0x10950(%ebp),%edx
    1d2d:	89 54 24 10          	mov    %edx,0x10(%esp)
    1d31:	8d 95 e0 09 01 00    	lea    0x109e0(%ebp),%edx
    1d37:	89 54 24 0c          	mov    %edx,0xc(%esp)
                tot_csize -= 12;   /* don't count encryption header */
            ++members;

#ifdef DLL
            if ((G.statreportcb != NULL) &&
                (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,
    1d3b:	8b 95 04 09 01 00    	mov    0x10904(%ebp),%edx
    1d41:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
    1d48:	00 
    1d49:	89 54 24 08          	mov    %edx,0x8(%esp)
    1d4d:	89 2c 24             	mov    %ebp,(%esp)
    1d50:	ff d0                	call   *%eax
    1d52:	83 ec 14             	sub    $0x14,%esp
            if (G.crec.general_purpose_bit_flag & 1)
                tot_csize -= 12;   /* don't count encryption header */
            ++members;

#ifdef DLL
            if ((G.statreportcb != NULL) &&
    1d55:	85 c0                	test   %eax,%eax
    1d57:	0f 85 3f 22 00 00    	jne    3f9c <_zipinfo+0x2ddc>

    /* reset endprev for new zipfile; account for multi-part archives (?) */
    endprev = (G.crec.relative_offset_local_header == 4L)? 4L : 0L;


    for (j = 1L;; j++) {
    1d5d:	8b 7c 24 44          	mov    0x44(%esp),%edi
    1d61:	47                   	inc    %edi
    1d62:	89 7c 24 44          	mov    %edi,0x44(%esp)
            SKIP_(G.crec.extra_field_length)
            SKIP_(G.crec.file_comment_length)

        } /* end if (list member?) */

    } /* end for-loop (j: member files) */
    1d66:	e9 0a f5 ff ff       	jmp    1275 <_zipinfo+0xb5>
    1d6b:	90                   	nop
    1d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                            return error;
                    }
                    break;

                default:
                    SKIP_(G.crec.extra_field_length)
    1d70:	66 8b 8d 56 09 01 00 	mov    0x10956(%ebp),%cx
    1d77:	66 85 c9             	test   %cx,%cx
    1d7a:	0f 85 66 0c 00 00    	jne    29e6 <_zipinfo+0x1826>
                    SKIP_(G.crec.file_comment_length)
    1d80:	8b b5 58 09 01 00    	mov    0x10958(%ebp),%esi
    1d86:	66 85 f6             	test   %si,%si
    1d89:	0f 84 58 ff ff ff    	je     1ce7 <_zipinfo+0xb27>
    1d8f:	31 c0                	xor    %eax,%eax
    1d91:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1d98:	00 
    1d99:	66 89 f0             	mov    %si,%ax
    1d9c:	89 44 24 04          	mov    %eax,0x4(%esp)
    1da0:	89 2c 24             	mov    %ebp,(%esp)
    1da3:	e8 00 00 00 00       	call   1da8 <_zipinfo+0xbe8>
    1da8:	85 c0                	test   %eax,%eax
    1daa:	0f 84 37 ff ff ff    	je     1ce7 <_zipinfo+0xb27>
    1db0:	83 f8 01             	cmp    $0x1,%eax
    1db3:	0f 8f 0a 02 00 00    	jg     1fc3 <_zipinfo+0xe03>
    1db9:	89 44 24 50          	mov    %eax,0x50(%esp)
    1dbd:	e9 25 ff ff ff       	jmp    1ce7 <_zipinfo+0xb27>

    zfstrcpy(methbuf, method[methnum]);
    if (methnum == IMPLODED) {
        methbuf[1] = (char)((G.crec.general_purpose_bit_flag & 2)? '8' : '4');
        methbuf[3] = (char)((G.crec.general_purpose_bit_flag & 4)? '3' : '2');
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
    1dc2:	83 ef 08             	sub    $0x8,%edi
    1dc5:	83 ff 01             	cmp    $0x1,%edi
    1dc8:	0f 86 e2 11 00 00    	jbe    2fb0 <_zipinfo+0x1df0>
    1dce:	8d bc 24 d0 00 00 00 	lea    0xd0(%esp),%edi
    1dd5:	8d 94 24 df 00 00 00 	lea    0xdf(%esp),%edx
    1ddc:	89 f8                	mov    %edi,%eax
    1dde:	8a 5c 24 68          	mov    0x68(%esp),%bl
    } else if (methnum >= NUM_METHODS) {   /* unknown */
        sprintf(&methbuf[1], "%03u", G.crec.compression_method);
    }

    for (k = 0;  k < 15;  ++k)
        attribs[k] = ' ';
    1de2:	c6 00 20             	movb   $0x20,(%eax)
    1de5:	40                   	inc    %eax
        methbuf[3] = dtype[dnum];
    } else if (methnum >= NUM_METHODS) {   /* unknown */
        sprintf(&methbuf[1], "%03u", G.crec.compression_method);
    }

    for (k = 0;  k < 15;  ++k)
    1de6:	39 d0                	cmp    %edx,%eax
    1de8:	75 f8                	jne    1de2 <_zipinfo+0xc22>
        attribs[k] = ' ';
    attribs[15] = 0;

    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    1dea:	8b b5 60 09 01 00    	mov    0x10960(%ebp),%esi
    1df0:	88 d9                	mov    %bl,%cl
    1df2:	89 f0                	mov    %esi,%eax
        sprintf(&methbuf[1], "%03u", G.crec.compression_method);
    }

    for (k = 0;  k < 15;  ++k)
        attribs[k] = ' ';
    attribs[15] = 0;
    1df4:	c6 84 24 df 00 00 00 	movb   $0x0,0xdf(%esp)
    1dfb:	00 

    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    1dfc:	c1 e8 10             	shr    $0x10,%eax
    switch (hostnum) {
    1dff:	80 fb 12             	cmp    $0x12,%bl
    1e02:	0f 87 38 07 00 00    	ja     2540 <_zipinfo+0x1380>
    1e08:	31 db                	xor    %ebx,%ebx
    1e0a:	88 cb                	mov    %cl,%bl
    1e0c:	ff 24 9d 9c 03 00 00 	jmp    *0x39c(,%ebx,4)
    1e13:	8b 45 74             	mov    0x74(%ebp),%eax
                            fn_matched[i] = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
    1e16:	c7 44 24 40 01 00 00 	movl   $0x1,0x40(%esp)
    1e1d:	00 
        If current file was specified on command line, or if no names were
        specified, do the listing for this file.  Otherwise, get rid of the
        file comment and go back for the next file.
      -----------------------------------------------------------------------*/

        if (G.process_all_files || do_this_file) {
    1e1e:	0b 44 24 40          	or     0x40(%esp),%eax
    1e22:	0f 85 96 f5 ff ff    	jne    13be <_zipinfo+0x1fe>
#ifdef MACOS  /* MacOS is no preemptive OS, thus call event-handling by hand */
            UserStop();
#endif

        } else {        /* not listing this file */
            SKIP_(G.crec.extra_field_length)
    1e28:	66 8b 8d 56 09 01 00 	mov    0x10956(%ebp),%cx
    1e2f:	66 85 c9             	test   %cx,%cx
    1e32:	75 62                	jne    1e96 <_zipinfo+0xcd6>
            SKIP_(G.crec.file_comment_length)
    1e34:	8b 8d 58 09 01 00    	mov    0x10958(%ebp),%ecx
    1e3a:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
    1e41:	00 
    1e42:	66 85 c9             	test   %cx,%cx
    1e45:	0f 84 12 ff ff ff    	je     1d5d <_zipinfo+0xb9d>
    1e4b:	31 c0                	xor    %eax,%eax
    1e4d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1e54:	00 
    1e55:	66 89 c8             	mov    %cx,%ax
    1e58:	89 2c 24             	mov    %ebp,(%esp)
    1e5b:	89 44 24 04          	mov    %eax,0x4(%esp)
    1e5f:	e8 00 00 00 00       	call   1e64 <_zipinfo+0xca4>
    1e64:	85 c0                	test   %eax,%eax
    1e66:	0f 84 f1 fe ff ff    	je     1d5d <_zipinfo+0xb9d>
    1e6c:	83 f8 01             	cmp    $0x1,%eax
    1e6f:	0f 8f 4e 01 00 00    	jg     1fc3 <_zipinfo+0xe03>
    1e75:	89 44 24 50          	mov    %eax,0x50(%esp)
    1e79:	e9 df fe ff ff       	jmp    1d5d <_zipinfo+0xb9d>
    1e7e:	66 90                	xchg   %ax,%ax
                            fn_matched[i] = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
    1e80:	8b 45 70             	mov    0x70(%ebp),%eax
    1e83:	85 c0                	test   %eax,%eax
    1e85:	0f 84 be 1d 00 00    	je     3c49 <_zipinfo+0x2a89>
    1e8b:	8d b5 e0 09 01 00    	lea    0x109e0(%ebp),%esi
    1e91:	e9 cb f4 ff ff       	jmp    1361 <_zipinfo+0x1a1>
#ifdef MACOS  /* MacOS is no preemptive OS, thus call event-handling by hand */
            UserStop();
#endif

        } else {        /* not listing this file */
            SKIP_(G.crec.extra_field_length)
    1e96:	31 c0                	xor    %eax,%eax
    1e98:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1e9f:	00 
    1ea0:	66 89 c8             	mov    %cx,%ax
    1ea3:	89 2c 24             	mov    %ebp,(%esp)
    1ea6:	89 44 24 04          	mov    %eax,0x4(%esp)
    1eaa:	e8 00 00 00 00       	call   1eaf <_zipinfo+0xcef>
    1eaf:	85 c0                	test   %eax,%eax
    1eb1:	0f 84 7d ff ff ff    	je     1e34 <_zipinfo+0xc74>
    1eb7:	83 f8 01             	cmp    $0x1,%eax
    1eba:	0f 8f 03 01 00 00    	jg     1fc3 <_zipinfo+0xe03>
    1ec0:	89 44 24 50          	mov    %eax,0x50(%esp)
    1ec4:	e9 6b ff ff ff       	jmp    1e34 <_zipinfo+0xc74>
    1ec9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
/*---------------------------------------------------------------------------
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    hostnum = (unsigned)(G.pInfo->hostnum);
    1ed0:	8b 85 d8 08 00 00    	mov    0x8d8(%ebp),%eax
        methbuf[3] = (char)((G.crec.general_purpose_bit_flag & 4)? '3' : '2');
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
        ush  dnum=(ush)((G.crec.general_purpose_bit_flag>>1) & 3);
        methbuf[3] = dtype[dnum];
    } else if (methnum >= NUM_METHODS) {   /* unknown */
        sprintf(&methbuf[1], "%03u", G.crec.compression_method);
    1ed6:	31 f6                	xor    %esi,%esi
    1ed8:	66 89 de             	mov    %bx,%si
/*---------------------------------------------------------------------------
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    hostnum = (unsigned)(G.pInfo->hostnum);
    1edb:	8a 48 13             	mov    0x13(%eax),%cl
    1ede:	88 4c 24 68          	mov    %cl,0x68(%esp)
    1ee2:	81 e1 ff 00 00 00    	and    $0xff,%ecx
    1ee8:	89 4c 24 60          	mov    %ecx,0x60(%esp)
    hostver = (unsigned)(G.pInfo->hostver);
    1eec:	31 c9                	xor    %ecx,%ecx
    1eee:	8a 48 12             	mov    0x12(%eax),%cl
/*
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    extver = (unsigned)G.crec.version_needed_to_extract[0];
 */

    zfstrcpy(methbuf, method[methnum]);
    1ef1:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
    1ef8:	c7 44 24 04 e1 05 00 	movl   $0x5e1,0x4(%esp)
    1eff:	00 
    1f00:	89 04 24             	mov    %eax,(%esp)
    Print out various interesting things about the compressed file.
  ---------------------------------------------------------------------------*/

    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);
    hostnum = (unsigned)(G.pInfo->hostnum);
    hostver = (unsigned)(G.pInfo->hostver);
    1f03:	89 4c 24 54          	mov    %ecx,0x54(%esp)
/*
    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);
    extver = (unsigned)G.crec.version_needed_to_extract[0];
 */

    zfstrcpy(methbuf, method[methnum]);
    1f07:	89 44 24 6c          	mov    %eax,0x6c(%esp)
    1f0b:	e8 00 00 00 00       	call   1f10 <_zipinfo+0xd50>
        methbuf[3] = (char)((G.crec.general_purpose_bit_flag & 4)? '3' : '2');
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
        ush  dnum=(ush)((G.crec.general_purpose_bit_flag>>1) & 3);
        methbuf[3] = dtype[dnum];
    } else if (methnum >= NUM_METHODS) {   /* unknown */
        sprintf(&methbuf[1], "%03u", G.crec.compression_method);
    1f10:	8d 84 24 9d 00 00 00 	lea    0x9d(%esp),%eax
    1f17:	89 74 24 08          	mov    %esi,0x8(%esp)
    1f1b:	c7 44 24 04 64 02 00 	movl   $0x264,0x4(%esp)
    1f22:	00 
    1f23:	89 04 24             	mov    %eax,(%esp)
    1f26:	e8 00 00 00 00       	call   1f2b <_zipinfo+0xd6b>
    1f2b:	e9 9e fe ff ff       	jmp    1dce <_zipinfo+0xc0e>
    }

    if (!G.crec.file_comment_length)
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    else {
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommBegin)));
    1f30:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
    1f37:	be 6c 02 00 00       	mov    $0x26c,%esi
    1f3c:	b8 4d 00 00 00       	mov    $0x4d,%eax
    1f41:	85 db                	test   %ebx,%ebx
    1f43:	0f 85 35 2c 00 00    	jne    4b7e <_zipinfo+0x39be>
    1f49:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1f4f:	0f 85 45 2c 00 00    	jne    4b9a <_zipinfo+0x39da>
    1f55:	89 c1                	mov    %eax,%ecx
    1f57:	c1 e9 02             	shr    $0x2,%ecx
    1f5a:	a8 02                	test   $0x2,%al
    1f5c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    1f5e:	74 0b                	je     1f6b <_zipinfo+0xdab>
    1f60:	66 8b 0e             	mov    (%esi),%cx
    1f63:	66 89 0f             	mov    %cx,(%edi)
    1f66:	b9 02 00 00 00       	mov    $0x2,%ecx
    1f6b:	a8 01                	test   $0x1,%al
    1f6d:	74 06                	je     1f75 <_zipinfo+0xdb5>
    1f6f:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    1f72:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    1f75:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    1f79:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1f80:	00 
    1f81:	c7 44 24 08 4c 00 00 	movl   $0x4c,0x8(%esp)
    1f88:	00 
    1f89:	89 44 24 04          	mov    %eax,0x4(%esp)
    1f8d:	89 2c 24             	mov    %ebp,(%esp)
    1f90:	ff d2                	call   *%edx
        if ((error = do_string(__G__ G.crec.file_comment_length, DISPL_8)) !=
    1f92:	31 c0                	xor    %eax,%eax
    }

    if (!G.crec.file_comment_length)
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    else {
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommBegin)));
    1f94:	83 ec 10             	sub    $0x10,%esp
        if ((error = do_string(__G__ G.crec.file_comment_length, DISPL_8)) !=
    1f97:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
    1f9e:	00 
    1f9f:	66 8b 85 58 09 01 00 	mov    0x10958(%ebp),%ax
    1fa6:	89 2c 24             	mov    %ebp,(%esp)
    1fa9:	89 44 24 04          	mov    %eax,0x4(%esp)
    1fad:	e8 00 00 00 00       	call   1fb2 <_zipinfo+0xdf2>
    1fb2:	85 c0                	test   %eax,%eax
    1fb4:	0f 84 e8 12 00 00    	je     32a2 <_zipinfo+0x20e2>
            PK_COOL)
        {
            error_in_archive = error;   /* might be warning */
            if (error > PK_WARN)   /* fatal */
    1fba:	83 f8 01             	cmp    $0x1,%eax
    1fbd:	0f 8e db 12 00 00    	jle    329e <_zipinfo+0x20de>
    1fc3:	89 c3                	mov    %eax,%ebx
    if (uO.lflag >= 10)
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

    return error_in_archive;

} /* end function zipinfo() */
    1fc5:	81 c4 2c 01 00 00    	add    $0x12c,%esp
    1fcb:	89 d8                	mov    %ebx,%eax
    1fcd:	5b                   	pop    %ebx
    1fce:	5e                   	pop    %esi
    1fcf:	5f                   	pop    %edi
    1fd0:	5d                   	pop    %ebp
    1fd1:	c3                   	ret    
    Info(slide, 0, ((char *)slide, LoadFarString(HostOS), varmsg_str));
    Info(slide, 0, ((char *)slide, LoadFarString(EncodeSWVer), hostver/10,
      hostver%10));

    if ((extnum >= NUM_HOSTS) || (os[extnum] == NULL)) {
        sprintf(unkn, LoadFarString(UnknownNo),
    1fd2:	31 c0                	xor    %eax,%eax
    1fd4:	8d b4 24 a8 00 00 00 	lea    0xa8(%esp),%esi
    1fdb:	8a 85 3f 09 01 00    	mov    0x1093f(%ebp),%al
    1fe1:	c7 44 24 04 ac 18 00 	movl   $0x18ac,0x4(%esp)
    1fe8:	00 
    1fe9:	89 44 24 08          	mov    %eax,0x8(%esp)
    1fed:	89 34 24             	mov    %esi,(%esp)
    1ff0:	e8 00 00 00 00       	call   1ff5 <_zipinfo+0xe35>
                (int)G.crec.version_needed_to_extract[1]);
        varmsg_str = unkn;
    1ff5:	89 f0                	mov    %esi,%eax
    1ff7:	e9 66 f6 ff ff       	jmp    1662 <_zipinfo+0x4a2>
            attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
            sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
            break;

        case THEOS_:
            switch (xattr & THS_IFMT) {
    1ffc:	89 c2                	mov    %eax,%edx
    1ffe:	81 e2 00 f0 00 00    	and    $0xf000,%edx
    2004:	81 fa 00 90 00 00    	cmp    $0x9000,%edx
    200a:	0f 84 8c 2c 00 00    	je     4c9c <_zipinfo+0x3adc>
    2010:	0f 86 b2 16 00 00    	jbe    36c8 <_zipinfo+0x2508>
    2016:	81 fa 00 d0 00 00    	cmp    $0xd000,%edx
    201c:	0f 84 4a 2c 00 00    	je     4c6c <_zipinfo+0x3aac>
    2022:	0f 87 f3 1f 00 00    	ja     401b <_zipinfo+0x2e5b>
    2028:	81 fa 00 a0 00 00    	cmp    $0xa000,%edx
    202e:	0f 84 08 2a 00 00    	je     4a3c <_zipinfo+0x387c>
    2034:	81 fa 00 b0 00 00    	cmp    $0xb000,%edx
    203a:	0f 85 1f 2c 00 00    	jne    4c5f <_zipinfo+0x3a9f>
                case THS_IFDIR: *attribs = 'D'; break;
                case THS_IFCHR: *attribs = 'C'; break;
                case THS_IFREG: *attribs = 'S'; break;
                case THS_IFREL: *attribs = 'R'; break;
                case THS_IFKEY: *attribs = 'K'; break;
                case THS_IFIND: *attribs = 'I'; break;
    2040:	c6 84 24 d0 00 00 00 	movb   $0x49,0xd0(%esp)
    2047:	49 
    2048:	e9 ad 16 00 00       	jmp    36fa <_zipinfo+0x253a>
    204d:	8d 76 00             	lea    0x0(%esi),%esi
    2050:	8d 9c 24 ba 00 00 00 	lea    0xba(%esp),%ebx
    2057:	8d b4 24 c6 00 00 00 	lea    0xc6(%esp),%esi
    for (k = 0;  k < 15;  ++k)
        attribs[k] = ' ';
    attribs[15] = 0;

    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    switch (hostnum) {
    205e:	89 da                	mov    %ebx,%edx
        case VMS_:
            {   int    i, j;

                for (k = 0;  k < 12;  ++k)
                    workspace[k] = 0;
    2060:	c6 02 00             	movb   $0x0,(%edx)
    2063:	42                   	inc    %edx
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    switch (hostnum) {
        case VMS_:
            {   int    i, j;

                for (k = 0;  k < 12;  ++k)
    2064:	39 f2                	cmp    %esi,%edx
    2066:	75 f8                	jne    2060 <_zipinfo+0xea0>
                    workspace[k] = 0;
                if (xattr & VMS_IRUSR)
    2068:	f6 c4 01             	test   $0x1,%ah
    206b:	74 08                	je     2075 <_zipinfo+0xeb5>
                    workspace[0] = 'R';
    206d:	c6 84 24 ba 00 00 00 	movb   $0x52,0xba(%esp)
    2074:	52 
                if (xattr & VMS_IWUSR) {
    2075:	a8 80                	test   $0x80,%al
    2077:	74 10                	je     2089 <_zipinfo+0xec9>
                    workspace[1] = 'W';
    2079:	c6 84 24 bb 00 00 00 	movb   $0x57,0xbb(%esp)
    2080:	57 
                    workspace[3] = 'D';
    2081:	c6 84 24 bd 00 00 00 	movb   $0x44,0xbd(%esp)
    2088:	44 
                }
                if (xattr & VMS_IXUSR)
    2089:	a8 40                	test   $0x40,%al
    208b:	74 08                	je     2095 <_zipinfo+0xed5>
                    workspace[2] = 'E';
    208d:	c6 84 24 bc 00 00 00 	movb   $0x45,0xbc(%esp)
    2094:	45 
                if (xattr & VMS_IRGRP)
    2095:	a8 20                	test   $0x20,%al
    2097:	74 08                	je     20a1 <_zipinfo+0xee1>
                    workspace[4] = 'R';
    2099:	c6 84 24 be 00 00 00 	movb   $0x52,0xbe(%esp)
    20a0:	52 
                if (xattr & VMS_IWGRP) {
    20a1:	a8 10                	test   $0x10,%al
    20a3:	74 10                	je     20b5 <_zipinfo+0xef5>
                    workspace[5] = 'W';
    20a5:	c6 84 24 bf 00 00 00 	movb   $0x57,0xbf(%esp)
    20ac:	57 
                    workspace[7] = 'D';
    20ad:	c6 84 24 c1 00 00 00 	movb   $0x44,0xc1(%esp)
    20b4:	44 
                }
                if (xattr & VMS_IXGRP)
    20b5:	a8 08                	test   $0x8,%al
    20b7:	74 08                	je     20c1 <_zipinfo+0xf01>
                  workspace[6] = 'E';
    20b9:	c6 84 24 c0 00 00 00 	movb   $0x45,0xc0(%esp)
    20c0:	45 
                if (xattr & VMS_IROTH)
    20c1:	a8 04                	test   $0x4,%al
    20c3:	74 08                	je     20cd <_zipinfo+0xf0d>
                    workspace[8] = 'R';
    20c5:	c6 84 24 c2 00 00 00 	movb   $0x52,0xc2(%esp)
    20cc:	52 
                if (xattr & VMS_IWOTH) {
    20cd:	a8 02                	test   $0x2,%al
    20cf:	74 10                	je     20e1 <_zipinfo+0xf21>
                    workspace[9] = 'W';
    20d1:	c6 84 24 c3 00 00 00 	movb   $0x57,0xc3(%esp)
    20d8:	57 
                    workspace[11] = 'D';
    20d9:	c6 84 24 c5 00 00 00 	movb   $0x44,0xc5(%esp)
    20e0:	44 
                }
                if (xattr & VMS_IXOTH)
    20e1:	a8 01                	test   $0x1,%al
    20e3:	0f 85 66 15 00 00    	jne    364f <_zipinfo+0x248f>
                    workspace[10] = 'E';

                p = attribs;
                for (k = j = 0;  j < 3;  ++j) {     /* groups of permissions */
                    for (i = 0;  i < 4;  ++i, ++k)  /* perms within a group */
    20e9:	89 f8                	mov    %edi,%eax
    for (k = 0;  k < 15;  ++k)
        attribs[k] = ' ';
    attribs[15] = 0;

    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    switch (hostnum) {
    20eb:	89 c1                	mov    %eax,%ecx
    20ed:	31 c0                	xor    %eax,%eax
                    workspace[10] = 'E';

                p = attribs;
                for (k = j = 0;  j < 3;  ++j) {     /* groups of permissions */
                    for (i = 0;  i < 4;  ++i, ++k)  /* perms within a group */
                        if (workspace[k])
    20ef:	8a 14 03             	mov    (%ebx,%eax,1),%dl
    20f2:	84 d2                	test   %dl,%dl
    20f4:	74 03                	je     20f9 <_zipinfo+0xf39>
                            *p++ = workspace[k];
    20f6:	88 11                	mov    %dl,(%ecx)
    20f8:	41                   	inc    %ecx
                if (xattr & VMS_IXOTH)
                    workspace[10] = 'E';

                p = attribs;
                for (k = j = 0;  j < 3;  ++j) {     /* groups of permissions */
                    for (i = 0;  i < 4;  ++i, ++k)  /* perms within a group */
    20f9:	40                   	inc    %eax
    20fa:	83 f8 04             	cmp    $0x4,%eax
    20fd:	75 f0                	jne    20ef <_zipinfo+0xf2f>
    20ff:	83 c3 04             	add    $0x4,%ebx
                        if (workspace[k])
                            *p++ = workspace[k];
                    *p++ = ',';                     /* group separator */
    2102:	8d 41 01             	lea    0x1(%ecx),%eax
    2105:	c6 01 2c             	movb   $0x2c,(%ecx)
                }
                if (xattr & VMS_IXOTH)
                    workspace[10] = 'E';

                p = attribs;
                for (k = j = 0;  j < 3;  ++j) {     /* groups of permissions */
    2108:	39 de                	cmp    %ebx,%esi
    210a:	75 df                	jne    20eb <_zipinfo+0xf2b>
                        if (workspace[k])
                            *p++ = workspace[k];
                    *p++ = ',';                     /* group separator */
                }
                *--p = ' ';   /* overwrite last comma */
                if ((p - attribs) < 12)
    210c:	29 f9                	sub    %edi,%ecx
                    for (i = 0;  i < 4;  ++i, ++k)  /* perms within a group */
                        if (workspace[k])
                            *p++ = workspace[k];
                    *p++ = ',';                     /* group separator */
                }
                *--p = ' ';   /* overwrite last comma */
    210e:	c6 40 ff 20          	movb   $0x20,-0x1(%eax)
                if ((p - attribs) < 12)
    2112:	83 f9 0b             	cmp    $0xb,%ecx
    2115:	0f 8e 5f 1d 00 00    	jle    3e7a <_zipinfo+0x2cba>
    211b:	90                   	nop
    211c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
      LoadFarStringSmall(((hostnum == FS_VFAT_ && hostver == 20) ?
                          os_TheosOld :
                          os[hostnum])),
      G.crec.ucsize));
#else
    Info(slide, 0, ((char *)slide, "%s %s %8lu ", attribs,
    2120:	8b 85 50 09 01 00    	mov    0x10950(%ebp),%eax
    2126:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    212c:	89 44 24 10          	mov    %eax,0x10(%esp)
    2130:	8b 44 24 60          	mov    0x60(%esp),%eax
    2134:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    2138:	89 7c 24 08          	mov    %edi,0x8(%esp)
    213c:	8d 04 85 00 05 00 00 	lea    0x500(,%eax,4),%eax
    2143:	c7 44 24 04 2b 02 00 	movl   $0x22b,0x4(%esp)
    214a:	00 
    214b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    214f:	89 34 24             	mov    %esi,(%esp)
    2152:	e8 00 00 00 00       	call   2157 <_zipinfo+0xf97>
    2157:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    215e:	00 
    215f:	89 44 24 08          	mov    %eax,0x8(%esp)
    2163:	89 74 24 04          	mov    %esi,0x4(%esp)
    2167:	89 2c 24             	mov    %ebp,(%esp)
    216a:	ff d3                	call   *%ebx
      LoadFarStringSmall(os[hostnum]),
      G.crec.ucsize));
#endif
    Info(slide, 0, ((char *)slide, "%c",
    216c:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
      LoadFarStringSmall(((hostnum == FS_VFAT_ && hostver == 20) ?
                          os_TheosOld :
                          os[hostnum])),
      G.crec.ucsize));
#else
    Info(slide, 0, ((char *)slide, "%s %s %8lu ", attribs,
    2172:	83 ec 10             	sub    $0x10,%esp
      LoadFarStringSmall(os[hostnum]),
      G.crec.ucsize));
#endif
    Info(slide, 0, ((char *)slide, "%c",
    2175:	8b 85 5c 09 01 00    	mov    0x1095c(%ebp),%eax
    217b:	f6 85 40 09 01 00 01 	testb  $0x1,0x10940(%ebp)
    2182:	0f 84 0b 08 00 00    	je     2993 <_zipinfo+0x17d3>
    2188:	83 e0 01             	and    $0x1,%eax
    218b:	66 83 f8 01          	cmp    $0x1,%ax
    218f:	19 c0                	sbb    %eax,%eax
    2191:	83 e0 ee             	and    $0xffffffee,%eax
    2194:	83 c0 54             	add    $0x54,%eax
    2197:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    219b:	89 44 24 08          	mov    %eax,0x8(%esp)
    219f:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
    21a6:	00 
    21a7:	89 34 24             	mov    %esi,(%esp)
    21aa:	e8 00 00 00 00       	call   21af <_zipinfo+0xfef>
    21af:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    21b6:	00 
    21b7:	89 44 24 08          	mov    %eax,0x8(%esp)
    21bb:	89 74 24 04          	mov    %esi,0x4(%esp)
    21bf:	89 2c 24             	mov    %ebp,(%esp)
    21c2:	ff d3                	call   *%ebx
    21c4:	83 ec 10             	sub    $0x10,%esp
      (G.crec.general_purpose_bit_flag & 1)?
      ((G.crec.internal_file_attributes & 1)? 'T' : 'B') :  /* encrypted */
      ((G.crec.internal_file_attributes & 1)? 't' : 'b'))); /* plaintext */
    k = (G.crec.extra_field_length ||
    21c7:	66 83 bd 56 09 01 00 	cmpw   $0x0,0x10956(%ebp)
    21ce:	00 
    21cf:	0f 85 ab 04 00 00    	jne    2680 <_zipinfo+0x14c0>
    21d5:	f6 85 61 09 01 00 80 	testb  $0x80,0x10961(%ebp)
    21dc:	74 1b                	je     21f9 <_zipinfo+0x1039>
         /* a local-only "UX" (old Unix/OS2/NT GMT times "IZUNIX") e.f.? */
         ((G.crec.external_file_attributes & 0x8000) &&
          (hostnum == UNIX_ || hostnum == FS_HPFS_ || hostnum == FS_NTFS_)));
    21de:	8b 4c 24 60          	mov    0x60(%esp),%ecx
    21e2:	89 c8                	mov    %ecx,%eax
    21e4:	83 e0 f7             	and    $0xfffffff7,%eax
    21e7:	83 f8 03             	cmp    $0x3,%eax
    21ea:	0f 84 90 04 00 00    	je     2680 <_zipinfo+0x14c0>
    21f0:	83 f9 06             	cmp    $0x6,%ecx
    21f3:	0f 84 87 04 00 00    	je     2680 <_zipinfo+0x14c0>
    Info(slide, 0, ((char *)slide, "%c", k?
    21f9:	8b 85 40 09 01 00    	mov    0x10940(%ebp),%eax
    21ff:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2205:	83 e0 08             	and    $0x8,%eax
    2208:	66 83 f8 01          	cmp    $0x1,%ax
    220c:	19 c0                	sbb    %eax,%eax
    220e:	83 e0 c1             	and    $0xffffffc1,%eax
    2211:	83 c0 6c             	add    $0x6c,%eax
    2214:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    2218:	89 44 24 08          	mov    %eax,0x8(%esp)
    221c:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
    2223:	00 
    2224:	89 34 24             	mov    %esi,(%esp)
    2227:	e8 00 00 00 00       	call   222c <_zipinfo+0x106c>
    222c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2233:	00 
    2234:	89 44 24 08          	mov    %eax,0x8(%esp)
    2238:	89 74 24 04          	mov    %esi,0x4(%esp)
    223c:	89 2c 24             	mov    %ebp,(%esp)
    223f:	ff d3                	call   *%ebx
      ((G.crec.general_purpose_bit_flag & 8)? 'X' : 'x') :  /* extra field */
      ((G.crec.general_purpose_bit_flag & 8)? 'l' : '-'))); /* no extra field */
      /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ extended local header or not */

    if (uO.lflag == 4) {
    2241:	8b 45 28             	mov    0x28(%ebp),%eax
      ((G.crec.internal_file_attributes & 1)? 't' : 'b'))); /* plaintext */
    k = (G.crec.extra_field_length ||
         /* a local-only "UX" (old Unix/OS2/NT GMT times "IZUNIX") e.f.? */
         ((G.crec.external_file_attributes & 0x8000) &&
          (hostnum == UNIX_ || hostnum == FS_HPFS_ || hostnum == FS_NTFS_)));
    Info(slide, 0, ((char *)slide, "%c", k?
    2244:	83 ec 10             	sub    $0x10,%esp
      ((G.crec.general_purpose_bit_flag & 8)? 'X' : 'x') :  /* extra field */
      ((G.crec.general_purpose_bit_flag & 8)? 'l' : '-'))); /* no extra field */
      /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ extended local header or not */

    if (uO.lflag == 4) {
    2247:	83 f8 04             	cmp    $0x4,%eax
    224a:	0f 84 74 0a 00 00    	je     2cc4 <_zipinfo+0x1b04>

        if (G.crec.general_purpose_bit_flag & 1)
            csiz -= 12;    /* if encrypted, don't count encryption header */
        Info(slide, 0, ((char *)slide, "%3d%%",
          (ratio(G.crec.ucsize,csiz)+5)/10));
    } else if (uO.lflag == 5)
    2250:	83 f8 05             	cmp    $0x5,%eax
    2253:	0f 84 b8 19 00 00    	je     3c11 <_zipinfo+0x2a51>
        Info(slide, 0, ((char *)slide, " %8lu", G.crec.csize));

    /* Read the extra field, if any.  The extra field info may be used
     * in the file modification time section, below.
     */
    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)
    2259:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    2260:	00 
    2261:	31 c0                	xor    %eax,%eax
    2263:	66 8b 85 56 09 01 00 	mov    0x10956(%ebp),%ax
    226a:	89 2c 24             	mov    %ebp,(%esp)
    226d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2271:	e8 00 00 00 00       	call   2276 <_zipinfo+0x10b6>
    2276:	89 c3                	mov    %eax,%ebx
    {
        if (G.extra_field != NULL) {
    2278:	8b 85 18 09 01 00    	mov    0x10918(%ebp),%eax
        Info(slide, 0, ((char *)slide, " %8lu", G.crec.csize));

    /* Read the extra field, if any.  The extra field info may be used
     * in the file modification time section, below.
     */
    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)
    227e:	85 db                	test   %ebx,%ebx
    2280:	0f 84 ba 06 00 00    	je     2940 <_zipinfo+0x1780>
    {
        if (G.extra_field != NULL) {
    2286:	85 c0                	test   %eax,%eax
    2288:	74 12                	je     229c <_zipinfo+0x10dc>
            free(G.extra_field);
    228a:	89 04 24             	mov    %eax,(%esp)
    228d:	e8 00 00 00 00       	call   2292 <_zipinfo+0x10d2>
            G.extra_field = NULL;
    2292:	c7 85 18 09 01 00 00 	movl   $0x0,0x10918(%ebp)
    2299:	00 00 00 
               G.tz_is_valid &&
#endif
               (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
                                 G.crec.last_mod_dos_datetime, &z_utime, NULL)
                & EB_UT_FL_MTIME)
              ? &z_utime.mtime : NULL;
    229c:	31 f6                	xor    %esi,%esi
    TIMET_TO_NATIVE(z_utime.mtime)     /* NOP unless MSC 7.0 or Macintosh */
    d_t_buf[0] = (char)0;              /* signal "show local time" */
#else
#   define z_modtim NULL
#endif
    Info(slide, 0, ((char *)slide, " %s %s ", methbuf,
    229e:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    22a4:	8d 55 48             	lea    0x48(%ebp),%edx
    22a7:	89 44 24 54          	mov    %eax,0x54(%esp)
    22ab:	89 34 24             	mov    %esi,(%esp)
    22ae:	8d 8d 44 09 01 00    	lea    0x10944(%ebp),%ecx
    22b4:	89 7c 24 04          	mov    %edi,0x4(%esp)
    22b8:	8d 45 28             	lea    0x28(%ebp),%eax
               (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
                                 G.crec.last_mod_dos_datetime, &z_utime, NULL)
                & EB_UT_FL_MTIME)
              ? &z_utime.mtime : NULL;
    TIMET_TO_NATIVE(z_utime.mtime)     /* NOP unless MSC 7.0 or Macintosh */
    d_t_buf[0] = (char)0;              /* signal "show local time" */
    22bb:	c6 84 24 d0 00 00 00 	movb   $0x0,0xd0(%esp)
    22c2:	00 
#else
#   define z_modtim NULL
#endif
    Info(slide, 0, ((char *)slide, " %s %s ", methbuf,
    22c3:	e8 d8 e3 ff ff       	call   6a0 <_zi_time.isra.0>
    22c8:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
    22cc:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    22d0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    22d4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    22d8:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
    22df:	00 
    22e0:	89 34 24             	mov    %esi,(%esp)
    22e3:	e8 00 00 00 00       	call   22e8 <_zipinfo+0x1128>
    22e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    22ef:	00 
    22f0:	89 44 24 08          	mov    %eax,0x8(%esp)
    22f4:	89 74 24 04          	mov    %esi,0x4(%esp)
    22f8:	89 2c 24             	mov    %ebp,(%esp)
    22fb:	ff 54 24 54          	call   *0x54(%esp)
    22ff:	83 ec 10             	sub    $0x10,%esp
      zi_time(__G__ &G.crec.last_mod_dos_datetime, z_modtim, d_t_buf)));
    fnprint(__G);
    2302:	89 2c 24             	mov    %ebp,(%esp)
    2305:	e8 00 00 00 00       	call   230a <_zipinfo+0x114a>
/*---------------------------------------------------------------------------
    Skip the file comment, if any (the filename has already been printed,
    above).  That finishes up this file entry...
  ---------------------------------------------------------------------------*/

    SKIP_(G.crec.file_comment_length)
    230a:	8b 8d 58 09 01 00    	mov    0x10958(%ebp),%ecx
    2310:	66 85 c9             	test   %cx,%cx
    2313:	0f 85 e7 07 00 00    	jne    2b00 <_zipinfo+0x1940>
                    break;

                case 3:
                case 4:
                case 5:
                    if ((error = zi_short(__G)) != PK_COOL) {
    2319:	85 db                	test   %ebx,%ebx
    231b:	0f 84 c6 f9 ff ff    	je     1ce7 <_zipinfo+0xb27>
    2321:	89 5c 24 50          	mov    %ebx,0x50(%esp)
                        error_in_archive = error;   /* might be warning */
                        if (error > PK_WARN)        /* fatal */
    2325:	83 7c 24 50 01       	cmpl   $0x1,0x50(%esp)
    232a:	0f 8e b7 f9 ff ff    	jle    1ce7 <_zipinfo+0xb27>
    2330:	8b 5c 24 50          	mov    0x50(%esp),%ebx
    2334:	e9 8c fc ff ff       	jmp    1fc5 <_zipinfo+0xe05>
    2339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                    sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
            }
            break;

        case AMIGA_:
            switch (xattr & AMI_IFMT) {
    2340:	89 c2                	mov    %eax,%edx
    2342:	81 e2 00 0c 00 00    	and    $0xc00,%edx
    2348:	81 fa 00 04 00 00    	cmp    $0x400,%edx
    234e:	0f 84 e0 14 00 00    	je     3834 <_zipinfo+0x2674>
                case AMI_IFDIR:  attribs[0] = 'd';  break;
                case AMI_IFREG:  attribs[0] = '-';  break;
                default:         attribs[0] = '?';  break;
    2354:	81 fa 00 08 00 00    	cmp    $0x800,%edx
    235a:	b1 3f                	mov    $0x3f,%cl
    235c:	b2 64                	mov    $0x64,%dl
    235e:	0f 45 d1             	cmovne %ecx,%edx
    2361:	88 94 24 d0 00 00 00 	mov    %dl,0xd0(%esp)
            }
            attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2368:	89 c2                	mov    %eax,%edx
    236a:	81 e2 80 00 00 00    	and    $0x80,%edx
    2370:	83 fa 01             	cmp    $0x1,%edx
    2373:	19 d2                	sbb    %edx,%edx
    2375:	83 e2 c5             	and    $0xffffffc5,%edx
    2378:	83 c2 68             	add    $0x68,%edx
    237b:	88 94 24 d1 00 00 00 	mov    %dl,0xd1(%esp)
            attribs[2] = (xattr & AMI_ISCRIPT)?   's' : '-';
    2382:	89 c2                	mov    %eax,%edx
    2384:	83 e2 40             	and    $0x40,%edx
    2387:	83 fa 01             	cmp    $0x1,%edx
    238a:	19 d2                	sbb    %edx,%edx
    238c:	83 e2 ba             	and    $0xffffffba,%edx
    238f:	83 c2 73             	add    $0x73,%edx
    2392:	88 94 24 d2 00 00 00 	mov    %dl,0xd2(%esp)
            attribs[3] = (xattr & AMI_IPURE)?     'p' : '-';
    2399:	89 c2                	mov    %eax,%edx
    239b:	83 e2 20             	and    $0x20,%edx
    239e:	83 fa 01             	cmp    $0x1,%edx
    23a1:	19 d2                	sbb    %edx,%edx
    23a3:	83 e2 bd             	and    $0xffffffbd,%edx
    23a6:	83 c2 70             	add    $0x70,%edx
    23a9:	88 94 24 d3 00 00 00 	mov    %dl,0xd3(%esp)
            attribs[4] = (xattr & AMI_IARCHIVE)?  'a' : '-';
    23b0:	89 c2                	mov    %eax,%edx
    23b2:	83 e2 10             	and    $0x10,%edx
    23b5:	83 fa 01             	cmp    $0x1,%edx
    23b8:	19 d2                	sbb    %edx,%edx
    23ba:	83 e2 cc             	and    $0xffffffcc,%edx
    23bd:	83 c2 61             	add    $0x61,%edx
    23c0:	88 94 24 d4 00 00 00 	mov    %dl,0xd4(%esp)
            attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
    23c7:	89 c2                	mov    %eax,%edx
    23c9:	83 e2 08             	and    $0x8,%edx
    23cc:	83 fa 01             	cmp    $0x1,%edx
    23cf:	19 d2                	sbb    %edx,%edx
    23d1:	83 e2 bb             	and    $0xffffffbb,%edx
    23d4:	83 c2 72             	add    $0x72,%edx
    23d7:	88 94 24 d5 00 00 00 	mov    %dl,0xd5(%esp)
            attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
    23de:	89 c2                	mov    %eax,%edx
    23e0:	83 e2 04             	and    $0x4,%edx
    23e3:	83 fa 01             	cmp    $0x1,%edx
    23e6:	19 d2                	sbb    %edx,%edx
    23e8:	83 e2 b6             	and    $0xffffffb6,%edx
    23eb:	83 c2 77             	add    $0x77,%edx
    23ee:	88 94 24 d6 00 00 00 	mov    %dl,0xd6(%esp)
            attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
    23f5:	89 c2                	mov    %eax,%edx
    23f7:	83 e2 02             	and    $0x2,%edx
    23fa:	83 fa 01             	cmp    $0x1,%edx
    23fd:	19 d2                	sbb    %edx,%edx
            attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
    23ff:	83 e0 01             	and    $0x1,%eax
            attribs[2] = (xattr & AMI_ISCRIPT)?   's' : '-';
            attribs[3] = (xattr & AMI_IPURE)?     'p' : '-';
            attribs[4] = (xattr & AMI_IARCHIVE)?  'a' : '-';
            attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
            attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
            attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
    2402:	83 e2 c8             	and    $0xffffffc8,%edx
    2405:	83 c2 65             	add    $0x65,%edx
            attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
    2408:	83 f8 01             	cmp    $0x1,%eax
    240b:	19 c0                	sbb    %eax,%eax
            attribs[2] = (xattr & AMI_ISCRIPT)?   's' : '-';
            attribs[3] = (xattr & AMI_IPURE)?     'p' : '-';
            attribs[4] = (xattr & AMI_IARCHIVE)?  'a' : '-';
            attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
            attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
            attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
    240d:	88 94 24 d7 00 00 00 	mov    %dl,0xd7(%esp)
            attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
    2414:	83 e0 c9             	and    $0xffffffc9,%eax
    2417:	83 c0 64             	add    $0x64,%eax
    241a:	88 84 24 d8 00 00 00 	mov    %al,0xd8(%esp)
            if (xattr & UNX_IXOTH)
                attribs[9] = (xattr & UNX_ISVTX)? 't' : 'x';  /* "sticky bit" */
            else
                attribs[9] = (xattr & UNX_ISVTX)? 'T' : '-';  /* T==undefined */

            sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
    2421:	8b 44 24 54          	mov    0x54(%esp),%eax
    2425:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
    242a:	f7 e2                	mul    %edx
    242c:	c1 ea 03             	shr    $0x3,%edx
    242f:	8b 4c 24 54          	mov    0x54(%esp),%ecx
    2433:	8d 04 92             	lea    (%edx,%edx,4),%eax
    2436:	01 c0                	add    %eax,%eax
    2438:	29 c1                	sub    %eax,%ecx
    243a:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    243e:	8d 84 24 dc 00 00 00 	lea    0xdc(%esp),%eax
    2445:	89 54 24 08          	mov    %edx,0x8(%esp)
    2449:	c7 44 24 04 03 02 00 	movl   $0x203,0x4(%esp)
    2450:	00 
    2451:	89 04 24             	mov    %eax,(%esp)
    2454:	e8 00 00 00 00       	call   2459 <_zipinfo+0x1299>
    2459:	e9 c2 fc ff ff       	jmp    2120 <_zipinfo+0xf60>
        case FS_HPFS_:
        case FS_NTFS_:
        case VM_CMS_:
        case MVS_:
        case ACORN_:
            if (hostnum != FS_FAT_ ||
    245e:	8b 54 24 60          	mov    0x60(%esp),%edx
    2462:	85 d2                	test   %edx,%edx
    2464:	0f 85 93 0e 00 00    	jne    32fd <_zipinfo+0x213d>
                (unsigned)(xattr & 0700) !=
    246a:	89 c1                	mov    %eax,%ecx
    246c:	81 e1 c0 01 00 00    	and    $0x1c0,%ecx
                 ((unsigned)0400 |
    2472:	f7 c6 01 00 00 00    	test   $0x1,%esi
    2478:	0f 85 5a 13 00 00    	jne    37d8 <_zipinfo+0x2618>
                  ((unsigned)!(G.crec.external_file_attributes & 1) << 7) |
                  ((unsigned)(G.crec.external_file_attributes & 0x10) << 2))
    247e:	89 f3                	mov    %esi,%ebx
    2480:	83 e3 10             	and    $0x10,%ebx
    2483:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
        case MVS_:
        case ACORN_:
            if (hostnum != FS_FAT_ ||
                (unsigned)(xattr & 0700) !=
                 ((unsigned)0400 |
                  ((unsigned)!(G.crec.external_file_attributes & 1) << 7) |
    248a:	81 ca 80 01 00 00    	or     $0x180,%edx
        case FS_HPFS_:
        case FS_NTFS_:
        case VM_CMS_:
        case MVS_:
        case ACORN_:
            if (hostnum != FS_FAT_ ||
    2490:	39 d1                	cmp    %edx,%ecx
    2492:	0f 84 a8 00 00 00    	je     2540 <_zipinfo+0x1380>
                  ((unsigned)!(G.crec.external_file_attributes & 1) << 7) |
                  ((unsigned)(G.crec.external_file_attributes & 0x10) << 2))
               )
            {
                xattr = (unsigned)(G.crec.external_file_attributes & 0xFF);
                sprintf(attribs, ".r.-...     %u.%u", hostver/10, hostver%10);
    2498:	8b 44 24 54          	mov    0x54(%esp),%eax
    249c:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
    24a1:	f7 e2                	mul    %edx
    24a3:	c1 ea 03             	shr    $0x3,%edx
    24a6:	8b 4c 24 54          	mov    0x54(%esp),%ecx
    24aa:	89 54 24 08          	mov    %edx,0x8(%esp)
    24ae:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
    24b5:	00 
    24b6:	8d 04 92             	lea    (%edx,%edx,4),%eax
    24b9:	89 3c 24             	mov    %edi,(%esp)
    24bc:	01 c0                	add    %eax,%eax
    24be:	29 c1                	sub    %eax,%ecx
    24c0:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    24c4:	e8 00 00 00 00       	call   24c9 <_zipinfo+0x1309>
                attribs[2] = (xattr & 0x01)? '-' : 'w';
    24c9:	b0 77                	mov    $0x77,%al
    24cb:	88 84 24 d2 00 00 00 	mov    %al,0xd2(%esp)
                attribs[5] = (xattr & 0x02)? 'h' : '-';
    24d2:	89 f0                	mov    %esi,%eax
    24d4:	83 e0 02             	and    $0x2,%eax
    24d7:	83 f8 01             	cmp    $0x1,%eax
    24da:	19 c0                	sbb    %eax,%eax
    24dc:	83 e0 c5             	and    $0xffffffc5,%eax
    24df:	83 c0 68             	add    $0x68,%eax
    24e2:	88 84 24 d5 00 00 00 	mov    %al,0xd5(%esp)
                attribs[6] = (xattr & 0x04)? 's' : '-';
    24e9:	89 f0                	mov    %esi,%eax
    24eb:	83 e0 04             	and    $0x4,%eax
    24ee:	83 f8 01             	cmp    $0x1,%eax
    24f1:	19 c0                	sbb    %eax,%eax
    24f3:	83 e0 ba             	and    $0xffffffba,%eax
    24f6:	83 c0 73             	add    $0x73,%eax
    24f9:	88 84 24 d6 00 00 00 	mov    %al,0xd6(%esp)
                attribs[4] = (xattr & 0x20)? 'a' : '-';
    2500:	89 f0                	mov    %esi,%eax
    2502:	83 e0 20             	and    $0x20,%eax
    2505:	83 f8 01             	cmp    $0x1,%eax
    2508:	19 c0                	sbb    %eax,%eax
    250a:	83 e0 cc             	and    $0xffffffcc,%eax
    250d:	83 c0 61             	add    $0x61,%eax
                if (xattr & 0x10) {
    2510:	85 db                	test   %ebx,%ebx
                xattr = (unsigned)(G.crec.external_file_attributes & 0xFF);
                sprintf(attribs, ".r.-...     %u.%u", hostver/10, hostver%10);
                attribs[2] = (xattr & 0x01)? '-' : 'w';
                attribs[5] = (xattr & 0x02)? 'h' : '-';
                attribs[6] = (xattr & 0x04)? 's' : '-';
                attribs[4] = (xattr & 0x20)? 'a' : '-';
    2512:	88 84 24 d4 00 00 00 	mov    %al,0xd4(%esp)
                if (xattr & 0x10) {
    2519:	0f 85 a4 12 00 00    	jne    37c3 <_zipinfo+0x2603>
                    attribs[0] = 'd';
                    attribs[3] = 'x';
                } else
                    attribs[0] = '-';
    251f:	c6 84 24 d0 00 00 00 	movb   $0x2d,0xd0(%esp)
    2526:	2d 
                if (IS_VOLID(xattr))
    2527:	83 e6 08             	and    $0x8,%esi
    252a:	0f 84 9d 1a 00 00    	je     3fcd <_zipinfo+0x2e0d>
                    attribs[0] = 'V';
    2530:	c6 84 24 d0 00 00 00 	movb   $0x56,0xd0(%esp)
    2537:	56 
    2538:	e9 e3 fb ff ff       	jmp    2120 <_zipinfo+0xf60>
    253d:	8d 76 00             	lea    0x0(%esi),%esi
                }
                break;
            } /* else: fall through! */

        default:   /* assume Unix-like */
            switch ((unsigned)(xattr & UNX_IFMT)) {
    2540:	89 c2                	mov    %eax,%edx
    2542:	81 e2 00 f0 00 00    	and    $0xf000,%edx
    2548:	81 fa 00 60 00 00    	cmp    $0x6000,%edx
    254e:	0f 84 1d 26 00 00    	je     4b71 <_zipinfo+0x39b1>
    2554:	0f 86 c4 10 00 00    	jbe    361e <_zipinfo+0x245e>
    255a:	81 fa 00 a0 00 00    	cmp    $0xa000,%edx
    2560:	0f 84 87 26 00 00    	je     4bed <_zipinfo+0x3a2d>
    2566:	81 fa 00 c0 00 00    	cmp    $0xc000,%edx
    256c:	0f 84 6e 26 00 00    	je     4be0 <_zipinfo+0x3a20>
    2572:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
    2578:	0f 84 a4 24 00 00    	je     4a22 <_zipinfo+0x3862>
                case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
                case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
                case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
                case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;
                case (unsigned)UNX_IFSOCK:  attribs[0] = 's';  break;
                default:          attribs[0] = '?';  break;
    257e:	c6 84 24 d0 00 00 00 	movb   $0x3f,0xd0(%esp)
    2585:	3f 
            }
            attribs[1] = (xattr & UNX_IRUSR)? 'r' : '-';
    2586:	89 c2                	mov    %eax,%edx
    2588:	81 e2 00 01 00 00    	and    $0x100,%edx
    258e:	83 fa 01             	cmp    $0x1,%edx
    2591:	19 d2                	sbb    %edx,%edx
    2593:	83 e2 bb             	and    $0xffffffbb,%edx
    2596:	83 c2 72             	add    $0x72,%edx
    2599:	88 94 24 d1 00 00 00 	mov    %dl,0xd1(%esp)
            attribs[4] = (xattr & UNX_IRGRP)? 'r' : '-';
    25a0:	89 c2                	mov    %eax,%edx
    25a2:	83 e2 20             	and    $0x20,%edx
    25a5:	83 fa 01             	cmp    $0x1,%edx
    25a8:	19 d2                	sbb    %edx,%edx
    25aa:	83 e2 bb             	and    $0xffffffbb,%edx
    25ad:	83 c2 72             	add    $0x72,%edx
    25b0:	88 94 24 d4 00 00 00 	mov    %dl,0xd4(%esp)
            attribs[7] = (xattr & UNX_IROTH)? 'r' : '-';
    25b7:	89 c2                	mov    %eax,%edx
    25b9:	83 e2 04             	and    $0x4,%edx
    25bc:	83 fa 01             	cmp    $0x1,%edx
    25bf:	19 d2                	sbb    %edx,%edx
    25c1:	83 e2 bb             	and    $0xffffffbb,%edx
    25c4:	83 c2 72             	add    $0x72,%edx
    25c7:	88 94 24 d7 00 00 00 	mov    %dl,0xd7(%esp)
            attribs[2] = (xattr & UNX_IWUSR)? 'w' : '-';
    25ce:	89 c2                	mov    %eax,%edx
    25d0:	81 e2 80 00 00 00    	and    $0x80,%edx
    25d6:	83 fa 01             	cmp    $0x1,%edx
    25d9:	19 d2                	sbb    %edx,%edx
    25db:	83 e2 b6             	and    $0xffffffb6,%edx
    25de:	83 c2 77             	add    $0x77,%edx
    25e1:	88 94 24 d2 00 00 00 	mov    %dl,0xd2(%esp)
            attribs[5] = (xattr & UNX_IWGRP)? 'w' : '-';
    25e8:	89 c2                	mov    %eax,%edx
    25ea:	83 e2 10             	and    $0x10,%edx
    25ed:	83 fa 01             	cmp    $0x1,%edx
    25f0:	19 d2                	sbb    %edx,%edx
    25f2:	83 e2 b6             	and    $0xffffffb6,%edx
    25f5:	83 c2 77             	add    $0x77,%edx
    25f8:	88 94 24 d5 00 00 00 	mov    %dl,0xd5(%esp)
            attribs[8] = (xattr & UNX_IWOTH)? 'w' : '-';
    25ff:	89 c2                	mov    %eax,%edx
    2601:	83 e2 02             	and    $0x2,%edx
    2604:	83 fa 01             	cmp    $0x1,%edx
    2607:	19 d2                	sbb    %edx,%edx
    2609:	83 e2 b6             	and    $0xffffffb6,%edx
    260c:	83 c2 77             	add    $0x77,%edx
    260f:	88 94 24 d8 00 00 00 	mov    %dl,0xd8(%esp)

            if (xattr & UNX_IXUSR)
                attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
    2616:	89 c2                	mov    %eax,%edx
    2618:	81 e2 00 08 00 00    	and    $0x800,%edx
    261e:	83 fa 01             	cmp    $0x1,%edx
    2621:	19 d2                	sbb    %edx,%edx
            attribs[7] = (xattr & UNX_IROTH)? 'r' : '-';
            attribs[2] = (xattr & UNX_IWUSR)? 'w' : '-';
            attribs[5] = (xattr & UNX_IWGRP)? 'w' : '-';
            attribs[8] = (xattr & UNX_IWOTH)? 'w' : '-';

            if (xattr & UNX_IXUSR)
    2623:	a8 40                	test   $0x40,%al
    2625:	0f 84 34 25 00 00    	je     4b5f <_zipinfo+0x399f>
                attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
    262b:	83 e2 05             	and    $0x5,%edx
    262e:	83 c2 73             	add    $0x73,%edx
    2631:	88 94 24 d3 00 00 00 	mov    %dl,0xd3(%esp)
            else
                attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';  /* S==undefined */
            if (xattr & UNX_IXGRP)
                attribs[6] = (xattr & UNX_ISGID)? 's' : 'x';  /* == UNX_ENFMT */
    2638:	89 c2                	mov    %eax,%edx
    263a:	81 e2 00 04 00 00    	and    $0x400,%edx
    2640:	83 fa 01             	cmp    $0x1,%edx
    2643:	19 d2                	sbb    %edx,%edx

            if (xattr & UNX_IXUSR)
                attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
            else
                attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';  /* S==undefined */
            if (xattr & UNX_IXGRP)
    2645:	a8 08                	test   $0x8,%al
    2647:	0f 84 00 25 00 00    	je     4b4d <_zipinfo+0x398d>
                attribs[6] = (xattr & UNX_ISGID)? 's' : 'x';  /* == UNX_ENFMT */
    264d:	83 e2 05             	and    $0x5,%edx
    2650:	83 c2 73             	add    $0x73,%edx
    2653:	88 94 24 d6 00 00 00 	mov    %dl,0xd6(%esp)
            else
                /* attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';  real 4.3BSD */
                attribs[6] = (xattr & UNX_ISGID)? 'S' : '-';  /* SunOS 4.1.x */
            if (xattr & UNX_IXOTH)
    265a:	a8 01                	test   $0x1,%al
    265c:	0f 84 cf 24 00 00    	je     4b31 <_zipinfo+0x3971>
                attribs[9] = (xattr & UNX_ISVTX)? 't' : 'x';  /* "sticky bit" */
    2662:	25 00 02 00 00       	and    $0x200,%eax
    2667:	83 f8 01             	cmp    $0x1,%eax
    266a:	19 c0                	sbb    %eax,%eax
    266c:	83 e0 04             	and    $0x4,%eax
    266f:	83 c0 74             	add    $0x74,%eax
    2672:	88 84 24 d9 00 00 00 	mov    %al,0xd9(%esp)
    2679:	e9 a3 fd ff ff       	jmp    2421 <_zipinfo+0x1261>
    267e:	66 90                	xchg   %ax,%ax
      ((G.crec.internal_file_attributes & 1)? 't' : 'b'))); /* plaintext */
    k = (G.crec.extra_field_length ||
         /* a local-only "UX" (old Unix/OS2/NT GMT times "IZUNIX") e.f.? */
         ((G.crec.external_file_attributes & 0x8000) &&
          (hostnum == UNIX_ || hostnum == FS_HPFS_ || hostnum == FS_NTFS_)));
    Info(slide, 0, ((char *)slide, "%c", k?
    2680:	8b 85 40 09 01 00    	mov    0x10940(%ebp),%eax
    2686:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    268c:	83 e0 08             	and    $0x8,%eax
    268f:	66 83 f8 01          	cmp    $0x1,%ax
    2693:	19 c0                	sbb    %eax,%eax
    2695:	83 e0 20             	and    $0x20,%eax
    2698:	83 c0 58             	add    $0x58,%eax
    269b:	e9 74 fb ff ff       	jmp    2214 <_zipinfo+0x1054>
                Info(slide, 0x421, ((char *)slide,
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    26a0:	66 81 fe 41 4c       	cmp    $0x4c41,%si
    26a5:	0f 84 f5 22 00 00    	je     49a0 <_zipinfo+0x37e0>
    26ab:	0f 86 d0 15 00 00    	jbe    3c81 <_zipinfo+0x2ac1>
    26b1:	66 81 fe 63 4d       	cmp    $0x4d63,%si
    26b6:	0f 84 ee 21 00 00    	je     48aa <_zipinfo+0x36ea>
    26bc:	66 81 fe 56 53       	cmp    $0x5356,%si
    26c1:	0f 84 3c 21 00 00    	je     4803 <_zipinfo+0x3643>
    26c7:	66 81 fe 49 4d       	cmp    $0x4d49,%si
    26cc:	0f 85 9c 0a 00 00    	jne    316e <_zipinfo+0x1fae>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    26d2:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    26d8:	89 7c 24 08          	mov    %edi,0x8(%esp)
    26dc:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    26e0:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    26e4:	c7 44 24 0c a4 0e 00 	movl   $0xea4,0xc(%esp)
    26eb:	00 
    26ec:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    26f3:	00 
    26f4:	89 3c 24             	mov    %edi,(%esp)
    26f7:	e8 00 00 00 00       	call   26fc <_zipinfo+0x153c>
    26fc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2703:	00 
    2704:	89 44 24 08          	mov    %eax,0x8(%esp)
    2708:	89 7c 24 04          	mov    %edi,0x4(%esp)
    270c:	89 2c 24             	mov    %ebp,(%esp)
    270f:	ff d6                	call   *%esi
    2711:	83 ec 10             	sub    $0x10,%esp
                          makelong(ef_ptr)));
                        *pEndprev = 0L;   /* no clue about csize of local */
                    }
                    break;
                case EF_IZVMS:
                    if (eb_datalen >= 8) {
    2714:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    2718:	66 83 fe 07          	cmp    $0x7,%si
    271c:	89 f0                	mov    %esi,%eax
    271e:	0f 86 b4 14 00 00    	jbe    3bd8 <_zipinfo+0x2a18>
                        char *p, q[8];
                        unsigned compr = makeword(ef_ptr+EB_IZVMS_FLGS)
    2724:	8b 44 24 68          	mov    0x68(%esp),%eax
    2728:	31 f6                	xor    %esi,%esi
    272a:	83 c0 08             	add    $0x8,%eax
    272d:	89 04 24             	mov    %eax,(%esp)
    2730:	e8 00 00 00 00       	call   2735 <_zipinfo+0x1575>
                                        & EB_IZVMS_BCMASK;

                        *q = '\0';
    2735:	c6 84 24 d0 00 00 00 	movb   $0x0,0xd0(%esp)
    273c:	00 
                    }
                    break;
                case EF_IZVMS:
                    if (eb_datalen >= 8) {
                        char *p, q[8];
                        unsigned compr = makeword(ef_ptr+EB_IZVMS_FLGS)
    273d:	83 e0 07             	and    $0x7,%eax
    2740:	66 83 f8 03          	cmp    $0x3,%ax
    2744:	66 89 c6             	mov    %ax,%si
    2747:	b8 03 00 00 00       	mov    $0x3,%eax
    274c:	0f 47 f0             	cmova  %eax,%esi
                                        & EB_IZVMS_BCMASK;

                        *q = '\0';
                        if (compr > 3)
                            compr = 3;
                        switch (makelong(ef_ptr)) {
    274f:	8b 44 24 78          	mov    0x78(%esp),%eax
    2753:	89 04 24             	mov    %eax,(%esp)
    2756:	e8 00 00 00 00       	call   275b <_zipinfo+0x159b>
    275b:	3d 56 50 52 4f       	cmp    $0x4f525056,%eax
    2760:	0f 84 2a 2a 00 00    	je     5190 <_zipinfo+0x3fd0>
    2766:	0f 86 68 29 00 00    	jbe    50d4 <_zipinfo+0x3f14>
    276c:	3d 56 52 44 54       	cmp    $0x54445256,%eax
    2771:	0f 84 90 2a 00 00    	je     5207 <_zipinfo+0x4047>
    2777:	0f 86 75 2a 00 00    	jbe    51f2 <_zipinfo+0x4032>
    277d:	3d 56 4d 53 56       	cmp    $0x56534d56,%eax
    2782:	0f 84 12 2a 00 00    	je     519a <_zipinfo+0x3fda>
                            case 0x54445256: /* "VRDT" */
                                p = "XABRDT"; break;
                            case 0x4F525056: /* "VPRO" */
                                p = "XABPRO"; break;
                            case 0x59454B56: /* "VKEY" */
                                p = "XABKEY"; break;
    2788:	bf e9 01 00 00       	mov    $0x1e9,%edi
                                        & EB_IZVMS_BCMASK;

                        *q = '\0';
                        if (compr > 3)
                            compr = 3;
                        switch (makelong(ef_ptr)) {
    278d:	3d 56 4b 45 59       	cmp    $0x59454b56,%eax
    2792:	0f 85 63 29 00 00    	jne    50fb <_zipinfo+0x3f3b>
                                }
                                break;
                            default:
                                p = "unknown";
                        }
                        Info(slide, 0, ((char *)slide,
    2798:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    279e:	89 c3                	mov    %eax,%ebx
    27a0:	8b 44 24 68          	mov    0x68(%esp),%eax
    27a4:	83 c0 0a             	add    $0xa,%eax
    27a7:	89 04 24             	mov    %eax,(%esp)
    27aa:	e8 00 00 00 00       	call   27af <_zipinfo+0x15ef>
    27af:	89 7c 24 10          	mov    %edi,0x10(%esp)
    27b3:	89 c1                	mov    %eax,%ecx
    27b5:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
    27bc:	89 44 24 14          	mov    %eax,0x14(%esp)
    27c0:	31 c0                	xor    %eax,%eax
    27c2:	66 89 c8             	mov    %cx,%ax
    27c5:	c7 44 24 04 80 0c 00 	movl   $0xc80,0x4(%esp)
    27cc:	00 
    27cd:	89 44 24 0c          	mov    %eax,0xc(%esp)
    27d1:	8b 04 b5 30 0c 00 00 	mov    0xc30(,%esi,4),%eax
    27d8:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    27dc:	89 44 24 08          	mov    %eax,0x8(%esp)
    27e0:	89 34 24             	mov    %esi,(%esp)
    27e3:	e8 00 00 00 00       	call   27e8 <_zipinfo+0x1628>
    27e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    27ef:	00 
    27f0:	89 44 24 08          	mov    %eax,0x8(%esp)
    27f4:	89 74 24 04          	mov    %esi,0x4(%esp)
    27f8:	89 2c 24             	mov    %ebp,(%esp)
    27fb:	89 d8                	mov    %ebx,%eax
    27fd:	ff d0                	call   *%eax
    27ff:	83 ec 10             	sub    $0x10,%esp
    2802:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    2806:	25 ff ff 00 00       	and    $0xffff,%eax
    280b:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    280f:	90                   	nop
                            Info(slide, 0, ((char *)slide,
                                 LoadFarString(efFormat), ef_ptr[i]));
                    }
                    break;
            }
            (*G.message)((zvoid *)&G, (uch *)".", 1L, 0);
    2810:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2817:	00 
    2818:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    281f:	00 
    2820:	c7 44 24 04 59 02 00 	movl   $0x259,0x4(%esp)
    2827:	00 
    2828:	89 2c 24             	mov    %ebp,(%esp)
    282b:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
    2831:	83 ec 10             	sub    $0x10,%esp

            ef_ptr += eb_datalen;
    2834:	8b 44 24 78          	mov    0x78(%esp),%eax
    2838:	8b 74 24 7c          	mov    0x7c(%esp),%esi
    283c:	01 f0                	add    %esi,%eax
    283e:	89 44 24 68          	mov    %eax,0x68(%esp)
        if (G.extra_field == (uch *)NULL)
            return PK_ERR;   /* not consistent with crec length */

        Info(slide, 0, ((char *)slide, LoadFarString(ExtraFields)));

        while (ef_len >= EB_HEADSIZE) {
    2842:	66 83 7c 24 60 03    	cmpw   $0x3,0x60(%esp)
    2848:	0f 87 82 08 00 00    	ja     30d0 <_zipinfo+0x1f10>
            (*G.message)((zvoid *)&G, (uch *)".", 1L, 0);

            ef_ptr += eb_datalen;
            ef_len -= eb_datalen;
        }
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);
    284e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2855:	00 
    2856:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    285d:	00 
    285e:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
    2865:	00 
    2866:	89 2c 24             	mov    %ebp,(%esp)
    2869:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
    286f:	83 ec 10             	sub    $0x10,%esp
    }

    /* high bit == Unix/OS2/NT GMT times (mtime, atime); next bit == UID/GID */
    if ((xattr = (unsigned)((G.crec.external_file_attributes & 0xC000) >> 12))
    2872:	8b 85 60 09 01 00    	mov    0x10960(%ebp),%eax
    2878:	25 00 c0 00 00       	and    $0xc000,%eax
    287d:	c1 e8 0c             	shr    $0xc,%eax
    2880:	a8 08                	test   $0x8,%al
    2882:	74 2c                	je     28b0 <_zipinfo+0x16f0>
        & 8)
    {
        if (hostnum == UNIX_ || hostnum == FS_HPFS_ || hostnum == FS_NTFS_)
    2884:	83 7c 24 54 06       	cmpl   $0x6,0x54(%esp)
    2889:	0f 84 3f 07 00 00    	je     2fce <_zipinfo+0x1e0e>
    288f:	8a 94 24 87 00 00 00 	mov    0x87(%esp),%dl
    2896:	83 e2 f7             	and    $0xfffffff7,%edx
    2899:	80 fa 03             	cmp    $0x3,%dl
    289c:	0f 84 2c 07 00 00    	je     2fce <_zipinfo+0x1e0e>
              "is", EF_IZUNIX, LoadFarStringSmall(efIZUnix),
              (unsigned)(xattr&12), (xattr&4)? efIZuid : efIZnouid));
            if (*pEndprev > 0L)
                *pEndprev += (ulg)(xattr&12);
        }
        else if (hostnum == FS_FAT_ && !(xattr&4))
    28a2:	8b 5c 24 54          	mov    0x54(%esp),%ebx
    28a6:	85 db                	test   %ebx,%ebx
    28a8:	0f 84 93 0f 00 00    	je     3841 <_zipinfo+0x2681>
    28ae:	66 90                	xchg   %ax,%ax
            Info(slide, 0, ((char *)slide, LoadFarString(lExtraFieldType),
              "may be", EF_IZUNIX, LoadFarStringSmall(efIZUnix), 8,
              efIZnouid));
    }

    if (!G.crec.file_comment_length)
    28b0:	66 83 bd 58 09 01 00 	cmpw   $0x0,0x10958(%ebp)
    28b7:	00 
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    28b8:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    28be:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
            Info(slide, 0, ((char *)slide, LoadFarString(lExtraFieldType),
              "may be", EF_IZUNIX, LoadFarStringSmall(efIZUnix), 8,
              efIZnouid));
    }

    if (!G.crec.file_comment_length)
    28c2:	0f 85 68 f6 ff ff    	jne    1f30 <_zipinfo+0xd70>
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    28c8:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
    28cf:	be b9 02 00 00       	mov    $0x2b9,%esi
    28d4:	b8 1e 00 00 00       	mov    $0x1e,%eax
    28d9:	85 c9                	test   %ecx,%ecx
    28db:	0f 85 ce 22 00 00    	jne    4baf <_zipinfo+0x39ef>
    28e1:	f7 c7 02 00 00 00    	test   $0x2,%edi
    28e7:	0f 85 de 22 00 00    	jne    4bcb <_zipinfo+0x3a0b>
    28ed:	89 c1                	mov    %eax,%ecx
    28ef:	c1 e9 02             	shr    $0x2,%ecx
    28f2:	a8 02                	test   $0x2,%al
    28f4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    28f6:	74 0b                	je     2903 <_zipinfo+0x1743>
    28f8:	66 8b 0e             	mov    (%esi),%cx
    28fb:	66 89 0f             	mov    %cx,(%edi)
    28fe:	b9 02 00 00 00       	mov    $0x2,%ecx
    2903:	a8 01                	test   $0x1,%al
    2905:	74 06                	je     290d <_zipinfo+0x174d>
    2907:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    290a:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    290d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2914:	00 
    2915:	c7 44 24 08 1d 00 00 	movl   $0x1d,0x8(%esp)
    291c:	00 
        {
            error_in_archive = error;   /* might be warning */
            if (error > PK_WARN)   /* fatal */
                return error;
        }
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommEnd)));
    291d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    2921:	89 2c 24             	mov    %ebp,(%esp)
    2924:	89 44 24 04          	mov    %eax,0x4(%esp)
    2928:	ff d2                	call   *%edx
    292a:	83 ec 10             	sub    $0x10,%esp
    292d:	8b 44 24 74          	mov    0x74(%esp),%eax
    2931:	89 44 24 6c          	mov    %eax,0x6c(%esp)
    2935:	e9 c5 f2 ff ff       	jmp    1bff <_zipinfo+0xa3f>
    293a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
               G.tz_is_valid &&
#endif
               (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
                                 G.crec.last_mod_dos_datetime, &z_utime, NULL)
                & EB_UT_FL_MTIME)
              ? &z_utime.mtime : NULL;
    2940:	85 c0                	test   %eax,%eax
    2942:	0f 84 54 f9 ff ff    	je     229c <_zipinfo+0x10dc>
#ifdef USE_EF_UT_TIME
    z_modtim = G.extra_field &&
#ifdef IZ_CHECK_TZ
               G.tz_is_valid &&
#endif
               (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
    2948:	8d 94 24 a8 00 00 00 	lea    0xa8(%esp),%edx
    294f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
    2956:	00 
    2957:	89 54 24 10          	mov    %edx,0x10(%esp)
                                 G.crec.last_mod_dos_datetime, &z_utime, NULL)
                & EB_UT_FL_MTIME)
              ? &z_utime.mtime : NULL;
    295b:	8d b4 24 ac 00 00 00 	lea    0xac(%esp),%esi
#ifdef USE_EF_UT_TIME
    z_modtim = G.extra_field &&
#ifdef IZ_CHECK_TZ
               G.tz_is_valid &&
#endif
               (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
    2962:	8b 95 44 09 01 00    	mov    0x10944(%ebp),%edx
    2968:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    296f:	00 
    2970:	89 54 24 0c          	mov    %edx,0xc(%esp)
    2974:	31 d2                	xor    %edx,%edx
    2976:	66 8b 95 56 09 01 00 	mov    0x10956(%ebp),%dx
    297d:	89 04 24             	mov    %eax,(%esp)
    2980:	89 54 24 04          	mov    %edx,0x4(%esp)
    2984:	e8 00 00 00 00       	call   2989 <_zipinfo+0x17c9>
                                 G.crec.last_mod_dos_datetime, &z_utime, NULL)
                & EB_UT_FL_MTIME)
              ? &z_utime.mtime : NULL;
    2989:	a8 01                	test   $0x1,%al
    298b:	0f 44 f3             	cmove  %ebx,%esi
    298e:	e9 0b f9 ff ff       	jmp    229e <_zipinfo+0x10de>
#else
    Info(slide, 0, ((char *)slide, "%s %s %8lu ", attribs,
      LoadFarStringSmall(os[hostnum]),
      G.crec.ucsize));
#endif
    Info(slide, 0, ((char *)slide, "%c",
    2993:	83 e0 01             	and    $0x1,%eax
    2996:	66 83 f8 01          	cmp    $0x1,%ax
    299a:	19 c0                	sbb    %eax,%eax
    299c:	83 e0 ee             	and    $0xffffffee,%eax
    299f:	83 c0 74             	add    $0x74,%eax
    29a2:	e9 f0 f7 ff ff       	jmp    2197 <_zipinfo+0xfd7>
            G.crec.external_file_attributes >> 8));

    } /* endif (hostnum: external attributes format) */

    if ((xattr=(unsigned)(G.crec.external_file_attributes & 0xFF)) == 0)
        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributes),
    29a7:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    29ad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    29b4:	00 
    29b5:	c7 44 24 04 a0 11 00 	movl   $0x11a0,0x4(%esp)
    29bc:	00 
          xattr));
    else if (xattr == 1)
        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributesRO),
    29bd:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    29c1:	89 34 24             	mov    %esi,(%esp)
    29c4:	e8 00 00 00 00       	call   29c9 <_zipinfo+0x1809>
    29c9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    29d0:	00 
    29d1:	89 44 24 08          	mov    %eax,0x8(%esp)
    29d5:	89 74 24 04          	mov    %esi,0x4(%esp)
    29d9:	89 2c 24             	mov    %ebp,(%esp)
    29dc:	ff d3                	call   *%ebx
    29de:	83 ec 10             	sub    $0x10,%esp
    29e1:	e9 ef f1 ff ff       	jmp    1bd5 <_zipinfo+0xa15>
                            return error;
                    }
                    break;

                default:
                    SKIP_(G.crec.extra_field_length)
    29e6:	31 c0                	xor    %eax,%eax
    29e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    29ef:	00 
    29f0:	66 89 c8             	mov    %cx,%ax
    29f3:	89 2c 24             	mov    %ebp,(%esp)
    29f6:	89 44 24 04          	mov    %eax,0x4(%esp)
    29fa:	e8 00 00 00 00       	call   29ff <_zipinfo+0x183f>
    29ff:	85 c0                	test   %eax,%eax
    2a01:	0f 84 79 f3 ff ff    	je     1d80 <_zipinfo+0xbc0>
    2a07:	83 f8 01             	cmp    $0x1,%eax
    2a0a:	0f 8f b3 f5 ff ff    	jg     1fc3 <_zipinfo+0xe03>
    2a10:	89 44 24 50          	mov    %eax,0x50(%esp)
    2a14:	e9 67 f3 ff ff       	jmp    1d80 <_zipinfo+0xbc0>
    2a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

            switch (uO.lflag) {
                case 1:
                case 2:
                    fnprint(__G);
                    SKIP_(G.crec.extra_field_length)
    2a20:	31 c0                	xor    %eax,%eax
    2a22:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    2a29:	00 
    2a2a:	66 89 c8             	mov    %cx,%ax
    2a2d:	89 2c 24             	mov    %ebp,(%esp)
    2a30:	89 44 24 04          	mov    %eax,0x4(%esp)
    2a34:	e8 00 00 00 00       	call   2a39 <_zipinfo+0x1879>
    2a39:	85 c0                	test   %eax,%eax
    2a3b:	0f 84 97 f2 ff ff    	je     1cd8 <_zipinfo+0xb18>
    2a41:	83 f8 01             	cmp    $0x1,%eax
    2a44:	0f 8f 79 f5 ff ff    	jg     1fc3 <_zipinfo+0xe03>
                    SKIP_(G.crec.file_comment_length)
    2a4a:	8b 8d 58 09 01 00    	mov    0x10958(%ebp),%ecx
    2a50:	89 44 24 50          	mov    %eax,0x50(%esp)
    2a54:	66 85 c9             	test   %cx,%cx
    2a57:	0f 84 8a f2 ff ff    	je     1ce7 <_zipinfo+0xb27>
    2a5d:	8d 76 00             	lea    0x0(%esi),%esi
    2a60:	31 c0                	xor    %eax,%eax
    2a62:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    2a69:	00 
    2a6a:	66 89 c8             	mov    %cx,%ax
    2a6d:	e9 2a f3 ff ff       	jmp    1d9c <_zipinfo+0xbdc>
    Info(slide, 0, ((char *)slide, LoadFarString(MinOSCompReq), varmsg_str));
    Info(slide, 0, ((char *)slide, LoadFarString(MinSWVerReq), extver/10,
      extver%10));

    if (methnum >= NUM_METHODS) {
        sprintf(unkn, LoadFarString(UnknownNo), G.crec.compression_method);
    2a72:	31 c0                	xor    %eax,%eax
    2a74:	8d b4 24 a8 00 00 00 	lea    0xa8(%esp),%esi
    2a7b:	66 8b 85 42 09 01 00 	mov    0x10942(%ebp),%ax
    2a82:	c7 44 24 04 ac 18 00 	movl   $0x18ac,0x4(%esp)
    2a89:	00 
    2a8a:	89 44 24 08          	mov    %eax,0x8(%esp)
    2a8e:	89 34 24             	mov    %esi,(%esp)
    2a91:	e8 00 00 00 00       	call   2a96 <_zipinfo+0x18d6>
        varmsg_str = unkn;
    } else {
        varmsg_str = LoadFarStringSmall(method[methnum]);
    }
    Info(slide, 0, ((char *)slide, LoadFarString(CompressMethod), varmsg_str));
    2a96:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2a9c:	89 74 24 08          	mov    %esi,0x8(%esp)
    2aa0:	c7 44 24 04 20 17 00 	movl   $0x1720,0x4(%esp)
    2aa7:	00 
        Info(slide, 0, ((char *)slide, LoadFarString(ShannonFanoTrees),
          (G.crec.general_purpose_bit_flag & 4)? '3' : '2'));
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
        ush  dnum=(ush)((G.crec.general_purpose_bit_flag>>1) & 3);

        Info(slide, 0, ((char *)slide, LoadFarString(CompressSubtype),
    2aa8:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    2aac:	89 34 24             	mov    %esi,(%esp)
    2aaf:	e8 00 00 00 00       	call   2ab4 <_zipinfo+0x18f4>
    2ab4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2abb:	00 
    2abc:	89 44 24 08          	mov    %eax,0x8(%esp)
    2ac0:	89 74 24 04          	mov    %esi,0x4(%esp)
    2ac4:	89 2c 24             	mov    %ebp,(%esp)
    2ac7:	ff d3                	call   *%ebx
    2ac9:	83 ec 10             	sub    $0x10,%esp
    2acc:	e9 71 ec ff ff       	jmp    1742 <_zipinfo+0x582>
    Info(slide, 0, ((char *)slide, LoadFarString(LocalHeaderOffset),
      G.crec.relative_offset_local_header,
      G.crec.relative_offset_local_header));

    if (hostnum >= NUM_HOSTS) {
        sprintf(unkn, LoadFarString(UnknownNo),
    2ad1:	31 c0                	xor    %eax,%eax
    2ad3:	8d bc 24 a8 00 00 00 	lea    0xa8(%esp),%edi
    2ada:	8a 85 3d 09 01 00    	mov    0x1093d(%ebp),%al
    2ae0:	c7 44 24 04 ac 18 00 	movl   $0x18ac,0x4(%esp)
    2ae7:	00 
    2ae8:	89 44 24 08          	mov    %eax,0x8(%esp)
    2aec:	89 3c 24             	mov    %edi,(%esp)
    2aef:	e8 00 00 00 00       	call   2af4 <_zipinfo+0x1934>
                (int)G.crec.version_made_by[1]);
        varmsg_str = unkn;
    2af4:	89 f8                	mov    %edi,%eax
    2af6:	e9 be ea ff ff       	jmp    15b9 <_zipinfo+0x3f9>
    2afb:	90                   	nop
    2afc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
/*---------------------------------------------------------------------------
    Skip the file comment, if any (the filename has already been printed,
    above).  That finishes up this file entry...
  ---------------------------------------------------------------------------*/

    SKIP_(G.crec.file_comment_length)
    2b00:	31 c0                	xor    %eax,%eax
    2b02:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    2b09:	00 
    2b0a:	66 89 c8             	mov    %cx,%ax
    2b0d:	89 2c 24             	mov    %ebp,(%esp)
    2b10:	89 44 24 04          	mov    %eax,0x4(%esp)
    2b14:	e8 00 00 00 00       	call   2b19 <_zipinfo+0x1959>
    2b19:	85 c0                	test   %eax,%eax
    2b1b:	0f 84 f8 f7 ff ff    	je     2319 <_zipinfo+0x1159>
    2b21:	89 44 24 50          	mov    %eax,0x50(%esp)
    2b25:	e9 fb f7 ff ff       	jmp    2325 <_zipinfo+0x1165>
    2b2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    2b30:	8d 9c 24 9c 00 00 00 	lea    0x9c(%esp),%ebx
    2b37:	8d 94 24 a8 00 00 00 	lea    0xa8(%esp),%edx
#ifdef ATARI
    printf("  external file attributes (hex):                   %.8lx\n",
      G.crec.external_file_attributes);
#endif
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    if (hostnum == VMS_) {
    2b3e:	89 d8                	mov    %ebx,%eax
        char   *p=attribs, *q=attribs+1;
        int    i, j, k;

        for (k = 0;  k < 12;  ++k)
            workspace[k] = 0;
    2b40:	c6 00 00             	movb   $0x0,(%eax)
    2b43:	40                   	inc    %eax
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    if (hostnum == VMS_) {
        char   *p=attribs, *q=attribs+1;
        int    i, j, k;

        for (k = 0;  k < 12;  ++k)
    2b44:	39 d0                	cmp    %edx,%eax
    2b46:	75 f8                	jne    2b40 <_zipinfo+0x1980>
            workspace[k] = 0;
        if (xattr & VMS_IRUSR)
    2b48:	f7 c7 00 01 00 00    	test   $0x100,%edi
    2b4e:	74 08                	je     2b58 <_zipinfo+0x1998>
            workspace[0] = 'R';
    2b50:	c6 84 24 9c 00 00 00 	movb   $0x52,0x9c(%esp)
    2b57:	52 
        if (xattr & VMS_IWUSR) {
    2b58:	f7 c7 80 00 00 00    	test   $0x80,%edi
    2b5e:	74 10                	je     2b70 <_zipinfo+0x19b0>
            workspace[1] = 'W';
    2b60:	c6 84 24 9d 00 00 00 	movb   $0x57,0x9d(%esp)
    2b67:	57 
            workspace[3] = 'D';
    2b68:	c6 84 24 9f 00 00 00 	movb   $0x44,0x9f(%esp)
    2b6f:	44 
        }
        if (xattr & VMS_IXUSR)
    2b70:	f7 c7 40 00 00 00    	test   $0x40,%edi
    2b76:	74 08                	je     2b80 <_zipinfo+0x19c0>
            workspace[2] = 'E';
    2b78:	c6 84 24 9e 00 00 00 	movb   $0x45,0x9e(%esp)
    2b7f:	45 
        if (xattr & VMS_IRGRP)
    2b80:	f7 c7 20 00 00 00    	test   $0x20,%edi
    2b86:	74 08                	je     2b90 <_zipinfo+0x19d0>
            workspace[4] = 'R';
    2b88:	c6 84 24 a0 00 00 00 	movb   $0x52,0xa0(%esp)
    2b8f:	52 
        if (xattr & VMS_IWGRP) {
    2b90:	f7 c7 10 00 00 00    	test   $0x10,%edi
    2b96:	74 10                	je     2ba8 <_zipinfo+0x19e8>
            workspace[5] = 'W';
    2b98:	c6 84 24 a1 00 00 00 	movb   $0x57,0xa1(%esp)
    2b9f:	57 
            workspace[7] = 'D';
    2ba0:	c6 84 24 a3 00 00 00 	movb   $0x44,0xa3(%esp)
    2ba7:	44 
        }
        if (xattr & VMS_IXGRP)
    2ba8:	f7 c7 08 00 00 00    	test   $0x8,%edi
    2bae:	74 08                	je     2bb8 <_zipinfo+0x19f8>
            workspace[6] = 'E';
    2bb0:	c6 84 24 a2 00 00 00 	movb   $0x45,0xa2(%esp)
    2bb7:	45 
        if (xattr & VMS_IROTH)
    2bb8:	f7 c7 04 00 00 00    	test   $0x4,%edi
    2bbe:	74 08                	je     2bc8 <_zipinfo+0x1a08>
            workspace[8] = 'R';
    2bc0:	c6 84 24 a4 00 00 00 	movb   $0x52,0xa4(%esp)
    2bc7:	52 
        if (xattr & VMS_IWOTH) {
    2bc8:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2bce:	74 10                	je     2be0 <_zipinfo+0x1a20>
            workspace[9] = 'W';
    2bd0:	c6 84 24 a5 00 00 00 	movb   $0x57,0xa5(%esp)
    2bd7:	57 
            workspace[11] = 'D';
    2bd8:	c6 84 24 a7 00 00 00 	movb   $0x44,0xa7(%esp)
    2bdf:	44 
        }
        if (xattr & VMS_IXOTH)
    2be0:	f7 c7 01 00 00 00    	test   $0x1,%edi
    2be6:	74 08                	je     2bf0 <_zipinfo+0x1a30>
            workspace[10] = 'E';
    2be8:	c6 84 24 a6 00 00 00 	movb   $0x45,0xa6(%esp)
    2bef:	45 
    printf("  external file attributes (hex):                   %.8lx\n",
      G.crec.external_file_attributes);
#endif
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    if (hostnum == VMS_) {
        char   *p=attribs, *q=attribs+1;
    2bf0:	8d 84 24 bb 00 00 00 	lea    0xbb(%esp),%eax
            workspace[11] = 'D';
        }
        if (xattr & VMS_IXOTH)
            workspace[10] = 'E';

        *p++ = '(';
    2bf7:	c6 84 24 ba 00 00 00 	movb   $0x28,0xba(%esp)
    2bfe:	28 
    2bff:	c7 44 24 60 01 00 00 	movl   $0x1,0x60(%esp)
    2c06:	00 
    printf("  external file attributes (hex):                   %.8lx\n",
      G.crec.external_file_attributes);
#endif
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    if (hostnum == VMS_) {
        char   *p=attribs, *q=attribs+1;
    2c07:	89 44 24 68          	mov    %eax,0x68(%esp)
            workspace[11] = 'D';
        }
        if (xattr & VMS_IXOTH)
            workspace[10] = 'E';

        *p++ = '(';
    2c0b:	89 c1                	mov    %eax,%ecx
#ifdef ATARI
    printf("  external file attributes (hex):                   %.8lx\n",
      G.crec.external_file_attributes);
#endif
    xattr = (unsigned)((G.crec.external_file_attributes >> 16) & 0xFFFF);
    if (hostnum == VMS_) {
    2c0d:	31 c0                	xor    %eax,%eax
            workspace[10] = 'E';

        *p++ = '(';
        for (k = j = 0;  j < 3;  ++j) {    /* loop over groups of permissions */
            for (i = 0;  i < 4;  ++i, ++k)  /* loop over perms within a group */
                if (workspace[k])
    2c0f:	8a 14 03             	mov    (%ebx,%eax,1),%dl
    2c12:	84 d2                	test   %dl,%dl
    2c14:	74 03                	je     2c19 <_zipinfo+0x1a59>
                    *p++ = workspace[k];
    2c16:	88 11                	mov    %dl,(%ecx)
    2c18:	41                   	inc    %ecx
        if (xattr & VMS_IXOTH)
            workspace[10] = 'E';

        *p++ = '(';
        for (k = j = 0;  j < 3;  ++j) {    /* loop over groups of permissions */
            for (i = 0;  i < 4;  ++i, ++k)  /* loop over perms within a group */
    2c19:	40                   	inc    %eax
    2c1a:	83 f8 04             	cmp    $0x4,%eax
    2c1d:	75 f0                	jne    2c0f <_zipinfo+0x1a4f>
                if (workspace[k])
                    *p++ = workspace[k];
            *p++ = ',';                       /* group separator */
    2c1f:	8d 51 01             	lea    0x1(%ecx),%edx
    2c22:	c6 01 2c             	movb   $0x2c,(%ecx)
            if (j == 0)
    2c25:	83 7c 24 60 01       	cmpl   $0x1,0x60(%esp)
    2c2a:	0f 84 e1 25 00 00    	je     5211 <_zipinfo+0x4051>
        }
        if (xattr & VMS_IXOTH)
            workspace[10] = 'E';

        *p++ = '(';
        for (k = j = 0;  j < 3;  ++j) {    /* loop over groups of permissions */
    2c30:	83 7c 24 60 03       	cmpl   $0x3,0x60(%esp)
    2c35:	0f 84 fd 00 00 00    	je     2d38 <_zipinfo+0x1b78>
    2c3b:	8b 44 24 60          	mov    0x60(%esp),%eax
    2c3f:	83 c3 04             	add    $0x4,%ebx
    2c42:	40                   	inc    %eax
            for (i = 0;  i < 4;  ++i, ++k)  /* loop over perms within a group */
                if (workspace[k])
                    *p++ = workspace[k];
    2c43:	89 d1                	mov    %edx,%ecx
    2c45:	89 44 24 60          	mov    %eax,0x60(%esp)
    2c49:	eb c2                	jmp    2c0d <_zipinfo+0x1a4d>
    2c4b:	90                   	nop
    2c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    } else {
        varmsg_str = LoadFarStringSmall(method[methnum]);
    }
    Info(slide, 0, ((char *)slide, LoadFarString(CompressMethod), varmsg_str));
    if (methnum == IMPLODED) {
        Info(slide, 0, ((char *)slide, LoadFarString(SlideWindowSizeImplode),
    2c50:	8b 85 40 09 01 00    	mov    0x10940(%ebp),%eax
    2c56:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    2c5a:	83 e0 02             	and    $0x2,%eax
    2c5d:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2c63:	66 83 f8 01          	cmp    $0x1,%ax
    2c67:	c7 44 24 04 e0 16 00 	movl   $0x16e0,0x4(%esp)
    2c6e:	00 
    2c6f:	19 c0                	sbb    %eax,%eax
    2c71:	89 34 24             	mov    %esi,(%esp)
    2c74:	83 e0 fc             	and    $0xfffffffc,%eax
    2c77:	83 c0 38             	add    $0x38,%eax
    2c7a:	89 44 24 08          	mov    %eax,0x8(%esp)
    2c7e:	e8 00 00 00 00       	call   2c83 <_zipinfo+0x1ac3>
    2c83:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2c8a:	00 
    2c8b:	89 44 24 08          	mov    %eax,0x8(%esp)
    2c8f:	89 74 24 04          	mov    %esi,0x4(%esp)
    2c93:	89 2c 24             	mov    %ebp,(%esp)
    2c96:	ff d3                	call   *%ebx
          (G.crec.general_purpose_bit_flag & 2)? '8' : '4'));
        Info(slide, 0, ((char *)slide, LoadFarString(ShannonFanoTrees),
    2c98:	8b 85 40 09 01 00    	mov    0x10940(%ebp),%eax
    2c9e:	83 e0 04             	and    $0x4,%eax
    } else {
        varmsg_str = LoadFarStringSmall(method[methnum]);
    }
    Info(slide, 0, ((char *)slide, LoadFarString(CompressMethod), varmsg_str));
    if (methnum == IMPLODED) {
        Info(slide, 0, ((char *)slide, LoadFarString(SlideWindowSizeImplode),
    2ca1:	83 ec 10             	sub    $0x10,%esp
          (G.crec.general_purpose_bit_flag & 2)? '8' : '4'));
        Info(slide, 0, ((char *)slide, LoadFarString(ShannonFanoTrees),
    2ca4:	66 83 f8 01          	cmp    $0x1,%ax
    2ca8:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2cae:	19 c0                	sbb    %eax,%eax
    2cb0:	c7 44 24 04 a0 16 00 	movl   $0x16a0,0x4(%esp)
    2cb7:	00 
    2cb8:	83 c0 33             	add    $0x33,%eax
    2cbb:	89 44 24 08          	mov    %eax,0x8(%esp)
    2cbf:	e9 e8 fd ff ff       	jmp    2aac <_zipinfo+0x18ec>
      ((G.crec.general_purpose_bit_flag & 8)? 'X' : 'x') :  /* extra field */
      ((G.crec.general_purpose_bit_flag & 8)? 'l' : '-'))); /* no extra field */
      /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ extended local header or not */

    if (uO.lflag == 4) {
        ulg csiz = G.crec.csize;
    2cc4:	8b 85 4c 09 01 00    	mov    0x1094c(%ebp),%eax

        if (G.crec.general_purpose_bit_flag & 1)
            csiz -= 12;    /* if encrypted, don't count encryption header */
    2cca:	f6 85 40 09 01 00 01 	testb  $0x1,0x10940(%ebp)
    2cd1:	8d 50 f4             	lea    -0xc(%eax),%edx
        Info(slide, 0, ((char *)slide, "%3d%%",
    2cd4:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx

    if (uO.lflag == 4) {
        ulg csiz = G.crec.csize;

        if (G.crec.general_purpose_bit_flag & 1)
            csiz -= 12;    /* if encrypted, don't count encryption header */
    2cda:	0f 45 c2             	cmovne %edx,%eax
        Info(slide, 0, ((char *)slide, "%3d%%",
    2cdd:	89 44 24 04          	mov    %eax,0x4(%esp)
    2ce1:	8b 85 50 09 01 00    	mov    0x10950(%ebp),%eax
    2ce7:	89 04 24             	mov    %eax,(%esp)
    2cea:	e8 00 00 00 00       	call   2cef <_zipinfo+0x1b2f>
    2cef:	ba 67 66 66 66       	mov    $0x66666667,%edx
    2cf4:	c7 44 24 04 3a 02 00 	movl   $0x23a,0x4(%esp)
    2cfb:	00 
    2cfc:	8d 48 05             	lea    0x5(%eax),%ecx
    2cff:	89 c8                	mov    %ecx,%eax
    2d01:	f7 ea                	imul   %edx
    2d03:	c1 f9 1f             	sar    $0x1f,%ecx
    2d06:	c1 fa 02             	sar    $0x2,%edx
    2d09:	29 ca                	sub    %ecx,%edx
    2d0b:	89 54 24 08          	mov    %edx,0x8(%esp)
          (ratio(G.crec.ucsize,csiz)+5)/10));
    } else if (uO.lflag == 5)
        Info(slide, 0, ((char *)slide, " %8lu", G.crec.csize));
    2d0f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    2d13:	89 34 24             	mov    %esi,(%esp)
    2d16:	e8 00 00 00 00       	call   2d1b <_zipinfo+0x1b5b>
    2d1b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2d22:	00 
    2d23:	89 44 24 08          	mov    %eax,0x8(%esp)
    2d27:	89 74 24 04          	mov    %esi,0x4(%esp)
    2d2b:	89 2c 24             	mov    %ebp,(%esp)
    2d2e:	ff d3                	call   *%ebx
    2d30:	83 ec 10             	sub    $0x10,%esp
    2d33:	e9 21 f5 ff ff       	jmp    2259 <_zipinfo+0x1099>
            *p++ = ',';                       /* group separator */
            if (j == 0)
                while ((*p++ = *q++) != ',')
                    ;                         /* system, owner perms are same */
        }
        *p-- = '\0';
    2d38:	c6 02 00             	movb   $0x0,(%edx)
        *p = ')';   /* overwrite last comma */
    2d3b:	c6 42 ff 29          	movb   $0x29,-0x1(%edx)
        Info(slide, 0, ((char *)slide, LoadFarString(VMSFileAttributes), xattr,
    2d3f:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2d45:	89 74 24 0c          	mov    %esi,0xc(%esp)
    2d49:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    2d4d:	89 7c 24 08          	mov    %edi,0x8(%esp)
    2d51:	c7 44 24 04 a0 12 00 	movl   $0x12a0,0x4(%esp)
    2d58:	00 
    2d59:	89 34 24             	mov    %esi,(%esp)
    2d5c:	e8 00 00 00 00       	call   2d61 <_zipinfo+0x1ba1>
    2d61:	e9 7f ed ff ff       	jmp    1ae5 <_zipinfo+0x925>
          attribs));

    } else if (hostnum == AMIGA_) {
        switch (xattr & AMI_IFMT) {
    2d66:	89 f8                	mov    %edi,%eax
    2d68:	25 00 0c 00 00       	and    $0xc00,%eax
    2d6d:	3d 00 04 00 00       	cmp    $0x400,%eax
    2d72:	0f 84 af 0a 00 00    	je     3827 <_zipinfo+0x2667>
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
    2d78:	3d 00 08 00 00       	cmp    $0x800,%eax
    2d7d:	b2 3f                	mov    $0x3f,%dl
    2d7f:	b0 64                	mov    $0x64,%al
    2d81:	0f 45 c2             	cmovne %edx,%eax
    2d84:	88 84 24 ba 00 00 00 	mov    %al,0xba(%esp)
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2d8b:	89 f8                	mov    %edi,%eax
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
    2d8d:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
        switch (xattr & AMI_IFMT) {
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2d93:	25 80 00 00 00       	and    $0x80,%eax
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
    2d98:	89 74 24 0c          	mov    %esi,0xc(%esp)
        switch (xattr & AMI_IFMT) {
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2d9c:	83 f8 01             	cmp    $0x1,%eax
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
    2d9f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
        switch (xattr & AMI_IFMT) {
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2da3:	19 c0                	sbb    %eax,%eax
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
    2da5:	89 7c 24 08          	mov    %edi,0x8(%esp)
        switch (xattr & AMI_IFMT) {
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2da9:	83 e0 c5             	and    $0xffffffc5,%eax
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
    2dac:	c7 44 24 04 60 12 00 	movl   $0x1260,0x4(%esp)
    2db3:	00 
        switch (xattr & AMI_IFMT) {
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2db4:	83 c0 68             	add    $0x68,%eax
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
    2db7:	89 34 24             	mov    %esi,(%esp)
        switch (xattr & AMI_IFMT) {
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
    2dba:	88 84 24 bb 00 00 00 	mov    %al,0xbb(%esp)
        attribs[2] = (xattr & AMI_ISCRIPT)?   's' : '-';
    2dc1:	89 f8                	mov    %edi,%eax
    2dc3:	83 e0 40             	and    $0x40,%eax
        attribs[4] = (xattr & AMI_IARCHIVE)?  'a' : '-';
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
        attribs[9] = 0;   /* better dlm the string */
    2dc6:	c6 84 24 c3 00 00 00 	movb   $0x0,0xc3(%esp)
    2dcd:	00 
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
            default:         attribs[0] = '?';  break;
        }
        attribs[1] = (xattr & AMI_IHIDDEN)?   'h' : '-';
        attribs[2] = (xattr & AMI_ISCRIPT)?   's' : '-';
    2dce:	83 f8 01             	cmp    $0x1,%eax
    2dd1:	19 c0                	sbb    %eax,%eax
    2dd3:	83 e0 ba             	and    $0xffffffba,%eax
    2dd6:	83 c0 73             	add    $0x73,%eax
    2dd9:	88 84 24 bc 00 00 00 	mov    %al,0xbc(%esp)
        attribs[3] = (xattr & AMI_IPURE)?     'p' : '-';
    2de0:	89 f8                	mov    %edi,%eax
    2de2:	83 e0 20             	and    $0x20,%eax
    2de5:	83 f8 01             	cmp    $0x1,%eax
    2de8:	19 c0                	sbb    %eax,%eax
    2dea:	83 e0 bd             	and    $0xffffffbd,%eax
    2ded:	83 c0 70             	add    $0x70,%eax
    2df0:	88 84 24 bd 00 00 00 	mov    %al,0xbd(%esp)
        attribs[4] = (xattr & AMI_IARCHIVE)?  'a' : '-';
    2df7:	89 f8                	mov    %edi,%eax
    2df9:	83 e0 10             	and    $0x10,%eax
    2dfc:	83 f8 01             	cmp    $0x1,%eax
    2dff:	19 c0                	sbb    %eax,%eax
    2e01:	83 e0 cc             	and    $0xffffffcc,%eax
    2e04:	83 c0 61             	add    $0x61,%eax
    2e07:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
        attribs[5] = (xattr & AMI_IREAD)?     'r' : '-';
    2e0e:	89 f8                	mov    %edi,%eax
    2e10:	83 e0 08             	and    $0x8,%eax
    2e13:	83 f8 01             	cmp    $0x1,%eax
    2e16:	19 c0                	sbb    %eax,%eax
    2e18:	83 e0 bb             	and    $0xffffffbb,%eax
    2e1b:	83 c0 72             	add    $0x72,%eax
    2e1e:	88 84 24 bf 00 00 00 	mov    %al,0xbf(%esp)
        attribs[6] = (xattr & AMI_IWRITE)?    'w' : '-';
    2e25:	89 f8                	mov    %edi,%eax
    2e27:	83 e0 04             	and    $0x4,%eax
    2e2a:	83 f8 01             	cmp    $0x1,%eax
    2e2d:	19 c0                	sbb    %eax,%eax
    2e2f:	83 e0 b6             	and    $0xffffffb6,%eax
    2e32:	83 c0 77             	add    $0x77,%eax
    2e35:	88 84 24 c0 00 00 00 	mov    %al,0xc0(%esp)
        attribs[7] = (xattr & AMI_IEXECUTE)?  'e' : '-';
    2e3c:	89 f8                	mov    %edi,%eax
    2e3e:	83 e0 02             	and    $0x2,%eax
    2e41:	83 f8 01             	cmp    $0x1,%eax
    2e44:	19 c0                	sbb    %eax,%eax
    2e46:	83 e0 c8             	and    $0xffffffc8,%eax
    2e49:	83 c0 65             	add    $0x65,%eax
    2e4c:	88 84 24 c1 00 00 00 	mov    %al,0xc1(%esp)
        attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
    2e53:	89 f8                	mov    %edi,%eax
    2e55:	83 e0 01             	and    $0x1,%eax
    2e58:	83 f8 01             	cmp    $0x1,%eax
    2e5b:	19 c0                	sbb    %eax,%eax
    2e5d:	83 e0 c9             	and    $0xffffffc9,%eax
    2e60:	83 c0 64             	add    $0x64,%eax
    2e63:	88 84 24 c2 00 00 00 	mov    %al,0xc2(%esp)
        attribs[9] = 0;   /* better dlm the string */
        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),
    2e6a:	e8 00 00 00 00       	call   2e6f <_zipinfo+0x1caf>
    2e6f:	e9 71 ec ff ff       	jmp    1ae5 <_zipinfo+0x925>
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != NULL)
        for (j = 0;  j < G.filespecs;  ++j)
            fn_matched[j] = FALSE;

    if (G.xfilespecs > 0  &&
        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != NULL)
    2e74:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != NULL)
        for (j = 0;  j < G.filespecs;  ++j)
            fn_matched[j] = FALSE;

    if (G.xfilespecs > 0  &&
    2e7b:	89 1c 24             	mov    %ebx,(%esp)
    2e7e:	e8 00 00 00 00       	call   2e83 <_zipinfo+0x1cc3>
    2e83:	89 c1                	mov    %eax,%ecx
    2e85:	89 44 24 70          	mov    %eax,0x70(%esp)
    2e89:	85 c0                	test   %eax,%eax
    2e8b:	0f 84 61 e3 ff ff    	je     11f2 <_zipinfo+0x32>
    2e91:	8d 14 19             	lea    (%ecx,%ebx,1),%edx
        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != NULL)
        for (j = 0;  j < G.xfilespecs;  ++j)
            xn_matched[j] = FALSE;
    2e94:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    2e9a:	83 c0 04             	add    $0x4,%eax
        for (j = 0;  j < G.filespecs;  ++j)
            fn_matched[j] = FALSE;

    if (G.xfilespecs > 0  &&
        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != NULL)
        for (j = 0;  j < G.xfilespecs;  ++j)
    2e9d:	39 d0                	cmp    %edx,%eax
    2e9f:	75 f3                	jne    2e94 <_zipinfo+0x1cd4>
    2ea1:	e9 54 e3 ff ff       	jmp    11fa <_zipinfo+0x3a>
    Malloc space for check on unmatched filespecs (no big deal if one or both
    are NULL).
  ---------------------------------------------------------------------------*/

    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != NULL)
    2ea6:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
/*---------------------------------------------------------------------------
    Malloc space for check on unmatched filespecs (no big deal if one or both
    are NULL).
  ---------------------------------------------------------------------------*/

    if (G.filespecs > 0  &&
    2ead:	89 1c 24             	mov    %ebx,(%esp)
    2eb0:	e8 00 00 00 00       	call   2eb5 <_zipinfo+0x1cf5>
    2eb5:	89 c1                	mov    %eax,%ecx
    2eb7:	89 84 24 80 00 00 00 	mov    %eax,0x80(%esp)
    2ebe:	85 c0                	test   %eax,%eax
    2ec0:	0f 84 16 e3 ff ff    	je     11dc <_zipinfo+0x1c>
    2ec6:	8d 14 19             	lea    (%ecx,%ebx,1),%edx
    2ec9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != NULL)
        for (j = 0;  j < G.filespecs;  ++j)
            fn_matched[j] = FALSE;
    2ed0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    2ed6:	83 c0 04             	add    $0x4,%eax
    are NULL).
  ---------------------------------------------------------------------------*/

    if (G.filespecs > 0  &&
        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != NULL)
        for (j = 0;  j < G.filespecs;  ++j)
    2ed9:	39 d0                	cmp    %edx,%eax
    2edb:	75 f3                	jne    2ed0 <_zipinfo+0x1d10>
    2edd:	e9 05 e3 ff ff       	jmp    11e7 <_zipinfo+0x27>
                          G.crec.last_mod_dos_datetime, &z_utime, NULL)
         & EB_UT_FL_MTIME))
    {
        TIMET_TO_NATIVE(z_utime.mtime)   /* NOP unless MSC 7.0 or Macintosh */
        d_t_buf[0] = (char)0;               /* signal "show local time" */
        zi_time(__G__ &G.crec.last_mod_dos_datetime, &(z_utime.mtime), d_t_buf);
    2ee2:	8d bc 24 94 00 00 00 	lea    0x94(%esp),%edi
    2ee9:	8b 4c 24 60          	mov    0x60(%esp),%ecx
    2eed:	89 3c 24             	mov    %edi,(%esp)
    2ef0:	89 da                	mov    %ebx,%edx
    2ef2:	89 74 24 04          	mov    %esi,0x4(%esp)
    2ef6:	8b 44 24 68          	mov    0x68(%esp),%eax
        (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,
                          G.crec.last_mod_dos_datetime, &z_utime, NULL)
         & EB_UT_FL_MTIME))
    {
        TIMET_TO_NATIVE(z_utime.mtime)   /* NOP unless MSC 7.0 or Macintosh */
        d_t_buf[0] = (char)0;               /* signal "show local time" */
    2efa:	c6 84 24 ba 00 00 00 	movb   $0x0,0xba(%esp)
    2f01:	00 
        zi_time(__G__ &G.crec.last_mod_dos_datetime, &(z_utime.mtime), d_t_buf);
    2f02:	e8 99 d7 ff ff       	call   6a0 <_zi_time.isra.0>
        Info(slide, 0, ((char *)slide, LoadFarString(UT_FileModDate),
    2f07:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    2f0d:	c7 44 24 0c 20 15 00 	movl   $0x1520,0xc(%esp)
    2f14:	00 
    2f15:	89 54 24 78          	mov    %edx,0x78(%esp)
    2f19:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    2f1d:	89 14 24             	mov    %edx,(%esp)
    2f20:	89 74 24 08          	mov    %esi,0x8(%esp)
    2f24:	c7 44 24 04 40 15 00 	movl   $0x1540,0x4(%esp)
    2f2b:	00 
    2f2c:	e8 00 00 00 00       	call   2f31 <_zipinfo+0x1d71>
    2f31:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    2f35:	89 54 24 04          	mov    %edx,0x4(%esp)
    2f39:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2f40:	00 
    2f41:	89 44 24 08          	mov    %eax,0x8(%esp)
    2f45:	89 2c 24             	mov    %ebp,(%esp)
    2f48:	ff 54 24 78          	call   *0x78(%esp)
          d_t_buf, LoadFarStringSmall(LocalTime)));
#ifndef NO_GMTIME
        d_t_buf[0] = (char)1;           /* signal "show UTC (GMT) time" */
        zi_time(__G__ &G.crec.last_mod_dos_datetime, &(z_utime.mtime), d_t_buf);
    2f4c:	89 da                	mov    %ebx,%edx
         & EB_UT_FL_MTIME))
    {
        TIMET_TO_NATIVE(z_utime.mtime)   /* NOP unless MSC 7.0 or Macintosh */
        d_t_buf[0] = (char)0;               /* signal "show local time" */
        zi_time(__G__ &G.crec.last_mod_dos_datetime, &(z_utime.mtime), d_t_buf);
        Info(slide, 0, ((char *)slide, LoadFarString(UT_FileModDate),
    2f4e:	83 ec 10             	sub    $0x10,%esp
          d_t_buf, LoadFarStringSmall(LocalTime)));
#ifndef NO_GMTIME
        d_t_buf[0] = (char)1;           /* signal "show UTC (GMT) time" */
        zi_time(__G__ &G.crec.last_mod_dos_datetime, &(z_utime.mtime), d_t_buf);
    2f51:	89 3c 24             	mov    %edi,(%esp)
    2f54:	8b 4c 24 60          	mov    0x60(%esp),%ecx
    2f58:	89 74 24 04          	mov    %esi,0x4(%esp)
    2f5c:	8b 44 24 68          	mov    0x68(%esp),%eax
        d_t_buf[0] = (char)0;               /* signal "show local time" */
        zi_time(__G__ &G.crec.last_mod_dos_datetime, &(z_utime.mtime), d_t_buf);
        Info(slide, 0, ((char *)slide, LoadFarString(UT_FileModDate),
          d_t_buf, LoadFarStringSmall(LocalTime)));
#ifndef NO_GMTIME
        d_t_buf[0] = (char)1;           /* signal "show UTC (GMT) time" */
    2f60:	c6 84 24 ba 00 00 00 	movb   $0x1,0xba(%esp)
    2f67:	01 
        zi_time(__G__ &G.crec.last_mod_dos_datetime, &(z_utime.mtime), d_t_buf);
    2f68:	e8 33 d7 ff ff       	call   6a0 <_zi_time.isra.0>
        Info(slide, 0, ((char *)slide, LoadFarString(UT_FileModDate),
    2f6d:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    2f71:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2f77:	c7 44 24 0c 1c 15 00 	movl   $0x151c,0xc(%esp)
    2f7e:	00 
    2f7f:	89 74 24 08          	mov    %esi,0x8(%esp)
    2f83:	c7 44 24 04 40 15 00 	movl   $0x1540,0x4(%esp)
    2f8a:	00 
    2f8b:	89 3c 24             	mov    %edi,(%esp)
    2f8e:	e8 00 00 00 00       	call   2f93 <_zipinfo+0x1dd3>
    2f93:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    2f9a:	00 
    2f9b:	89 44 24 08          	mov    %eax,0x8(%esp)
    2f9f:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2fa3:	89 2c 24             	mov    %ebp,(%esp)
    2fa6:	ff d3                	call   *%ebx
    2fa8:	83 ec 10             	sub    $0x10,%esp
    2fab:	e9 dd e8 ff ff       	jmp    188d <_zipinfo+0x6cd>
    zfstrcpy(methbuf, method[methnum]);
    if (methnum == IMPLODED) {
        methbuf[1] = (char)((G.crec.general_purpose_bit_flag & 2)? '8' : '4');
        methbuf[3] = (char)((G.crec.general_purpose_bit_flag & 4)? '3' : '2');
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
        ush  dnum=(ush)((G.crec.general_purpose_bit_flag>>1) & 3);
    2fb0:	8b 85 40 09 01 00    	mov    0x10940(%ebp),%eax
    2fb6:	66 d1 e8             	shr    %ax
        methbuf[3] = dtype[dnum];
    2fb9:	83 e0 03             	and    $0x3,%eax
    2fbc:	8a 80 80 05 00 00    	mov    0x580(%eax),%al
    2fc2:	88 84 24 9f 00 00 00 	mov    %al,0x9f(%esp)
    2fc9:	e9 00 ee ff ff       	jmp    1dce <_zipinfo+0xc0e>
    if ((xattr = (unsigned)((G.crec.external_file_attributes & 0xC000) >> 12))
        & 8)
    {
        if (hostnum == UNIX_ || hostnum == FS_HPFS_ || hostnum == FS_NTFS_)
        {
            Info(slide, 0, ((char *)slide, LoadFarString(lExtraFieldType),
    2fce:	b9 40 06 00 00       	mov    $0x640,%ecx
    2fd3:	ba 80 06 00 00       	mov    $0x680,%edx
    2fd8:	a8 04                	test   $0x4,%al
    2fda:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    2fde:	0f 44 d1             	cmove  %ecx,%edx
    2fe1:	83 e0 0c             	and    $0xc,%eax
    2fe4:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    2fea:	89 54 24 18          	mov    %edx,0x18(%esp)
    2fee:	89 44 24 14          	mov    %eax,0x14(%esp)
    2ff2:	c7 44 24 10 88 0e 00 	movl   $0xe88,0x10(%esp)
    2ff9:	00 
    2ffa:	c7 44 24 0c 55 58 00 	movl   $0x5855,0xc(%esp)
    3001:	00 
    3002:	c7 44 24 08 23 00 00 	movl   $0x23,0x8(%esp)
    3009:	00 
    300a:	c7 44 24 04 c0 06 00 	movl   $0x6c0,0x4(%esp)
    3011:	00 
    3012:	89 3c 24             	mov    %edi,(%esp)
    3015:	89 c6                	mov    %eax,%esi
    3017:	e8 00 00 00 00       	call   301c <_zipinfo+0x1e5c>
    301c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3023:	00 
    3024:	89 44 24 08          	mov    %eax,0x8(%esp)
    3028:	89 7c 24 04          	mov    %edi,0x4(%esp)
    302c:	89 2c 24             	mov    %ebp,(%esp)
    302f:	ff d3                	call   *%ebx
    3031:	83 ec 10             	sub    $0x10,%esp
              "is", EF_IZUNIX, LoadFarStringSmall(efIZUnix),
              (unsigned)(xattr&12), (xattr&4)? efIZuid : efIZnouid));
            if (*pEndprev > 0L)
                *pEndprev += (ulg)(xattr&12);
    3034:	8b 4c 24 64          	mov    0x64(%esp),%ecx
    3038:	89 c8                	mov    %ecx,%eax
    303a:	01 f0                	add    %esi,%eax
    303c:	85 c9                	test   %ecx,%ecx
    303e:	0f 44 c1             	cmove  %ecx,%eax
    3041:	89 44 24 64          	mov    %eax,0x64(%esp)
    3045:	e9 66 f8 ff ff       	jmp    28b0 <_zipinfo+0x16f0>
        ZCONST char Far *ef_fieldname;

        if (error_in_archive > PK_WARN)   /* fatal:  can't continue */
            /* delayed "fatal error" return from extra field reading */
            return error;
        if (G.extra_field == (uch *)NULL)
    304a:	85 c0                	test   %eax,%eax
    304c:	0f 84 34 06 00 00    	je     3686 <_zipinfo+0x24c6>
            return PK_ERR;   /* not consistent with crec length */

        Info(slide, 0, ((char *)slide, LoadFarString(ExtraFields)));
    3052:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
    3059:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    305f:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    3063:	be d8 02 00 00       	mov    $0x2d8,%esi
    3068:	b8 2f 00 00 00       	mov    $0x2f,%eax
    306d:	85 c9                	test   %ecx,%ecx
    306f:	0f 85 21 1f 00 00    	jne    4f96 <_zipinfo+0x3dd6>
    3075:	f7 c7 02 00 00 00    	test   $0x2,%edi
    307b:	0f 85 00 1f 00 00    	jne    4f81 <_zipinfo+0x3dc1>
    3081:	89 c1                	mov    %eax,%ecx
    3083:	c1 e9 02             	shr    $0x2,%ecx
    3086:	a8 02                	test   $0x2,%al
    3088:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    308a:	74 0b                	je     3097 <_zipinfo+0x1ed7>
    308c:	66 8b 0e             	mov    (%esi),%cx
    308f:	66 89 0f             	mov    %cx,(%edi)
    3092:	b9 02 00 00 00       	mov    $0x2,%ecx
    3097:	a8 01                	test   $0x1,%al
    3099:	74 06                	je     30a1 <_zipinfo+0x1ee1>
    309b:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    309e:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    30a1:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    30a5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    30ac:	00 
    30ad:	c7 44 24 08 2e 00 00 	movl   $0x2e,0x8(%esp)
    30b4:	00 
    30b5:	89 44 24 04          	mov    %eax,0x4(%esp)
    30b9:	89 2c 24             	mov    %ebp,(%esp)
    30bc:	ff d2                	call   *%edx
    30be:	83 ec 10             	sub    $0x10,%esp

        while (ef_len >= EB_HEADSIZE) {
    30c1:	66 83 7c 24 60 03    	cmpw   $0x3,0x60(%esp)
    30c7:	0f 86 81 f7 ff ff    	jbe    284e <_zipinfo+0x168e>
    30cd:	8d 76 00             	lea    0x0(%esi),%esi
            eb_id = makeword(&ef_ptr[EB_ID]);
    30d0:	8b 7c 24 68          	mov    0x68(%esp),%edi
    30d4:	89 3c 24             	mov    %edi,(%esp)
    30d7:	e8 00 00 00 00       	call   30dc <_zipinfo+0x1f1c>
    30dc:	89 c6                	mov    %eax,%esi
            eb_datalen = makeword(&ef_ptr[EB_LEN]);
    30de:	89 f8                	mov    %edi,%eax
    30e0:	83 c0 02             	add    $0x2,%eax
    30e3:	89 04 24             	mov    %eax,(%esp)
    30e6:	e8 00 00 00 00       	call   30eb <_zipinfo+0x1f2b>
            ef_ptr += EB_HEADSIZE;
            ef_len -= EB_HEADSIZE;
    30eb:	8b 54 24 60          	mov    0x60(%esp),%edx

        Info(slide, 0, ((char *)slide, LoadFarString(ExtraFields)));

        while (ef_len >= EB_HEADSIZE) {
            eb_id = makeword(&ef_ptr[EB_ID]);
            eb_datalen = makeword(&ef_ptr[EB_LEN]);
    30ef:	89 c1                	mov    %eax,%ecx
    30f1:	66 89 44 24 6c       	mov    %ax,0x6c(%esp)
            ef_ptr += EB_HEADSIZE;
    30f6:	89 f8                	mov    %edi,%eax
            ef_len -= EB_HEADSIZE;
    30f8:	83 ea 04             	sub    $0x4,%edx
        Info(slide, 0, ((char *)slide, LoadFarString(ExtraFields)));

        while (ef_len >= EB_HEADSIZE) {
            eb_id = makeword(&ef_ptr[EB_ID]);
            eb_datalen = makeword(&ef_ptr[EB_LEN]);
            ef_ptr += EB_HEADSIZE;
    30fb:	83 c0 04             	add    $0x4,%eax
            ef_len -= EB_HEADSIZE;

            if (eb_datalen > (ush)ef_len) {
    30fe:	66 39 d1             	cmp    %dx,%cx
        Info(slide, 0, ((char *)slide, LoadFarString(ExtraFields)));

        while (ef_len >= EB_HEADSIZE) {
            eb_id = makeword(&ef_ptr[EB_ID]);
            eb_datalen = makeword(&ef_ptr[EB_LEN]);
            ef_ptr += EB_HEADSIZE;
    3101:	89 44 24 78          	mov    %eax,0x78(%esp)
            ef_len -= EB_HEADSIZE;

            if (eb_datalen > (ush)ef_len) {
    3105:	89 c8                	mov    %ecx,%eax
    3107:	0f 87 cb 09 00 00    	ja     3ad8 <_zipinfo+0x2918>
    310d:	31 ff                	xor    %edi,%edi
    310f:	31 c9                	xor    %ecx,%ecx
    3111:	29 c2                	sub    %eax,%edx
    3113:	66 89 f7             	mov    %si,%di
    3116:	66 89 c1             	mov    %ax,%cx
    3119:	66 89 54 24 60       	mov    %dx,0x60(%esp)
                Info(slide, 0x421, ((char *)slide,
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    311e:	66 81 fe 04 47       	cmp    $0x4704,%si
    3123:	0f 84 f1 10 00 00    	je     421a <_zipinfo+0x305a>
    3129:	0f 87 41 09 00 00    	ja     3a70 <_zipinfo+0x28b0>
    312f:	66 81 fe c8 07       	cmp    $0x7c8,%si
    3134:	0f 84 1e 16 00 00    	je     4758 <_zipinfo+0x3598>
    313a:	0f 87 14 0a 00 00    	ja     3b54 <_zipinfo+0x2994>
    3140:	66 83 fe 09          	cmp    $0x9,%si
    3144:	0f 84 da 10 00 00    	je     4224 <_zipinfo+0x3064>
    314a:	0f 86 06 0b 00 00    	jbe    3c56 <_zipinfo+0x2a96>
    3150:	66 83 fe 0c          	cmp    $0xc,%si
    3154:	0f 84 f0 0e 00 00    	je     404a <_zipinfo+0x2e8a>
    315a:	66 83 fe 0d          	cmp    $0xd,%si
    315e:	0f 84 dc 0e 00 00    	je     4040 <_zipinfo+0x2e80>
    3164:	66 83 fe 0a          	cmp    $0xa,%si
    3168:	0f 84 cd 07 00 00    	je     393b <_zipinfo+0x277b>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    316e:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    3174:	89 7c 24 08          	mov    %edi,0x8(%esp)
    3178:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    317c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    3180:	c7 44 24 0c 64 0d 00 	movl   $0xd64,0xc(%esp)
    3187:	00 
    3188:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    318f:	00 
    3190:	89 3c 24             	mov    %edi,(%esp)
    3193:	89 c3                	mov    %eax,%ebx
    3195:	e8 00 00 00 00       	call   319a <_zipinfo+0x1fda>
    319a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    31a1:	00 
    31a2:	89 44 24 08          	mov    %eax,0x8(%esp)
    31a6:	89 7c 24 04          	mov    %edi,0x4(%esp)
    31aa:	89 2c 24             	mov    %ebp,(%esp)
    31ad:	89 d8                	mov    %ebx,%eax
    31af:	ff d0                	call   *%eax
    31b1:	83 ec 10             	sub    $0x10,%esp
                 eb_id, LoadFarStringSmall(ef_fieldname), eb_datalen));

            /* additional, field-specific information: */
            switch (eb_id) {
    31b4:	66 81 fe 46 4b       	cmp    $0x4b46,%si
    31b9:	0f 84 1a 0b 00 00    	je     3cd9 <_zipinfo+0x2b19>
    31bf:	0f 87 30 19 00 00    	ja     4af5 <_zipinfo+0x3935>
    31c5:	66 81 fe 05 27       	cmp    $0x2705,%si
    31ca:	0f 84 19 0c 00 00    	je     3de9 <_zipinfo+0x2c29>
    31d0:	0f 86 dc 1d 00 00    	jbe    4fb2 <_zipinfo+0x3df2>
    31d6:	66 81 fe 54 41       	cmp    $0x4154,%si
    31db:	0f 84 e7 09 00 00    	je     3bc8 <_zipinfo+0x2a08>
    31e1:	66 81 fe 53 44       	cmp    $0x4453,%si
    31e6:	0f 84 34 11 00 00    	je     4320 <_zipinfo+0x3160>
    31ec:	66 81 fe 4d 33       	cmp    $0x334d,%si
    31f1:	0f 85 87 07 00 00    	jne    397e <_zipinfo+0x27be>
    31f7:	e9 5a 14 00 00       	jmp    4656 <_zipinfo+0x3496>
    31fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (uO.lflag >= 10)
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

    return error_in_archive;

} /* end function zipinfo() */
    3200:	81 c4 2c 01 00 00    	add    $0x12c,%esp
    endprev = (G.crec.relative_offset_local_header == 4L)? 4L : 0L;


    for (j = 1L;; j++) {
        if (readbuf(__G__ G.sig, 4) == 0)
            return PK_EOF;
    3206:	bb 33 00 00 00       	mov    $0x33,%ebx
    if (uO.lflag >= 10)
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

    return error_in_archive;

} /* end function zipinfo() */
    320b:	89 d8                	mov    %ebx,%eax
    320d:	5b                   	pop    %ebx
    320e:	5e                   	pop    %esi
    320f:	5f                   	pop    %edi
    3210:	5d                   	pop    %ebp
    3211:	c3                   	ret    

    for (j = 1L;; j++) {
        if (readbuf(__G__ G.sig, 4) == 0)
            return PK_EOF;
        if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a CentDir entry? */
            if (((unsigned)(j - 1) & (unsigned)0xFFFF) ==
    3212:	8b 4c 24 44          	mov    0x44(%esp),%ecx
    3216:	89 c8                	mov    %ecx,%eax
    3218:	48                   	dec    %eax
    3219:	66 39 85 6e 09 01 00 	cmp    %ax,0x1096e(%ebp)
    3220:	0f 84 82 06 00 00    	je     38a8 <_zipinfo+0x26e8>
                 * number of directory entries -> probably, the regular
                 * end of the central directory has been reached
                 */
                break;
            } else {
                Info(slide, 0x401,
    3226:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    322c:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3232:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    3236:	89 1c 24             	mov    %ebx,(%esp)
    3239:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    3240:	00 
    3241:	e8 00 00 00 00       	call   3246 <_zipinfo+0x2086>
    3246:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    324a:	89 2c 24             	mov    %ebp,(%esp)
    324d:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    3254:	00 
    3255:	89 44 24 08          	mov    %eax,0x8(%esp)
    3259:	ff d6                	call   *%esi
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
    325b:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
                 * number of directory entries -> probably, the regular
                 * end of the central directory has been reached
                 */
                break;
            } else {
                Info(slide, 0x401,
    3261:	83 ec 10             	sub    $0x10,%esp
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
    3264:	89 1c 24             	mov    %ebx,(%esp)
    3267:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    326e:	00 
    326f:	e8 00 00 00 00       	call   3274 <_zipinfo+0x20b4>
    3274:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3278:	89 2c 24             	mov    %ebp,(%esp)
    327b:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    3282:	00 
    3283:	89 44 24 08          	mov    %eax,0x8(%esp)
                     ((char *)slide, LoadFarString(ReportMsg)));
                return PK_BADERR;   /* sig not found */
    3287:	bb 03 00 00 00       	mov    $0x3,%ebx
                 */
                break;
            } else {
                Info(slide, 0x401,
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
    328c:	ff d6                	call   *%esi
    if (uO.lflag >= 10)
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

    return error_in_archive;

} /* end function zipinfo() */
    328e:	89 d8                	mov    %ebx,%eax
                 */
                break;
            } else {
                Info(slide, 0x401,
                     ((char *)slide, LoadFarString(CentSigMsg), j));
                Info(slide, 0x401,
    3290:	83 ec 10             	sub    $0x10,%esp
    if (uO.lflag >= 10)
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

    return error_in_archive;

} /* end function zipinfo() */
    3293:	81 c4 2c 01 00 00    	add    $0x12c,%esp
    3299:	5b                   	pop    %ebx
    329a:	5e                   	pop    %esi
    329b:	5f                   	pop    %edi
    329c:	5d                   	pop    %ebp
    329d:	c3                   	ret    
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommBegin)));
        if ((error = do_string(__G__ G.crec.file_comment_length, DISPL_8)) !=
            PK_COOL)
        {
            error_in_archive = error;   /* might be warning */
            if (error > PK_WARN)   /* fatal */
    329e:	89 44 24 74          	mov    %eax,0x74(%esp)
                return error;
        }
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommEnd)));
    32a2:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
    32a9:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    32af:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    32b3:	be 08 03 00 00       	mov    $0x308,%esi
    32b8:	b8 4c 00 00 00       	mov    $0x4c,%eax
    32bd:	85 c9                	test   %ecx,%ecx
    32bf:	0f 85 fa 19 00 00    	jne    4cbf <_zipinfo+0x3aff>
    32c5:	f7 c7 02 00 00 00    	test   $0x2,%edi
    32cb:	0f 85 0a 1a 00 00    	jne    4cdb <_zipinfo+0x3b1b>
    32d1:	89 c1                	mov    %eax,%ecx
    32d3:	c1 e9 02             	shr    $0x2,%ecx
    32d6:	a8 02                	test   $0x2,%al
    32d8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    32da:	0f 85 d3 03 00 00    	jne    36b3 <_zipinfo+0x24f3>
    32e0:	a8 01                	test   $0x1,%al
    32e2:	0f 85 b0 03 00 00    	jne    3698 <_zipinfo+0x24d8>
    32e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    32ef:	00 
    32f0:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
    32f7:	00 
    32f8:	e9 20 f6 ff ff       	jmp    291d <_zipinfo+0x175d>
                  ((unsigned)!(G.crec.external_file_attributes & 1) << 7) |
                  ((unsigned)(G.crec.external_file_attributes & 0x10) << 2))
               )
            {
                xattr = (unsigned)(G.crec.external_file_attributes & 0xFF);
                sprintf(attribs, ".r.-...     %u.%u", hostver/10, hostver%10);
    32fd:	8b 44 24 54          	mov    0x54(%esp),%eax
    3301:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
    3306:	f7 e2                	mul    %edx
    3308:	c1 ea 03             	shr    $0x3,%edx
    330b:	8b 4c 24 54          	mov    0x54(%esp),%ecx
    330f:	89 54 24 08          	mov    %edx,0x8(%esp)
    3313:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
    331a:	00 
    331b:	8d 04 92             	lea    (%edx,%edx,4),%eax
    331e:	89 3c 24             	mov    %edi,(%esp)
    3321:	01 c0                	add    %eax,%eax
    3323:	89 f3                	mov    %esi,%ebx
    3325:	29 c1                	sub    %eax,%ecx
    3327:	83 e3 10             	and    $0x10,%ebx
    332a:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    332e:	e8 00 00 00 00       	call   3333 <_zipinfo+0x2173>
                attribs[2] = (xattr & 0x01)? '-' : 'w';
    3333:	b0 2d                	mov    $0x2d,%al
    3335:	f7 c6 01 00 00 00    	test   $0x1,%esi
    333b:	0f 84 88 f1 ff ff    	je     24c9 <_zipinfo+0x1309>
    3341:	e9 85 f1 ff ff       	jmp    24cb <_zipinfo+0x130b>
    Read the extra field, if any. It may be used to get UNIX style modtime.
  ---------------------------------------------------------------------------*/

    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)
    {
        if (G.extra_field != NULL) {
    3346:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    334a:	89 44 24 74          	mov    %eax,0x74(%esp)
    334e:	e9 7a e1 ff ff       	jmp    14cd <_zipinfo+0x30d>
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    3353:	89 fa                	mov    %edi,%edx
    3355:	81 e2 00 f0 00 00    	and    $0xf000,%edx
    335b:	81 fa 00 a0 00 00    	cmp    $0xa000,%edx
    3361:	0f 84 c0 17 00 00    	je     4b27 <_zipinfo+0x3967>
    3367:	0f 87 cf 0a 00 00    	ja     3e3c <_zipinfo+0x2c7c>
    336d:	81 fa 00 50 00 00    	cmp    $0x5000,%edx
    3373:	0f 84 80 1a 00 00    	je     4df9 <_zipinfo+0x3c39>
    3379:	0f 86 07 19 00 00    	jbe    4c86 <_zipinfo+0x3ac6>
            case THS_IFLIB:  fpFtyp = TheosFTypLib;  break;
            case THS_IFDIR:  fpFtyp = TheosFTypDir;  break;
            case THS_IFREG:  fpFtyp = TheosFTypReg;  break;
    337f:	b8 54 10 00 00       	mov    $0x1054,%eax
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    3384:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
    338a:	74 11                	je     339d <_zipinfo+0x21dd>
            case THS_IFLIB:  fpFtyp = TheosFTypLib;  break;
            case THS_IFDIR:  fpFtyp = TheosFTypDir;  break;
            case THS_IFREG:  fpFtyp = TheosFTypReg;  break;
            case THS_IFREL:  fpFtyp = TheosFTypRel;  break;
    338c:	b8 44 10 00 00       	mov    $0x1044,%eax
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    3391:	81 fa 00 90 00 00    	cmp    $0x9000,%edx
    3397:	0f 85 d3 0a 00 00    	jne    3e70 <_zipinfo+0x2cb0>
            case THS_IFR16:  fpFtyp = TheosFTypR16;  break;
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
    339d:	8b 10                	mov    (%eax),%edx
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
    339f:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
            case THS_IFR16:  fpFtyp = TheosFTypR16;  break;
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
    33a5:	89 16                	mov    %edx,(%esi)
    33a7:	8b 50 04             	mov    0x4(%eax),%edx
    33aa:	8b 40 08             	mov    0x8(%eax),%eax
    33ad:	89 56 04             	mov    %edx,0x4(%esi)
    33b0:	89 46 08             	mov    %eax,0x8(%esi)
        attribs[12] = (xattr & THS_INHID) ? '.' : 'H';
    33b3:	89 f8                	mov    %edi,%eax
    33b5:	25 00 04 00 00       	and    $0x400,%eax
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
    33ba:	89 74 24 0c          	mov    %esi,0xc(%esp)
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
        attribs[12] = (xattr & THS_INHID) ? '.' : 'H';
    33be:	83 f8 01             	cmp    $0x1,%eax
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
    33c1:	8b 74 24 3c          	mov    0x3c(%esp),%esi
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
        attribs[12] = (xattr & THS_INHID) ? '.' : 'H';
    33c5:	19 c0                	sbb    %eax,%eax
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
    33c7:	89 7c 24 08          	mov    %edi,0x8(%esp)
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
        attribs[12] = (xattr & THS_INHID) ? '.' : 'H';
    33cb:	83 e0 1a             	and    $0x1a,%eax
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
    33ce:	c7 44 24 04 a0 10 00 	movl   $0x10a0,0x4(%esp)
    33d5:	00 
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
        attribs[12] = (xattr & THS_INHID) ? '.' : 'H';
    33d6:	83 c0 2e             	add    $0x2e,%eax
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
    33d9:	89 34 24             	mov    %esi,(%esp)
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
        attribs[12] = (xattr & THS_INHID) ? '.' : 'H';
    33dc:	88 84 24 c6 00 00 00 	mov    %al,0xc6(%esp)
        attribs[13] = (xattr & THS_IMODF) ? '.' : 'M';
    33e3:	89 f8                	mov    %edi,%eax
    33e5:	25 00 08 00 00       	and    $0x800,%eax
        attribs[15] = (xattr & THS_IROTH) ? '.' : 'R';
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
        attribs[20] = 0;
    33ea:	c6 84 24 ce 00 00 00 	movb   $0x0,0xce(%esp)
    33f1:	00 
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
        }
        strcpy(attribs, LoadFarStringSmall(fpFtyp));
        attribs[12] = (xattr & THS_INHID) ? '.' : 'H';
        attribs[13] = (xattr & THS_IMODF) ? '.' : 'M';
    33f2:	83 f8 01             	cmp    $0x1,%eax
    33f5:	19 c0                	sbb    %eax,%eax
    33f7:	83 e0 1f             	and    $0x1f,%eax
    33fa:	83 c0 2e             	add    $0x2e,%eax
    33fd:	88 84 24 c7 00 00 00 	mov    %al,0xc7(%esp)
        attribs[14] = (xattr & THS_IWOTH) ? '.' : 'W';
    3404:	89 f8                	mov    %edi,%eax
    3406:	83 e0 02             	and    $0x2,%eax
    3409:	83 f8 01             	cmp    $0x1,%eax
    340c:	19 c0                	sbb    %eax,%eax
    340e:	83 e0 29             	and    $0x29,%eax
    3411:	83 c0 2e             	add    $0x2e,%eax
    3414:	88 84 24 c8 00 00 00 	mov    %al,0xc8(%esp)
        attribs[15] = (xattr & THS_IROTH) ? '.' : 'R';
    341b:	89 f8                	mov    %edi,%eax
    341d:	83 e0 04             	and    $0x4,%eax
    3420:	83 f8 01             	cmp    $0x1,%eax
    3423:	19 c0                	sbb    %eax,%eax
    3425:	83 e0 24             	and    $0x24,%eax
    3428:	83 c0 2e             	add    $0x2e,%eax
    342b:	88 84 24 c9 00 00 00 	mov    %al,0xc9(%esp)
        attribs[16] = (xattr & THS_IEUSR) ? '.' : 'E';
    3432:	89 f8                	mov    %edi,%eax
    3434:	25 00 02 00 00       	and    $0x200,%eax
    3439:	83 f8 01             	cmp    $0x1,%eax
    343c:	19 c0                	sbb    %eax,%eax
    343e:	83 e0 17             	and    $0x17,%eax
    3441:	83 c0 2e             	add    $0x2e,%eax
    3444:	88 84 24 ca 00 00 00 	mov    %al,0xca(%esp)
        attribs[17] = (xattr & THS_IXUSR) ? '.' : 'X';
    344b:	89 f8                	mov    %edi,%eax
    344d:	83 e0 40             	and    $0x40,%eax
    3450:	83 f8 01             	cmp    $0x1,%eax
    3453:	19 c0                	sbb    %eax,%eax
    3455:	83 e0 2a             	and    $0x2a,%eax
    3458:	83 c0 2e             	add    $0x2e,%eax
    345b:	88 84 24 cb 00 00 00 	mov    %al,0xcb(%esp)
        attribs[18] = (xattr & THS_IWUSR) ? '.' : 'W';
    3462:	89 f8                	mov    %edi,%eax
    3464:	25 80 00 00 00       	and    $0x80,%eax
    3469:	83 f8 01             	cmp    $0x1,%eax
    346c:	19 c0                	sbb    %eax,%eax
    346e:	83 e0 29             	and    $0x29,%eax
    3471:	83 c0 2e             	add    $0x2e,%eax
    3474:	88 84 24 cc 00 00 00 	mov    %al,0xcc(%esp)
        attribs[19] = (xattr & THS_IRUSR) ? '.' : 'R';
    347b:	89 f8                	mov    %edi,%eax
    347d:	25 00 01 00 00       	and    $0x100,%eax
    3482:	83 f8 01             	cmp    $0x1,%eax
    3485:	19 c0                	sbb    %eax,%eax
    3487:	83 e0 24             	and    $0x24,%eax
    348a:	83 c0 2e             	add    $0x2e,%eax
    348d:	88 84 24 cd 00 00 00 	mov    %al,0xcd(%esp)
        attribs[20] = 0;
        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),
    3494:	e8 00 00 00 00       	call   3499 <_zipinfo+0x22d9>
    3499:	e9 47 e6 ff ff       	jmp    1ae5 <_zipinfo+0x925>
          xattr, attribs));
#endif /* OLD_THEOS_EXTRA */

    } else if ((hostnum != FS_FAT_) && (hostnum != FS_HPFS_) &&
               (hostnum != FS_NTFS_) && (hostnum != FS_VFAT_) &&
               (hostnum != ACORN_) &&
    349e:	8a 8c 24 87 00 00 00 	mov    0x87(%esp),%cl
    34a5:	8d 51 f3             	lea    -0xd(%ecx),%edx
               (hostnum != VM_CMS_) && (hostnum != MVS_))
    34a8:	80 fa 02             	cmp    $0x2,%dl
    34ab:	0f 86 13 e6 ff ff    	jbe    1ac4 <_zipinfo+0x904>
    {                                 /* assume Unix-like */
        switch ((unsigned)(xattr & UNX_IFMT)) {
    34b1:	89 f8                	mov    %edi,%eax
    34b3:	25 00 f0 00 00       	and    $0xf000,%eax
    34b8:	3d 00 60 00 00       	cmp    $0x6000,%eax
    34bd:	0f 84 aa 1b 00 00    	je     506d <_zipinfo+0x3ead>
    34c3:	0f 86 2b 15 00 00    	jbe    49f4 <_zipinfo+0x3834>
    34c9:	3d 00 a0 00 00       	cmp    $0xa000,%eax
    34ce:	0f 84 b3 1b 00 00    	je     5087 <_zipinfo+0x3ec7>
    34d4:	3d 00 c0 00 00       	cmp    $0xc000,%eax
    34d9:	0f 84 9b 1b 00 00    	je     507a <_zipinfo+0x3eba>
    34df:	3d 00 80 00 00       	cmp    $0x8000,%eax
    34e4:	0f 84 76 1b 00 00    	je     5060 <_zipinfo+0x3ea0>
            case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
            case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
            case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
            case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;
            case (unsigned)UNX_IFSOCK:  attribs[0] = 's';  break;
            default:          attribs[0] = '?';  break;
    34ea:	c6 84 24 ba 00 00 00 	movb   $0x3f,0xba(%esp)
    34f1:	3f 
        }
        attribs[1] = (xattr & UNX_IRUSR)? 'r' : '-';
    34f2:	89 f8                	mov    %edi,%eax
    34f4:	25 00 01 00 00       	and    $0x100,%eax
    34f9:	83 f8 01             	cmp    $0x1,%eax
    34fc:	19 c0                	sbb    %eax,%eax
    34fe:	83 e0 bb             	and    $0xffffffbb,%eax
    3501:	83 c0 72             	add    $0x72,%eax
    3504:	88 84 24 bb 00 00 00 	mov    %al,0xbb(%esp)
        attribs[4] = (xattr & UNX_IRGRP)? 'r' : '-';
    350b:	89 f8                	mov    %edi,%eax
    350d:	83 e0 20             	and    $0x20,%eax
    3510:	83 f8 01             	cmp    $0x1,%eax
    3513:	19 c0                	sbb    %eax,%eax
    3515:	83 e0 bb             	and    $0xffffffbb,%eax
    3518:	83 c0 72             	add    $0x72,%eax
    351b:	88 84 24 be 00 00 00 	mov    %al,0xbe(%esp)
        attribs[7] = (xattr & UNX_IROTH)? 'r' : '-';
    3522:	89 f8                	mov    %edi,%eax
    3524:	83 e0 04             	and    $0x4,%eax
    3527:	83 f8 01             	cmp    $0x1,%eax
    352a:	19 c0                	sbb    %eax,%eax
    352c:	83 e0 bb             	and    $0xffffffbb,%eax
    352f:	83 c0 72             	add    $0x72,%eax
    3532:	88 84 24 c1 00 00 00 	mov    %al,0xc1(%esp)

        attribs[2] = (xattr & UNX_IWUSR)? 'w' : '-';
    3539:	89 f8                	mov    %edi,%eax
    353b:	25 80 00 00 00       	and    $0x80,%eax
    3540:	83 f8 01             	cmp    $0x1,%eax
    3543:	19 c0                	sbb    %eax,%eax
    3545:	83 e0 b6             	and    $0xffffffb6,%eax
    3548:	83 c0 77             	add    $0x77,%eax
    354b:	88 84 24 bc 00 00 00 	mov    %al,0xbc(%esp)
        attribs[5] = (xattr & UNX_IWGRP)? 'w' : '-';
    3552:	89 f8                	mov    %edi,%eax
    3554:	83 e0 10             	and    $0x10,%eax
    3557:	83 f8 01             	cmp    $0x1,%eax
    355a:	19 c0                	sbb    %eax,%eax
    355c:	83 e0 b6             	and    $0xffffffb6,%eax
    355f:	83 c0 77             	add    $0x77,%eax
    3562:	88 84 24 bf 00 00 00 	mov    %al,0xbf(%esp)
        attribs[8] = (xattr & UNX_IWOTH)? 'w' : '-';
    3569:	89 f8                	mov    %edi,%eax
    356b:	83 e0 02             	and    $0x2,%eax
    356e:	83 f8 01             	cmp    $0x1,%eax
    3571:	19 c0                	sbb    %eax,%eax
    3573:	83 e0 b6             	and    $0xffffffb6,%eax
    3576:	83 c0 77             	add    $0x77,%eax
    3579:	88 84 24 c2 00 00 00 	mov    %al,0xc2(%esp)

        if (xattr & UNX_IXUSR)
            attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
    3580:	89 f8                	mov    %edi,%eax
    3582:	25 00 08 00 00       	and    $0x800,%eax
    3587:	83 f8 01             	cmp    $0x1,%eax
    358a:	19 c0                	sbb    %eax,%eax

        attribs[2] = (xattr & UNX_IWUSR)? 'w' : '-';
        attribs[5] = (xattr & UNX_IWGRP)? 'w' : '-';
        attribs[8] = (xattr & UNX_IWOTH)? 'w' : '-';

        if (xattr & UNX_IXUSR)
    358c:	f7 c7 40 00 00 00    	test   $0x40,%edi
    3592:	0f 84 b5 16 00 00    	je     4c4d <_zipinfo+0x3a8d>
            attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
    3598:	83 e0 05             	and    $0x5,%eax
    359b:	83 c0 73             	add    $0x73,%eax
    359e:	88 84 24 bd 00 00 00 	mov    %al,0xbd(%esp)
        else
            attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';   /* S = undefined */
        if (xattr & UNX_IXGRP)
            attribs[6] = (xattr & UNX_ISGID)? 's' : 'x';   /* == UNX_ENFMT */
    35a5:	89 f8                	mov    %edi,%eax
    35a7:	25 00 04 00 00       	and    $0x400,%eax
    35ac:	83 f8 01             	cmp    $0x1,%eax
    35af:	19 c0                	sbb    %eax,%eax

        if (xattr & UNX_IXUSR)
            attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
        else
            attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';   /* S = undefined */
        if (xattr & UNX_IXGRP)
    35b1:	f7 c7 08 00 00 00    	test   $0x8,%edi
    35b7:	0f 84 7e 16 00 00    	je     4c3b <_zipinfo+0x3a7b>
            attribs[6] = (xattr & UNX_ISGID)? 's' : 'x';   /* == UNX_ENFMT */
    35bd:	83 e0 05             	and    $0x5,%eax
    35c0:	83 c0 73             	add    $0x73,%eax
    35c3:	88 84 24 c0 00 00 00 	mov    %al,0xc0(%esp)
        else
            attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';
        if (xattr & UNX_IXOTH)
            attribs[9] = (xattr & UNX_ISVTX)? 't' : 'x';   /* "sticky bit" */
    35ca:	89 f8                	mov    %edi,%eax
    35cc:	25 00 02 00 00       	and    $0x200,%eax
    35d1:	83 f8 01             	cmp    $0x1,%eax
    35d4:	19 c0                	sbb    %eax,%eax
            attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';   /* S = undefined */
        if (xattr & UNX_IXGRP)
            attribs[6] = (xattr & UNX_ISGID)? 's' : 'x';   /* == UNX_ENFMT */
        else
            attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';
        if (xattr & UNX_IXOTH)
    35d6:	f7 c7 01 00 00 00    	test   $0x1,%edi
    35dc:	0f 84 47 16 00 00    	je     4c29 <_zipinfo+0x3a69>
            attribs[9] = (xattr & UNX_ISVTX)? 't' : 'x';   /* "sticky bit" */
    35e2:	83 e0 04             	and    $0x4,%eax
    35e5:	83 c0 74             	add    $0x74,%eax
    35e8:	88 84 24 c3 00 00 00 	mov    %al,0xc3(%esp)
        else
            attribs[9] = (xattr & UNX_ISVTX)? 'T' : '-';   /* T = undefined */
        attribs[10] = 0;

        Info(slide, 0, ((char *)slide, LoadFarString(UnixFileAttributes), xattr,
    35ef:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    35f5:	89 74 24 0c          	mov    %esi,0xc(%esp)
    35f9:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    35fd:	89 7c 24 08          	mov    %edi,0x8(%esp)
    3601:	c7 44 24 04 20 12 00 	movl   $0x1220,0x4(%esp)
    3608:	00 
    3609:	89 34 24             	mov    %esi,(%esp)
            attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';
        if (xattr & UNX_IXOTH)
            attribs[9] = (xattr & UNX_ISVTX)? 't' : 'x';   /* "sticky bit" */
        else
            attribs[9] = (xattr & UNX_ISVTX)? 'T' : '-';   /* T = undefined */
        attribs[10] = 0;
    360c:	c6 84 24 c4 00 00 00 	movb   $0x0,0xc4(%esp)
    3613:	00 

        Info(slide, 0, ((char *)slide, LoadFarString(UnixFileAttributes), xattr,
    3614:	e8 00 00 00 00       	call   3619 <_zipinfo+0x2459>
    3619:	e9 c7 e4 ff ff       	jmp    1ae5 <_zipinfo+0x925>
                }
                break;
            } /* else: fall through! */

        default:   /* assume Unix-like */
            switch ((unsigned)(xattr & UNX_IFMT)) {
    361e:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
    3624:	0f 84 dd 15 00 00    	je     4c07 <_zipinfo+0x3a47>
    362a:	81 fa 00 40 00 00    	cmp    $0x4000,%edx
    3630:	0f 84 c4 15 00 00    	je     4bfa <_zipinfo+0x3a3a>
    3636:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
    363c:	0f 85 3c ef ff ff    	jne    257e <_zipinfo+0x13be>
                case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
                case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
                case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
                case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
                case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
                case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;
    3642:	c6 84 24 d0 00 00 00 	movb   $0x70,0xd0(%esp)
    3649:	70 
    364a:	e9 37 ef ff ff       	jmp    2586 <_zipinfo+0x13c6>
                if (xattr & VMS_IWOTH) {
                    workspace[9] = 'W';
                    workspace[11] = 'D';
                }
                if (xattr & VMS_IXOTH)
                    workspace[10] = 'E';
    364f:	c6 84 24 c4 00 00 00 	movb   $0x45,0xc4(%esp)
    3656:	45 
    3657:	e9 8d ea ff ff       	jmp    20e9 <_zipinfo+0xf29>
        Info(slide, 0, ((char *)slide, LoadFarString(SlideWindowSizeImplode),
          (G.crec.general_purpose_bit_flag & 2)? '8' : '4'));
        Info(slide, 0, ((char *)slide, LoadFarString(ShannonFanoTrees),
          (G.crec.general_purpose_bit_flag & 4)? '3' : '2'));
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
        ush  dnum=(ush)((G.crec.general_purpose_bit_flag>>1) & 3);
    365c:	8b 85 40 09 01 00    	mov    0x10940(%ebp),%eax

        Info(slide, 0, ((char *)slide, LoadFarString(CompressSubtype),
    3662:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
        Info(slide, 0, ((char *)slide, LoadFarString(SlideWindowSizeImplode),
          (G.crec.general_purpose_bit_flag & 2)? '8' : '4'));
        Info(slide, 0, ((char *)slide, LoadFarString(ShannonFanoTrees),
          (G.crec.general_purpose_bit_flag & 4)? '3' : '2'));
    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {
        ush  dnum=(ush)((G.crec.general_purpose_bit_flag>>1) & 3);
    3668:	66 d1 e8             	shr    %ax

        Info(slide, 0, ((char *)slide, LoadFarString(CompressSubtype),
    366b:	c7 44 24 04 60 16 00 	movl   $0x1660,0x4(%esp)
    3672:	00 
    3673:	83 e0 03             	and    $0x3,%eax
    3676:	8b 04 85 e8 03 00 00 	mov    0x3e8(,%eax,4),%eax
    367d:	89 44 24 08          	mov    %eax,0x8(%esp)
    3681:	e9 22 f4 ff ff       	jmp    2aa8 <_zipinfo+0x18e8>
    if (uO.lflag >= 10)
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

    return error_in_archive;

} /* end function zipinfo() */
    3686:	81 c4 2c 01 00 00    	add    $0x12c,%esp

        if (error_in_archive > PK_WARN)   /* fatal:  can't continue */
            /* delayed "fatal error" return from extra field reading */
            return error;
        if (G.extra_field == (uch *)NULL)
            return PK_ERR;   /* not consistent with crec length */
    368c:	bb 02 00 00 00       	mov    $0x2,%ebx
    if (uO.lflag >= 10)
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);

    return error_in_archive;

} /* end function zipinfo() */
    3691:	89 d8                	mov    %ebx,%eax
    3693:	5b                   	pop    %ebx
    3694:	5e                   	pop    %esi
    3695:	5f                   	pop    %edi
    3696:	5d                   	pop    %ebp
    3697:	c3                   	ret    
        {
            error_in_archive = error;   /* might be warning */
            if (error > PK_WARN)   /* fatal */
                return error;
        }
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommEnd)));
    3698:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    369b:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    369e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    36a5:	00 
    36a6:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
    36ad:	00 
    36ae:	e9 6a f2 ff ff       	jmp    291d <_zipinfo+0x175d>
    36b3:	66 8b 0e             	mov    (%esi),%cx
    36b6:	a8 01                	test   $0x1,%al
    36b8:	66 89 0f             	mov    %cx,(%edi)
    36bb:	b9 02 00 00 00       	mov    $0x2,%ecx
    36c0:	0f 84 22 fc ff ff    	je     32e8 <_zipinfo+0x2128>
    36c6:	eb d0                	jmp    3698 <_zipinfo+0x24d8>
            attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
            sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
            break;

        case THEOS_:
            switch (xattr & THS_IFMT) {
    36c8:	81 fa 00 40 00 00    	cmp    $0x4000,%edx
    36ce:	0f 84 a5 15 00 00    	je     4c79 <_zipinfo+0x3ab9>
    36d4:	0f 86 3a 15 00 00    	jbe    4c14 <_zipinfo+0x3a54>
    36da:	81 fa 00 50 00 00    	cmp    $0x5000,%edx
    36e0:	0f 84 49 13 00 00    	je     4a2f <_zipinfo+0x386f>
    36e6:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
    36ec:	0f 85 6d 15 00 00    	jne    4c5f <_zipinfo+0x3a9f>
                case THS_IFLIB: *attribs = 'L'; break;
                case THS_IFDIR: *attribs = 'D'; break;
                case THS_IFCHR: *attribs = 'C'; break;
                case THS_IFREG: *attribs = 'S'; break;
    36f2:	c6 84 24 d0 00 00 00 	movb   $0x53,0xd0(%esp)
    36f9:	53 
                case THS_IFR16: *attribs = 'P'; break;
                case THS_IFP16: *attribs = '2'; break;
                case THS_IFP32: *attribs = '3'; break;
                default:        *attribs = '?'; break;
            }
            attribs[1] = (xattr & THS_INHID) ? '.' : 'H';
    36fa:	89 c2                	mov    %eax,%edx
    36fc:	81 e2 00 04 00 00    	and    $0x400,%edx
    3702:	83 fa 01             	cmp    $0x1,%edx
    3705:	19 d2                	sbb    %edx,%edx
    3707:	83 e2 1a             	and    $0x1a,%edx
    370a:	83 c2 2e             	add    $0x2e,%edx
    370d:	88 94 24 d1 00 00 00 	mov    %dl,0xd1(%esp)
            attribs[2] = (xattr & THS_IMODF) ? '.' : 'M';
    3714:	89 c2                	mov    %eax,%edx
    3716:	81 e2 00 08 00 00    	and    $0x800,%edx
    371c:	83 fa 01             	cmp    $0x1,%edx
    371f:	19 d2                	sbb    %edx,%edx
    3721:	83 e2 1f             	and    $0x1f,%edx
    3724:	83 c2 2e             	add    $0x2e,%edx
    3727:	88 94 24 d2 00 00 00 	mov    %dl,0xd2(%esp)
            attribs[3] = (xattr & THS_IWOTH) ? '.' : 'W';
    372e:	89 c2                	mov    %eax,%edx
    3730:	83 e2 02             	and    $0x2,%edx
    3733:	83 fa 01             	cmp    $0x1,%edx
    3736:	19 d2                	sbb    %edx,%edx
    3738:	83 e2 29             	and    $0x29,%edx
    373b:	83 c2 2e             	add    $0x2e,%edx
    373e:	88 94 24 d3 00 00 00 	mov    %dl,0xd3(%esp)
            attribs[4] = (xattr & THS_IROTH) ? '.' : 'R';
    3745:	89 c2                	mov    %eax,%edx
    3747:	83 e2 04             	and    $0x4,%edx
    374a:	83 fa 01             	cmp    $0x1,%edx
    374d:	19 d2                	sbb    %edx,%edx
    374f:	83 e2 24             	and    $0x24,%edx
    3752:	83 c2 2e             	add    $0x2e,%edx
    3755:	88 94 24 d4 00 00 00 	mov    %dl,0xd4(%esp)
            attribs[5] = (xattr & THS_IEUSR) ? '.' : 'E';
    375c:	89 c2                	mov    %eax,%edx
    375e:	81 e2 00 02 00 00    	and    $0x200,%edx
    3764:	83 fa 01             	cmp    $0x1,%edx
    3767:	19 d2                	sbb    %edx,%edx
    3769:	83 e2 17             	and    $0x17,%edx
    376c:	83 c2 2e             	add    $0x2e,%edx
    376f:	88 94 24 d5 00 00 00 	mov    %dl,0xd5(%esp)
            attribs[6] = (xattr & THS_IXUSR) ? '.' : 'X';
    3776:	89 c2                	mov    %eax,%edx
    3778:	83 e2 40             	and    $0x40,%edx
    377b:	83 fa 01             	cmp    $0x1,%edx
    377e:	19 d2                	sbb    %edx,%edx
    3780:	83 e2 2a             	and    $0x2a,%edx
    3783:	83 c2 2e             	add    $0x2e,%edx
    3786:	88 94 24 d6 00 00 00 	mov    %dl,0xd6(%esp)
            attribs[7] = (xattr & THS_IWUSR) ? '.' : 'W';
    378d:	89 c2                	mov    %eax,%edx
    378f:	81 e2 80 00 00 00    	and    $0x80,%edx
    3795:	83 fa 01             	cmp    $0x1,%edx
    3798:	19 d2                	sbb    %edx,%edx
            attribs[8] = (xattr & THS_IRUSR) ? '.' : 'R';
    379a:	25 00 01 00 00       	and    $0x100,%eax
            attribs[2] = (xattr & THS_IMODF) ? '.' : 'M';
            attribs[3] = (xattr & THS_IWOTH) ? '.' : 'W';
            attribs[4] = (xattr & THS_IROTH) ? '.' : 'R';
            attribs[5] = (xattr & THS_IEUSR) ? '.' : 'E';
            attribs[6] = (xattr & THS_IXUSR) ? '.' : 'X';
            attribs[7] = (xattr & THS_IWUSR) ? '.' : 'W';
    379f:	83 e2 29             	and    $0x29,%edx
    37a2:	83 c2 2e             	add    $0x2e,%edx
            attribs[8] = (xattr & THS_IRUSR) ? '.' : 'R';
    37a5:	83 f8 01             	cmp    $0x1,%eax
    37a8:	19 c0                	sbb    %eax,%eax
            attribs[2] = (xattr & THS_IMODF) ? '.' : 'M';
            attribs[3] = (xattr & THS_IWOTH) ? '.' : 'W';
            attribs[4] = (xattr & THS_IROTH) ? '.' : 'R';
            attribs[5] = (xattr & THS_IEUSR) ? '.' : 'E';
            attribs[6] = (xattr & THS_IXUSR) ? '.' : 'X';
            attribs[7] = (xattr & THS_IWUSR) ? '.' : 'W';
    37aa:	88 94 24 d7 00 00 00 	mov    %dl,0xd7(%esp)
            attribs[8] = (xattr & THS_IRUSR) ? '.' : 'R';
    37b1:	83 e0 24             	and    $0x24,%eax
    37b4:	83 c0 2e             	add    $0x2e,%eax
    37b7:	88 84 24 d8 00 00 00 	mov    %al,0xd8(%esp)
    37be:	e9 5e ec ff ff       	jmp    2421 <_zipinfo+0x1261>
                attribs[2] = (xattr & 0x01)? '-' : 'w';
                attribs[5] = (xattr & 0x02)? 'h' : '-';
                attribs[6] = (xattr & 0x04)? 's' : '-';
                attribs[4] = (xattr & 0x20)? 'a' : '-';
                if (xattr & 0x10) {
                    attribs[0] = 'd';
    37c3:	c6 84 24 d0 00 00 00 	movb   $0x64,0xd0(%esp)
    37ca:	64 
                    attribs[3] = 'x';
    37cb:	c6 84 24 d3 00 00 00 	movb   $0x78,0xd3(%esp)
    37d2:	78 
    37d3:	e9 4f ed ff ff       	jmp    2527 <_zipinfo+0x1367>
        case ACORN_:
            if (hostnum != FS_FAT_ ||
                (unsigned)(xattr & 0700) !=
                 ((unsigned)0400 |
                  ((unsigned)!(G.crec.external_file_attributes & 1) << 7) |
                  ((unsigned)(G.crec.external_file_attributes & 0x10) << 2))
    37d8:	89 f3                	mov    %esi,%ebx
    37da:	83 e3 10             	and    $0x10,%ebx
    37dd:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
        case MVS_:
        case ACORN_:
            if (hostnum != FS_FAT_ ||
                (unsigned)(xattr & 0700) !=
                 ((unsigned)0400 |
                  ((unsigned)!(G.crec.external_file_attributes & 1) << 7) |
    37e4:	80 ce 01             	or     $0x1,%dh
        case FS_HPFS_:
        case FS_NTFS_:
        case VM_CMS_:
        case MVS_:
        case ACORN_:
            if (hostnum != FS_FAT_ ||
    37e7:	39 d1                	cmp    %edx,%ecx
    37e9:	0f 84 51 ed ff ff    	je     2540 <_zipinfo+0x1380>
                  ((unsigned)!(G.crec.external_file_attributes & 1) << 7) |
                  ((unsigned)(G.crec.external_file_attributes & 0x10) << 2))
               )
            {
                xattr = (unsigned)(G.crec.external_file_attributes & 0xFF);
                sprintf(attribs, ".r.-...     %u.%u", hostver/10, hostver%10);
    37ef:	8b 44 24 54          	mov    0x54(%esp),%eax
    37f3:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
    37f8:	f7 e2                	mul    %edx
    37fa:	c1 ea 03             	shr    $0x3,%edx
    37fd:	8b 4c 24 54          	mov    0x54(%esp),%ecx
    3801:	89 54 24 08          	mov    %edx,0x8(%esp)
    3805:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
    380c:	00 
    380d:	8d 04 92             	lea    (%edx,%edx,4),%eax
    3810:	89 3c 24             	mov    %edi,(%esp)
    3813:	01 c0                	add    %eax,%eax
    3815:	29 c1                	sub    %eax,%ecx
    3817:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    381b:	e8 00 00 00 00       	call   3820 <_zipinfo+0x2660>
                attribs[2] = (xattr & 0x01)? '-' : 'w';
    3820:	b0 2d                	mov    $0x2d,%al
    3822:	e9 a4 ec ff ff       	jmp    24cb <_zipinfo+0x130b>
          attribs));

    } else if (hostnum == AMIGA_) {
        switch (xattr & AMI_IFMT) {
            case AMI_IFDIR:  attribs[0] = 'd';  break;
            case AMI_IFREG:  attribs[0] = '-';  break;
    3827:	c6 84 24 ba 00 00 00 	movb   $0x2d,0xba(%esp)
    382e:	2d 
    382f:	e9 57 f5 ff ff       	jmp    2d8b <_zipinfo+0x1bcb>
            break;

        case AMIGA_:
            switch (xattr & AMI_IFMT) {
                case AMI_IFDIR:  attribs[0] = 'd';  break;
                case AMI_IFREG:  attribs[0] = '-';  break;
    3834:	c6 84 24 d0 00 00 00 	movb   $0x2d,0xd0(%esp)
    383b:	2d 
    383c:	e9 27 eb ff ff       	jmp    2368 <_zipinfo+0x11a8>
              "is", EF_IZUNIX, LoadFarStringSmall(efIZUnix),
              (unsigned)(xattr&12), (xattr&4)? efIZuid : efIZnouid));
            if (*pEndprev > 0L)
                *pEndprev += (ulg)(xattr&12);
        }
        else if (hostnum == FS_FAT_ && !(xattr&4))
    3841:	a8 04                	test   $0x4,%al
    3843:	0f 85 67 f0 ff ff    	jne    28b0 <_zipinfo+0x16f0>
            Info(slide, 0, ((char *)slide, LoadFarString(lExtraFieldType),
    3849:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    384d:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    3853:	c7 44 24 18 40 06 00 	movl   $0x640,0x18(%esp)
    385a:	00 
    385b:	c7 44 24 14 08 00 00 	movl   $0x8,0x14(%esp)
    3862:	00 
    3863:	c7 44 24 10 88 0e 00 	movl   $0xe88,0x10(%esp)
    386a:	00 
    386b:	c7 44 24 0c 55 58 00 	movl   $0x5855,0xc(%esp)
    3872:	00 
    3873:	c7 44 24 08 5d 02 00 	movl   $0x25d,0x8(%esp)
    387a:	00 
    387b:	c7 44 24 04 c0 06 00 	movl   $0x6c0,0x4(%esp)
    3882:	00 
    3883:	89 34 24             	mov    %esi,(%esp)
    3886:	e8 00 00 00 00       	call   388b <_zipinfo+0x26cb>
    388b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3892:	00 
    3893:	89 44 24 08          	mov    %eax,0x8(%esp)
    3897:	89 74 24 04          	mov    %esi,0x4(%esp)
    389b:	89 2c 24             	mov    %ebp,(%esp)
    389e:	ff d3                	call   *%ebx
    38a0:	83 ec 10             	sub    $0x10,%esp
    38a3:	e9 08 f0 ff ff       	jmp    28b0 <_zipinfo+0x16f0>

/*---------------------------------------------------------------------------
    Check that we actually found requested files; if so, print totals.
  ---------------------------------------------------------------------------*/

    if (uO.tflag) {
    38a8:	8b 75 44             	mov    0x44(%ebp),%esi
    38ab:	85 f6                	test   %esi,%esi
    38ad:	0f 85 88 14 00 00    	jne    4d3b <_zipinfo+0x3b7b>
/*---------------------------------------------------------------------------
    Check for unmatched filespecs on command line and print warning if any
    found.
  ---------------------------------------------------------------------------*/

    if (fn_matched) {
    38b3:	8b 9c 24 80 00 00 00 	mov    0x80(%esp),%ebx
    38ba:	85 db                	test   %ebx,%ebx
    38bc:	0f 84 eb 05 00 00    	je     3ead <_zipinfo+0x2ced>
        for (j = 0;  j < G.filespecs;  ++j)
    38c2:	8b 4d 6c             	mov    0x6c(%ebp),%ecx
    38c5:	31 ff                	xor    %edi,%edi
            if (!fn_matched[j])
                Info(slide, 0x401, ((char *)slide,
    38c7:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    38cd:	8b b4 24 80 00 00 00 	mov    0x80(%esp),%esi
    Check for unmatched filespecs on command line and print warning if any
    found.
  ---------------------------------------------------------------------------*/

    if (fn_matched) {
        for (j = 0;  j < G.filespecs;  ++j)
    38d4:	85 c9                	test   %ecx,%ecx
    38d6:	75 12                	jne    38ea <_zipinfo+0x272a>
    38d8:	e9 c1 05 00 00       	jmp    3e9e <_zipinfo+0x2cde>
    38dd:	8d 76 00             	lea    0x0(%esi),%esi
    38e0:	47                   	inc    %edi
    38e1:	39 7d 6c             	cmp    %edi,0x6c(%ebp)
    38e4:	0f 86 b4 05 00 00    	jbe    3e9e <_zipinfo+0x2cde>
            if (!fn_matched[j])
    38ea:	8b 14 be             	mov    (%esi,%edi,4),%edx
    38ed:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
    38f4:	85 d2                	test   %edx,%edx
    38f6:	75 e8                	jne    38e0 <_zipinfo+0x2720>
                Info(slide, 0x401, ((char *)slide,
    38f8:	8b 8d 44 0b 01 00    	mov    0x10b44(%ebp),%ecx
    38fe:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
    3902:	8b 8d c0 00 00 00    	mov    0xc0(%ebp),%ecx
    3908:	8b 04 01             	mov    (%ecx,%eax,1),%eax
    390b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    3912:	00 
    3913:	89 44 24 08          	mov    %eax,0x8(%esp)
    3917:	89 1c 24             	mov    %ebx,(%esp)
    391a:	e8 00 00 00 00       	call   391f <_zipinfo+0x275f>
    391f:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    3926:	00 
    3927:	89 44 24 08          	mov    %eax,0x8(%esp)
    392b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    392f:	89 2c 24             	mov    %ebp,(%esp)
    3932:	ff 54 24 3c          	call   *0x3c(%esp)
    3936:	83 ec 10             	sub    $0x10,%esp
    3939:	eb a5                	jmp    38e0 <_zipinfo+0x2720>
                    break;
                case EF_IZVMS:
                    ef_fieldname = efIZVMS;
                    break;
                case EF_PKW32:
                    ef_fieldname = efPKWin32;
    393b:	b8 c0 0e 00 00       	mov    $0xec0,%eax
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    3940:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3946:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    394a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    394e:	89 7c 24 08          	mov    %edi,0x8(%esp)
    3952:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    3956:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    395d:	00 
    395e:	89 3c 24             	mov    %edi,(%esp)
    3961:	e8 00 00 00 00       	call   3966 <_zipinfo+0x27a6>
    3966:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    396d:	00 
    396e:	89 44 24 08          	mov    %eax,0x8(%esp)
    3972:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3976:	89 2c 24             	mov    %ebp,(%esp)
    3979:	ff d6                	call   *%esi
    397b:	83 ec 10             	sub    $0x10,%esp
                        Info(slide, 0, ((char *)slide, LoadFarString(MD5data),
                          md5));
                        break;
                    }   /* else: fall through !! */
                default:
                    if (eb_datalen > 0) {
    397e:	c7 44 24 7c 00 00 00 	movl   $0x0,0x7c(%esp)
    3985:	00 
    3986:	66 83 7c 24 6c 00    	cmpw   $0x0,0x6c(%esp)
    398c:	0f 84 7e ee ff ff    	je     2810 <_zipinfo+0x1650>
                        ush i, n;

                        if (eb_datalen <= 24) {
    3992:	66 83 7c 24 6c 18    	cmpw   $0x18,0x6c(%esp)
    3998:	0f 86 16 10 00 00    	jbe    49b4 <_zipinfo+0x37f4>
                            Info(slide, 0, ((char *)slide,
                                 LoadFarString(ColonIndent)));
                            n = eb_datalen;
                        } else {
                            Info(slide, 0, ((char *)slide,
    399e:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
    39a5:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    39ab:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    39af:	be 54 03 00 00       	mov    $0x354,%esi
    39b4:	b8 1b 00 00 00       	mov    $0x1b,%eax
    39b9:	85 c9                	test   %ecx,%ecx
    39bb:	0f 85 97 17 00 00    	jne    5158 <_zipinfo+0x3f98>
    39c1:	f7 c7 02 00 00 00    	test   $0x2,%edi
    39c7:	0f 85 6c 17 00 00    	jne    5139 <_zipinfo+0x3f79>
    39cd:	89 c1                	mov    %eax,%ecx
    39cf:	c1 e9 02             	shr    $0x2,%ecx
    39d2:	a8 02                	test   $0x2,%al
    39d4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    39d6:	74 0b                	je     39e3 <_zipinfo+0x2823>
    39d8:	66 8b 0e             	mov    (%esi),%cx
    39db:	66 89 0f             	mov    %cx,(%edi)
    39de:	b9 02 00 00 00       	mov    $0x2,%ecx
    39e3:	a8 01                	test   $0x1,%al
    39e5:	74 06                	je     39ed <_zipinfo+0x282d>
    39e7:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    39ea:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    39ed:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    39f1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    39f8:	00 
    39f9:	c7 44 24 08 1a 00 00 	movl   $0x1a,0x8(%esp)
    3a00:	00 
    3a01:	89 44 24 04          	mov    %eax,0x4(%esp)
    3a05:	89 2c 24             	mov    %ebp,(%esp)
                                 LoadFarString(First20)));
                            n = 20;
    3a08:	bf 14 00 00 00       	mov    $0x14,%edi
                        if (eb_datalen <= 24) {
                            Info(slide, 0, ((char *)slide,
                                 LoadFarString(ColonIndent)));
                            n = eb_datalen;
                        } else {
                            Info(slide, 0, ((char *)slide,
    3a0d:	ff d2                	call   *%edx
    3a0f:	83 ec 10             	sub    $0x10,%esp
                                 LoadFarString(First20)));
                            n = 20;
    3a12:	31 f6                	xor    %esi,%esi
    3a14:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
                        }
                        for (i = 0;  i < n;  ++i)
                            Info(slide, 0, ((char *)slide,
    3a18:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    3a1e:	8b 4c 24 68          	mov    0x68(%esp),%ecx
    3a22:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    3a26:	31 c0                	xor    %eax,%eax
    3a28:	8a 44 31 04          	mov    0x4(%ecx,%esi,1),%al
    3a2c:	c7 44 24 04 10 07 00 	movl   $0x710,0x4(%esp)
    3a33:	00 
    3a34:	89 44 24 08          	mov    %eax,0x8(%esp)
    3a38:	89 1c 24             	mov    %ebx,(%esp)
    3a3b:	e8 00 00 00 00       	call   3a40 <_zipinfo+0x2880>
    3a40:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3a47:	00 
    3a48:	89 44 24 08          	mov    %eax,0x8(%esp)
    3a4c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3a50:	89 2c 24             	mov    %ebp,(%esp)
    3a53:	46                   	inc    %esi
    3a54:	ff 54 24 7c          	call   *0x7c(%esp)
    3a58:	83 ec 10             	sub    $0x10,%esp
                        } else {
                            Info(slide, 0, ((char *)slide,
                                 LoadFarString(First20)));
                            n = 20;
                        }
                        for (i = 0;  i < n;  ++i)
    3a5b:	66 39 f7             	cmp    %si,%di
    3a5e:	77 b8                	ja     3a18 <_zipinfo+0x2858>
    3a60:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    3a64:	e9 6f 01 00 00       	jmp    3bd8 <_zipinfo+0x2a18>
    3a69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                Info(slide, 0x421, ((char *)slide,
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    3a70:	66 81 fe 55 54       	cmp    $0x5455,%si
    3a75:	0f 84 03 09 00 00    	je     437e <_zipinfo+0x31be>
    3a7b:	0f 86 1f ec ff ff    	jbe    26a0 <_zipinfo+0x14e0>
    3a81:	66 81 fe 41 74       	cmp    $0x7441,%si
    3a86:	0f 84 e8 08 00 00    	je     4374 <_zipinfo+0x31b4>
    3a8c:	0f 87 54 01 00 00    	ja     3be6 <_zipinfo+0x2a26>
    3a92:	66 81 fe 42 65       	cmp    $0x6542,%si
    3a97:	0f 84 7f 06 00 00    	je     411c <_zipinfo+0x2f5c>
    3a9d:	66 81 fe 54 68       	cmp    $0x6854,%si
    3aa2:	0f 84 68 07 00 00    	je     4210 <_zipinfo+0x3050>
    3aa8:	66 81 fe 55 58       	cmp    $0x5855,%si
    3aad:	0f 85 bb f6 ff ff    	jne    316e <_zipinfo+0x1fae>
                    break;
                case EF_PKUNIX:
                    ef_fieldname = efPKUnix;
                    break;
                case EF_IZUNIX:
                    ef_fieldname = efIZUnix;
    3ab3:	b8 88 0e 00 00       	mov    $0xe88,%eax
                    if (hostnum == UNIX_ && *pEndprev > 0L)
    3ab8:	83 7c 24 54 03       	cmpl   $0x3,0x54(%esp)
    3abd:	0f 85 7d fe ff ff    	jne    3940 <_zipinfo+0x2780>
                        *pEndprev += 4L;  /* also have UID/GID in local copy */
                    break;
                case EF_IZUNIX2:
                    ef_fieldname = efIZUnix2;
                    if (*pEndprev > 0L)
    3ac3:	8b 74 24 64          	mov    0x64(%esp),%esi
                        *pEndprev += 4L;  /* 4 byte UID/GID in local copy */
    3ac7:	85 f6                	test   %esi,%esi
    3ac9:	8d 56 04             	lea    0x4(%esi),%edx
    3acc:	0f 44 d6             	cmove  %esi,%edx
    3acf:	89 54 24 64          	mov    %edx,0x64(%esp)
    3ad3:	e9 68 fe ff ff       	jmp    3940 <_zipinfo+0x2780>
            eb_datalen = makeword(&ef_ptr[EB_LEN]);
            ef_ptr += EB_HEADSIZE;
            ef_len -= EB_HEADSIZE;

            if (eb_datalen > (ush)ef_len) {
                Info(slide, 0x421, ((char *)slide,
    3ad8:	31 db                	xor    %ebx,%ebx
    3ada:	31 c9                	xor    %ecx,%ecx
    3adc:	66 8b 5c 24 6c       	mov    0x6c(%esp),%bx
    3ae1:	31 ff                	xor    %edi,%edi
    3ae3:	8b 85 44 0b 01 00    	mov    0x10b44(%ebp),%eax
    3ae9:	66 89 d1             	mov    %dx,%cx
    3aec:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
    3af0:	66 89 f7             	mov    %si,%di
    3af3:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
    3af7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    3afb:	89 7c 24 08          	mov    %edi,0x8(%esp)
    3aff:	c7 44 24 04 60 0f 00 	movl   $0xf60,0x4(%esp)
    3b06:	00 
    3b07:	89 1c 24             	mov    %ebx,(%esp)
    3b0a:	89 94 24 8c 00 00 00 	mov    %edx,0x8c(%esp)
    3b11:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
    3b15:	89 44 24 60          	mov    %eax,0x60(%esp)
    3b19:	e8 00 00 00 00       	call   3b1e <_zipinfo+0x295e>
    3b1e:	c7 44 24 0c 21 04 00 	movl   $0x421,0xc(%esp)
    3b25:	00 
    3b26:	89 44 24 08          	mov    %eax,0x8(%esp)
    3b2a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3b2e:	89 2c 24             	mov    %ebp,(%esp)
    3b31:	ff 54 24 60          	call   *0x60(%esp)
    3b35:	83 ec 10             	sub    $0x10,%esp
    3b38:	8b 94 24 8c 00 00 00 	mov    0x8c(%esp),%edx
    3b3f:	66 c7 44 24 60 00 00 	movw   $0x0,0x60(%esp)
    3b46:	66 89 54 24 6c       	mov    %dx,0x6c(%esp)
    3b4b:	8b 4c 24 7c          	mov    0x7c(%esp),%ecx
    3b4f:	e9 ca f5 ff ff       	jmp    311e <_zipinfo+0x1f5e>
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    3b54:	66 81 fe 4d 33       	cmp    $0x334d,%si
    3b59:	0f 84 b5 0a 00 00    	je     4614 <_zipinfo+0x3454>
    3b5f:	0f 86 2c 02 00 00    	jbe    3d91 <_zipinfo+0x2bd1>
    3b65:	66 81 fe 41 43       	cmp    $0x4341,%si
    3b6a:	0f 84 9a 0a 00 00    	je     460a <_zipinfo+0x344a>
    3b70:	66 81 fe 53 44       	cmp    $0x4453,%si
    3b75:	0f 84 63 07 00 00    	je     42de <_zipinfo+0x311e>
    3b7b:	66 81 fe 54 41       	cmp    $0x4154,%si
    3b80:	0f 85 e8 f5 ff ff    	jne    316e <_zipinfo+0x1fae>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    3b86:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3b8c:	89 7c 24 08          	mov    %edi,0x8(%esp)
    3b90:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    3b94:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    3b98:	c7 44 24 0c 74 0d 00 	movl   $0xd74,0xc(%esp)
    3b9f:	00 
    3ba0:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    3ba7:	00 
    3ba8:	89 3c 24             	mov    %edi,(%esp)
    3bab:	e8 00 00 00 00       	call   3bb0 <_zipinfo+0x29f0>
    3bb0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3bb7:	00 
    3bb8:	89 44 24 08          	mov    %eax,0x8(%esp)
    3bbc:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3bc0:	89 2c 24             	mov    %ebp,(%esp)
    3bc3:	ff d6                	call   *%esi
    3bc5:	83 ec 10             	sub    $0x10,%esp
                        Info(slide, 0, ((char *)slide, LoadFarString(AOSVSdata),
                          ((int)(uch)ef_ptr[4])/10, ((int)(uch)ef_ptr[4])%10));
                    }
                    break;
                case EF_TANDEM:
                    if (eb_datalen == 20) {
    3bc8:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    3bcc:	66 83 fe 14          	cmp    $0x14,%si
    3bd0:	89 f0                	mov    %esi,%eax
    3bd2:	0f 84 8e 12 00 00    	je     4e66 <_zipinfo+0x3ca6>
    3bd8:	25 ff ff 00 00       	and    $0xffff,%eax
    3bdd:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    3be1:	e9 2a ec ff ff       	jmp    2810 <_zipinfo+0x1650>
                Info(slide, 0x421, ((char *)slide,
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    3be6:	66 81 fe 55 78       	cmp    $0x7855,%si
    3beb:	0f 84 21 05 00 00    	je     4112 <_zipinfo+0x2f52>
    3bf1:	66 81 fe 4a fb       	cmp    $0xfb4a,%si
    3bf6:	0f 84 58 04 00 00    	je     4054 <_zipinfo+0x2e94>
    3bfc:	66 81 fe 6e 75       	cmp    $0x756e,%si
    3c01:	0f 85 67 f5 ff ff    	jne    316e <_zipinfo+0x1fae>
                    break;
                case EF_MD5:
                    ef_fieldname = efMD5;
                    break;
                case EF_ASIUNIX:
                    ef_fieldname = efASiUnix;
    3c07:	b8 80 0d 00 00       	mov    $0xd80,%eax
    3c0c:	e9 2f fd ff ff       	jmp    3940 <_zipinfo+0x2780>
        if (G.crec.general_purpose_bit_flag & 1)
            csiz -= 12;    /* if encrypted, don't count encryption header */
        Info(slide, 0, ((char *)slide, "%3d%%",
          (ratio(G.crec.ucsize,csiz)+5)/10));
    } else if (uO.lflag == 5)
        Info(slide, 0, ((char *)slide, " %8lu", G.crec.csize));
    3c11:	8b 85 4c 09 01 00    	mov    0x1094c(%ebp),%eax
    3c17:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    3c1d:	89 44 24 08          	mov    %eax,0x8(%esp)
    3c21:	c7 44 24 04 40 02 00 	movl   $0x240,0x4(%esp)
    3c28:	00 
    3c29:	e9 e1 f0 ff ff       	jmp    2d0f <_zipinfo+0x1b4f>

    if ((xattr=(unsigned)(G.crec.external_file_attributes & 0xFF)) == 0)
        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributes),
          xattr));
    else if (xattr == 1)
        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributesRO),
    3c2e:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
    3c34:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    3c3b:	00 
    3c3c:	c7 44 24 04 40 11 00 	movl   $0x1140,0x4(%esp)
    3c43:	00 
    3c44:	e9 74 ed ff ff       	jmp    29bd <_zipinfo+0x17fd>
                            fn_matched[i] = TRUE;
                        break;       /* found match, so stop looping */
                    }
            }
            if (do_this_file) {  /* check if this is an excluded file */
                for (i = 0; i < G.xfilespecs; i++)
    3c49:	c7 44 24 40 01 00 00 	movl   $0x1,0x40(%esp)
    3c50:	00 
    3c51:	e9 68 d7 ff ff       	jmp    13be <_zipinfo+0x1fe>
                Info(slide, 0x421, ((char *)slide,
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    3c56:	66 83 fe 01          	cmp    $0x1,%si
    3c5a:	0f 84 4a 0d 00 00    	je     49aa <_zipinfo+0x37ea>
    3c60:	66 83 fe 07          	cmp    $0x7,%si
    3c64:	0f 85 04 f5 ff ff    	jne    316e <_zipinfo+0x1fae>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    3c6a:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3c70:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    3c74:	c7 44 24 0c e4 0e 00 	movl   $0xee4,0xc(%esp)
    3c7b:	00 
    3c7c:	e9 cd fc ff ff       	jmp    394e <_zipinfo+0x278e>
                Info(slide, 0x421, ((char *)slide,
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    3c81:	66 81 fe 0f 47       	cmp    $0x470f,%si
    3c86:	0f 84 74 09 00 00    	je     4600 <_zipinfo+0x3440>
    3c8c:	66 81 fe 46 4b       	cmp    $0x4b46,%si
    3c91:	0f 85 d7 f4 ff ff    	jne    316e <_zipinfo+0x1fae>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    3c97:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3c9d:	89 7c 24 08          	mov    %edi,0x8(%esp)
    3ca1:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    3ca5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    3ca9:	c7 44 24 0c 8c 0d 00 	movl   $0xd8c,0xc(%esp)
    3cb0:	00 
    3cb1:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    3cb8:	00 
    3cb9:	89 3c 24             	mov    %edi,(%esp)
    3cbc:	e8 00 00 00 00       	call   3cc1 <_zipinfo+0x2b01>
    3cc1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3cc8:	00 
    3cc9:	89 44 24 08          	mov    %eax,0x8(%esp)
    3ccd:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3cd1:	89 2c 24             	mov    %ebp,(%esp)
    3cd4:	ff d6                	call   *%esi
    3cd6:	83 ec 10             	sub    $0x10,%esp
                          LoadFarStringSmall(TandemFileformat[type]),
                          code));
                    }
                    break;
                case EF_MD5:
                    if (eb_datalen >= 19) {
    3cd9:	66 83 7c 24 6c 12    	cmpw   $0x12,0x6c(%esp)
    3cdf:	0f 86 99 fc ff ff    	jbe    397e <_zipinfo+0x27be>
    3ce5:	31 f6                	xor    %esi,%esi
    3ce7:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
    3cee:	89 ac 24 40 01 00 00 	mov    %ebp,0x140(%esp)
    3cf5:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
    3cfc:	89 f5                	mov    %esi,%ebp
    3cfe:	8b 7c 24 68          	mov    0x68(%esp),%edi
    3d02:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    3d06:	89 c3                	mov    %eax,%ebx
    3d08:	89 e8                	mov    %ebp,%eax
    3d0a:	f7 d8                	neg    %eax
                        char md5[33];
                        int i;

                        for (i = 0;  i < 16;  ++i)
                            sprintf(&md5[i<<1], "%02x", ef_ptr[15-i]);
    3d0c:	8a 4c 07 13          	mov    0x13(%edi,%eax,1),%cl
    3d10:	8d 04 6b             	lea    (%ebx,%ebp,2),%eax
    3d13:	81 e1 ff 00 00 00    	and    $0xff,%ecx
    3d19:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
    3d20:	00 
    3d21:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    3d25:	89 04 24             	mov    %eax,(%esp)
                case EF_MD5:
                    if (eb_datalen >= 19) {
                        char md5[33];
                        int i;

                        for (i = 0;  i < 16;  ++i)
    3d28:	45                   	inc    %ebp
                            sprintf(&md5[i<<1], "%02x", ef_ptr[15-i]);
    3d29:	e8 00 00 00 00       	call   3d2e <_zipinfo+0x2b6e>
                case EF_MD5:
                    if (eb_datalen >= 19) {
                        char md5[33];
                        int i;

                        for (i = 0;  i < 16;  ++i)
    3d2e:	83 fd 10             	cmp    $0x10,%ebp
    3d31:	75 d5                	jne    3d08 <_zipinfo+0x2b48>
    3d33:	8b ac 24 40 01 00 00 	mov    0x140(%esp),%ebp
                            sprintf(&md5[i<<1], "%02x", ef_ptr[15-i]);
                        md5[32] = '\0';
                        Info(slide, 0, ((char *)slide, LoadFarString(MD5data),
    3d3a:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    3d3e:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
    3d45:	89 f3                	mov    %esi,%ebx
    3d47:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3d4d:	89 44 24 08          	mov    %eax,0x8(%esp)
    3d51:	c7 44 24 04 20 07 00 	movl   $0x720,0x4(%esp)
    3d58:	00 
    3d59:	89 3c 24             	mov    %edi,(%esp)
                        char md5[33];
                        int i;

                        for (i = 0;  i < 16;  ++i)
                            sprintf(&md5[i<<1], "%02x", ef_ptr[15-i]);
                        md5[32] = '\0';
    3d5c:	c6 84 24 f0 00 00 00 	movb   $0x0,0xf0(%esp)
    3d63:	00 
                        Info(slide, 0, ((char *)slide, LoadFarString(MD5data),
    3d64:	e8 00 00 00 00       	call   3d69 <_zipinfo+0x2ba9>
    3d69:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3d70:	00 
    3d71:	89 44 24 08          	mov    %eax,0x8(%esp)
    3d75:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3d79:	89 2c 24             	mov    %ebp,(%esp)
    3d7c:	ff d6                	call   *%esi
    3d7e:	89 d8                	mov    %ebx,%eax
    3d80:	83 ec 10             	sub    $0x10,%esp
    3d83:	25 ff ff 00 00       	and    $0xffff,%eax
    3d88:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    3d8c:	e9 7f ea ff ff       	jmp    2810 <_zipinfo+0x1650>
                Info(slide, 0x421, ((char *)slide,
                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));
                eb_datalen = ef_len;
            }

            switch (eb_id) {
    3d91:	66 81 fe 05 26       	cmp    $0x2605,%si
    3d96:	0f 84 73 07 00 00    	je     450f <_zipinfo+0x334f>
    3d9c:	66 81 fe 05 27       	cmp    $0x2705,%si
    3da1:	0f 85 c7 f3 ff ff    	jne    316e <_zipinfo+0x1fae>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    3da7:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    3dad:	89 7c 24 08          	mov    %edi,0x8(%esp)
    3db1:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    3db5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    3db9:	c7 44 24 0c fc 0d 00 	movl   $0xdfc,0xc(%esp)
    3dc0:	00 
    3dc1:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    3dc8:	00 
    3dc9:	89 3c 24             	mov    %edi,(%esp)
    3dcc:	e8 00 00 00 00       	call   3dd1 <_zipinfo+0x2c11>
    3dd1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3dd8:	00 
    3dd9:	89 44 24 08          	mov    %eax,0x8(%esp)
    3ddd:	89 7c 24 04          	mov    %edi,0x4(%esp)
    3de1:	89 2c 24             	mov    %ebp,(%esp)
    3de4:	ff d6                	call   *%esi
    3de6:	83 ec 10             	sub    $0x10,%esp
                          (mac3_flgs & EB_M3_FL_TIME64 ? 64 : 32)));
                        zi_showMacTypeCreator(__G__ &ef_ptr[6]);
                    }
                    break;
                case EF_ZIPIT2:
                    if (eb_datalen >= 5 &&
    3de9:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    3ded:	66 83 fe 04          	cmp    $0x4,%si
    3df1:	89 f0                	mov    %esi,%eax
    3df3:	0f 86 df fd ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        makelong(ef_ptr) == 0x5449505A /* "ZPIT" */) {
    3df9:	8b 44 24 78          	mov    0x78(%esp),%eax
    3dfd:	89 04 24             	mov    %eax,(%esp)
    3e00:	e8 00 00 00 00       	call   3e05 <_zipinfo+0x2c45>

                        if (eb_datalen >= 12) {
    3e05:	3d 5a 50 49 54       	cmp    $0x5449505a,%eax
    3e0a:	0f 85 50 fc ff ff    	jne    3a60 <_zipinfo+0x28a0>
    3e10:	66 83 7c 24 6c 0b    	cmpw   $0xb,0x6c(%esp)
    3e16:	0f 86 44 fc ff ff    	jbe    3a60 <_zipinfo+0x28a0>
                            zi_showMacTypeCreator(__G__ &ef_ptr[4]);
    3e1c:	8b 54 24 68          	mov    0x68(%esp),%edx
    3e20:	83 c2 08             	add    $0x8,%edx
    3e23:	89 e8                	mov    %ebp,%eax
    3e25:	e8 d6 c1 ff ff       	call   0 <_zi_showMacTypeCreator>
    3e2a:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    3e2e:	25 ff ff 00 00       	and    $0xffff,%eax
    3e33:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    3e37:	e9 d4 e9 ff ff       	jmp    2810 <_zipinfo+0x1650>
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    3e3c:	81 fa 00 d0 00 00    	cmp    $0xd000,%edx
    3e42:	0f 84 a7 0f 00 00    	je     4def <_zipinfo+0x3c2f>
    3e48:	0f 86 5b 0e 00 00    	jbe    4ca9 <_zipinfo+0x3ae9>
            case THS_IFREG:  fpFtyp = TheosFTypReg;  break;
            case THS_IFREL:  fpFtyp = TheosFTypRel;  break;
            case THS_IFKEY:  fpFtyp = TheosFTypKey;  break;
            case THS_IFIND:  fpFtyp = TheosFTypInd;  break;
            case THS_IFR16:  fpFtyp = TheosFTypR16;  break;
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
    3e4e:	b8 04 10 00 00       	mov    $0x1004,%eax
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    3e53:	81 fa 00 e0 00 00    	cmp    $0xe000,%edx
    3e59:	0f 84 3e f5 ff ff    	je     339d <_zipinfo+0x21dd>
            case THS_IFREL:  fpFtyp = TheosFTypRel;  break;
            case THS_IFKEY:  fpFtyp = TheosFTypKey;  break;
            case THS_IFIND:  fpFtyp = TheosFTypInd;  break;
            case THS_IFR16:  fpFtyp = TheosFTypR16;  break;
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
    3e5f:	b8 f4 0f 00 00       	mov    $0xff4,%eax
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    3e64:	81 fa 00 f0 00 00    	cmp    $0xf000,%edx
    3e6a:	0f 84 2d f5 ff ff    	je     339d <_zipinfo+0x21dd>
            case THS_IFKEY:  fpFtyp = TheosFTypKey;  break;
            case THS_IFIND:  fpFtyp = TheosFTypInd;  break;
            case THS_IFR16:  fpFtyp = TheosFTypR16;  break;
            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;
            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;
            default:         fpFtyp = TheosFTypUkn;  break;
    3e70:	b8 e4 0f 00 00       	mov    $0xfe4,%eax
    3e75:	e9 23 f5 ff ff       	jmp    339d <_zipinfo+0x21dd>
                            *p++ = workspace[k];
                    *p++ = ',';                     /* group separator */
                }
                *--p = ' ';   /* overwrite last comma */
                if ((p - attribs) < 12)
                    sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
    3e7a:	b9 0a 00 00 00       	mov    $0xa,%ecx
    3e7f:	8b 44 24 54          	mov    0x54(%esp),%eax
    3e83:	31 d2                	xor    %edx,%edx
    3e85:	f7 f1                	div    %ecx
    3e87:	89 54 24 0c          	mov    %edx,0xc(%esp)
    3e8b:	8b 44 24 54          	mov    0x54(%esp),%eax
    3e8f:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
    3e94:	f7 e2                	mul    %edx
    3e96:	c1 ea 03             	shr    $0x3,%edx
    3e99:	e9 a0 e5 ff ff       	jmp    243e <_zipinfo+0x127e>
    if (fn_matched) {
        for (j = 0;  j < G.filespecs;  ++j)
            if (!fn_matched[j])
                Info(slide, 0x401, ((char *)slide,
                  LoadFarString(FilenameNotMatched), G.pfnames[j]));
        free((zvoid *)fn_matched);
    3e9e:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    3ea5:	89 04 24             	mov    %eax,(%esp)
    3ea8:	e8 00 00 00 00       	call   3ead <_zipinfo+0x2ced>
    }
    if (xn_matched) {
    3ead:	8b 5c 24 70          	mov    0x70(%esp),%ebx
    3eb1:	85 db                	test   %ebx,%ebx
    3eb3:	74 7e                	je     3f33 <_zipinfo+0x2d73>
        for (j = 0;  j < G.xfilespecs;  ++j)
    3eb5:	8b 4d 70             	mov    0x70(%ebp),%ecx
    3eb8:	31 ff                	xor    %edi,%edi
            if (!xn_matched[j])
                Info(slide, 0x401, ((char *)slide,
    3eba:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    3ec0:	8b 74 24 70          	mov    0x70(%esp),%esi
                Info(slide, 0x401, ((char *)slide,
                  LoadFarString(FilenameNotMatched), G.pfnames[j]));
        free((zvoid *)fn_matched);
    }
    if (xn_matched) {
        for (j = 0;  j < G.xfilespecs;  ++j)
    3ec4:	85 c9                	test   %ecx,%ecx
    3ec6:	75 0e                	jne    3ed6 <_zipinfo+0x2d16>
    3ec8:	eb 5d                	jmp    3f27 <_zipinfo+0x2d67>
    3eca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    3ed0:	47                   	inc    %edi
    3ed1:	39 7d 70             	cmp    %edi,0x70(%ebp)
    3ed4:	76 51                	jbe    3f27 <_zipinfo+0x2d67>
            if (!xn_matched[j])
    3ed6:	8b 14 be             	mov    (%esi,%edi,4),%edx
    3ed9:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
    3ee0:	85 d2                	test   %edx,%edx
    3ee2:	75 ec                	jne    3ed0 <_zipinfo+0x2d10>
                Info(slide, 0x401, ((char *)slide,
    3ee4:	8b 8d 44 0b 01 00    	mov    0x10b44(%ebp),%ecx
    3eea:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
    3eee:	8b 8d c4 00 00 00    	mov    0xc4(%ebp),%ecx
    3ef4:	8b 04 01             	mov    (%ecx,%eax,1),%eax
    3ef7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    3efe:	00 
    3eff:	89 44 24 08          	mov    %eax,0x8(%esp)
    3f03:	89 1c 24             	mov    %ebx,(%esp)
    3f06:	e8 00 00 00 00       	call   3f0b <_zipinfo+0x2d4b>
    3f0b:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    3f12:	00 
    3f13:	89 44 24 08          	mov    %eax,0x8(%esp)
    3f17:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    3f1b:	89 2c 24             	mov    %ebp,(%esp)
    3f1e:	ff 54 24 3c          	call   *0x3c(%esp)
    3f22:	83 ec 10             	sub    $0x10,%esp
    3f25:	eb a9                	jmp    3ed0 <_zipinfo+0x2d10>
                  LoadFarString(ExclFilenameNotMatched), G.pxnames[j]));
        free((zvoid *)xn_matched);
    3f27:	8b 44 24 70          	mov    0x70(%esp),%eax
    3f2b:	89 04 24             	mov    %eax,(%esp)
    3f2e:	e8 00 00 00 00       	call   3f33 <_zipinfo+0x2d73>

/*---------------------------------------------------------------------------
    Double check that we're back at the end-of-central-directory record.
  ---------------------------------------------------------------------------*/

    if (strncmp(G.sig, end_central_sig, 4)) {   /* just to make sure again */
    3f33:	8b 44 24 48          	mov    0x48(%esp),%eax
    3f37:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    3f3e:	00 
    3f3f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    3f46:	00 
    3f47:	89 04 24             	mov    %eax,(%esp)
    3f4a:	e8 00 00 00 00       	call   3f4f <_zipinfo+0x2d8f>
    3f4f:	85 c0                	test   %eax,%eax
    3f51:	0f 85 a3 0d 00 00    	jne    4cfa <_zipinfo+0x3b3a>
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
        error_in_archive = PK_WARN;   /* didn't find sig */
    }
    if (members == 0 && error_in_archive <= PK_WARN)
        error_in_archive = PK_FIND;
    3f57:	8b 44 24 58          	mov    0x58(%esp),%eax
    3f5b:	8b 5c 24 50          	mov    0x50(%esp),%ebx
    3f5f:	85 c0                	test   %eax,%eax
    3f61:	b8 0b 00 00 00       	mov    $0xb,%eax
    3f66:	0f 44 d8             	cmove  %eax,%ebx

    if (uO.lflag >= 10)
    3f69:	83 7d 28 09          	cmpl   $0x9,0x28(%ebp)
    3f6d:	0f 8e 52 e0 ff ff    	jle    1fc5 <_zipinfo+0xe05>
        (*G.message)((zvoid *)&G, (uch *)"\n", 1L, 0);
    3f73:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    3f7a:	00 
    3f7b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    3f82:	00 
    3f83:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
    3f8a:	00 
    3f8b:	89 2c 24             	mov    %ebp,(%esp)
    3f8e:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
    3f94:	83 ec 10             	sub    $0x10,%esp
    3f97:	e9 29 e0 ff ff       	jmp    1fc5 <_zipinfo+0xe05>

#ifdef DLL
            if ((G.statreportcb != NULL) &&
                (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,
                                  G.filename, (zvoid *)&G.crec.ucsize)) {
                if (fn_matched)
    3f9c:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
    3fa3:	85 c0                	test   %eax,%eax
    3fa5:	74 08                	je     3faf <_zipinfo+0x2def>
                    free((zvoid *)fn_matched);
    3fa7:	89 04 24             	mov    %eax,(%esp)
    3faa:	e8 00 00 00 00       	call   3faf <_zipinfo+0x2def>
                if (xn_matched)
    3faf:	8b 44 24 70          	mov    0x70(%esp),%eax
    3fb3:	85 c0                	test   %eax,%eax
    3fb5:	0f 84 35 0d 00 00    	je     4cf0 <_zipinfo+0x3b30>
                    free((zvoid *)xn_matched);
    3fbb:	89 04 24             	mov    %eax,(%esp)
                return IZ_CTRLC;        /* cancel operation by user request */
    3fbe:	bb 50 00 00 00       	mov    $0x50,%ebx
                (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,
                                  G.filename, (zvoid *)&G.crec.ucsize)) {
                if (fn_matched)
                    free((zvoid *)fn_matched);
                if (xn_matched)
                    free((zvoid *)xn_matched);
    3fc3:	e8 00 00 00 00       	call   3fc8 <_zipinfo+0x2e08>
    3fc8:	e9 f8 df ff ff       	jmp    1fc5 <_zipinfo+0xe05>
                    attribs[3] = 'x';
                } else
                    attribs[0] = '-';
                if (IS_VOLID(xattr))
                    attribs[0] = 'V';
                else if ((p = MBSRCHR(G.filename, '.')) != (char *)NULL) {
    3fcd:	8d 85 e0 09 01 00    	lea    0x109e0(%ebp),%eax
    3fd3:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
    3fda:	00 
    3fdb:	89 04 24             	mov    %eax,(%esp)
    3fde:	e8 00 00 00 00       	call   3fe3 <_zipinfo+0x2e23>
    3fe3:	85 c0                	test   %eax,%eax
    3fe5:	0f 84 35 e1 ff ff    	je     2120 <_zipinfo+0xf60>
                    ++p;
    3feb:	8d 58 01             	lea    0x1(%eax),%ebx
                    if (STRNICMP(p, "com", 3) == 0 ||
    3fee:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    3ff5:	00 
    3ff6:	c7 44 24 04 1b 02 00 	movl   $0x21b,0x4(%esp)
    3ffd:	00 
    3ffe:	89 1c 24             	mov    %ebx,(%esp)
    4001:	e8 00 00 00 00       	call   4006 <_zipinfo+0x2e46>
    4006:	85 c0                	test   %eax,%eax
    4008:	0f 85 c9 0f 00 00    	jne    4fd7 <_zipinfo+0x3e17>
                        STRNICMP(p, "exe", 3) == 0 ||
                        STRNICMP(p, "btm", 3) == 0 ||
                        STRNICMP(p, "cmd", 3) == 0 ||
                        STRNICMP(p, "bat", 3) == 0)
                        attribs[3] = 'x';
    400e:	c6 84 24 d3 00 00 00 	movb   $0x78,0xd3(%esp)
    4015:	78 
    4016:	e9 05 e1 ff ff       	jmp    2120 <_zipinfo+0xf60>
            attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
            sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
            break;

        case THEOS_:
            switch (xattr & THS_IFMT) {
    401b:	81 fa 00 e0 00 00    	cmp    $0xe000,%edx
    4021:	0f 84 22 0a 00 00    	je     4a49 <_zipinfo+0x3889>
    4027:	81 fa 00 f0 00 00    	cmp    $0xf000,%edx
    402d:	0f 85 2c 0c 00 00    	jne    4c5f <_zipinfo+0x3a9f>
                case THS_IFREL: *attribs = 'R'; break;
                case THS_IFKEY: *attribs = 'K'; break;
                case THS_IFIND: *attribs = 'I'; break;
                case THS_IFR16: *attribs = 'P'; break;
                case THS_IFP16: *attribs = '2'; break;
                case THS_IFP32: *attribs = '3'; break;
    4033:	c6 84 24 d0 00 00 00 	movb   $0x33,0xd0(%esp)
    403a:	33 
    403b:	e9 ba f6 ff ff       	jmp    36fa <_zipinfo+0x253a>
                    break;
                case EF_PKW32:
                    ef_fieldname = efPKWin32;
                    break;
                case EF_PKUNIX:
                    ef_fieldname = efPKUnix;
    4040:	b8 b4 0e 00 00       	mov    $0xeb4,%eax
    4045:	e9 f6 f8 ff ff       	jmp    3940 <_zipinfo+0x2780>
                    break;
                case EF_NTSD:
                    ef_fieldname = efNTSD;
                    break;
                case EF_PKVMS:
                    ef_fieldname = efPKVMS;
    404a:	b8 d0 0e 00 00       	mov    $0xed0,%eax
    404f:	e9 ec f8 ff ff       	jmp    3940 <_zipinfo+0x2780>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    4054:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    405a:	89 7c 24 08          	mov    %edi,0x8(%esp)
    405e:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4062:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    4066:	c7 44 24 0c b4 0d 00 	movl   $0xdb4,0xc(%esp)
    406d:	00 
    406e:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    4075:	00 
    4076:	89 3c 24             	mov    %edi,(%esp)
    4079:	e8 00 00 00 00       	call   407e <_zipinfo+0x2ebe>
    407e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4085:	00 
    4086:	89 44 24 08          	mov    %eax,0x8(%esp)
    408a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    408e:	89 2c 24             	mov    %ebp,(%esp)
    4091:	ff d6                	call   *%esi
    4093:	83 ec 10             	sub    $0x10,%esp
                            *pEndprev = 0L; /* no clue about csize of local */
                        }
                    }
                    break;
                case EF_QDOS:
                    if (eb_datalen >= 4) {
    4096:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    409a:	66 83 fe 03          	cmp    $0x3,%si
    409e:	89 f0                	mov    %esi,%eax
    40a0:	0f 86 32 fb ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        Info(slide, 0, ((char *)slide, LoadFarString(QDOSdata),
    40a6:	8b 4c 24 68          	mov    0x68(%esp),%ecx
    40aa:	31 c0                	xor    %eax,%eax
    40ac:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    40b2:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    40b6:	8a 41 07             	mov    0x7(%ecx),%al
    40b9:	89 44 24 14          	mov    %eax,0x14(%esp)
    40bd:	31 c0                	xor    %eax,%eax
    40bf:	8a 41 06             	mov    0x6(%ecx),%al
    40c2:	89 44 24 10          	mov    %eax,0x10(%esp)
    40c6:	31 c0                	xor    %eax,%eax
    40c8:	8a 41 05             	mov    0x5(%ecx),%al
    40cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
    40cf:	31 c0                	xor    %eax,%eax
    40d1:	8a 41 04             	mov    0x4(%ecx),%al
    40d4:	c7 44 24 04 60 08 00 	movl   $0x860,0x4(%esp)
    40db:	00 
    40dc:	89 44 24 08          	mov    %eax,0x8(%esp)
    40e0:	89 3c 24             	mov    %edi,(%esp)
    40e3:	e8 00 00 00 00       	call   40e8 <_zipinfo+0x2f28>
                          ef_ptr[0], ef_ptr[1], ef_ptr[2], ef_ptr[3]));
                    }
                    break;
                case EF_AOSVS:
                    if (eb_datalen >= 5) {
                        Info(slide, 0, ((char *)slide, LoadFarString(AOSVSdata),
    40e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    40ef:	00 
    40f0:	89 44 24 08          	mov    %eax,0x8(%esp)
    40f4:	89 7c 24 04          	mov    %edi,0x4(%esp)
    40f8:	89 2c 24             	mov    %ebp,(%esp)
    40fb:	ff d6                	call   *%esi
    40fd:	83 ec 10             	sub    $0x10,%esp
    4100:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    4104:	25 ff ff 00 00       	and    $0xffff,%eax
    4109:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    410d:	e9 fe e6 ff ff       	jmp    2810 <_zipinfo+0x1650>
                    ef_fieldname = efIZUnix;
                    if (hostnum == UNIX_ && *pEndprev > 0L)
                        *pEndprev += 4L;  /* also have UID/GID in local copy */
                    break;
                case EF_IZUNIX2:
                    ef_fieldname = efIZUnix2;
    4112:	b8 78 0e 00 00       	mov    $0xe78,%eax
    4117:	e9 a7 f9 ff ff       	jmp    3ac3 <_zipinfo+0x2903>
                    break;
                case EF_ATHEOS:
                    ef_fieldname = efAtheOS;
                    break;
                case EF_BEOS:
                    ef_fieldname = efBeOS;
    411c:	b8 c0 0d 00 00       	mov    $0xdc0,%eax
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    4121:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    4127:	89 7c 24 08          	mov    %edi,0x8(%esp)
    412b:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    412f:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    4133:	89 44 24 0c          	mov    %eax,0xc(%esp)
    4137:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    413e:	00 
    413f:	89 3c 24             	mov    %edi,(%esp)
    4142:	89 d3                	mov    %edx,%ebx
    4144:	e8 00 00 00 00       	call   4149 <_zipinfo+0x2f89>
    4149:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4150:	00 
    4151:	89 44 24 08          	mov    %eax,0x8(%esp)
    4155:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4159:	89 2c 24             	mov    %ebp,(%esp)
    415c:	ff d3                	call   *%ebx
    415e:	83 ec 10             	sub    $0x10,%esp
                    }
                    break;
#endif /* CMS_MVS */
                case EF_ATHEOS:
                case EF_BEOS:
                    if (eb_datalen >= EB_BEOS_HLEN) {
    4161:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
    4165:	66 83 f9 04          	cmp    $0x4,%cx
    4169:	89 c8                	mov    %ecx,%eax
    416b:	0f 86 67 fa ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        ulg eb_uc = makelong(ef_ptr);
    4171:	8b 44 24 78          	mov    0x78(%esp),%eax
    4175:	89 04 24             	mov    %eax,(%esp)
    4178:	e8 00 00 00 00       	call   417d <_zipinfo+0x2fbd>
                          *(ef_ptr+EB_FLGS_OFFS) & EB_BE_FL_UNCMPR;

                        if (eb_id == EF_ATHEOS)
                            ef_fieldname = AtheOSdata;
                        else
                            ef_fieldname = BeOSdata;
    417d:	b9 a0 08 00 00       	mov    $0x8a0,%ecx
    4182:	66 81 fe 41 74       	cmp    $0x7441,%si
    4187:	ba 00 09 00 00       	mov    $0x900,%edx
    418c:	0f 45 d1             	cmovne %ecx,%edx
                        Info(slide, 0, ((char *)slide,
    418f:	8b 4c 24 68          	mov    0x68(%esp),%ecx
    4193:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    4199:	f6 41 08 01          	testb  $0x1,0x8(%ecx)
    419d:	0f 84 78 0d 00 00    	je     4f1b <_zipinfo+0x3d5b>
    41a3:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    41a7:	c7 44 24 0c 51 02 00 	movl   $0x251,0xc(%esp)
    41ae:	00 
    41af:	89 44 24 08          	mov    %eax,0x8(%esp)
    41b3:	89 54 24 04          	mov    %edx,0x4(%esp)
    41b7:	89 3c 24             	mov    %edi,(%esp)
    41ba:	e8 00 00 00 00       	call   41bf <_zipinfo+0x2fff>
    41bf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    41c6:	00 
    41c7:	89 44 24 08          	mov    %eax,0x8(%esp)
    41cb:	89 7c 24 04          	mov    %edi,0x4(%esp)
    41cf:	89 2c 24             	mov    %ebp,(%esp)
    41d2:	ff d6                	call   *%esi
    41d4:	83 ec 10             	sub    $0x10,%esp
                          LoadFarString(ef_fieldname),
                          eb_uc, eb_is_uc ? "un" : nullStr));
                        if (eb_is_uc) {
                            if (*pEndprev > 0L)
    41d7:	8b 74 24 64          	mov    0x64(%esp),%esi
    41db:	85 f6                	test   %esi,%esi
    41dd:	0f 84 7d f8 ff ff    	je     3a60 <_zipinfo+0x28a0>
                                *pEndprev += makelong(ef_ptr);
    41e3:	8b 44 24 78          	mov    0x78(%esp),%eax
    41e7:	89 04 24             	mov    %eax,(%esp)
    41ea:	e8 00 00 00 00       	call   41ef <_zipinfo+0x302f>
    41ef:	8b 5c 24 64          	mov    0x64(%esp),%ebx
    41f3:	01 c3                	add    %eax,%ebx
    41f5:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    41f9:	25 ff ff 00 00       	and    $0xffff,%eax
    41fe:	89 5c 24 64          	mov    %ebx,0x64(%esp)
    4202:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    4206:	e9 05 e6 ff ff       	jmp    2810 <_zipinfo+0x1650>
    420b:	90                   	nop
    420c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                    break;
                case EF_THEOS:
#ifdef OLD_THEOS_EXTRA
                case EF_THEOSO:
#endif
                    ef_fieldname = efTheos;
    4210:	b8 6c 0d 00 00       	mov    $0xd6c,%eax
    4215:	e9 26 f7 ff ff       	jmp    3940 <_zipinfo+0x2780>
                    break;
                case EF_ZIPIT2:
                    ef_fieldname = efZipIt2;
                    break;
                case EF_VMCMS:
                    ef_fieldname = efVMCMS;
    421a:	b8 f4 0d 00 00       	mov    $0xdf4,%eax
    421f:	e9 1c f7 ff ff       	jmp    3940 <_zipinfo+0x2780>
                    break;
                case EF_AV:
                    ef_fieldname = efAV;
                    break;
                case EF_OS2:
                    ef_fieldname = efOS2;
    4224:	b8 dc 0e 00 00       	mov    $0xedc,%eax
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    4229:	8b 95 44 0b 01 00    	mov    0x10b44(%ebp),%edx
    422f:	89 7c 24 08          	mov    %edi,0x8(%esp)
    4233:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4237:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    423b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    423f:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    4246:	00 
    4247:	89 3c 24             	mov    %edi,(%esp)
    424a:	89 d3                	mov    %edx,%ebx
    424c:	e8 00 00 00 00       	call   4251 <_zipinfo+0x3091>
    4251:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4258:	00 
    4259:	89 44 24 08          	mov    %eax,0x8(%esp)
    425d:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4261:	89 2c 24             	mov    %ebp,(%esp)
    4264:	ff d3                	call   *%ebx
    4266:	83 ec 10             	sub    $0x10,%esp

            /* additional, field-specific information: */
            switch (eb_id) {
                case EF_OS2:
                case EF_ACL:
                    if (eb_datalen >= EB_OS2_HLEN) {
    4269:	66 83 7c 24 6c 03    	cmpw   $0x3,0x6c(%esp)
    426f:	0f 86 eb f7 ff ff    	jbe    3a60 <_zipinfo+0x28a0>
                        if (eb_id == EF_OS2)
                            ef_fieldname = OS2EAs;
                        else
                            ef_fieldname = ACLdata;
    4275:	66 83 fe 09          	cmp    $0x9,%si
    4279:	b8 e0 0c 00 00       	mov    $0xce0,%eax
    427e:	be e0 0b 00 00       	mov    $0xbe0,%esi
                        Info(slide, 0, ((char *)slide,
    4283:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
                case EF_ACL:
                    if (eb_datalen >= EB_OS2_HLEN) {
                        if (eb_id == EF_OS2)
                            ef_fieldname = OS2EAs;
                        else
                            ef_fieldname = ACLdata;
    4289:	0f 44 f0             	cmove  %eax,%esi
                        Info(slide, 0, ((char *)slide,
    428c:	8b 44 24 78          	mov    0x78(%esp),%eax
    4290:	89 04 24             	mov    %eax,(%esp)
    4293:	e8 00 00 00 00       	call   4298 <_zipinfo+0x30d8>
    4298:	89 74 24 04          	mov    %esi,0x4(%esp)
    429c:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    42a0:	89 44 24 08          	mov    %eax,0x8(%esp)
    42a4:	89 34 24             	mov    %esi,(%esp)
    42a7:	e8 00 00 00 00       	call   42ac <_zipinfo+0x30ec>
    42ac:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    42b3:	00 
    42b4:	89 44 24 08          	mov    %eax,0x8(%esp)
    42b8:	89 74 24 04          	mov    %esi,0x4(%esp)
    42bc:	89 2c 24             	mov    %ebp,(%esp)
    42bf:	ff d7                	call   *%edi

                        if (eb_id == EF_ATHEOS)
                            ef_fieldname = AtheOSdata;
                        else
                            ef_fieldname = BeOSdata;
                        Info(slide, 0, ((char *)slide,
    42c1:	83 ec 10             	sub    $0x10,%esp
    42c4:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    42c8:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
    42cf:	00 
    42d0:	25 ff ff 00 00       	and    $0xffff,%eax
    42d5:	89 44 24 7c          	mov    %eax,0x7c(%esp)
    42d9:	e9 32 e5 ff ff       	jmp    2810 <_zipinfo+0x1650>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    42de:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    42e4:	89 7c 24 08          	mov    %edi,0x8(%esp)
    42e8:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    42ec:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    42f0:	c7 44 24 0c d0 0d 00 	movl   $0xdd0,0xc(%esp)
    42f7:	00 
    42f8:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    42ff:	00 
    4300:	89 3c 24             	mov    %edi,(%esp)
    4303:	e8 00 00 00 00       	call   4308 <_zipinfo+0x3148>
    4308:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    430f:	00 
    4310:	89 44 24 08          	mov    %eax,0x8(%esp)
    4314:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4318:	89 2c 24             	mov    %ebp,(%esp)
    431b:	ff d6                	call   *%esi
    431d:	83 ec 10             	sub    $0x10,%esp
                          LoadFarString(ef_fieldname), makelong(ef_ptr)));
                        *pEndprev = 0L;   /* no clue about csize of local */
                    }
                    break;
                case EF_NTSD:
                    if (eb_datalen >= EB_NTSD_C_LEN) {
    4320:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    4324:	66 83 fe 03          	cmp    $0x3,%si
    4328:	89 f0                	mov    %esi,%eax
    432a:	0f 86 a8 f8 ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        Info(slide, 0, ((char *)slide, LoadFarString(NTSDData),
    4330:	8b 44 24 78          	mov    0x78(%esp),%eax
    4334:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    433a:	89 04 24             	mov    %eax,(%esp)
    433d:	e8 00 00 00 00       	call   4342 <_zipinfo+0x3182>
    4342:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4346:	89 44 24 08          	mov    %eax,0x8(%esp)
    434a:	c7 44 24 04 80 0b 00 	movl   $0xb80,0x4(%esp)
    4351:	00 
    4352:	89 3c 24             	mov    %edi,(%esp)
    4355:	e8 00 00 00 00       	call   435a <_zipinfo+0x319a>

                        if (eb_id == EF_ATHEOS)
                            ef_fieldname = AtheOSdata;
                        else
                            ef_fieldname = BeOSdata;
                        Info(slide, 0, ((char *)slide,
    435a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    435e:	89 2c 24             	mov    %ebp,(%esp)
    4361:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4368:	00 
    4369:	89 44 24 08          	mov    %eax,0x8(%esp)
    436d:	ff d6                	call   *%esi
    436f:	e9 4d ff ff ff       	jmp    42c1 <_zipinfo+0x3101>
                    break;
                case EF_MVS:
                    ef_fieldname = efMVS;
                    break;
                case EF_ATHEOS:
                    ef_fieldname = efAtheOS;
    4374:	b8 c8 0d 00 00       	mov    $0xdc8,%eax
    4379:	e9 a3 fd ff ff       	jmp    4121 <_zipinfo+0x2f61>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    437e:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    4384:	89 7c 24 08          	mov    %edi,0x8(%esp)
    4388:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    438c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    4390:	c7 44 24 0c 68 0e 00 	movl   $0xe68,0xc(%esp)
    4397:	00 
    4398:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    439f:	00 
    43a0:	89 3c 24             	mov    %edi,(%esp)
    43a3:	e8 00 00 00 00       	call   43a8 <_zipinfo+0x31e8>
    43a8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    43af:	00 
    43b0:	89 44 24 08          	mov    %eax,0x8(%esp)
    43b4:	89 7c 24 04          	mov    %edi,0x4(%esp)
    43b8:	89 2c 24             	mov    %ebp,(%esp)
    43bb:	ff d6                	call   *%esi
    43bd:	83 ec 10             	sub    $0x10,%esp
                          LoadFarStringSmall(izVMScomp[compr]),
                          makeword(ef_ptr+EB_IZVMS_UCSIZ), p, q));
                    }
                    break;
                case EF_TIME:
                    if (eb_datalen >= 1) {
    43c0:	c7 44 24 7c 00 00 00 	movl   $0x0,0x7c(%esp)
    43c7:	00 
    43c8:	66 83 7c 24 6c 00    	cmpw   $0x0,0x6c(%esp)
    43ce:	0f 84 3c e4 ff ff    	je     2810 <_zipinfo+0x1650>
                        char types[80];
                        int num = 0, len;

                        *types = '\0';
                        if (*ef_ptr & 1) {
    43d4:	8b 44 24 68          	mov    0x68(%esp),%eax
                case EF_TIME:
                    if (eb_datalen >= 1) {
                        char types[80];
                        int num = 0, len;

                        *types = '\0';
    43d8:	c6 84 24 d0 00 00 00 	movb   $0x0,0xd0(%esp)
    43df:	00 
                        if (*ef_ptr & 1) {
    43e0:	8a 40 04             	mov    0x4(%eax),%al
    43e3:	a8 01                	test   $0x1,%al
    43e5:	0f 85 6b 06 00 00    	jne    4a56 <_zipinfo+0x3896>
                            strcpy(types, LoadFarString(UTmodification));
                            ++num;
                        }
                        if (*ef_ptr & 2) {
    43eb:	a8 02                	test   $0x2,%al
    43ed:	0f 84 08 0b 00 00    	je     4efb <_zipinfo+0x3d3b>
    43f3:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
    43fa:	b9 01 00 00 00       	mov    $0x1,%ecx
    43ff:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
                            if (num)
                                types[len++] = '/';
                            strcpy(types+len, LoadFarString(UTaccess));
                            ++num;
                            if (*pEndprev > 0L)
                                *pEndprev += 4L;
    4406:	8b 74 24 64          	mov    0x64(%esp),%esi
                        }
                        if (*ef_ptr & 2) {
                            len = strlen(types);
                            if (num)
                                types[len++] = '/';
                            strcpy(types+len, LoadFarString(UTaccess));
    440a:	66 c7 40 04 73 73    	movw   $0x7373,0x4(%eax)
    4410:	c7 00 61 63 63 65    	movl   $0x65636361,(%eax)
    4416:	c6 40 06 00          	movb   $0x0,0x6(%eax)
                            ++num;
                            if (*pEndprev > 0L)
                                *pEndprev += 4L;
    441a:	89 f0                	mov    %esi,%eax
    441c:	83 c0 04             	add    $0x4,%eax
    441f:	85 f6                	test   %esi,%esi
    4421:	0f 44 c6             	cmove  %esi,%eax
    4424:	89 44 24 64          	mov    %eax,0x64(%esp)
                        }
                        if (*ef_ptr & 4) {
    4428:	8b 44 24 68          	mov    0x68(%esp),%eax
    442c:	f6 40 04 04          	testb  $0x4,0x4(%eax)
    4430:	0f 84 85 00 00 00    	je     44bb <_zipinfo+0x32fb>
                            len = strlen(types);
    4436:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
    443d:	8b 5c 24 6c          	mov    0x6c(%esp),%ebx
    4441:	8b 30                	mov    (%eax),%esi
    4443:	83 c0 04             	add    $0x4,%eax
    4446:	8d 96 ff fe fe fe    	lea    -0x1010101(%esi),%edx
    444c:	83 f6 ff             	xor    $0xffffffff,%esi
    444f:	21 f2                	and    %esi,%edx
    4451:	81 e2 80 80 80 80    	and    $0x80808080,%edx
    4457:	74 e8                	je     4441 <_zipinfo+0x3281>
    4459:	89 d6                	mov    %edx,%esi
    445b:	66 89 5c 24 6c       	mov    %bx,0x6c(%esp)
    4460:	c1 ee 10             	shr    $0x10,%esi
    4463:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
    446a:	f7 c2 80 80 00 00    	test   $0x8080,%edx
    4470:	0f 44 d6             	cmove  %esi,%edx
    4473:	8d 70 02             	lea    0x2(%eax),%esi
    4476:	0f 44 c6             	cmove  %esi,%eax
    4479:	00 d2                	add    %dl,%dl
    447b:	8d 51 01             	lea    0x1(%ecx),%edx
    447e:	83 d8 03             	sbb    $0x3,%eax
    4481:	29 d8                	sub    %ebx,%eax
    4483:	8b 8c 24 8c 00 00 00 	mov    0x8c(%esp),%ecx
                            if (num)
                                types[len++] = '/';
    448a:	c6 84 04 d0 00 00 00 	movb   $0x2f,0xd0(%esp,%eax,1)
    4491:	2f 
    4492:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
    4496:	89 d1                	mov    %edx,%ecx
                            strcpy(types+len, LoadFarString(UTcreation));
                            ++num;
                            if (*pEndprev > 0L)
                                *pEndprev += 4L;
    4498:	8b 74 24 64          	mov    0x64(%esp),%esi
                        }
                        if (*ef_ptr & 4) {
                            len = strlen(types);
                            if (num)
                                types[len++] = '/';
                            strcpy(types+len, LoadFarString(UTcreation));
    449c:	c7 00 63 72 65 61    	movl   $0x61657263,(%eax)
    44a2:	c7 40 04 74 69 6f 6e 	movl   $0x6e6f6974,0x4(%eax)
    44a9:	c6 40 08 00          	movb   $0x0,0x8(%eax)
                            ++num;
                            if (*pEndprev > 0L)
                                *pEndprev += 4L;
    44ad:	89 f0                	mov    %esi,%eax
    44af:	83 c0 04             	add    $0x4,%eax
    44b2:	85 f6                	test   %esi,%esi
    44b4:	0f 44 c6             	cmove  %esi,%eax
    44b7:	89 44 24 64          	mov    %eax,0x64(%esp)
                        }
                        if (num > 0)
                            Info(slide, 0, ((char *)slide,
    44bb:	ba c6 1f 00 00       	mov    $0x1fc6,%edx
    44c0:	b8 c8 1f 00 00       	mov    $0x1fc8,%eax
    44c5:	49                   	dec    %ecx
    44c6:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    44cc:	0f 45 c2             	cmovne %edx,%eax
    44cf:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    44d3:	89 44 24 0c          	mov    %eax,0xc(%esp)
    44d7:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
    44de:	c7 44 24 04 40 0b 00 	movl   $0xb40,0x4(%esp)
    44e5:	00 
    44e6:	89 44 24 08          	mov    %eax,0x8(%esp)
    44ea:	89 3c 24             	mov    %edi,(%esp)
    44ed:	e8 00 00 00 00       	call   44f2 <_zipinfo+0x3332>
    44f2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    44f9:	00 
    44fa:	89 44 24 08          	mov    %eax,0x8(%esp)
    44fe:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4502:	89 2c 24             	mov    %ebp,(%esp)
    4505:	ff d6                	call   *%esi
    4507:	83 ec 10             	sub    $0x10,%esp
    450a:	e9 51 f5 ff ff       	jmp    3a60 <_zipinfo+0x28a0>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    450f:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    4515:	89 7c 24 08          	mov    %edi,0x8(%esp)
    4519:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    451d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    4521:	c7 44 24 0c 28 0e 00 	movl   $0xe28,0xc(%esp)
    4528:	00 
    4529:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    4530:	00 
    4531:	89 3c 24             	mov    %edi,(%esp)
    4534:	e8 00 00 00 00       	call   4539 <_zipinfo+0x3379>
    4539:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4540:	00 
    4541:	89 44 24 08          	mov    %eax,0x8(%esp)
    4545:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4549:	89 2c 24             	mov    %ebp,(%esp)
    454c:	ff d6                	call   *%esi
    454e:	83 ec 10             	sub    $0x10,%esp
                            zi_showMacTypeCreator(__G__ &ef_ptr[4]);
                        }
                    }
                    break;
                case EF_ZIPIT:
                    if (eb_datalen >= 5 &&
    4551:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    4555:	66 83 fe 04          	cmp    $0x4,%si
    4559:	89 f0                	mov    %esi,%eax
    455b:	0f 86 77 f6 ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        makelong(ef_ptr) == 0x5449505A /* "ZPIT" */) {
    4561:	8b 44 24 78          	mov    0x78(%esp),%eax
    4565:	89 04 24             	mov    %eax,(%esp)
    4568:	e8 00 00 00 00       	call   456d <_zipinfo+0x33ad>
                            zi_showMacTypeCreator(__G__ &ef_ptr[4]);
                        }
                    }
                    break;
                case EF_ZIPIT:
                    if (eb_datalen >= 5 &&
    456d:	3d 5a 50 49 54       	cmp    $0x5449505a,%eax
    4572:	0f 85 e8 f4 ff ff    	jne    3a60 <_zipinfo+0x28a0>
                        makelong(ef_ptr) == 0x5449505A /* "ZPIT" */) {
                        unsigned fnlen = ef_ptr[4];
    4578:	8b 4c 24 68          	mov    0x68(%esp),%ecx
    457c:	31 c0                	xor    %eax,%eax
    457e:	8a 41 08             	mov    0x8(%ecx),%al

                        if ((unsigned)eb_datalen >= fnlen + (5 + 8)) {
    4581:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
    4585:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
    458b:	8d 50 0d             	lea    0xd(%eax),%edx
    458e:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
    4592:	39 d1                	cmp    %edx,%ecx
    4594:	0f 82 76 e2 ff ff    	jb     2810 <_zipinfo+0x1650>
                            uch nullchar = ef_ptr[fnlen+5];
    459a:	8b 4c 24 78          	mov    0x78(%esp),%ecx

                            ef_ptr[fnlen+5] = '\0'; /* terminate filename */
                            A_TO_N(ef_ptr+5);
                            Info(slide, 0, ((char *)slide,
    459e:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
                    if (eb_datalen >= 5 &&
                        makelong(ef_ptr) == 0x5449505A /* "ZPIT" */) {
                        unsigned fnlen = ef_ptr[4];

                        if ((unsigned)eb_datalen >= fnlen + (5 + 8)) {
                            uch nullchar = ef_ptr[fnlen+5];
    45a2:	8d 5c 01 05          	lea    0x5(%ecx,%eax,1),%ebx

                            ef_ptr[fnlen+5] = '\0'; /* terminate filename */
                            A_TO_N(ef_ptr+5);
                            Info(slide, 0, ((char *)slide,
    45a6:	8b 44 24 68          	mov    0x68(%esp),%eax
    45aa:	83 c0 09             	add    $0x9,%eax
                    if (eb_datalen >= 5 &&
                        makelong(ef_ptr) == 0x5449505A /* "ZPIT" */) {
                        unsigned fnlen = ef_ptr[4];

                        if ((unsigned)eb_datalen >= fnlen + (5 + 8)) {
                            uch nullchar = ef_ptr[fnlen+5];
    45ad:	8a 13                	mov    (%ebx),%dl

                            ef_ptr[fnlen+5] = '\0'; /* terminate filename */
    45af:	c6 03 00             	movb   $0x0,(%ebx)
                            A_TO_N(ef_ptr+5);
                            Info(slide, 0, ((char *)slide,
    45b2:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    45b8:	89 3c 24             	mov    %edi,(%esp)
    45bb:	89 44 24 08          	mov    %eax,0x8(%esp)
    45bf:	c7 44 24 04 00 0b 00 	movl   $0xb00,0x4(%esp)
    45c6:	00 
                    if (eb_datalen >= 5 &&
                        makelong(ef_ptr) == 0x5449505A /* "ZPIT" */) {
                        unsigned fnlen = ef_ptr[4];

                        if ((unsigned)eb_datalen >= fnlen + (5 + 8)) {
                            uch nullchar = ef_ptr[fnlen+5];
    45c7:	88 54 24 6c          	mov    %dl,0x6c(%esp)

                            ef_ptr[fnlen+5] = '\0'; /* terminate filename */
                            A_TO_N(ef_ptr+5);
                            Info(slide, 0, ((char *)slide,
    45cb:	e8 00 00 00 00       	call   45d0 <_zipinfo+0x3410>
    45d0:	89 7c 24 04          	mov    %edi,0x4(%esp)
    45d4:	89 2c 24             	mov    %ebp,(%esp)
    45d7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    45de:	00 
    45df:	89 44 24 08          	mov    %eax,0x8(%esp)
    45e3:	ff d6                	call   *%esi
                              LoadFarString(ZipItFname), (char *)ef_ptr+5));
                            ef_ptr[fnlen+5] = nullchar;
                            zi_showMacTypeCreator(__G__ &ef_ptr[fnlen+5]);
    45e5:	89 e8                	mov    %ebp,%eax
                        if ((unsigned)eb_datalen >= fnlen + (5 + 8)) {
                            uch nullchar = ef_ptr[fnlen+5];

                            ef_ptr[fnlen+5] = '\0'; /* terminate filename */
                            A_TO_N(ef_ptr+5);
                            Info(slide, 0, ((char *)slide,
    45e7:	83 ec 10             	sub    $0x10,%esp
                              LoadFarString(ZipItFname), (char *)ef_ptr+5));
                            ef_ptr[fnlen+5] = nullchar;
    45ea:	8a 54 24 6c          	mov    0x6c(%esp),%dl
    45ee:	88 13                	mov    %dl,(%ebx)
                            zi_showMacTypeCreator(__G__ &ef_ptr[fnlen+5]);
    45f0:	89 da                	mov    %ebx,%edx
    45f2:	e8 09 ba ff ff       	call   0 <_zi_showMacTypeCreator>
    45f7:	e9 14 e2 ff ff       	jmp    2810 <_zipinfo+0x1650>
    45fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                    break;
                case EF_VMCMS:
                    ef_fieldname = efVMCMS;
                    break;
                case EF_MVS:
                    ef_fieldname = efMVS;
    4600:	b8 f0 0d 00 00       	mov    $0xdf0,%eax
    4605:	e9 36 f3 ff ff       	jmp    3940 <_zipinfo+0x2780>
                    break;
                case EF_AOSVS:
                    ef_fieldname = efAOSVS;
                    break;
                case EF_SPARK:   /* from RISC OS */
                    ef_fieldname = efSpark;
    460a:	b8 9c 0d 00 00       	mov    $0xd9c,%eax
    460f:	e9 2c f3 ff ff       	jmp    3940 <_zipinfo+0x2780>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    4614:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    461a:	89 7c 24 08          	mov    %edi,0x8(%esp)
    461e:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4622:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    4626:	c7 44 24 0c 38 0e 00 	movl   $0xe38,0xc(%esp)
    462d:	00 
    462e:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    4635:	00 
    4636:	89 3c 24             	mov    %edi,(%esp)
    4639:	e8 00 00 00 00       	call   463e <_zipinfo+0x347e>
    463e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4645:	00 
    4646:	89 44 24 08          	mov    %eax,0x8(%esp)
    464a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    464e:	89 2c 24             	mov    %ebp,(%esp)
    4651:	ff d6                	call   *%esi
    4653:	83 ec 10             	sub    $0x10,%esp
                              LoadFarString(UTdata), types,
                              num == 1? nullStr : PlurSufx));
                    }
                    break;
                case EF_MAC3:
                    if (eb_datalen >= EB_MAC3_HLEN) {
    4656:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    465a:	66 83 fe 0d          	cmp    $0xd,%si
    465e:	89 f0                	mov    %esi,%eax
    4660:	0f 86 72 f5 ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        ulg eb_uc = makelong(ef_ptr);
    4666:	8b 44 24 78          	mov    0x78(%esp),%eax
    466a:	89 04 24             	mov    %eax,(%esp)
    466d:	e8 00 00 00 00       	call   4672 <_zipinfo+0x34b2>
    4672:	89 44 24 7c          	mov    %eax,0x7c(%esp)
                        unsigned mac3_flgs = makeword(ef_ptr+EB_FLGS_OFFS);
    4676:	8b 44 24 68          	mov    0x68(%esp),%eax
    467a:	83 c0 08             	add    $0x8,%eax
    467d:	89 04 24             	mov    %eax,(%esp)
    4680:	e8 00 00 00 00       	call   4685 <_zipinfo+0x34c5>
                        unsigned eb_is_uc = mac3_flgs & EB_M3_FL_UNCMPR;

                        Info(slide, 0, ((char *)slide, LoadFarString(Mac3data),
    4685:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
                    }
                    break;
                case EF_MAC3:
                    if (eb_datalen >= EB_MAC3_HLEN) {
                        ulg eb_uc = makelong(ef_ptr);
                        unsigned mac3_flgs = makeword(ef_ptr+EB_FLGS_OFFS);
    468b:	89 c6                	mov    %eax,%esi
                        unsigned eb_is_uc = mac3_flgs & EB_M3_FL_UNCMPR;

                        Info(slide, 0, ((char *)slide, LoadFarString(Mac3data),
    468d:	8b 54 24 7c          	mov    0x7c(%esp),%edx
    4691:	f7 c6 04 00 00 00    	test   $0x4,%esi
    4697:	0f 84 9f 08 00 00    	je     4f3c <_zipinfo+0x3d7c>
    469d:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
    46a1:	c7 44 24 0c 51 02 00 	movl   $0x251,0xc(%esp)
    46a8:	00 
    46a9:	89 54 24 08          	mov    %edx,0x8(%esp)
    46ad:	c7 44 24 04 a0 0a 00 	movl   $0xaa0,0x4(%esp)
    46b4:	00 
    46b5:	89 1c 24             	mov    %ebx,(%esp)
    46b8:	e8 00 00 00 00       	call   46bd <_zipinfo+0x34fd>
    46bd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    46c4:	00 
    46c5:	89 44 24 08          	mov    %eax,0x8(%esp)
    46c9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    46cd:	89 2c 24             	mov    %ebp,(%esp)
    46d0:	ff d7                	call   *%edi
    46d2:	83 ec 10             	sub    $0x10,%esp
                          eb_uc, eb_is_uc ? "un" : nullStr));
                        if (eb_is_uc) {
                            if (*pEndprev > 0L)
    46d5:	8b 7c 24 64          	mov    0x64(%esp),%edi
    46d9:	85 ff                	test   %edi,%edi
    46db:	74 14                	je     46f1 <_zipinfo+0x3531>
                                *pEndprev += makelong(ef_ptr);
    46dd:	8b 44 24 78          	mov    0x78(%esp),%eax
    46e1:	89 04 24             	mov    %eax,(%esp)
    46e4:	e8 00 00 00 00       	call   46e9 <_zipinfo+0x3529>
    46e9:	89 f9                	mov    %edi,%ecx
    46eb:	01 c1                	add    %eax,%ecx
    46ed:	89 4c 24 64          	mov    %ecx,0x64(%esp)
                        } else {
                            *pEndprev = 0L; /* no clue about csize of local */
                        }

                        Info(slide, 0, ((char *)slide,
    46f1:	89 f0                	mov    %esi,%eax
    46f3:	b9 a4 09 00 00       	mov    $0x9a4,%ecx
    46f8:	83 e0 08             	and    $0x8,%eax
    46fb:	ba 98 09 00 00       	mov    $0x998,%edx
    4700:	66 83 f8 01          	cmp    $0x1,%ax
    4704:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    470a:	19 c0                	sbb    %eax,%eax
    470c:	c7 44 24 04 60 09 00 	movl   $0x960,0x4(%esp)
    4713:	00 
    4714:	83 e0 e0             	and    $0xffffffe0,%eax
    4717:	83 c0 40             	add    $0x40,%eax
    471a:	83 e6 01             	and    $0x1,%esi
    471d:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    4721:	89 44 24 0c          	mov    %eax,0xc(%esp)
    4725:	0f 44 d1             	cmove  %ecx,%edx
    4728:	89 54 24 08          	mov    %edx,0x8(%esp)
    472c:	89 34 24             	mov    %esi,(%esp)
    472f:	e8 00 00 00 00       	call   4734 <_zipinfo+0x3574>
    4734:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    473b:	00 
    473c:	89 44 24 08          	mov    %eax,0x8(%esp)
    4740:	89 74 24 04          	mov    %esi,0x4(%esp)
    4744:	89 2c 24             	mov    %ebp,(%esp)
    4747:	ff d7                	call   *%edi
    4749:	83 ec 10             	sub    $0x10,%esp
                          LoadFarString(MacOSMAC3flags),
                          LoadFarStringSmall(mac3_flgs & EB_M3_FL_DATFRK ?
                                             MacOS_DF : MacOS_RF),
                          (mac3_flgs & EB_M3_FL_TIME64 ? 64 : 32)));
                        zi_showMacTypeCreator(__G__ &ef_ptr[6]);
    474c:	8b 54 24 68          	mov    0x68(%esp),%edx
    4750:	83 c2 0a             	add    $0xa,%edx
    4753:	e9 cb f6 ff ff       	jmp    3e23 <_zipinfo+0x2c63>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    4758:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    475e:	89 7c 24 08          	mov    %edi,0x8(%esp)
    4762:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4766:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    476a:	c7 44 24 0c 50 0e 00 	movl   $0xe50,0xc(%esp)
    4771:	00 
    4772:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    4779:	00 
    477a:	89 3c 24             	mov    %edi,(%esp)
    477d:	e8 00 00 00 00       	call   4782 <_zipinfo+0x35c2>
    4782:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4789:	00 
    478a:	89 44 24 08          	mov    %eax,0x8(%esp)
    478e:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4792:	89 2c 24             	mov    %ebp,(%esp)
    4795:	ff d6                	call   *%esi
    4797:	83 ec 10             	sub    $0x10,%esp
                            zi_showMacTypeCreator(__G__ &ef_ptr[fnlen+5]);
                        }
                    }
                    break;
                case EF_JLMAC:
                    if (eb_datalen >= 40 &&
    479a:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    479e:	66 83 fe 27          	cmp    $0x27,%si
    47a2:	89 f0                	mov    %esi,%eax
    47a4:	0f 86 2e f4 ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        makelong(ef_ptr) == 0x45454C4A /* "JLEE" */)
    47aa:	8b 44 24 78          	mov    0x78(%esp),%eax
    47ae:	89 04 24             	mov    %eax,(%esp)
    47b1:	e8 00 00 00 00       	call   47b6 <_zipinfo+0x35f6>
                            zi_showMacTypeCreator(__G__ &ef_ptr[fnlen+5]);
                        }
                    }
                    break;
                case EF_JLMAC:
                    if (eb_datalen >= 40 &&
    47b6:	3d 4a 4c 45 45       	cmp    $0x45454c4a,%eax
    47bb:	0f 85 9f f2 ff ff    	jne    3a60 <_zipinfo+0x28a0>
                        makelong(ef_ptr) == 0x45454C4A /* "JLEE" */)
                    {
                        zi_showMacTypeCreator(__G__ &ef_ptr[4]);
    47c1:	8b 7c 24 68          	mov    0x68(%esp),%edi
    47c5:	89 e8                	mov    %ebp,%eax
    47c7:	8d 57 08             	lea    0x8(%edi),%edx
    47ca:	e8 31 b8 ff ff       	call   0 <_zi_showMacTypeCreator>

                        Info(slide, 0, ((char *)slide,
    47cf:	ba a4 09 00 00       	mov    $0x9a4,%edx
    47d4:	b8 98 09 00 00       	mov    $0x998,%eax
    47d9:	f6 47 23 01          	testb  $0x1,0x23(%edi)
    47dd:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    47e1:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    47e7:	0f 44 c2             	cmove  %edx,%eax
    47ea:	89 44 24 08          	mov    %eax,0x8(%esp)
    47ee:	c7 44 24 04 b4 09 00 	movl   $0x9b4,0x4(%esp)
    47f5:	00 
    47f6:	89 3c 24             	mov    %edi,(%esp)
    47f9:	e8 00 00 00 00       	call   47fe <_zipinfo+0x363e>
    47fe:	e9 e5 f8 ff ff       	jmp    40e8 <_zipinfo+0x2f28>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    4803:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    4809:	89 7c 24 08          	mov    %edi,0x8(%esp)
    480d:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4811:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    4815:	c7 44 24 0c ac 0d 00 	movl   $0xdac,0xc(%esp)
    481c:	00 
    481d:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    4824:	00 
    4825:	89 3c 24             	mov    %edi,(%esp)
    4828:	e8 00 00 00 00       	call   482d <_zipinfo+0x366d>
    482d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4834:	00 
    4835:	89 44 24 08          	mov    %eax,0x8(%esp)
    4839:	89 7c 24 04          	mov    %edi,0x4(%esp)
    483d:	89 2c 24             	mov    %ebp,(%esp)
    4840:	ff d6                	call   *%esi
    4842:	83 ec 10             	sub    $0x10,%esp
                        Info(slide, 0, ((char *)slide, LoadFarString(QDOSdata),
                          ef_ptr[0], ef_ptr[1], ef_ptr[2], ef_ptr[3]));
                    }
                    break;
                case EF_AOSVS:
                    if (eb_datalen >= 5) {
    4845:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    4849:	66 83 fe 04          	cmp    $0x4,%si
    484d:	89 f0                	mov    %esi,%eax
    484f:	0f 86 83 f3 ff ff    	jbe    3bd8 <_zipinfo+0x2a18>
                        Info(slide, 0, ((char *)slide, LoadFarString(AOSVSdata),
    4855:	8b 44 24 68          	mov    0x68(%esp),%eax
    4859:	31 c9                	xor    %ecx,%ecx
    485b:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    4861:	8a 50 08             	mov    0x8(%eax),%dl
    4864:	c7 44 24 04 20 08 00 	movl   $0x820,0x4(%esp)
    486b:	00 
    486c:	88 d1                	mov    %dl,%cl
    486e:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
    4871:	8d 04 c1             	lea    (%ecx,%eax,8),%eax
    4874:	8d 04 80             	lea    (%eax,%eax,4),%eax
    4877:	66 c1 e8 0b          	shr    $0xb,%ax
    487b:	89 c7                	mov    %eax,%edi
    487d:	88 d0                	mov    %dl,%al
    487f:	31 d2                	xor    %edx,%edx
    4881:	8d 0c bf             	lea    (%edi,%edi,4),%ecx
    4884:	01 c9                	add    %ecx,%ecx
    4886:	29 c8                	sub    %ecx,%eax
    4888:	88 c2                	mov    %al,%dl
    488a:	89 f8                	mov    %edi,%eax
    488c:	25 ff 00 00 00       	and    $0xff,%eax
    4891:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4895:	89 54 24 0c          	mov    %edx,0xc(%esp)
    4899:	89 44 24 08          	mov    %eax,0x8(%esp)
    489d:	89 3c 24             	mov    %edi,(%esp)
    48a0:	e8 00 00 00 00       	call   48a5 <_zipinfo+0x36e5>
    48a5:	e9 3e f8 ff ff       	jmp    40e8 <_zipinfo+0x2f28>
                    break;
                default:
                    ef_fieldname = efUnknown;
                    break;
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
    48aa:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    48b0:	89 7c 24 08          	mov    %edi,0x8(%esp)
    48b4:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    48b8:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    48bc:	c7 44 24 0c 14 0e 00 	movl   $0xe14,0xc(%esp)
    48c3:	00 
    48c4:	c7 44 24 04 20 0f 00 	movl   $0xf20,0x4(%esp)
    48cb:	00 
    48cc:	89 3c 24             	mov    %edi,(%esp)
    48cf:	e8 00 00 00 00       	call   48d4 <_zipinfo+0x3714>
    48d4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    48db:	00 
    48dc:	89 44 24 08          	mov    %eax,0x8(%esp)
    48e0:	89 7c 24 04          	mov    %edi,0x4(%esp)
    48e4:	89 2c 24             	mov    %ebp,(%esp)
    48e7:	ff d6                	call   *%esi
    48e9:	83 ec 10             	sub    $0x10,%esp
                          LoadFarStringSmall(ef_ptr[31] & 1 ?
                                             MacOS_DF : MacOS_RF)));
                    }
                    break;
                case EF_SMARTZIP:
                    if ((eb_datalen == EB_SMARTZIP_HLEN) &&
    48ec:	8b 74 24 6c          	mov    0x6c(%esp),%esi
    48f0:	66 83 fe 40          	cmp    $0x40,%si
    48f4:	89 f0                	mov    %esi,%eax
    48f6:	0f 85 dc f2 ff ff    	jne    3bd8 <_zipinfo+0x2a18>
                        makelong(ef_ptr) == 0x70695A64 /* "dZip" */) {
    48fc:	8b 44 24 78          	mov    0x78(%esp),%eax
    4900:	89 04 24             	mov    %eax,(%esp)
    4903:	e8 00 00 00 00       	call   4908 <_zipinfo+0x3748>
                          LoadFarStringSmall(ef_ptr[31] & 1 ?
                                             MacOS_DF : MacOS_RF)));
                    }
                    break;
                case EF_SMARTZIP:
                    if ((eb_datalen == EB_SMARTZIP_HLEN) &&
    4908:	c7 44 24 7c 40 00 00 	movl   $0x40,0x7c(%esp)
    490f:	00 
    4910:	3d 64 5a 69 70       	cmp    $0x70695a64,%eax
    4915:	0f 85 f5 de ff ff    	jne    2810 <_zipinfo+0x1650>
                        makelong(ef_ptr) == 0x70695A64 /* "dZip" */) {
                        char filenameBuf[32];
                        zi_showMacTypeCreator(__G__ &ef_ptr[4]);
    491b:	8b 74 24 68          	mov    0x68(%esp),%esi
    491f:	89 e8                	mov    %ebp,%eax
                        memcpy(filenameBuf, &ef_ptr[33], 31);
    4921:	8d bc 24 d0 00 00 00 	lea    0xd0(%esp),%edi
                    break;
                case EF_SMARTZIP:
                    if ((eb_datalen == EB_SMARTZIP_HLEN) &&
                        makelong(ef_ptr) == 0x70695A64 /* "dZip" */) {
                        char filenameBuf[32];
                        zi_showMacTypeCreator(__G__ &ef_ptr[4]);
    4928:	8d 56 08             	lea    0x8(%esi),%edx
    492b:	e8 d0 b6 ff ff       	call   0 <_zi_showMacTypeCreator>
                        memcpy(filenameBuf, &ef_ptr[33], 31);
    4930:	89 f2                	mov    %esi,%edx
    4932:	b9 07 00 00 00       	mov    $0x7,%ecx
    4937:	8d 76 25             	lea    0x25(%esi),%esi
    493a:	89 bc 24 8c 00 00 00 	mov    %edi,0x8c(%esp)
                        filenameBuf[ef_ptr[32]] = '\0';
                        A_TO_N(filenameBuf);
                        Info(slide, 0, ((char *)slide,
    4941:	8b 9d 44 0b 01 00    	mov    0x10b44(%ebp),%ebx
                case EF_SMARTZIP:
                    if ((eb_datalen == EB_SMARTZIP_HLEN) &&
                        makelong(ef_ptr) == 0x70695A64 /* "dZip" */) {
                        char filenameBuf[32];
                        zi_showMacTypeCreator(__G__ &ef_ptr[4]);
                        memcpy(filenameBuf, &ef_ptr[33], 31);
    4947:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    4949:	66 8b 06             	mov    (%esi),%ax
    494c:	66 89 07             	mov    %ax,(%edi)
    494f:	8a 46 02             	mov    0x2(%esi),%al
                        filenameBuf[ef_ptr[32]] = '\0';
                        A_TO_N(filenameBuf);
                        Info(slide, 0, ((char *)slide,
    4952:	8b 74 24 3c          	mov    0x3c(%esp),%esi
                case EF_SMARTZIP:
                    if ((eb_datalen == EB_SMARTZIP_HLEN) &&
                        makelong(ef_ptr) == 0x70695A64 /* "dZip" */) {
                        char filenameBuf[32];
                        zi_showMacTypeCreator(__G__ &ef_ptr[4]);
                        memcpy(filenameBuf, &ef_ptr[33], 31);
    4956:	88 47 02             	mov    %al,0x2(%edi)
                        filenameBuf[ef_ptr[32]] = '\0';
    4959:	31 c0                	xor    %eax,%eax
    495b:	8a 42 24             	mov    0x24(%edx),%al
                        A_TO_N(filenameBuf);
                        Info(slide, 0, ((char *)slide,
    495e:	8b bc 24 8c 00 00 00 	mov    0x8c(%esp),%edi
                    if ((eb_datalen == EB_SMARTZIP_HLEN) &&
                        makelong(ef_ptr) == 0x70695A64 /* "dZip" */) {
                        char filenameBuf[32];
                        zi_showMacTypeCreator(__G__ &ef_ptr[4]);
                        memcpy(filenameBuf, &ef_ptr[33], 31);
                        filenameBuf[ef_ptr[32]] = '\0';
    4965:	c6 84 04 d0 00 00 00 	movb   $0x0,0xd0(%esp,%eax,1)
    496c:	00 
                        A_TO_N(filenameBuf);
                        Info(slide, 0, ((char *)slide,
    496d:	89 7c 24 08          	mov    %edi,0x8(%esp)
    4971:	c7 44 24 04 00 0b 00 	movl   $0xb00,0x4(%esp)
    4978:	00 
    4979:	89 34 24             	mov    %esi,(%esp)
    497c:	e8 00 00 00 00       	call   4981 <_zipinfo+0x37c1>
    4981:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4988:	00 
    4989:	89 44 24 08          	mov    %eax,0x8(%esp)
    498d:	89 74 24 04          	mov    %esi,0x4(%esp)
    4991:	89 2c 24             	mov    %ebp,(%esp)
    4994:	ff d3                	call   *%ebx
    4996:	83 ec 10             	sub    $0x10,%esp
    4999:	e9 72 de ff ff       	jmp    2810 <_zipinfo+0x1650>
    499e:	66 90                	xchg   %ax,%ax
                    break;
                case EF_OS2:
                    ef_fieldname = efOS2;
                    break;
                case EF_ACL:
                    ef_fieldname = efACL;
    49a0:	b8 e4 0d 00 00       	mov    $0xde4,%eax
    49a5:	e9 7f f8 ff ff       	jmp    4229 <_zipinfo+0x3069>
                eb_datalen = ef_len;
            }

            switch (eb_id) {
                case EF_PKSZ64:
                    ef_fieldname = efPKSZ64;
    49aa:	b8 f0 0e 00 00       	mov    $0xef0,%eax
    49af:	e9 8c ef ff ff       	jmp    3940 <_zipinfo+0x2780>
                default:
                    if (eb_datalen > 0) {
                        ush i, n;

                        if (eb_datalen <= 24) {
                            Info(slide, 0, ((char *)slide,
    49b4:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    49b8:	c7 85 dc 08 00 00 3a 	movl   $0x20200a3a,0x8dc(%ebp)
    49bf:	0a 20 20 
    49c2:	66 c7 85 e0 08 00 00 	movw   $0x20,0x8e0(%ebp)
    49c9:	20 00 
    49cb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    49d2:	00 
    49d3:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
    49da:	00 
    49db:	89 44 24 04          	mov    %eax,0x4(%esp)
    49df:	89 2c 24             	mov    %ebp,(%esp)
    49e2:	ff 95 44 0b 01 00    	call   *0x10b44(%ebp)
    49e8:	83 ec 10             	sub    $0x10,%esp
    49eb:	8b 7c 24 6c          	mov    0x6c(%esp),%edi
    49ef:	e9 1e f0 ff ff       	jmp    3a12 <_zipinfo+0x2852>
    } else if ((hostnum != FS_FAT_) && (hostnum != FS_HPFS_) &&
               (hostnum != FS_NTFS_) && (hostnum != FS_VFAT_) &&
               (hostnum != ACORN_) &&
               (hostnum != VM_CMS_) && (hostnum != MVS_))
    {                                 /* assume Unix-like */
        switch ((unsigned)(xattr & UNX_IFMT)) {
    49f4:	3d 00 20 00 00       	cmp    $0x2000,%eax
    49f9:	0f 84 a2 06 00 00    	je     50a1 <_zipinfo+0x3ee1>
    49ff:	3d 00 40 00 00       	cmp    $0x4000,%eax
    4a04:	0f 84 8a 06 00 00    	je     5094 <_zipinfo+0x3ed4>
    4a0a:	3d 00 10 00 00       	cmp    $0x1000,%eax
    4a0f:	0f 85 d5 ea ff ff    	jne    34ea <_zipinfo+0x232a>
            case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
            case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
            case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
            case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
            case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
            case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;
    4a15:	c6 84 24 ba 00 00 00 	movb   $0x70,0xba(%esp)
    4a1c:	70 
    4a1d:	e9 d0 ea ff ff       	jmp    34f2 <_zipinfo+0x2332>
            } /* else: fall through! */

        default:   /* assume Unix-like */
            switch ((unsigned)(xattr & UNX_IFMT)) {
                case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
                case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
    4a22:	c6 84 24 d0 00 00 00 	movb   $0x2d,0xd0(%esp)
    4a29:	2d 
    4a2a:	e9 57 db ff ff       	jmp    2586 <_zipinfo+0x13c6>
            sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
            break;

        case THEOS_:
            switch (xattr & THS_IFMT) {
                case THS_IFLIB: *attribs = 'L'; break;
    4a2f:	c6 84 24 d0 00 00 00 	movb   $0x4c,0xd0(%esp)
    4a36:	4c 
    4a37:	e9 be ec ff ff       	jmp    36fa <_zipinfo+0x253a>
                case THS_IFDIR: *attribs = 'D'; break;
                case THS_IFCHR: *attribs = 'C'; break;
                case THS_IFREG: *attribs = 'S'; break;
                case THS_IFREL: *attribs = 'R'; break;
                case THS_IFKEY: *attribs = 'K'; break;
    4a3c:	c6 84 24 d0 00 00 00 	movb   $0x4b,0xd0(%esp)
    4a43:	4b 
    4a44:	e9 b1 ec ff ff       	jmp    36fa <_zipinfo+0x253a>
                case THS_IFIND: *attribs = 'I'; break;
                case THS_IFR16: *attribs = 'P'; break;
                case THS_IFP16: *attribs = '2'; break;
    4a49:	c6 84 24 d0 00 00 00 	movb   $0x32,0xd0(%esp)
    4a50:	32 
    4a51:	e9 a4 ec ff ff       	jmp    36fa <_zipinfo+0x253a>
                        *types = '\0';
                        if (*ef_ptr & 1) {
                            strcpy(types, LoadFarString(UTmodification));
                            ++num;
                        }
                        if (*ef_ptr & 2) {
    4a56:	8b 44 24 68          	mov    0x68(%esp),%eax
                        char types[80];
                        int num = 0, len;

                        *types = '\0';
                        if (*ef_ptr & 1) {
                            strcpy(types, LoadFarString(UTmodification));
    4a5a:	c7 84 24 d0 00 00 00 	movl   $0x69646f6d,0xd0(%esp)
    4a61:	6d 6f 64 69 
    4a65:	c7 84 24 d4 00 00 00 	movl   $0x61636966,0xd4(%esp)
    4a6c:	66 69 63 61 
    4a70:	c7 84 24 d8 00 00 00 	movl   $0x6e6f6974,0xd8(%esp)
    4a77:	74 69 6f 6e 
    4a7b:	c6 84 24 dc 00 00 00 	movb   $0x0,0xdc(%esp)
    4a82:	00 
                            ++num;
                        }
                        if (*ef_ptr & 2) {
    4a83:	8a 40 04             	mov    0x4(%eax),%al
    4a86:	a8 02                	test   $0x2,%al
    4a88:	0f 84 75 03 00 00    	je     4e03 <_zipinfo+0x3c43>
                            len = strlen(types);
    4a8e:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
    4a95:	8b 5c 24 6c          	mov    0x6c(%esp),%ebx
    4a99:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
    4aa0:	89 c2                	mov    %eax,%edx
    4aa2:	8b 0a                	mov    (%edx),%ecx
    4aa4:	83 c2 04             	add    $0x4,%edx
    4aa7:	8d 81 ff fe fe fe    	lea    -0x1010101(%ecx),%eax
    4aad:	83 f1 ff             	xor    $0xffffffff,%ecx
    4ab0:	21 c8                	and    %ecx,%eax
    4ab2:	25 80 80 80 80       	and    $0x80808080,%eax
    4ab7:	74 e9                	je     4aa2 <_zipinfo+0x38e2>
    4ab9:	89 c1                	mov    %eax,%ecx
    4abb:	66 89 5c 24 6c       	mov    %bx,0x6c(%esp)
    4ac0:	c1 e9 10             	shr    $0x10,%ecx
    4ac3:	a9 80 80 00 00       	test   $0x8080,%eax
    4ac8:	0f 44 c1             	cmove  %ecx,%eax
    4acb:	8d 4a 02             	lea    0x2(%edx),%ecx
    4ace:	0f 44 d1             	cmove  %ecx,%edx
    4ad1:	00 c0                	add    %al,%al
    4ad3:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
    4ada:	83 da 03             	sbb    $0x3,%edx
                            if (num)
                                types[len++] = '/';
    4add:	b9 02 00 00 00       	mov    $0x2,%ecx
                        if (*ef_ptr & 1) {
                            strcpy(types, LoadFarString(UTmodification));
                            ++num;
                        }
                        if (*ef_ptr & 2) {
                            len = strlen(types);
    4ae2:	29 c2                	sub    %eax,%edx
                            if (num)
                                types[len++] = '/';
    4ae4:	c6 84 14 d0 00 00 00 	movb   $0x2f,0xd0(%esp,%edx,1)
    4aeb:	2f 
    4aec:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
    4af0:	e9 11 f9 ff ff       	jmp    4406 <_zipinfo+0x3246>
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
                 eb_id, LoadFarStringSmall(ef_fieldname), eb_datalen));

            /* additional, field-specific information: */
            switch (eb_id) {
    4af5:	66 81 fe 56 53       	cmp    $0x5356,%si
    4afa:	0f 84 45 fd ff ff    	je     4845 <_zipinfo+0x3685>
    4b00:	0f 86 a8 05 00 00    	jbe    50ae <_zipinfo+0x3eee>
    4b06:	66 81 fe 42 65       	cmp    $0x6542,%si
    4b0b:	0f 84 50 f6 ff ff    	je     4161 <_zipinfo+0x2fa1>
    4b11:	0f 87 5d 06 00 00    	ja     5174 <_zipinfo+0x3fb4>
    4b17:	66 81 fe 55 54       	cmp    $0x5455,%si
    4b1c:	0f 84 9e f8 ff ff    	je     43c0 <_zipinfo+0x3200>
    4b22:	e9 57 ee ff ff       	jmp    397e <_zipinfo+0x27be>
        switch (xattr & THS_IFMT) {
            case THS_IFLIB:  fpFtyp = TheosFTypLib;  break;
            case THS_IFDIR:  fpFtyp = TheosFTypDir;  break;
            case THS_IFREG:  fpFtyp = TheosFTypReg;  break;
            case THS_IFREL:  fpFtyp = TheosFTypRel;  break;
            case THS_IFKEY:  fpFtyp = TheosFTypKey;  break;
    4b27:	b8 34 10 00 00       	mov    $0x1034,%eax
    4b2c:	e9 6c e8 ff ff       	jmp    339d <_zipinfo+0x21dd>
                /* attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';  real 4.3BSD */
                attribs[6] = (xattr & UNX_ISGID)? 'S' : '-';  /* SunOS 4.1.x */
            if (xattr & UNX_IXOTH)
                attribs[9] = (xattr & UNX_ISVTX)? 't' : 'x';  /* "sticky bit" */
            else
                attribs[9] = (xattr & UNX_ISVTX)? 'T' : '-';  /* T==undefined */
    4b31:	25 00 02 00 00       	and    $0x200,%eax
    4b36:	83 f8 01             	cmp    $0x1,%eax
    4b39:	19 c0                	sbb    %eax,%eax
    4b3b:	83 e0 d9             	and    $0xffffffd9,%eax
    4b3e:	83 c0 54             	add    $0x54,%eax
    4b41:	88 84 24 d9 00 00 00 	mov    %al,0xd9(%esp)
    4b48:	e9 d4 d8 ff ff       	jmp    2421 <_zipinfo+0x1261>
                attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';  /* S==undefined */
            if (xattr & UNX_IXGRP)
                attribs[6] = (xattr & UNX_ISGID)? 's' : 'x';  /* == UNX_ENFMT */
            else
                /* attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';  real 4.3BSD */
                attribs[6] = (xattr & UNX_ISGID)? 'S' : '-';  /* SunOS 4.1.x */
    4b4d:	83 e2 da             	and    $0xffffffda,%edx
    4b50:	83 c2 53             	add    $0x53,%edx
    4b53:	88 94 24 d6 00 00 00 	mov    %dl,0xd6(%esp)
    4b5a:	e9 fb da ff ff       	jmp    265a <_zipinfo+0x149a>
            attribs[8] = (xattr & UNX_IWOTH)? 'w' : '-';

            if (xattr & UNX_IXUSR)
                attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
            else
                attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';  /* S==undefined */
    4b5f:	83 e2 da             	and    $0xffffffda,%edx
    4b62:	83 c2 53             	add    $0x53,%edx
    4b65:	88 94 24 d3 00 00 00 	mov    %dl,0xd3(%esp)
    4b6c:	e9 c7 da ff ff       	jmp    2638 <_zipinfo+0x1478>
        default:   /* assume Unix-like */
            switch ((unsigned)(xattr & UNX_IFMT)) {
                case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
                case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
                case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
                case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
    4b71:	c6 84 24 d0 00 00 00 	movb   $0x62,0xd0(%esp)
    4b78:	62 
    4b79:	e9 08 da ff ff       	jmp    2586 <_zipinfo+0x13c6>
    }

    if (!G.crec.file_comment_length)
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    else {
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommBegin)));
    4b7e:	a0 6c 02 00 00       	mov    0x26c,%al
    4b83:	be 6d 02 00 00       	mov    $0x26d,%esi
    4b88:	88 07                	mov    %al,(%edi)
    4b8a:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    4b90:	b8 4c 00 00 00       	mov    $0x4c,%eax
    4b95:	e9 af d3 ff ff       	jmp    1f49 <_zipinfo+0xd89>
    4b9a:	66 8b 0e             	mov    (%esi),%cx
    4b9d:	83 c7 02             	add    $0x2,%edi
    4ba0:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    4ba4:	83 c6 02             	add    $0x2,%esi
    4ba7:	83 e8 02             	sub    $0x2,%eax
    4baa:	e9 a6 d3 ff ff       	jmp    1f55 <_zipinfo+0xd95>
              "may be", EF_IZUNIX, LoadFarStringSmall(efIZUnix), 8,
              efIZnouid));
    }

    if (!G.crec.file_comment_length)
        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));
    4baf:	a0 b9 02 00 00       	mov    0x2b9,%al
    4bb4:	be ba 02 00 00       	mov    $0x2ba,%esi
    4bb9:	88 07                	mov    %al,(%edi)
    4bbb:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    4bc1:	b8 1d 00 00 00       	mov    $0x1d,%eax
    4bc6:	e9 16 dd ff ff       	jmp    28e1 <_zipinfo+0x1721>
    4bcb:	66 8b 0e             	mov    (%esi),%cx
    4bce:	83 c7 02             	add    $0x2,%edi
    4bd1:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    4bd5:	83 c6 02             	add    $0x2,%esi
    4bd8:	83 e8 02             	sub    $0x2,%eax
    4bdb:	e9 0d dd ff ff       	jmp    28ed <_zipinfo+0x172d>
                case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
                case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
                case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
                case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
                case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;
                case (unsigned)UNX_IFSOCK:  attribs[0] = 's';  break;
    4be0:	c6 84 24 d0 00 00 00 	movb   $0x73,0xd0(%esp)
    4be7:	73 
    4be8:	e9 99 d9 ff ff       	jmp    2586 <_zipinfo+0x13c6>

        default:   /* assume Unix-like */
            switch ((unsigned)(xattr & UNX_IFMT)) {
                case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
                case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
                case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
    4bed:	c6 84 24 d0 00 00 00 	movb   $0x6c,0xd0(%esp)
    4bf4:	6c 
    4bf5:	e9 8c d9 ff ff       	jmp    2586 <_zipinfo+0x13c6>
                break;
            } /* else: fall through! */

        default:   /* assume Unix-like */
            switch ((unsigned)(xattr & UNX_IFMT)) {
                case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
    4bfa:	c6 84 24 d0 00 00 00 	movb   $0x64,0xd0(%esp)
    4c01:	64 
    4c02:	e9 7f d9 ff ff       	jmp    2586 <_zipinfo+0x13c6>
                case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
                case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
                case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
                case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
    4c07:	c6 84 24 d0 00 00 00 	movb   $0x63,0xd0(%esp)
    4c0e:	63 
    4c0f:	e9 72 d9 ff ff       	jmp    2586 <_zipinfo+0x13c6>
            attribs[8] = (xattr & AMI_IDELETE)?   'd' : '-';
            sprintf(&attribs[12], "%u.%u", hostver/10, hostver%10);
            break;

        case THEOS_:
            switch (xattr & THS_IFMT) {
    4c14:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
    4c1a:	75 43                	jne    4c5f <_zipinfo+0x3a9f>
                case THS_IFLIB: *attribs = 'L'; break;
                case THS_IFDIR: *attribs = 'D'; break;
                case THS_IFCHR: *attribs = 'C'; break;
    4c1c:	c6 84 24 d0 00 00 00 	movb   $0x43,0xd0(%esp)
    4c23:	43 
    4c24:	e9 d1 ea ff ff       	jmp    36fa <_zipinfo+0x253a>
        else
            attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';
        if (xattr & UNX_IXOTH)
            attribs[9] = (xattr & UNX_ISVTX)? 't' : 'x';   /* "sticky bit" */
        else
            attribs[9] = (xattr & UNX_ISVTX)? 'T' : '-';   /* T = undefined */
    4c29:	83 e0 d9             	and    $0xffffffd9,%eax
    4c2c:	83 c0 54             	add    $0x54,%eax
    4c2f:	88 84 24 c3 00 00 00 	mov    %al,0xc3(%esp)
    4c36:	e9 b4 e9 ff ff       	jmp    35ef <_zipinfo+0x242f>
        else
            attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';   /* S = undefined */
        if (xattr & UNX_IXGRP)
            attribs[6] = (xattr & UNX_ISGID)? 's' : 'x';   /* == UNX_ENFMT */
        else
            attribs[6] = (xattr & UNX_ISGID)? 'l' : '-';
    4c3b:	83 e0 c1             	and    $0xffffffc1,%eax
    4c3e:	83 c0 6c             	add    $0x6c,%eax
    4c41:	88 84 24 c0 00 00 00 	mov    %al,0xc0(%esp)
    4c48:	e9 7d e9 ff ff       	jmp    35ca <_zipinfo+0x240a>
        attribs[8] = (xattr & UNX_IWOTH)? 'w' : '-';

        if (xattr & UNX_IXUSR)
            attribs[3] = (xattr & UNX_ISUID)? 's' : 'x';
        else
            attribs[3] = (xattr & UNX_ISUID)? 'S' : '-';   /* S = undefined */
    4c4d:	83 e0 da             	and    $0xffffffda,%eax
    4c50:	83 c0 53             	add    $0x53,%eax
    4c53:	88 84 24 bd 00 00 00 	mov    %al,0xbd(%esp)
    4c5a:	e9 46 e9 ff ff       	jmp    35a5 <_zipinfo+0x23e5>
                case THS_IFKEY: *attribs = 'K'; break;
                case THS_IFIND: *attribs = 'I'; break;
                case THS_IFR16: *attribs = 'P'; break;
                case THS_IFP16: *attribs = '2'; break;
                case THS_IFP32: *attribs = '3'; break;
                default:        *attribs = '?'; break;
    4c5f:	c6 84 24 d0 00 00 00 	movb   $0x3f,0xd0(%esp)
    4c66:	3f 
    4c67:	e9 8e ea ff ff       	jmp    36fa <_zipinfo+0x253a>
                case THS_IFCHR: *attribs = 'C'; break;
                case THS_IFREG: *attribs = 'S'; break;
                case THS_IFREL: *attribs = 'R'; break;
                case THS_IFKEY: *attribs = 'K'; break;
                case THS_IFIND: *attribs = 'I'; break;
                case THS_IFR16: *attribs = 'P'; break;
    4c6c:	c6 84 24 d0 00 00 00 	movb   $0x50,0xd0(%esp)
    4c73:	50 
    4c74:	e9 81 ea ff ff       	jmp    36fa <_zipinfo+0x253a>
            break;

        case THEOS_:
            switch (xattr & THS_IFMT) {
                case THS_IFLIB: *attribs = 'L'; break;
                case THS_IFDIR: *attribs = 'D'; break;
    4c79:	c6 84 24 d0 00 00 00 	movb   $0x44,0xd0(%esp)
    4c80:	44 
    4c81:	e9 74 ea ff ff       	jmp    36fa <_zipinfo+0x253a>
    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
            case THS_IFLIB:  fpFtyp = TheosFTypLib;  break;
            case THS_IFDIR:  fpFtyp = TheosFTypDir;  break;
    4c86:	b8 64 10 00 00       	mov    $0x1064,%eax
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    4c8b:	81 fa 00 40 00 00    	cmp    $0x4000,%edx
    4c91:	0f 84 06 e7 ff ff    	je     339d <_zipinfo+0x21dd>
    4c97:	e9 d4 f1 ff ff       	jmp    3e70 <_zipinfo+0x2cb0>
            switch (xattr & THS_IFMT) {
                case THS_IFLIB: *attribs = 'L'; break;
                case THS_IFDIR: *attribs = 'D'; break;
                case THS_IFCHR: *attribs = 'C'; break;
                case THS_IFREG: *attribs = 'S'; break;
                case THS_IFREL: *attribs = 'R'; break;
    4c9c:	c6 84 24 d0 00 00 00 	movb   $0x52,0xd0(%esp)
    4ca3:	52 
    4ca4:	e9 51 ea ff ff       	jmp    36fa <_zipinfo+0x253a>
            case THS_IFLIB:  fpFtyp = TheosFTypLib;  break;
            case THS_IFDIR:  fpFtyp = TheosFTypDir;  break;
            case THS_IFREG:  fpFtyp = TheosFTypReg;  break;
            case THS_IFREL:  fpFtyp = TheosFTypRel;  break;
            case THS_IFKEY:  fpFtyp = TheosFTypKey;  break;
            case THS_IFIND:  fpFtyp = TheosFTypInd;  break;
    4ca9:	b8 24 10 00 00       	mov    $0x1024,%eax
          xattr, attribs));

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
    4cae:	81 fa 00 b0 00 00    	cmp    $0xb000,%edx
    4cb4:	0f 84 e3 e6 ff ff    	je     339d <_zipinfo+0x21dd>
    4cba:	e9 b1 f1 ff ff       	jmp    3e70 <_zipinfo+0x2cb0>
        {
            error_in_archive = error;   /* might be warning */
            if (error > PK_WARN)   /* fatal */
                return error;
        }
        Info(slide, 0, ((char *)slide, LoadFarString(FileCommEnd)));
    4cbf:	a0 08 03 00 00       	mov    0x308,%al
    4cc4:	be 09 03 00 00       	mov    $0x309,%esi
    4cc9:	88 07                	mov    %al,(%edi)
    4ccb:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    4cd1:	b8 4b 00 00 00       	mov    $0x4b,%eax
    4cd6:	e9 ea e5 ff ff       	jmp    32c5 <_zipinfo+0x2105>
    4cdb:	66 8b 0e             	mov    (%esi),%cx
    4cde:	83 c7 02             	add    $0x2,%edi
    4ce1:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    4ce5:	83 c6 02             	add    $0x2,%esi
    4ce8:	83 e8 02             	sub    $0x2,%eax
    4ceb:	e9 e1 e5 ff ff       	jmp    32d1 <_zipinfo+0x2111>
                                  G.filename, (zvoid *)&G.crec.ucsize)) {
                if (fn_matched)
                    free((zvoid *)fn_matched);
                if (xn_matched)
                    free((zvoid *)xn_matched);
                return IZ_CTRLC;        /* cancel operation by user request */
    4cf0:	bb 50 00 00 00       	mov    $0x50,%ebx
    4cf5:	e9 cb d2 ff ff       	jmp    1fc5 <_zipinfo+0xe05>
/*---------------------------------------------------------------------------
    Double check that we're back at the end-of-central-directory record.
  ---------------------------------------------------------------------------*/

    if (strncmp(G.sig, end_central_sig, 4)) {   /* just to make sure again */
        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));
    4cfa:	8d 9d dc 08 00 00    	lea    0x8dc(%ebp),%ebx
    4d00:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    4d06:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    4d0d:	00 
    4d0e:	89 1c 24             	mov    %ebx,(%esp)
    4d11:	e8 00 00 00 00       	call   4d16 <_zipinfo+0x3b56>
    4d16:	c7 44 24 0c 01 04 00 	movl   $0x401,0xc(%esp)
    4d1d:	00 
    4d1e:	89 44 24 08          	mov    %eax,0x8(%esp)
    4d22:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    4d26:	89 2c 24             	mov    %ebp,(%esp)
    4d29:	ff d6                	call   *%esi
    4d2b:	83 ec 10             	sub    $0x10,%esp
        error_in_archive = PK_WARN;   /* didn't find sig */
    4d2e:	c7 44 24 50 01 00 00 	movl   $0x1,0x50(%esp)
    4d35:	00 
    4d36:	e9 1c f2 ff ff       	jmp    3f57 <_zipinfo+0x2d97>
    Check that we actually found requested files; if so, print totals.
  ---------------------------------------------------------------------------*/

    if (uO.tflag) {
        char *sgn = "";
        int cfactor = ratio(tot_ucsize, tot_csize);
    4d3b:	8b 44 24 4c          	mov    0x4c(%esp),%eax
/*---------------------------------------------------------------------------
    Check that we actually found requested files; if so, print totals.
  ---------------------------------------------------------------------------*/

    if (uO.tflag) {
        char *sgn = "";
    4d3f:	bb 00 02 00 00       	mov    $0x200,%ebx
        int cfactor = ratio(tot_ucsize, tot_csize);
    4d44:	89 44 24 04          	mov    %eax,0x4(%esp)
    4d48:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    4d4c:	89 04 24             	mov    %eax,(%esp)
    4d4f:	e8 00 00 00 00       	call   4d54 <_zipinfo+0x3b94>
    4d54:	89 c1                	mov    %eax,%ecx

        if (cfactor < 0) {
    4d56:	85 c0                	test   %eax,%eax
    4d58:	0f 88 a7 03 00 00    	js     5105 <_zipinfo+0x3f45>
            sgn = "-";
            cfactor = -cfactor;
        }
        Info(slide, 0, ((char *)slide, LoadFarString(ZipfileStats),
    4d5e:	89 c8                	mov    %ecx,%eax
    4d60:	ba 67 66 66 66       	mov    $0x66666667,%edx
    4d65:	f7 ea                	imul   %edx
    4d67:	89 c8                	mov    %ecx,%eax
    4d69:	be c8 1f 00 00       	mov    $0x1fc8,%esi
    4d6e:	c1 f8 1f             	sar    $0x1f,%eax
    4d71:	8b bd 44 0b 01 00    	mov    0x10b44(%ebp),%edi
    4d77:	c1 fa 02             	sar    $0x2,%edx
    4d7a:	89 5c 24 18          	mov    %ebx,0x18(%esp)
    4d7e:	29 c2                	sub    %eax,%edx
    4d80:	c7 44 24 04 e0 1a 00 	movl   $0x1ae0,0x4(%esp)
    4d87:	00 
    4d88:	89 d0                	mov    %edx,%eax
    4d8a:	8d 14 92             	lea    (%edx,%edx,4),%edx
    4d8d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    4d91:	01 d2                	add    %edx,%edx
    4d93:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    4d97:	29 d1                	sub    %edx,%ecx
    4d99:	89 44 24 14          	mov    %eax,0x14(%esp)
    4d9d:	89 ca                	mov    %ecx,%edx
    4d9f:	b9 c6 1f 00 00       	mov    $0x1fc6,%ecx
    4da4:	83 7c 24 58 01       	cmpl   $0x1,0x58(%esp)
    4da9:	0f 44 ce             	cmove  %esi,%ecx
    4dac:	8b 44 24 5c          	mov    0x5c(%esp),%eax
    4db0:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    4db4:	8d b5 dc 08 00 00    	lea    0x8dc(%ebp),%esi
    4dba:	8b 4c 24 58          	mov    0x58(%esp),%ecx
    4dbe:	89 54 24 20          	mov    %edx,0x20(%esp)
    4dc2:	89 44 24 10          	mov    %eax,0x10(%esp)
    4dc6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    4dca:	89 34 24             	mov    %esi,(%esp)
    4dcd:	e8 00 00 00 00       	call   4dd2 <_zipinfo+0x3c12>
    4dd2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4dd9:	00 
    4dda:	89 44 24 08          	mov    %eax,0x8(%esp)
    4dde:	89 74 24 04          	mov    %esi,0x4(%esp)
    4de2:	89 2c 24             	mov    %ebp,(%esp)
    4de5:	ff d7                	call   *%edi
    4de7:	83 ec 10             	sub    $0x10,%esp
    4dea:	e9 c4 ea ff ff       	jmp    38b3 <_zipinfo+0x26f3>
            case THS_IFDIR:  fpFtyp = TheosFTypDir;  break;
            case THS_IFREG:  fpFtyp = TheosFTypReg;  break;
            case THS_IFREL:  fpFtyp = TheosFTypRel;  break;
            case THS_IFKEY:  fpFtyp = TheosFTypKey;  break;
            case THS_IFIND:  fpFtyp = TheosFTypInd;  break;
            case THS_IFR16:  fpFtyp = TheosFTypR16;  break;
    4def:	b8 14 10 00 00       	mov    $0x1014,%eax
    4df4:	e9 a4 e5 ff ff       	jmp    339d <_zipinfo+0x21dd>

    } else if (hostnum == THEOS_) {
        ZCONST char Far *fpFtyp;

        switch (xattr & THS_IFMT) {
            case THS_IFLIB:  fpFtyp = TheosFTypLib;  break;
    4df9:	b8 74 10 00 00       	mov    $0x1074,%eax
    4dfe:	e9 9a e5 ff ff       	jmp    339d <_zipinfo+0x21dd>
                            strcpy(types+len, LoadFarString(UTaccess));
                            ++num;
                            if (*pEndprev > 0L)
                                *pEndprev += 4L;
                        }
                        if (*ef_ptr & 4) {
    4e03:	a8 04                	test   $0x4,%al
    4e05:	0f 84 06 03 00 00    	je     5111 <_zipinfo+0x3f51>
                            len = strlen(types);
    4e0b:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
    4e12:	8b 5c 24 6c          	mov    0x6c(%esp),%ebx
    4e16:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
    4e1d:	8b 08                	mov    (%eax),%ecx
    4e1f:	83 c0 04             	add    $0x4,%eax
    4e22:	8d 91 ff fe fe fe    	lea    -0x1010101(%ecx),%edx
    4e28:	83 f1 ff             	xor    $0xffffffff,%ecx
    4e2b:	21 ca                	and    %ecx,%edx
    4e2d:	81 e2 80 80 80 80    	and    $0x80808080,%edx
    4e33:	74 e8                	je     4e1d <_zipinfo+0x3c5d>
    4e35:	89 d1                	mov    %edx,%ecx
    4e37:	66 89 5c 24 6c       	mov    %bx,0x6c(%esp)
    4e3c:	c1 e9 10             	shr    $0x10,%ecx
    4e3f:	f7 c2 80 80 00 00    	test   $0x8080,%edx
    4e45:	0f 44 d1             	cmove  %ecx,%edx
    4e48:	8d 48 02             	lea    0x2(%eax),%ecx
    4e4b:	0f 44 c1             	cmove  %ecx,%eax
    4e4e:	00 d2                	add    %dl,%dl
    4e50:	8b 94 24 8c 00 00 00 	mov    0x8c(%esp),%edx
    4e57:	83 d8 03             	sbb    $0x3,%eax
    4e5a:	29 d0                	sub    %edx,%eax
    4e5c:	ba 02 00 00 00       	mov    $0x2,%edx
    4e61:	e9 1d f6 ff ff       	jmp    4483 <_zipinfo+0x32c3>
                    break;
                case EF_TANDEM:
                    if (eb_datalen == 20) {
                        unsigned type, code;

                        type = (ef_ptr[18] & 0x60) >> 5;
    4e66:	8b 44 24 68          	mov    0x68(%esp),%eax
    4e6a:	8a 58 16             	mov    0x16(%eax),%bl
                        code = makeword(ef_ptr);
    4e6d:	8b 44 24 78          	mov    0x78(%esp),%eax
    4e71:	89 04 24             	mov    %eax,(%esp)
                    break;
                case EF_TANDEM:
                    if (eb_datalen == 20) {
                        unsigned type, code;

                        type = (ef_ptr[18] & 0x60) >> 5;
    4e74:	83 e3 60             	and    $0x60,%ebx
    4e77:	c1 fb 05             	sar    $0x5,%ebx
                        code = makeword(ef_ptr);
    4e7a:	e8 00 00 00 00       	call   4e7f <_zipinfo+0x3cbf>
    4e7f:	31 d2                	xor    %edx,%edx
                        /* Arrg..., Tandem e.f. uses BigEndian byte-order */
                        code = ((code << 8) & 0xff00) | ((code >> 8) & 0x00ff);
    4e81:	31 c9                	xor    %ecx,%ecx
                case EF_TANDEM:
                    if (eb_datalen == 20) {
                        unsigned type, code;

                        type = (ef_ptr[18] & 0x60) >> 5;
                        code = makeword(ef_ptr);
    4e83:	66 89 c2             	mov    %ax,%dx
                        /* Arrg..., Tandem e.f. uses BigEndian byte-order */
                        code = ((code << 8) & 0xff00) | ((code >> 8) & 0x00ff);
    4e86:	89 d0                	mov    %edx,%eax
    4e88:	c1 e0 08             	shl    $0x8,%eax
    4e8b:	c1 ea 08             	shr    $0x8,%edx
    4e8e:	66 89 c1             	mov    %ax,%cx
    4e91:	89 c8                	mov    %ecx,%eax
    4e93:	09 d0                	or     %edx,%eax
                        if (type == NSK_UNSTRUCTURED) {
    4e95:	85 db                	test   %ebx,%ebx
    4e97:	75 14                	jne    4ead <_zipinfo+0x3ced>
                            if (code == NSK_EDITFILECODE)
    4e99:	83 f8 65             	cmp    $0x65,%eax
    4e9c:	0f 84 ac 02 00 00    	je     514e <_zipinfo+0x3f8e>
                                type = 4;
                            else if (code == NSK_OBJECTFILECODE)
                                type = 5;
    4ea2:	31 db                	xor    %ebx,%ebx
    4ea4:	83 f8 64             	cmp    $0x64,%eax
    4ea7:	0f 94 c3             	sete   %bl
    4eaa:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
                        }
                        Info(slide, 0, ((char *)slide,
    4ead:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    4eb3:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4eb7:	89 44 24 0c          	mov    %eax,0xc(%esp)
    4ebb:	8b 04 9d a4 07 00 00 	mov    0x7a4(,%ebx,4),%eax
    4ec2:	89 44 24 08          	mov    %eax,0x8(%esp)
    4ec6:	c7 44 24 04 60 07 00 	movl   $0x760,0x4(%esp)
    4ecd:	00 
    4ece:	89 3c 24             	mov    %edi,(%esp)
    4ed1:	e8 00 00 00 00       	call   4ed6 <_zipinfo+0x3d16>
    4ed6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4edd:	00 
    4ede:	89 44 24 08          	mov    %eax,0x8(%esp)
    4ee2:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4ee6:	89 2c 24             	mov    %ebp,(%esp)
    4ee9:	ff d6                	call   *%esi
    4eeb:	83 ec 10             	sub    $0x10,%esp
    4eee:	c7 44 24 7c 14 00 00 	movl   $0x14,0x7c(%esp)
    4ef5:	00 
    4ef6:	e9 15 d9 ff ff       	jmp    2810 <_zipinfo+0x1650>
                            strcpy(types+len, LoadFarString(UTaccess));
                            ++num;
                            if (*pEndprev > 0L)
                                *pEndprev += 4L;
                        }
                        if (*ef_ptr & 4) {
    4efb:	a8 04                	test   $0x4,%al
    4efd:	0f 84 5d eb ff ff    	je     3a60 <_zipinfo+0x28a0>
    4f03:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
    4f0a:	b9 01 00 00 00       	mov    $0x1,%ecx
    4f0f:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
    4f16:	e9 7d f5 ff ff       	jmp    4498 <_zipinfo+0x32d8>

                        if (eb_id == EF_ATHEOS)
                            ef_fieldname = AtheOSdata;
                        else
                            ef_fieldname = BeOSdata;
                        Info(slide, 0, ((char *)slide,
    4f1b:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    4f1f:	c7 44 24 0c c8 1f 00 	movl   $0x1fc8,0xc(%esp)
    4f26:	00 
    4f27:	89 44 24 08          	mov    %eax,0x8(%esp)
    4f2b:	89 54 24 04          	mov    %edx,0x4(%esp)
    4f2f:	89 3c 24             	mov    %edi,(%esp)
    4f32:	e8 00 00 00 00       	call   4f37 <_zipinfo+0x3d77>
    4f37:	e9 1e f4 ff ff       	jmp    435a <_zipinfo+0x319a>
                    if (eb_datalen >= EB_MAC3_HLEN) {
                        ulg eb_uc = makelong(ef_ptr);
                        unsigned mac3_flgs = makeword(ef_ptr+EB_FLGS_OFFS);
                        unsigned eb_is_uc = mac3_flgs & EB_M3_FL_UNCMPR;

                        Info(slide, 0, ((char *)slide, LoadFarString(Mac3data),
    4f3c:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
    4f40:	c7 44 24 0c c8 1f 00 	movl   $0x1fc8,0xc(%esp)
    4f47:	00 
    4f48:	89 54 24 08          	mov    %edx,0x8(%esp)
    4f4c:	c7 44 24 04 a0 0a 00 	movl   $0xaa0,0x4(%esp)
    4f53:	00 
    4f54:	89 1c 24             	mov    %ebx,(%esp)
    4f57:	e8 00 00 00 00       	call   4f5c <_zipinfo+0x3d9c>
    4f5c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    4f63:	00 
    4f64:	89 44 24 08          	mov    %eax,0x8(%esp)
    4f68:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    4f6c:	89 2c 24             	mov    %ebp,(%esp)
    4f6f:	ff d7                	call   *%edi
    4f71:	83 ec 10             	sub    $0x10,%esp
    4f74:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
    4f7b:	00 
    4f7c:	e9 70 f7 ff ff       	jmp    46f1 <_zipinfo+0x3531>
            /* delayed "fatal error" return from extra field reading */
            return error;
        if (G.extra_field == (uch *)NULL)
            return PK_ERR;   /* not consistent with crec length */

        Info(slide, 0, ((char *)slide, LoadFarString(ExtraFields)));
    4f81:	66 8b 0e             	mov    (%esi),%cx
    4f84:	83 c7 02             	add    $0x2,%edi
    4f87:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    4f8b:	83 c6 02             	add    $0x2,%esi
    4f8e:	83 e8 02             	sub    $0x2,%eax
    4f91:	e9 eb e0 ff ff       	jmp    3081 <_zipinfo+0x1ec1>
    4f96:	a0 d8 02 00 00       	mov    0x2d8,%al
    4f9b:	be d9 02 00 00       	mov    $0x2d9,%esi
    4fa0:	88 07                	mov    %al,(%edi)
    4fa2:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    4fa8:	b8 2e 00 00 00       	mov    $0x2e,%eax
    4fad:	e9 c3 e0 ff ff       	jmp    3075 <_zipinfo+0x1eb5>
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
                 eb_id, LoadFarStringSmall(ef_fieldname), eb_datalen));

            /* additional, field-specific information: */
            switch (eb_id) {
    4fb2:	66 81 fe c8 07       	cmp    $0x7c8,%si
    4fb7:	0f 84 dd f7 ff ff    	je     479a <_zipinfo+0x35da>
    4fbd:	66 81 fe 05 26       	cmp    $0x2605,%si
    4fc2:	0f 84 89 f5 ff ff    	je     4551 <_zipinfo+0x3391>
    4fc8:	66 83 fe 09          	cmp    $0x9,%si
    4fcc:	0f 85 ac e9 ff ff    	jne    397e <_zipinfo+0x27be>
    4fd2:	e9 92 f2 ff ff       	jmp    4269 <_zipinfo+0x30a9>
                if (IS_VOLID(xattr))
                    attribs[0] = 'V';
                else if ((p = MBSRCHR(G.filename, '.')) != (char *)NULL) {
                    ++p;
                    if (STRNICMP(p, "com", 3) == 0 ||
                        STRNICMP(p, "exe", 3) == 0 ||
    4fd7:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    4fde:	00 
    4fdf:	c7 44 24 04 9b 01 00 	movl   $0x19b,0x4(%esp)
    4fe6:	00 
    4fe7:	89 1c 24             	mov    %ebx,(%esp)
    4fea:	e8 00 00 00 00       	call   4fef <_zipinfo+0x3e2f>
                    attribs[0] = '-';
                if (IS_VOLID(xattr))
                    attribs[0] = 'V';
                else if ((p = MBSRCHR(G.filename, '.')) != (char *)NULL) {
                    ++p;
                    if (STRNICMP(p, "com", 3) == 0 ||
    4fef:	85 c0                	test   %eax,%eax
    4ff1:	0f 84 17 f0 ff ff    	je     400e <_zipinfo+0x2e4e>
                        STRNICMP(p, "exe", 3) == 0 ||
                        STRNICMP(p, "btm", 3) == 0 ||
    4ff7:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    4ffe:	00 
    4fff:	c7 44 24 04 1f 02 00 	movl   $0x21f,0x4(%esp)
    5006:	00 
    5007:	89 1c 24             	mov    %ebx,(%esp)
    500a:	e8 00 00 00 00       	call   500f <_zipinfo+0x3e4f>
                if (IS_VOLID(xattr))
                    attribs[0] = 'V';
                else if ((p = MBSRCHR(G.filename, '.')) != (char *)NULL) {
                    ++p;
                    if (STRNICMP(p, "com", 3) == 0 ||
                        STRNICMP(p, "exe", 3) == 0 ||
    500f:	85 c0                	test   %eax,%eax
    5011:	0f 84 f7 ef ff ff    	je     400e <_zipinfo+0x2e4e>
                        STRNICMP(p, "btm", 3) == 0 ||
                        STRNICMP(p, "cmd", 3) == 0 ||
    5017:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    501e:	00 
    501f:	c7 44 24 04 23 02 00 	movl   $0x223,0x4(%esp)
    5026:	00 
    5027:	89 1c 24             	mov    %ebx,(%esp)
    502a:	e8 00 00 00 00       	call   502f <_zipinfo+0x3e6f>
                    attribs[0] = 'V';
                else if ((p = MBSRCHR(G.filename, '.')) != (char *)NULL) {
                    ++p;
                    if (STRNICMP(p, "com", 3) == 0 ||
                        STRNICMP(p, "exe", 3) == 0 ||
                        STRNICMP(p, "btm", 3) == 0 ||
    502f:	85 c0                	test   %eax,%eax
    5031:	0f 84 d7 ef ff ff    	je     400e <_zipinfo+0x2e4e>
                        STRNICMP(p, "cmd", 3) == 0 ||
                        STRNICMP(p, "bat", 3) == 0)
    5037:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
    503e:	00 
    503f:	c7 44 24 04 27 02 00 	movl   $0x227,0x4(%esp)
    5046:	00 
    5047:	89 1c 24             	mov    %ebx,(%esp)
    504a:	e8 00 00 00 00       	call   504f <_zipinfo+0x3e8f>
                else if ((p = MBSRCHR(G.filename, '.')) != (char *)NULL) {
                    ++p;
                    if (STRNICMP(p, "com", 3) == 0 ||
                        STRNICMP(p, "exe", 3) == 0 ||
                        STRNICMP(p, "btm", 3) == 0 ||
                        STRNICMP(p, "cmd", 3) == 0 ||
    504f:	85 c0                	test   %eax,%eax
    5051:	0f 84 b7 ef ff ff    	je     400e <_zipinfo+0x2e4e>
    5057:	e9 c4 d0 ff ff       	jmp    2120 <_zipinfo+0xf60>
    505c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
               (hostnum != ACORN_) &&
               (hostnum != VM_CMS_) && (hostnum != MVS_))
    {                                 /* assume Unix-like */
        switch ((unsigned)(xattr & UNX_IFMT)) {
            case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
            case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
    5060:	c6 84 24 ba 00 00 00 	movb   $0x2d,0xba(%esp)
    5067:	2d 
    5068:	e9 85 e4 ff ff       	jmp    34f2 <_zipinfo+0x2332>
            case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
            case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
    506d:	c6 84 24 ba 00 00 00 	movb   $0x62,0xba(%esp)
    5074:	62 
    5075:	e9 78 e4 ff ff       	jmp    34f2 <_zipinfo+0x2332>
            case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
            case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;
            case (unsigned)UNX_IFSOCK:  attribs[0] = 's';  break;
    507a:	c6 84 24 ba 00 00 00 	movb   $0x73,0xba(%esp)
    5081:	73 
    5082:	e9 6b e4 ff ff       	jmp    34f2 <_zipinfo+0x2332>
               (hostnum != VM_CMS_) && (hostnum != MVS_))
    {                                 /* assume Unix-like */
        switch ((unsigned)(xattr & UNX_IFMT)) {
            case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
            case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
            case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
    5087:	c6 84 24 ba 00 00 00 	movb   $0x6c,0xba(%esp)
    508e:	6c 
    508f:	e9 5e e4 ff ff       	jmp    34f2 <_zipinfo+0x2332>
               (hostnum != FS_NTFS_) && (hostnum != FS_VFAT_) &&
               (hostnum != ACORN_) &&
               (hostnum != VM_CMS_) && (hostnum != MVS_))
    {                                 /* assume Unix-like */
        switch ((unsigned)(xattr & UNX_IFMT)) {
            case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;
    5094:	c6 84 24 ba 00 00 00 	movb   $0x64,0xba(%esp)
    509b:	64 
    509c:	e9 51 e4 ff ff       	jmp    34f2 <_zipinfo+0x2332>
            case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;
            case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;
            case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;
            case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;
    50a1:	c6 84 24 ba 00 00 00 	movb   $0x63,0xba(%esp)
    50a8:	63 
    50a9:	e9 44 e4 ff ff       	jmp    34f2 <_zipinfo+0x2332>
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
                 eb_id, LoadFarStringSmall(ef_fieldname), eb_datalen));

            /* additional, field-specific information: */
            switch (eb_id) {
    50ae:	66 81 fe 49 4d       	cmp    $0x4d49,%si
    50b3:	0f 84 5b d6 ff ff    	je     2714 <_zipinfo+0x1554>
    50b9:	66 81 fe 63 4d       	cmp    $0x4d63,%si
    50be:	0f 84 28 f8 ff ff    	je     48ec <_zipinfo+0x372c>
    50c4:	66 81 fe 41 4c       	cmp    $0x4c41,%si
    50c9:	0f 85 af e8 ff ff    	jne    397e <_zipinfo+0x27be>
    50cf:	e9 95 f1 ff ff       	jmp    4269 <_zipinfo+0x30a9>
                                        & EB_IZVMS_BCMASK;

                        *q = '\0';
                        if (compr > 3)
                            compr = 3;
                        switch (makelong(ef_ptr)) {
    50d4:	3d 56 46 48 43       	cmp    $0x43484656,%eax
    50d9:	74 54                	je     512f <_zipinfo+0x3f6f>
                            case 0x42414656: /* "VFAB" */
                                p = "FAB"; break;
                            case 0x4C4C4156: /* "VALL" */
                                p = "XABALL"; break;
    50db:	bf c6 01 00 00       	mov    $0x1c6,%edi
                                        & EB_IZVMS_BCMASK;

                        *q = '\0';
                        if (compr > 3)
                            compr = 3;
                        switch (makelong(ef_ptr)) {
    50e0:	3d 56 41 4c 4c       	cmp    $0x4c4c4156,%eax
    50e5:	0f 84 ad d6 ff ff    	je     2798 <_zipinfo+0x15d8>
                            case 0x42414656: /* "VFAB" */
                                p = "FAB"; break;
    50eb:	bf c2 01 00 00       	mov    $0x1c2,%edi
                                        & EB_IZVMS_BCMASK;

                        *q = '\0';
                        if (compr > 3)
                            compr = 3;
                        switch (makelong(ef_ptr)) {
    50f0:	3d 56 46 41 42       	cmp    $0x42414656,%eax
    50f5:	0f 84 9d d6 ff ff    	je     2798 <_zipinfo+0x15d8>
                                    A_TO_N(q+2);
                                    q[6] = ')';
                                }
                                break;
                            default:
                                p = "unknown";
    50fb:	bf f8 01 00 00       	mov    $0x1f8,%edi
    5100:	e9 93 d6 ff ff       	jmp    2798 <_zipinfo+0x15d8>
        char *sgn = "";
        int cfactor = ratio(tot_ucsize, tot_csize);

        if (cfactor < 0) {
            sgn = "-";
            cfactor = -cfactor;
    5105:	f7 d9                	neg    %ecx
    if (uO.tflag) {
        char *sgn = "";
        int cfactor = ratio(tot_ucsize, tot_csize);

        if (cfactor < 0) {
            sgn = "-";
    5107:	bb 01 02 00 00       	mov    $0x201,%ebx
    510c:	e9 4d fc ff ff       	jmp    4d5e <_zipinfo+0x3b9e>
    5111:	8d 8c 24 d0 00 00 00 	lea    0xd0(%esp),%ecx
                            ++num;
                            if (*pEndprev > 0L)
                                *pEndprev += 4L;
                        }
                        if (num > 0)
                            Info(slide, 0, ((char *)slide,
    5118:	8b b5 44 0b 01 00    	mov    0x10b44(%ebp),%esi
    511e:	b8 c8 1f 00 00       	mov    $0x1fc8,%eax
    5123:	89 8c 24 8c 00 00 00 	mov    %ecx,0x8c(%esp)
    512a:	e9 a0 f3 ff ff       	jmp    44cf <_zipinfo+0x330f>
                            case 0x42414656: /* "VFAB" */
                                p = "FAB"; break;
                            case 0x4C4C4156: /* "VALL" */
                                p = "XABALL"; break;
                            case 0x43484656: /* "VFHC" */
                                p = "XABFHC"; break;
    512f:	bf cd 01 00 00       	mov    $0x1cd,%edi
    5134:	e9 5f d6 ff ff       	jmp    2798 <_zipinfo+0x15d8>
                        if (eb_datalen <= 24) {
                            Info(slide, 0, ((char *)slide,
                                 LoadFarString(ColonIndent)));
                            n = eb_datalen;
                        } else {
                            Info(slide, 0, ((char *)slide,
    5139:	66 8b 0e             	mov    (%esi),%cx
    513c:	83 c7 02             	add    $0x2,%edi
    513f:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    5143:	83 c6 02             	add    $0x2,%esi
    5146:	83 e8 02             	sub    $0x2,%eax
    5149:	e9 7f e8 ff ff       	jmp    39cd <_zipinfo+0x280d>
                        code = makeword(ef_ptr);
                        /* Arrg..., Tandem e.f. uses BigEndian byte-order */
                        code = ((code << 8) & 0xff00) | ((code >> 8) & 0x00ff);
                        if (type == NSK_UNSTRUCTURED) {
                            if (code == NSK_EDITFILECODE)
                                type = 4;
    514e:	bb 04 00 00 00       	mov    $0x4,%ebx
    5153:	e9 55 fd ff ff       	jmp    4ead <_zipinfo+0x3ced>
                        if (eb_datalen <= 24) {
                            Info(slide, 0, ((char *)slide,
                                 LoadFarString(ColonIndent)));
                            n = eb_datalen;
                        } else {
                            Info(slide, 0, ((char *)slide,
    5158:	a0 54 03 00 00       	mov    0x354,%al
    515d:	be 55 03 00 00       	mov    $0x355,%esi
    5162:	88 07                	mov    %al,(%edi)
    5164:	8d bd dd 08 00 00    	lea    0x8dd(%ebp),%edi
    516a:	b8 1a 00 00 00       	mov    $0x1a,%eax
    516f:	e9 4d e8 ff ff       	jmp    39c1 <_zipinfo+0x2801>
            }
            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),
                 eb_id, LoadFarStringSmall(ef_fieldname), eb_datalen));

            /* additional, field-specific information: */
            switch (eb_id) {
    5174:	66 81 fe 41 74       	cmp    $0x7441,%si
    5179:	0f 84 e2 ef ff ff    	je     4161 <_zipinfo+0x2fa1>
    517f:	66 81 fe 4a fb       	cmp    $0xfb4a,%si
    5184:	0f 84 0c ef ff ff    	je     4096 <_zipinfo+0x2ed6>
    518a:	e9 ef e7 ff ff       	jmp    397e <_zipinfo+0x27be>
    518f:	90                   	nop
                            case 0x54414456: /* "VDAT" */
                                p = "XABDAT"; break;
                            case 0x54445256: /* "VRDT" */
                                p = "XABRDT"; break;
                            case 0x4F525056: /* "VPRO" */
                                p = "XABPRO"; break;
    5190:	bf e2 01 00 00       	mov    $0x1e2,%edi
    5195:	e9 fe d5 ff ff       	jmp    2798 <_zipinfo+0x15d8>
                            case 0x59454B56: /* "VKEY" */
                                p = "XABKEY"; break;
                            case 0x56534D56: /* "VMSV" */
                                p = "version";
    519a:	bf f0 01 00 00       	mov    $0x1f0,%edi
                                if (eb_datalen >= 16) {
    519f:	66 83 7c 24 6c 0f    	cmpw   $0xf,0x6c(%esp)
    51a5:	0f 86 ed d5 ff ff    	jbe    2798 <_zipinfo+0x15d8>
                                    /* put termitation first, for A_TO_N() */
                                    q[7] = '\0';
                                    q[0] = ' ';
                                    q[1] = '(';
                                    strncpy(q+2,
    51ab:	8b 44 24 68          	mov    0x68(%esp),%eax
    51af:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
    51b6:	00 
    51b7:	83 c0 10             	add    $0x10,%eax
                                p = "XABKEY"; break;
                            case 0x56534D56: /* "VMSV" */
                                p = "version";
                                if (eb_datalen >= 16) {
                                    /* put termitation first, for A_TO_N() */
                                    q[7] = '\0';
    51ba:	c6 84 24 d7 00 00 00 	movb   $0x0,0xd7(%esp)
    51c1:	00 
                                    q[0] = ' ';
                                    q[1] = '(';
                                    strncpy(q+2,
    51c2:	89 44 24 04          	mov    %eax,0x4(%esp)
    51c6:	8d 84 24 d2 00 00 00 	lea    0xd2(%esp),%eax
    51cd:	89 04 24             	mov    %eax,(%esp)
                            case 0x56534D56: /* "VMSV" */
                                p = "version";
                                if (eb_datalen >= 16) {
                                    /* put termitation first, for A_TO_N() */
                                    q[7] = '\0';
                                    q[0] = ' ';
    51d0:	c6 84 24 d0 00 00 00 	movb   $0x20,0xd0(%esp)
    51d7:	20 
                                    q[1] = '(';
    51d8:	c6 84 24 d1 00 00 00 	movb   $0x28,0xd1(%esp)
    51df:	28 
                                    strncpy(q+2,
    51e0:	e8 00 00 00 00       	call   51e5 <_zipinfo+0x4025>
                                            (char *)ef_ptr+EB_IZVMS_HLEN, 4);
                                    A_TO_N(q+2);
                                    q[6] = ')';
    51e5:	c6 84 24 d6 00 00 00 	movb   $0x29,0xd6(%esp)
    51ec:	29 
    51ed:	e9 a6 d5 ff ff       	jmp    2798 <_zipinfo+0x15d8>
                            case 0x4C4C4156: /* "VALL" */
                                p = "XABALL"; break;
                            case 0x43484656: /* "VFHC" */
                                p = "XABFHC"; break;
                            case 0x54414456: /* "VDAT" */
                                p = "XABDAT"; break;
    51f2:	bf d4 01 00 00       	mov    $0x1d4,%edi
                                        & EB_IZVMS_BCMASK;

                        *q = '\0';
                        if (compr > 3)
                            compr = 3;
                        switch (makelong(ef_ptr)) {
    51f7:	3d 56 44 41 54       	cmp    $0x54414456,%eax
    51fc:	0f 84 96 d5 ff ff    	je     2798 <_zipinfo+0x15d8>
    5202:	e9 f4 fe ff ff       	jmp    50fb <_zipinfo+0x3f3b>
                            case 0x43484656: /* "VFHC" */
                                p = "XABFHC"; break;
                            case 0x54414456: /* "VDAT" */
                                p = "XABDAT"; break;
                            case 0x54445256: /* "VRDT" */
                                p = "XABRDT"; break;
    5207:	bf db 01 00 00       	mov    $0x1db,%edi
    520c:	e9 87 d5 ff ff       	jmp    2798 <_zipinfo+0x15d8>
    5211:	8b 44 24 68          	mov    0x68(%esp),%eax
            for (i = 0;  i < 4;  ++i, ++k)  /* loop over perms within a group */
                if (workspace[k])
                    *p++ = workspace[k];
            *p++ = ',';                       /* group separator */
            if (j == 0)
                while ((*p++ = *q++) != ',')
    5215:	40                   	inc    %eax
    5216:	42                   	inc    %edx
    5217:	8a 48 ff             	mov    -0x1(%eax),%cl
    521a:	88 4a ff             	mov    %cl,-0x1(%edx)
    521d:	80 f9 2c             	cmp    $0x2c,%cl
    5220:	75 f3                	jne    5215 <_zipinfo+0x4055>
    5222:	89 44 24 68          	mov    %eax,0x68(%esp)
    5226:	e9 10 da ff ff       	jmp    2c3b <_zipinfo+0x1a7b>
    522b:	90                   	nop
    522c:	90                   	nop
    522d:	90                   	nop
    522e:	90                   	nop
    522f:	90                   	nop
